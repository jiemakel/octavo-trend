!function(g){function n(t){if(I[t])return I[t].exports;var e=I[t]={i:t,l:!1,exports:{}};return g[t].call(e.exports,e,e.exports,n),e.l=!0,e.exports}var I={};n.m=g,n.c=I,n.d=function(g,I,t){n.o(g,I)||Object.defineProperty(g,I,{configurable:!1,enumerable:!0,get:t})},n.n=function(g){var I=g&&g.__esModule?function(){return g.default}:function(){return g};return n.d(I,"a",I),I},n.o=function(g,n){return Object.prototype.hasOwnProperty.call(g,n)},n.p="",n(n.s=108)}([function(module,exports,__webpack_require__){"use strict";eval('/* WEBPACK VAR INJECTION */(function(global) {\nObject.defineProperty(exports, "__esModule", { value: true });\n/**\n * Random utility functions used in the UI-Router code\n *\n * These functions are exported, but are subject to change without notice.\n *\n * @preferred\n * @module common\n */\n/** for typedoc */\nvar predicates_1 = __webpack_require__(1);\nvar hof_1 = __webpack_require__(2);\nvar coreservices_1 = __webpack_require__(3);\nexports.root = (typeof self === \'object\' && self.self === self && self) ||\n    (typeof global === \'object\' && global.global === global && global) || this;\nvar angular = exports.root.angular || {};\nexports.fromJson = angular.fromJson || JSON.parse.bind(JSON);\nexports.toJson = angular.toJson || JSON.stringify.bind(JSON);\nexports.forEach = angular.forEach || _forEach;\nexports.extend = Object.assign || _extend;\nexports.equals = angular.equals || _equals;\nfunction identity(x) { return x; }\nexports.identity = identity;\nfunction noop() { }\nexports.noop = noop;\n/**\n * Builds proxy functions on the `to` object which pass through to the `from` object.\n *\n * For each key in `fnNames`, creates a proxy function on the `to` object.\n * The proxy function calls the real function on the `from` object.\n *\n *\n * #### Example:\n * This example creates an new class instance whose functions are prebound to the new\'d object.\n * ```js\n * class Foo {\n *   constructor(data) {\n *     // Binds all functions from Foo.prototype to \'this\',\n *     // then copies them to \'this\'\n *     bindFunctions(Foo.prototype, this, this);\n *     this.data = data;\n *   }\n *\n *   log() {\n *     console.log(this.data);\n *   }\n * }\n *\n * let myFoo = new Foo([1,2,3]);\n * var logit = myFoo.log;\n * logit(); // logs [1, 2, 3] from the myFoo \'this\' instance\n * ```\n *\n * #### Example:\n * This example creates a bound version of a service function, and copies it to another object\n * ```\n *\n * var SomeService = {\n *   this.data = [3, 4, 5];\n *   this.log = function() {\n *     console.log(this.data);\n *   }\n * }\n *\n * // Constructor fn\n * function OtherThing() {\n *   // Binds all functions from SomeService to SomeService,\n *   // then copies them to \'this\'\n *   bindFunctions(SomeService, this, SomeService);\n * }\n *\n * let myOtherThing = new OtherThing();\n * myOtherThing.log(); // logs [3, 4, 5] from SomeService\'s \'this\'\n * ```\n *\n * @param source A function that returns the source object which contains the original functions to be bound\n * @param target A function that returns the target object which will receive the bound functions\n * @param bind A function that returns the object which the functions will be bound to\n * @param fnNames The function names which will be bound (Defaults to all the functions found on the \'from\' object)\n * @param latebind If true, the binding of the function is delayed until the first time it\'s invoked\n */\nfunction createProxyFunctions(source, target, bind, fnNames, latebind) {\n    if (latebind === void 0) { latebind = false; }\n    var bindFunction = function (fnName) {\n        return source()[fnName].bind(bind());\n    };\n    var makeLateRebindFn = function (fnName) { return function lateRebindFunction() {\n        target[fnName] = bindFunction(fnName);\n        return target[fnName].apply(null, arguments);\n    }; };\n    fnNames = fnNames || Object.keys(source());\n    return fnNames.reduce(function (acc, name) {\n        acc[name] = latebind ? makeLateRebindFn(name) : bindFunction(name);\n        return acc;\n    }, target);\n}\nexports.createProxyFunctions = createProxyFunctions;\n/**\n * prototypal inheritance helper.\n * Creates a new object which has `parent` object as its prototype, and then copies the properties from `extra` onto it\n */\nexports.inherit = function (parent, extra) {\n    return exports.extend(Object.create(parent), extra);\n};\n/** Given an array, returns true if the object is found in the array, (using indexOf) */\nexports.inArray = hof_1.curry(_inArray);\nfunction _inArray(array, obj) {\n    return array.indexOf(obj) !== -1;\n}\nexports._inArray = _inArray;\n/**\n * Given an array, and an item, if the item is found in the array, it removes it (in-place).\n * The same array is returned\n */\nexports.removeFrom = hof_1.curry(_removeFrom);\nfunction _removeFrom(array, obj) {\n    var idx = array.indexOf(obj);\n    if (idx >= 0)\n        array.splice(idx, 1);\n    return array;\n}\nexports._removeFrom = _removeFrom;\n/** pushes a values to an array and returns the value */\nexports.pushTo = hof_1.curry(_pushTo);\nfunction _pushTo(arr, val) {\n    return (arr.push(val), val);\n}\nexports._pushTo = _pushTo;\n/** Given an array of (deregistration) functions, calls all functions and removes each one from the source array */\nexports.deregAll = function (functions) {\n    return functions.slice().forEach(function (fn) {\n        typeof fn === \'function\' && fn();\n        exports.removeFrom(functions, fn);\n    });\n};\n/**\n * Applies a set of defaults to an options object.  The options object is filtered\n * to only those properties of the objects in the defaultsList.\n * Earlier objects in the defaultsList take precedence when applying defaults.\n */\nfunction defaults(opts) {\n    var defaultsList = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        defaultsList[_i - 1] = arguments[_i];\n    }\n    var _defaultsList = defaultsList.concat({}).reverse();\n    var defaultVals = exports.extend.apply(null, _defaultsList);\n    return exports.extend({}, defaultVals, pick(opts || {}, Object.keys(defaultVals)));\n}\nexports.defaults = defaults;\n/** Reduce function that merges each element of the list into a single object, using extend */\nexports.mergeR = function (memo, item) { return exports.extend(memo, item); };\n/**\n * Finds the common ancestor path between two states.\n *\n * @param {Object} first The first state.\n * @param {Object} second The second state.\n * @return {Array} Returns an array of state names in descending order, not including the root.\n */\nfunction ancestors(first, second) {\n    var path = [];\n    for (var n in first.path) {\n        if (first.path[n] !== second.path[n])\n            break;\n        path.push(first.path[n]);\n    }\n    return path;\n}\nexports.ancestors = ancestors;\n/**\n * Return a copy of the object only containing the whitelisted properties.\n *\n * #### Example:\n * ```\n * var foo = { a: 1, b: 2, c: 3 };\n * var ab = pick(foo, [\'a\', \'b\']); // { a: 1, b: 2 }\n * ```\n * @param obj the source object\n * @param propNames an Array of strings, which are the whitelisted property names\n */\nfunction pick(obj, propNames) {\n    var objCopy = {};\n    for (var _prop in obj) {\n        if (propNames.indexOf(_prop) !== -1) {\n            objCopy[_prop] = obj[_prop];\n        }\n    }\n    return objCopy;\n}\nexports.pick = pick;\n/**\n * Return a copy of the object omitting the blacklisted properties.\n *\n * @example\n * ```\n *\n * var foo = { a: 1, b: 2, c: 3 };\n * var ab = omit(foo, [\'a\', \'b\']); // { c: 3 }\n * ```\n * @param obj the source object\n * @param propNames an Array of strings, which are the blacklisted property names\n */\nfunction omit(obj, propNames) {\n    return Object.keys(obj)\n        .filter(hof_1.not(exports.inArray(propNames)))\n        .reduce(function (acc, key) { return (acc[key] = obj[key], acc); }, {});\n}\nexports.omit = omit;\n/**\n * Maps an array, or object to a property (by name)\n */\nfunction pluck(collection, propName) {\n    return map(collection, hof_1.prop(propName));\n}\nexports.pluck = pluck;\n/** Filters an Array or an Object\'s properties based on a predicate */\nfunction filter(collection, callback) {\n    var arr = predicates_1.isArray(collection), result = arr ? [] : {};\n    var accept = arr ? function (x) { return result.push(x); } : function (x, key) { return result[key] = x; };\n    exports.forEach(collection, function (item, i) {\n        if (callback(item, i))\n            accept(item, i);\n    });\n    return result;\n}\nexports.filter = filter;\n/** Finds an object from an array, or a property of an object, that matches a predicate */\nfunction find(collection, callback) {\n    var result;\n    exports.forEach(collection, function (item, i) {\n        if (result)\n            return;\n        if (callback(item, i))\n            result = item;\n    });\n    return result;\n}\nexports.find = find;\n/** Given an object, returns a new object, where each property is transformed by the callback function */\nexports.mapObj = map;\n/** Maps an array or object properties using a callback function */\nfunction map(collection, callback) {\n    var result = predicates_1.isArray(collection) ? [] : {};\n    exports.forEach(collection, function (item, i) { return result[i] = callback(item, i); });\n    return result;\n}\nexports.map = map;\n/**\n * Given an object, return its enumerable property values\n *\n * @example\n * ```\n *\n * let foo = { a: 1, b: 2, c: 3 }\n * let vals = values(foo); // [ 1, 2, 3 ]\n * ```\n */\nexports.values = function (obj) {\n    return Object.keys(obj).map(function (key) { return obj[key]; });\n};\n/**\n * Reduce function that returns true if all of the values are truthy.\n *\n * @example\n * ```\n *\n * let vals = [ 1, true, {}, "hello world"];\n * vals.reduce(allTrueR, true); // true\n *\n * vals.push(0);\n * vals.reduce(allTrueR, true); // false\n * ```\n */\nexports.allTrueR = function (memo, elem) { return memo && elem; };\n/**\n * Reduce function that returns true if any of the values are truthy.\n *\n *  * @example\n * ```\n *\n * let vals = [ 0, null, undefined ];\n * vals.reduce(anyTrueR, true); // false\n *\n * vals.push("hello world");\n * vals.reduce(anyTrueR, true); // true\n * ```\n */\nexports.anyTrueR = function (memo, elem) { return memo || elem; };\n/**\n * Reduce function which un-nests a single level of arrays\n * @example\n * ```\n *\n * let input = [ [ "a", "b" ], [ "c", "d" ], [ [ "double", "nested" ] ] ];\n * input.reduce(unnestR, []) // [ "a", "b", "c", "d", [ "double, "nested" ] ]\n * ```\n */\nexports.unnestR = function (memo, elem) { return memo.concat(elem); };\n/**\n * Reduce function which recursively un-nests all arrays\n *\n * @example\n * ```\n *\n * let input = [ [ "a", "b" ], [ "c", "d" ], [ [ "double", "nested" ] ] ];\n * input.reduce(unnestR, []) // [ "a", "b", "c", "d", "double, "nested" ]\n * ```\n */\nexports.flattenR = function (memo, elem) {\n    return predicates_1.isArray(elem) ? memo.concat(elem.reduce(exports.flattenR, [])) : pushR(memo, elem);\n};\n/**\n * Reduce function that pushes an object to an array, then returns the array.\n * Mostly just for [[flattenR]] and [[uniqR]]\n */\nfunction pushR(arr, obj) {\n    arr.push(obj);\n    return arr;\n}\nexports.pushR = pushR;\n/** Reduce function that filters out duplicates */\nexports.uniqR = function (acc, token) {\n    return exports.inArray(acc, token) ? acc : pushR(acc, token);\n};\n/**\n * Return a new array with a single level of arrays unnested.\n *\n * @example\n * ```\n *\n * let input = [ [ "a", "b" ], [ "c", "d" ], [ [ "double", "nested" ] ] ];\n * unnest(input) // [ "a", "b", "c", "d", [ "double, "nested" ] ]\n * ```\n */\nexports.unnest = function (arr) { return arr.reduce(exports.unnestR, []); };\n/**\n * Return a completely flattened version of an array.\n *\n * @example\n * ```\n *\n * let input = [ [ "a", "b" ], [ "c", "d" ], [ [ "double", "nested" ] ] ];\n * flatten(input) // [ "a", "b", "c", "d", "double, "nested" ]\n * ```\n */\nexports.flatten = function (arr) { return arr.reduce(exports.flattenR, []); };\n/**\n * Given a .filter Predicate, builds a .filter Predicate which throws an error if any elements do not pass.\n * @example\n * ```\n *\n * let isNumber = (obj) => typeof(obj) === \'number\';\n * let allNumbers = [ 1, 2, 3, 4, 5 ];\n * allNumbers.filter(assertPredicate(isNumber)); //OK\n *\n * let oneString = [ 1, 2, 3, 4, "5" ];\n * oneString.filter(assertPredicate(isNumber, "Not all numbers")); // throws Error(""Not all numbers"");\n * ```\n */\nexports.assertPredicate = assertFn;\n/**\n * Given a .map function, builds a .map function which throws an error if any mapped elements do not pass a truthyness test.\n * @example\n * ```\n *\n * var data = { foo: 1, bar: 2 };\n *\n * let keys = [ \'foo\', \'bar\' ]\n * let values = keys.map(assertMap(key => data[key], "Key not found"));\n * // values is [1, 2]\n *\n * let keys = [ \'foo\', \'bar\', \'baz\' ]\n * let values = keys.map(assertMap(key => data[key], "Key not found"));\n * // throws Error("Key not found")\n * ```\n */\nexports.assertMap = assertFn;\nfunction assertFn(predicateOrMap, errMsg) {\n    if (errMsg === void 0) { errMsg = \'assert failure\'; }\n    return function (obj) {\n        var result = predicateOrMap(obj);\n        if (!result) {\n            throw new Error(predicates_1.isFunction(errMsg) ? errMsg(obj) : errMsg);\n        }\n        return result;\n    };\n}\nexports.assertFn = assertFn;\n/**\n * Like _.pairs: Given an object, returns an array of key/value pairs\n *\n * @example\n * ```\n *\n * pairs({ foo: "FOO", bar: "BAR }) // [ [ "foo", "FOO" ], [ "bar": "BAR" ] ]\n * ```\n */\nexports.pairs = function (obj) {\n    return Object.keys(obj).map(function (key) { return [key, obj[key]]; });\n};\n/**\n * Given two or more parallel arrays, returns an array of tuples where\n * each tuple is composed of [ a[i], b[i], ... z[i] ]\n *\n * @example\n * ```\n *\n * let foo = [ 0, 2, 4, 6 ];\n * let bar = [ 1, 3, 5, 7 ];\n * let baz = [ 10, 30, 50, 70 ];\n * arrayTuples(foo, bar);       // [ [0, 1], [2, 3], [4, 5], [6, 7] ]\n * arrayTuples(foo, bar, baz);  // [ [0, 1, 10], [2, 3, 30], [4, 5, 50], [6, 7, 70] ]\n * ```\n */\nfunction arrayTuples() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    if (args.length === 0)\n        return [];\n    var maxArrayLen = args.reduce(function (min, arr) { return Math.min(arr.length, min); }, 9007199254740991); // aka 2^53 − 1 aka Number.MAX_SAFE_INTEGER\n    var result = [];\n    var _loop_1 = function (i) {\n        // This is a hot function\n        // Unroll when there are 1-4 arguments\n        switch (args.length) {\n            case 1:\n                result.push([args[0][i]]);\n                break;\n            case 2:\n                result.push([args[0][i], args[1][i]]);\n                break;\n            case 3:\n                result.push([args[0][i], args[1][i], args[2][i]]);\n                break;\n            case 4:\n                result.push([args[0][i], args[1][i], args[2][i], args[3][i]]);\n                break;\n            default:\n                result.push(args.map(function (array) { return array[i]; }));\n                break;\n        }\n    };\n    for (var i = 0; i < maxArrayLen; i++) {\n        _loop_1(i);\n    }\n    return result;\n}\nexports.arrayTuples = arrayTuples;\n/**\n * Reduce function which builds an object from an array of [key, value] pairs.\n *\n * Each iteration sets the key/val pair on the memo object, then returns the memo for the next iteration.\n *\n * Each keyValueTuple should be an array with values [ key: string, value: any ]\n *\n * @example\n * ```\n *\n * var pairs = [ ["fookey", "fooval"], ["barkey", "barval"] ]\n *\n * var pairsToObj = pairs.reduce((memo, pair) => applyPairs(memo, pair), {})\n * // pairsToObj == { fookey: "fooval", barkey: "barval" }\n *\n * // Or, more simply:\n * var pairsToObj = pairs.reduce(applyPairs, {})\n * // pairsToObj == { fookey: "fooval", barkey: "barval" }\n * ```\n */\nfunction applyPairs(memo, keyValTuple) {\n    var key, value;\n    if (predicates_1.isArray(keyValTuple))\n        key = keyValTuple[0], value = keyValTuple[1];\n    if (!predicates_1.isString(key))\n        throw new Error(\'invalid parameters to applyPairs\');\n    memo[key] = value;\n    return memo;\n}\nexports.applyPairs = applyPairs;\n/** Get the last element of an array */\nfunction tail(arr) {\n    return arr.length && arr[arr.length - 1] || undefined;\n}\nexports.tail = tail;\n/**\n * shallow copy from src to dest\n */\nfunction copy(src, dest) {\n    if (dest)\n        Object.keys(dest).forEach(function (key) { return delete dest[key]; });\n    if (!dest)\n        dest = {};\n    return exports.extend(dest, src);\n}\nexports.copy = copy;\n/** Naive forEach implementation works with Objects or Arrays */\nfunction _forEach(obj, cb, _this) {\n    if (predicates_1.isArray(obj))\n        return obj.forEach(cb, _this);\n    Object.keys(obj).forEach(function (key) { return cb(obj[key], key); });\n}\nfunction _extend(toObj) {\n    for (var i = 1; i < arguments.length; i++) {\n        var obj = arguments[i];\n        if (!obj)\n            continue;\n        var keys = Object.keys(obj);\n        for (var j = 0; j < keys.length; j++) {\n            toObj[keys[j]] = obj[keys[j]];\n        }\n    }\n    return toObj;\n}\nexports._extend = _extend;\nfunction _equals(o1, o2) {\n    if (o1 === o2)\n        return true;\n    if (o1 === null || o2 === null)\n        return false;\n    if (o1 !== o1 && o2 !== o2)\n        return true; // NaN === NaN\n    var t1 = typeof o1, t2 = typeof o2;\n    if (t1 !== t2 || t1 !== \'object\')\n        return false;\n    var tup = [o1, o2];\n    if (hof_1.all(predicates_1.isArray)(tup))\n        return _arraysEq(o1, o2);\n    if (hof_1.all(predicates_1.isDate)(tup))\n        return o1.getTime() === o2.getTime();\n    if (hof_1.all(predicates_1.isRegExp)(tup))\n        return o1.toString() === o2.toString();\n    if (hof_1.all(predicates_1.isFunction)(tup))\n        return true; // meh\n    var predicates = [predicates_1.isFunction, predicates_1.isArray, predicates_1.isDate, predicates_1.isRegExp];\n    if (predicates.map(hof_1.any).reduce(function (b, fn) { return b || !!fn(tup); }, false))\n        return false;\n    var keys = {};\n    for (var key in o1) {\n        if (!_equals(o1[key], o2[key]))\n            return false;\n        keys[key] = true;\n    }\n    for (var key in o2) {\n        if (!keys[key])\n            return false;\n    }\n    return true;\n}\nfunction _arraysEq(a1, a2) {\n    if (a1.length !== a2.length)\n        return false;\n    return arrayTuples(a1, a2).reduce(function (b, t) { return b && _equals(t[0], t[1]); }, true);\n}\n// issue #2676\nexports.silenceUncaughtInPromise = function (promise) {\n    return promise.catch(function (e) { return 0; }) && promise;\n};\nexports.silentRejection = function (error) {\n    return exports.silenceUncaughtInPromise(coreservices_1.services.$q.reject(error));\n};\n//# sourceMappingURL=common.js.map\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(111)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvY29tbW9uL2NvbW1vbi5qcz81OWE3Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBSYW5kb20gdXRpbGl0eSBmdW5jdGlvbnMgdXNlZCBpbiB0aGUgVUktUm91dGVyIGNvZGVcbiAqXG4gKiBUaGVzZSBmdW5jdGlvbnMgYXJlIGV4cG9ydGVkLCBidXQgYXJlIHN1YmplY3QgdG8gY2hhbmdlIHdpdGhvdXQgbm90aWNlLlxuICpcbiAqIEBwcmVmZXJyZWRcbiAqIEBtb2R1bGUgY29tbW9uXG4gKi9cbi8qKiBmb3IgdHlwZWRvYyAqL1xudmFyIHByZWRpY2F0ZXNfMSA9IHJlcXVpcmUoXCIuL3ByZWRpY2F0ZXNcIik7XG52YXIgaG9mXzEgPSByZXF1aXJlKFwiLi9ob2ZcIik7XG52YXIgY29yZXNlcnZpY2VzXzEgPSByZXF1aXJlKFwiLi9jb3Jlc2VydmljZXNcIik7XG5leHBvcnRzLnJvb3QgPSAodHlwZW9mIHNlbGYgPT09ICdvYmplY3QnICYmIHNlbGYuc2VsZiA9PT0gc2VsZiAmJiBzZWxmKSB8fFxuICAgICh0eXBlb2YgZ2xvYmFsID09PSAnb2JqZWN0JyAmJiBnbG9iYWwuZ2xvYmFsID09PSBnbG9iYWwgJiYgZ2xvYmFsKSB8fCB0aGlzO1xudmFyIGFuZ3VsYXIgPSBleHBvcnRzLnJvb3QuYW5ndWxhciB8fCB7fTtcbmV4cG9ydHMuZnJvbUpzb24gPSBhbmd1bGFyLmZyb21Kc29uIHx8IEpTT04ucGFyc2UuYmluZChKU09OKTtcbmV4cG9ydHMudG9Kc29uID0gYW5ndWxhci50b0pzb24gfHwgSlNPTi5zdHJpbmdpZnkuYmluZChKU09OKTtcbmV4cG9ydHMuZm9yRWFjaCA9IGFuZ3VsYXIuZm9yRWFjaCB8fCBfZm9yRWFjaDtcbmV4cG9ydHMuZXh0ZW5kID0gT2JqZWN0LmFzc2lnbiB8fCBfZXh0ZW5kO1xuZXhwb3J0cy5lcXVhbHMgPSBhbmd1bGFyLmVxdWFscyB8fCBfZXF1YWxzO1xuZnVuY3Rpb24gaWRlbnRpdHkoeCkgeyByZXR1cm4geDsgfVxuZXhwb3J0cy5pZGVudGl0eSA9IGlkZW50aXR5O1xuZnVuY3Rpb24gbm9vcCgpIHsgfVxuZXhwb3J0cy5ub29wID0gbm9vcDtcbi8qKlxuICogQnVpbGRzIHByb3h5IGZ1bmN0aW9ucyBvbiB0aGUgYHRvYCBvYmplY3Qgd2hpY2ggcGFzcyB0aHJvdWdoIHRvIHRoZSBgZnJvbWAgb2JqZWN0LlxuICpcbiAqIEZvciBlYWNoIGtleSBpbiBgZm5OYW1lc2AsIGNyZWF0ZXMgYSBwcm94eSBmdW5jdGlvbiBvbiB0aGUgYHRvYCBvYmplY3QuXG4gKiBUaGUgcHJveHkgZnVuY3Rpb24gY2FsbHMgdGhlIHJlYWwgZnVuY3Rpb24gb24gdGhlIGBmcm9tYCBvYmplY3QuXG4gKlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqIFRoaXMgZXhhbXBsZSBjcmVhdGVzIGFuIG5ldyBjbGFzcyBpbnN0YW5jZSB3aG9zZSBmdW5jdGlvbnMgYXJlIHByZWJvdW5kIHRvIHRoZSBuZXcnZCBvYmplY3QuXG4gKiBgYGBqc1xuICogY2xhc3MgRm9vIHtcbiAqICAgY29uc3RydWN0b3IoZGF0YSkge1xuICogICAgIC8vIEJpbmRzIGFsbCBmdW5jdGlvbnMgZnJvbSBGb28ucHJvdG90eXBlIHRvICd0aGlzJyxcbiAqICAgICAvLyB0aGVuIGNvcGllcyB0aGVtIHRvICd0aGlzJ1xuICogICAgIGJpbmRGdW5jdGlvbnMoRm9vLnByb3RvdHlwZSwgdGhpcywgdGhpcyk7XG4gKiAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAqICAgfVxuICpcbiAqICAgbG9nKCkge1xuICogICAgIGNvbnNvbGUubG9nKHRoaXMuZGF0YSk7XG4gKiAgIH1cbiAqIH1cbiAqXG4gKiBsZXQgbXlGb28gPSBuZXcgRm9vKFsxLDIsM10pO1xuICogdmFyIGxvZ2l0ID0gbXlGb28ubG9nO1xuICogbG9naXQoKTsgLy8gbG9ncyBbMSwgMiwgM10gZnJvbSB0aGUgbXlGb28gJ3RoaXMnIGluc3RhbmNlXG4gKiBgYGBcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKiBUaGlzIGV4YW1wbGUgY3JlYXRlcyBhIGJvdW5kIHZlcnNpb24gb2YgYSBzZXJ2aWNlIGZ1bmN0aW9uLCBhbmQgY29waWVzIGl0IHRvIGFub3RoZXIgb2JqZWN0XG4gKiBgYGBcbiAqXG4gKiB2YXIgU29tZVNlcnZpY2UgPSB7XG4gKiAgIHRoaXMuZGF0YSA9IFszLCA0LCA1XTtcbiAqICAgdGhpcy5sb2cgPSBmdW5jdGlvbigpIHtcbiAqICAgICBjb25zb2xlLmxvZyh0aGlzLmRhdGEpO1xuICogICB9XG4gKiB9XG4gKlxuICogLy8gQ29uc3RydWN0b3IgZm5cbiAqIGZ1bmN0aW9uIE90aGVyVGhpbmcoKSB7XG4gKiAgIC8vIEJpbmRzIGFsbCBmdW5jdGlvbnMgZnJvbSBTb21lU2VydmljZSB0byBTb21lU2VydmljZSxcbiAqICAgLy8gdGhlbiBjb3BpZXMgdGhlbSB0byAndGhpcydcbiAqICAgYmluZEZ1bmN0aW9ucyhTb21lU2VydmljZSwgdGhpcywgU29tZVNlcnZpY2UpO1xuICogfVxuICpcbiAqIGxldCBteU90aGVyVGhpbmcgPSBuZXcgT3RoZXJUaGluZygpO1xuICogbXlPdGhlclRoaW5nLmxvZygpOyAvLyBsb2dzIFszLCA0LCA1XSBmcm9tIFNvbWVTZXJ2aWNlJ3MgJ3RoaXMnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc291cmNlIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBzb3VyY2Ugb2JqZWN0IHdoaWNoIGNvbnRhaW5zIHRoZSBvcmlnaW5hbCBmdW5jdGlvbnMgdG8gYmUgYm91bmRcbiAqIEBwYXJhbSB0YXJnZXQgQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHRhcmdldCBvYmplY3Qgd2hpY2ggd2lsbCByZWNlaXZlIHRoZSBib3VuZCBmdW5jdGlvbnNcbiAqIEBwYXJhbSBiaW5kIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBvYmplY3Qgd2hpY2ggdGhlIGZ1bmN0aW9ucyB3aWxsIGJlIGJvdW5kIHRvXG4gKiBAcGFyYW0gZm5OYW1lcyBUaGUgZnVuY3Rpb24gbmFtZXMgd2hpY2ggd2lsbCBiZSBib3VuZCAoRGVmYXVsdHMgdG8gYWxsIHRoZSBmdW5jdGlvbnMgZm91bmQgb24gdGhlICdmcm9tJyBvYmplY3QpXG4gKiBAcGFyYW0gbGF0ZWJpbmQgSWYgdHJ1ZSwgdGhlIGJpbmRpbmcgb2YgdGhlIGZ1bmN0aW9uIGlzIGRlbGF5ZWQgdW50aWwgdGhlIGZpcnN0IHRpbWUgaXQncyBpbnZva2VkXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVByb3h5RnVuY3Rpb25zKHNvdXJjZSwgdGFyZ2V0LCBiaW5kLCBmbk5hbWVzLCBsYXRlYmluZCkge1xuICAgIGlmIChsYXRlYmluZCA9PT0gdm9pZCAwKSB7IGxhdGViaW5kID0gZmFsc2U7IH1cbiAgICB2YXIgYmluZEZ1bmN0aW9uID0gZnVuY3Rpb24gKGZuTmFtZSkge1xuICAgICAgICByZXR1cm4gc291cmNlKClbZm5OYW1lXS5iaW5kKGJpbmQoKSk7XG4gICAgfTtcbiAgICB2YXIgbWFrZUxhdGVSZWJpbmRGbiA9IGZ1bmN0aW9uIChmbk5hbWUpIHsgcmV0dXJuIGZ1bmN0aW9uIGxhdGVSZWJpbmRGdW5jdGlvbigpIHtcbiAgICAgICAgdGFyZ2V0W2ZuTmFtZV0gPSBiaW5kRnVuY3Rpb24oZm5OYW1lKTtcbiAgICAgICAgcmV0dXJuIHRhcmdldFtmbk5hbWVdLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgfTsgfTtcbiAgICBmbk5hbWVzID0gZm5OYW1lcyB8fCBPYmplY3Qua2V5cyhzb3VyY2UoKSk7XG4gICAgcmV0dXJuIGZuTmFtZXMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIG5hbWUpIHtcbiAgICAgICAgYWNjW25hbWVdID0gbGF0ZWJpbmQgPyBtYWtlTGF0ZVJlYmluZEZuKG5hbWUpIDogYmluZEZ1bmN0aW9uKG5hbWUpO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHRhcmdldCk7XG59XG5leHBvcnRzLmNyZWF0ZVByb3h5RnVuY3Rpb25zID0gY3JlYXRlUHJveHlGdW5jdGlvbnM7XG4vKipcbiAqIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UgaGVscGVyLlxuICogQ3JlYXRlcyBhIG5ldyBvYmplY3Qgd2hpY2ggaGFzIGBwYXJlbnRgIG9iamVjdCBhcyBpdHMgcHJvdG90eXBlLCBhbmQgdGhlbiBjb3BpZXMgdGhlIHByb3BlcnRpZXMgZnJvbSBgZXh0cmFgIG9udG8gaXRcbiAqL1xuZXhwb3J0cy5pbmhlcml0ID0gZnVuY3Rpb24gKHBhcmVudCwgZXh0cmEpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5leHRlbmQoT2JqZWN0LmNyZWF0ZShwYXJlbnQpLCBleHRyYSk7XG59O1xuLyoqIEdpdmVuIGFuIGFycmF5LCByZXR1cm5zIHRydWUgaWYgdGhlIG9iamVjdCBpcyBmb3VuZCBpbiB0aGUgYXJyYXksICh1c2luZyBpbmRleE9mKSAqL1xuZXhwb3J0cy5pbkFycmF5ID0gaG9mXzEuY3VycnkoX2luQXJyYXkpO1xuZnVuY3Rpb24gX2luQXJyYXkoYXJyYXksIG9iaikge1xuICAgIHJldHVybiBhcnJheS5pbmRleE9mKG9iaikgIT09IC0xO1xufVxuZXhwb3J0cy5faW5BcnJheSA9IF9pbkFycmF5O1xuLyoqXG4gKiBHaXZlbiBhbiBhcnJheSwgYW5kIGFuIGl0ZW0sIGlmIHRoZSBpdGVtIGlzIGZvdW5kIGluIHRoZSBhcnJheSwgaXQgcmVtb3ZlcyBpdCAoaW4tcGxhY2UpLlxuICogVGhlIHNhbWUgYXJyYXkgaXMgcmV0dXJuZWRcbiAqL1xuZXhwb3J0cy5yZW1vdmVGcm9tID0gaG9mXzEuY3VycnkoX3JlbW92ZUZyb20pO1xuZnVuY3Rpb24gX3JlbW92ZUZyb20oYXJyYXksIG9iaikge1xuICAgIHZhciBpZHggPSBhcnJheS5pbmRleE9mKG9iaik7XG4gICAgaWYgKGlkeCA+PSAwKVxuICAgICAgICBhcnJheS5zcGxpY2UoaWR4LCAxKTtcbiAgICByZXR1cm4gYXJyYXk7XG59XG5leHBvcnRzLl9yZW1vdmVGcm9tID0gX3JlbW92ZUZyb207XG4vKiogcHVzaGVzIGEgdmFsdWVzIHRvIGFuIGFycmF5IGFuZCByZXR1cm5zIHRoZSB2YWx1ZSAqL1xuZXhwb3J0cy5wdXNoVG8gPSBob2ZfMS5jdXJyeShfcHVzaFRvKTtcbmZ1bmN0aW9uIF9wdXNoVG8oYXJyLCB2YWwpIHtcbiAgICByZXR1cm4gKGFyci5wdXNoKHZhbCksIHZhbCk7XG59XG5leHBvcnRzLl9wdXNoVG8gPSBfcHVzaFRvO1xuLyoqIEdpdmVuIGFuIGFycmF5IG9mIChkZXJlZ2lzdHJhdGlvbikgZnVuY3Rpb25zLCBjYWxscyBhbGwgZnVuY3Rpb25zIGFuZCByZW1vdmVzIGVhY2ggb25lIGZyb20gdGhlIHNvdXJjZSBhcnJheSAqL1xuZXhwb3J0cy5kZXJlZ0FsbCA9IGZ1bmN0aW9uIChmdW5jdGlvbnMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb25zLnNsaWNlKCkuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgdHlwZW9mIGZuID09PSAnZnVuY3Rpb24nICYmIGZuKCk7XG4gICAgICAgIGV4cG9ydHMucmVtb3ZlRnJvbShmdW5jdGlvbnMsIGZuKTtcbiAgICB9KTtcbn07XG4vKipcbiAqIEFwcGxpZXMgYSBzZXQgb2YgZGVmYXVsdHMgdG8gYW4gb3B0aW9ucyBvYmplY3QuICBUaGUgb3B0aW9ucyBvYmplY3QgaXMgZmlsdGVyZWRcbiAqIHRvIG9ubHkgdGhvc2UgcHJvcGVydGllcyBvZiB0aGUgb2JqZWN0cyBpbiB0aGUgZGVmYXVsdHNMaXN0LlxuICogRWFybGllciBvYmplY3RzIGluIHRoZSBkZWZhdWx0c0xpc3QgdGFrZSBwcmVjZWRlbmNlIHdoZW4gYXBwbHlpbmcgZGVmYXVsdHMuXG4gKi9cbmZ1bmN0aW9uIGRlZmF1bHRzKG9wdHMpIHtcbiAgICB2YXIgZGVmYXVsdHNMaXN0ID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgZGVmYXVsdHNMaXN0W19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgX2RlZmF1bHRzTGlzdCA9IGRlZmF1bHRzTGlzdC5jb25jYXQoe30pLnJldmVyc2UoKTtcbiAgICB2YXIgZGVmYXVsdFZhbHMgPSBleHBvcnRzLmV4dGVuZC5hcHBseShudWxsLCBfZGVmYXVsdHNMaXN0KTtcbiAgICByZXR1cm4gZXhwb3J0cy5leHRlbmQoe30sIGRlZmF1bHRWYWxzLCBwaWNrKG9wdHMgfHwge30sIE9iamVjdC5rZXlzKGRlZmF1bHRWYWxzKSkpO1xufVxuZXhwb3J0cy5kZWZhdWx0cyA9IGRlZmF1bHRzO1xuLyoqIFJlZHVjZSBmdW5jdGlvbiB0aGF0IG1lcmdlcyBlYWNoIGVsZW1lbnQgb2YgdGhlIGxpc3QgaW50byBhIHNpbmdsZSBvYmplY3QsIHVzaW5nIGV4dGVuZCAqL1xuZXhwb3J0cy5tZXJnZVIgPSBmdW5jdGlvbiAobWVtbywgaXRlbSkgeyByZXR1cm4gZXhwb3J0cy5leHRlbmQobWVtbywgaXRlbSk7IH07XG4vKipcbiAqIEZpbmRzIHRoZSBjb21tb24gYW5jZXN0b3IgcGF0aCBiZXR3ZWVuIHR3byBzdGF0ZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGZpcnN0IFRoZSBmaXJzdCBzdGF0ZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzZWNvbmQgVGhlIHNlY29uZCBzdGF0ZS5cbiAqIEByZXR1cm4ge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIHN0YXRlIG5hbWVzIGluIGRlc2NlbmRpbmcgb3JkZXIsIG5vdCBpbmNsdWRpbmcgdGhlIHJvb3QuXG4gKi9cbmZ1bmN0aW9uIGFuY2VzdG9ycyhmaXJzdCwgc2Vjb25kKSB7XG4gICAgdmFyIHBhdGggPSBbXTtcbiAgICBmb3IgKHZhciBuIGluIGZpcnN0LnBhdGgpIHtcbiAgICAgICAgaWYgKGZpcnN0LnBhdGhbbl0gIT09IHNlY29uZC5wYXRoW25dKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIHBhdGgucHVzaChmaXJzdC5wYXRoW25dKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGg7XG59XG5leHBvcnRzLmFuY2VzdG9ycyA9IGFuY2VzdG9ycztcbi8qKlxuICogUmV0dXJuIGEgY29weSBvZiB0aGUgb2JqZWN0IG9ubHkgY29udGFpbmluZyB0aGUgd2hpdGVsaXN0ZWQgcHJvcGVydGllcy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKiBgYGBcbiAqIHZhciBmb28gPSB7IGE6IDEsIGI6IDIsIGM6IDMgfTtcbiAqIHZhciBhYiA9IHBpY2soZm9vLCBbJ2EnLCAnYiddKTsgLy8geyBhOiAxLCBiOiAyIH1cbiAqIGBgYFxuICogQHBhcmFtIG9iaiB0aGUgc291cmNlIG9iamVjdFxuICogQHBhcmFtIHByb3BOYW1lcyBhbiBBcnJheSBvZiBzdHJpbmdzLCB3aGljaCBhcmUgdGhlIHdoaXRlbGlzdGVkIHByb3BlcnR5IG5hbWVzXG4gKi9cbmZ1bmN0aW9uIHBpY2sob2JqLCBwcm9wTmFtZXMpIHtcbiAgICB2YXIgb2JqQ29weSA9IHt9O1xuICAgIGZvciAodmFyIF9wcm9wIGluIG9iaikge1xuICAgICAgICBpZiAocHJvcE5hbWVzLmluZGV4T2YoX3Byb3ApICE9PSAtMSkge1xuICAgICAgICAgICAgb2JqQ29weVtfcHJvcF0gPSBvYmpbX3Byb3BdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmpDb3B5O1xufVxuZXhwb3J0cy5waWNrID0gcGljaztcbi8qKlxuICogUmV0dXJuIGEgY29weSBvZiB0aGUgb2JqZWN0IG9taXR0aW5nIHRoZSBibGFja2xpc3RlZCBwcm9wZXJ0aWVzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBcbiAqXG4gKiB2YXIgZm9vID0geyBhOiAxLCBiOiAyLCBjOiAzIH07XG4gKiB2YXIgYWIgPSBvbWl0KGZvbywgWydhJywgJ2InXSk7IC8vIHsgYzogMyB9XG4gKiBgYGBcbiAqIEBwYXJhbSBvYmogdGhlIHNvdXJjZSBvYmplY3RcbiAqIEBwYXJhbSBwcm9wTmFtZXMgYW4gQXJyYXkgb2Ygc3RyaW5ncywgd2hpY2ggYXJlIHRoZSBibGFja2xpc3RlZCBwcm9wZXJ0eSBuYW1lc1xuICovXG5mdW5jdGlvbiBvbWl0KG9iaiwgcHJvcE5hbWVzKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iailcbiAgICAgICAgLmZpbHRlcihob2ZfMS5ub3QoZXhwb3J0cy5pbkFycmF5KHByb3BOYW1lcykpKVxuICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGtleSkgeyByZXR1cm4gKGFjY1trZXldID0gb2JqW2tleV0sIGFjYyk7IH0sIHt9KTtcbn1cbmV4cG9ydHMub21pdCA9IG9taXQ7XG4vKipcbiAqIE1hcHMgYW4gYXJyYXksIG9yIG9iamVjdCB0byBhIHByb3BlcnR5IChieSBuYW1lKVxuICovXG5mdW5jdGlvbiBwbHVjayhjb2xsZWN0aW9uLCBwcm9wTmFtZSkge1xuICAgIHJldHVybiBtYXAoY29sbGVjdGlvbiwgaG9mXzEucHJvcChwcm9wTmFtZSkpO1xufVxuZXhwb3J0cy5wbHVjayA9IHBsdWNrO1xuLyoqIEZpbHRlcnMgYW4gQXJyYXkgb3IgYW4gT2JqZWN0J3MgcHJvcGVydGllcyBiYXNlZCBvbiBhIHByZWRpY2F0ZSAqL1xuZnVuY3Rpb24gZmlsdGVyKGNvbGxlY3Rpb24sIGNhbGxiYWNrKSB7XG4gICAgdmFyIGFyciA9IHByZWRpY2F0ZXNfMS5pc0FycmF5KGNvbGxlY3Rpb24pLCByZXN1bHQgPSBhcnIgPyBbXSA6IHt9O1xuICAgIHZhciBhY2NlcHQgPSBhcnIgPyBmdW5jdGlvbiAoeCkgeyByZXR1cm4gcmVzdWx0LnB1c2goeCk7IH0gOiBmdW5jdGlvbiAoeCwga2V5KSB7IHJldHVybiByZXN1bHRba2V5XSA9IHg7IH07XG4gICAgZXhwb3J0cy5mb3JFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uIChpdGVtLCBpKSB7XG4gICAgICAgIGlmIChjYWxsYmFjayhpdGVtLCBpKSlcbiAgICAgICAgICAgIGFjY2VwdChpdGVtLCBpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5maWx0ZXIgPSBmaWx0ZXI7XG4vKiogRmluZHMgYW4gb2JqZWN0IGZyb20gYW4gYXJyYXksIG9yIGEgcHJvcGVydHkgb2YgYW4gb2JqZWN0LCB0aGF0IG1hdGNoZXMgYSBwcmVkaWNhdGUgKi9cbmZ1bmN0aW9uIGZpbmQoY29sbGVjdGlvbiwgY2FsbGJhY2spIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIGV4cG9ydHMuZm9yRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbiAoaXRlbSwgaSkge1xuICAgICAgICBpZiAocmVzdWx0KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoY2FsbGJhY2soaXRlbSwgaSkpXG4gICAgICAgICAgICByZXN1bHQgPSBpdGVtO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLmZpbmQgPSBmaW5kO1xuLyoqIEdpdmVuIGFuIG9iamVjdCwgcmV0dXJucyBhIG5ldyBvYmplY3QsIHdoZXJlIGVhY2ggcHJvcGVydHkgaXMgdHJhbnNmb3JtZWQgYnkgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uICovXG5leHBvcnRzLm1hcE9iaiA9IG1hcDtcbi8qKiBNYXBzIGFuIGFycmF5IG9yIG9iamVjdCBwcm9wZXJ0aWVzIHVzaW5nIGEgY2FsbGJhY2sgZnVuY3Rpb24gKi9cbmZ1bmN0aW9uIG1hcChjb2xsZWN0aW9uLCBjYWxsYmFjaykge1xuICAgIHZhciByZXN1bHQgPSBwcmVkaWNhdGVzXzEuaXNBcnJheShjb2xsZWN0aW9uKSA/IFtdIDoge307XG4gICAgZXhwb3J0cy5mb3JFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uIChpdGVtLCBpKSB7IHJldHVybiByZXN1bHRbaV0gPSBjYWxsYmFjayhpdGVtLCBpKTsgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMubWFwID0gbWFwO1xuLyoqXG4gKiBHaXZlbiBhbiBvYmplY3QsIHJldHVybiBpdHMgZW51bWVyYWJsZSBwcm9wZXJ0eSB2YWx1ZXNcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKlxuICogbGV0IGZvbyA9IHsgYTogMSwgYjogMiwgYzogMyB9XG4gKiBsZXQgdmFscyA9IHZhbHVlcyhmb28pOyAvLyBbIDEsIDIsIDMgXVxuICogYGBgXG4gKi9cbmV4cG9ydHMudmFsdWVzID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBvYmpba2V5XTsgfSk7XG59O1xuLyoqXG4gKiBSZWR1Y2UgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRydWUgaWYgYWxsIG9mIHRoZSB2YWx1ZXMgYXJlIHRydXRoeS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKlxuICogbGV0IHZhbHMgPSBbIDEsIHRydWUsIHt9LCBcImhlbGxvIHdvcmxkXCJdO1xuICogdmFscy5yZWR1Y2UoYWxsVHJ1ZVIsIHRydWUpOyAvLyB0cnVlXG4gKlxuICogdmFscy5wdXNoKDApO1xuICogdmFscy5yZWR1Y2UoYWxsVHJ1ZVIsIHRydWUpOyAvLyBmYWxzZVxuICogYGBgXG4gKi9cbmV4cG9ydHMuYWxsVHJ1ZVIgPSBmdW5jdGlvbiAobWVtbywgZWxlbSkgeyByZXR1cm4gbWVtbyAmJiBlbGVtOyB9O1xuLyoqXG4gKiBSZWR1Y2UgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRydWUgaWYgYW55IG9mIHRoZSB2YWx1ZXMgYXJlIHRydXRoeS5cbiAqXG4gKiAgKiBAZXhhbXBsZVxuICogYGBgXG4gKlxuICogbGV0IHZhbHMgPSBbIDAsIG51bGwsIHVuZGVmaW5lZCBdO1xuICogdmFscy5yZWR1Y2UoYW55VHJ1ZVIsIHRydWUpOyAvLyBmYWxzZVxuICpcbiAqIHZhbHMucHVzaChcImhlbGxvIHdvcmxkXCIpO1xuICogdmFscy5yZWR1Y2UoYW55VHJ1ZVIsIHRydWUpOyAvLyB0cnVlXG4gKiBgYGBcbiAqL1xuZXhwb3J0cy5hbnlUcnVlUiA9IGZ1bmN0aW9uIChtZW1vLCBlbGVtKSB7IHJldHVybiBtZW1vIHx8IGVsZW07IH07XG4vKipcbiAqIFJlZHVjZSBmdW5jdGlvbiB3aGljaCB1bi1uZXN0cyBhIHNpbmdsZSBsZXZlbCBvZiBhcnJheXNcbiAqIEBleGFtcGxlXG4gKiBgYGBcbiAqXG4gKiBsZXQgaW5wdXQgPSBbIFsgXCJhXCIsIFwiYlwiIF0sIFsgXCJjXCIsIFwiZFwiIF0sIFsgWyBcImRvdWJsZVwiLCBcIm5lc3RlZFwiIF0gXSBdO1xuICogaW5wdXQucmVkdWNlKHVubmVzdFIsIFtdKSAvLyBbIFwiYVwiLCBcImJcIiwgXCJjXCIsIFwiZFwiLCBbIFwiZG91YmxlLCBcIm5lc3RlZFwiIF0gXVxuICogYGBgXG4gKi9cbmV4cG9ydHMudW5uZXN0UiA9IGZ1bmN0aW9uIChtZW1vLCBlbGVtKSB7IHJldHVybiBtZW1vLmNvbmNhdChlbGVtKTsgfTtcbi8qKlxuICogUmVkdWNlIGZ1bmN0aW9uIHdoaWNoIHJlY3Vyc2l2ZWx5IHVuLW5lc3RzIGFsbCBhcnJheXNcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKlxuICogbGV0IGlucHV0ID0gWyBbIFwiYVwiLCBcImJcIiBdLCBbIFwiY1wiLCBcImRcIiBdLCBbIFsgXCJkb3VibGVcIiwgXCJuZXN0ZWRcIiBdIF0gXTtcbiAqIGlucHV0LnJlZHVjZSh1bm5lc3RSLCBbXSkgLy8gWyBcImFcIiwgXCJiXCIsIFwiY1wiLCBcImRcIiwgXCJkb3VibGUsIFwibmVzdGVkXCIgXVxuICogYGBgXG4gKi9cbmV4cG9ydHMuZmxhdHRlblIgPSBmdW5jdGlvbiAobWVtbywgZWxlbSkge1xuICAgIHJldHVybiBwcmVkaWNhdGVzXzEuaXNBcnJheShlbGVtKSA/IG1lbW8uY29uY2F0KGVsZW0ucmVkdWNlKGV4cG9ydHMuZmxhdHRlblIsIFtdKSkgOiBwdXNoUihtZW1vLCBlbGVtKTtcbn07XG4vKipcbiAqIFJlZHVjZSBmdW5jdGlvbiB0aGF0IHB1c2hlcyBhbiBvYmplY3QgdG8gYW4gYXJyYXksIHRoZW4gcmV0dXJucyB0aGUgYXJyYXkuXG4gKiBNb3N0bHkganVzdCBmb3IgW1tmbGF0dGVuUl1dIGFuZCBbW3VuaXFSXV1cbiAqL1xuZnVuY3Rpb24gcHVzaFIoYXJyLCBvYmopIHtcbiAgICBhcnIucHVzaChvYmopO1xuICAgIHJldHVybiBhcnI7XG59XG5leHBvcnRzLnB1c2hSID0gcHVzaFI7XG4vKiogUmVkdWNlIGZ1bmN0aW9uIHRoYXQgZmlsdGVycyBvdXQgZHVwbGljYXRlcyAqL1xuZXhwb3J0cy51bmlxUiA9IGZ1bmN0aW9uIChhY2MsIHRva2VuKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuaW5BcnJheShhY2MsIHRva2VuKSA/IGFjYyA6IHB1c2hSKGFjYywgdG9rZW4pO1xufTtcbi8qKlxuICogUmV0dXJuIGEgbmV3IGFycmF5IHdpdGggYSBzaW5nbGUgbGV2ZWwgb2YgYXJyYXlzIHVubmVzdGVkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBcbiAqXG4gKiBsZXQgaW5wdXQgPSBbIFsgXCJhXCIsIFwiYlwiIF0sIFsgXCJjXCIsIFwiZFwiIF0sIFsgWyBcImRvdWJsZVwiLCBcIm5lc3RlZFwiIF0gXSBdO1xuICogdW5uZXN0KGlucHV0KSAvLyBbIFwiYVwiLCBcImJcIiwgXCJjXCIsIFwiZFwiLCBbIFwiZG91YmxlLCBcIm5lc3RlZFwiIF0gXVxuICogYGBgXG4gKi9cbmV4cG9ydHMudW5uZXN0ID0gZnVuY3Rpb24gKGFycikgeyByZXR1cm4gYXJyLnJlZHVjZShleHBvcnRzLnVubmVzdFIsIFtdKTsgfTtcbi8qKlxuICogUmV0dXJuIGEgY29tcGxldGVseSBmbGF0dGVuZWQgdmVyc2lvbiBvZiBhbiBhcnJheS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKlxuICogbGV0IGlucHV0ID0gWyBbIFwiYVwiLCBcImJcIiBdLCBbIFwiY1wiLCBcImRcIiBdLCBbIFsgXCJkb3VibGVcIiwgXCJuZXN0ZWRcIiBdIF0gXTtcbiAqIGZsYXR0ZW4oaW5wdXQpIC8vIFsgXCJhXCIsIFwiYlwiLCBcImNcIiwgXCJkXCIsIFwiZG91YmxlLCBcIm5lc3RlZFwiIF1cbiAqIGBgYFxuICovXG5leHBvcnRzLmZsYXR0ZW4gPSBmdW5jdGlvbiAoYXJyKSB7IHJldHVybiBhcnIucmVkdWNlKGV4cG9ydHMuZmxhdHRlblIsIFtdKTsgfTtcbi8qKlxuICogR2l2ZW4gYSAuZmlsdGVyIFByZWRpY2F0ZSwgYnVpbGRzIGEgLmZpbHRlciBQcmVkaWNhdGUgd2hpY2ggdGhyb3dzIGFuIGVycm9yIGlmIGFueSBlbGVtZW50cyBkbyBub3QgcGFzcy5cbiAqIEBleGFtcGxlXG4gKiBgYGBcbiAqXG4gKiBsZXQgaXNOdW1iZXIgPSAob2JqKSA9PiB0eXBlb2Yob2JqKSA9PT0gJ251bWJlcic7XG4gKiBsZXQgYWxsTnVtYmVycyA9IFsgMSwgMiwgMywgNCwgNSBdO1xuICogYWxsTnVtYmVycy5maWx0ZXIoYXNzZXJ0UHJlZGljYXRlKGlzTnVtYmVyKSk7IC8vT0tcbiAqXG4gKiBsZXQgb25lU3RyaW5nID0gWyAxLCAyLCAzLCA0LCBcIjVcIiBdO1xuICogb25lU3RyaW5nLmZpbHRlcihhc3NlcnRQcmVkaWNhdGUoaXNOdW1iZXIsIFwiTm90IGFsbCBudW1iZXJzXCIpKTsgLy8gdGhyb3dzIEVycm9yKFwiXCJOb3QgYWxsIG51bWJlcnNcIlwiKTtcbiAqIGBgYFxuICovXG5leHBvcnRzLmFzc2VydFByZWRpY2F0ZSA9IGFzc2VydEZuO1xuLyoqXG4gKiBHaXZlbiBhIC5tYXAgZnVuY3Rpb24sIGJ1aWxkcyBhIC5tYXAgZnVuY3Rpb24gd2hpY2ggdGhyb3dzIGFuIGVycm9yIGlmIGFueSBtYXBwZWQgZWxlbWVudHMgZG8gbm90IHBhc3MgYSB0cnV0aHluZXNzIHRlc3QuXG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKlxuICogdmFyIGRhdGEgPSB7IGZvbzogMSwgYmFyOiAyIH07XG4gKlxuICogbGV0IGtleXMgPSBbICdmb28nLCAnYmFyJyBdXG4gKiBsZXQgdmFsdWVzID0ga2V5cy5tYXAoYXNzZXJ0TWFwKGtleSA9PiBkYXRhW2tleV0sIFwiS2V5IG5vdCBmb3VuZFwiKSk7XG4gKiAvLyB2YWx1ZXMgaXMgWzEsIDJdXG4gKlxuICogbGV0IGtleXMgPSBbICdmb28nLCAnYmFyJywgJ2JheicgXVxuICogbGV0IHZhbHVlcyA9IGtleXMubWFwKGFzc2VydE1hcChrZXkgPT4gZGF0YVtrZXldLCBcIktleSBub3QgZm91bmRcIikpO1xuICogLy8gdGhyb3dzIEVycm9yKFwiS2V5IG5vdCBmb3VuZFwiKVxuICogYGBgXG4gKi9cbmV4cG9ydHMuYXNzZXJ0TWFwID0gYXNzZXJ0Rm47XG5mdW5jdGlvbiBhc3NlcnRGbihwcmVkaWNhdGVPck1hcCwgZXJyTXNnKSB7XG4gICAgaWYgKGVyck1zZyA9PT0gdm9pZCAwKSB7IGVyck1zZyA9ICdhc3NlcnQgZmFpbHVyZSc7IH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcHJlZGljYXRlT3JNYXAob2JqKTtcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihwcmVkaWNhdGVzXzEuaXNGdW5jdGlvbihlcnJNc2cpID8gZXJyTXNnKG9iaikgOiBlcnJNc2cpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn1cbmV4cG9ydHMuYXNzZXJ0Rm4gPSBhc3NlcnRGbjtcbi8qKlxuICogTGlrZSBfLnBhaXJzOiBHaXZlbiBhbiBvYmplY3QsIHJldHVybnMgYW4gYXJyYXkgb2Yga2V5L3ZhbHVlIHBhaXJzXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYFxuICpcbiAqIHBhaXJzKHsgZm9vOiBcIkZPT1wiLCBiYXI6IFwiQkFSIH0pIC8vIFsgWyBcImZvb1wiLCBcIkZPT1wiIF0sIFsgXCJiYXJcIjogXCJCQVJcIiBdIF1cbiAqIGBgYFxuICovXG5leHBvcnRzLnBhaXJzID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBba2V5LCBvYmpba2V5XV07IH0pO1xufTtcbi8qKlxuICogR2l2ZW4gdHdvIG9yIG1vcmUgcGFyYWxsZWwgYXJyYXlzLCByZXR1cm5zIGFuIGFycmF5IG9mIHR1cGxlcyB3aGVyZVxuICogZWFjaCB0dXBsZSBpcyBjb21wb3NlZCBvZiBbIGFbaV0sIGJbaV0sIC4uLiB6W2ldIF1cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKlxuICogbGV0IGZvbyA9IFsgMCwgMiwgNCwgNiBdO1xuICogbGV0IGJhciA9IFsgMSwgMywgNSwgNyBdO1xuICogbGV0IGJheiA9IFsgMTAsIDMwLCA1MCwgNzAgXTtcbiAqIGFycmF5VHVwbGVzKGZvbywgYmFyKTsgICAgICAgLy8gWyBbMCwgMV0sIFsyLCAzXSwgWzQsIDVdLCBbNiwgN10gXVxuICogYXJyYXlUdXBsZXMoZm9vLCBiYXIsIGJheik7ICAvLyBbIFswLCAxLCAxMF0sIFsyLCAzLCAzMF0sIFs0LCA1LCA1MF0sIFs2LCA3LCA3MF0gXVxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIGFycmF5VHVwbGVzKCkge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiBbXTtcbiAgICB2YXIgbWF4QXJyYXlMZW4gPSBhcmdzLnJlZHVjZShmdW5jdGlvbiAobWluLCBhcnIpIHsgcmV0dXJuIE1hdGgubWluKGFyci5sZW5ndGgsIG1pbik7IH0sIDkwMDcxOTkyNTQ3NDA5OTEpOyAvLyBha2EgMl41MyDiiJIgMSBha2EgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICAvLyBUaGlzIGlzIGEgaG90IGZ1bmN0aW9uXG4gICAgICAgIC8vIFVucm9sbCB3aGVuIHRoZXJlIGFyZSAxLTQgYXJndW1lbnRzXG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChbYXJnc1swXVtpXV0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFthcmdzWzBdW2ldLCBhcmdzWzFdW2ldXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goW2FyZ3NbMF1baV0sIGFyZ3NbMV1baV0sIGFyZ3NbMl1baV1dKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChbYXJnc1swXVtpXSwgYXJnc1sxXVtpXSwgYXJnc1syXVtpXSwgYXJnc1szXVtpXV0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChhcmdzLm1hcChmdW5jdGlvbiAoYXJyYXkpIHsgcmV0dXJuIGFycmF5W2ldOyB9KSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF4QXJyYXlMZW47IGkrKykge1xuICAgICAgICBfbG9vcF8xKGkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5hcnJheVR1cGxlcyA9IGFycmF5VHVwbGVzO1xuLyoqXG4gKiBSZWR1Y2UgZnVuY3Rpb24gd2hpY2ggYnVpbGRzIGFuIG9iamVjdCBmcm9tIGFuIGFycmF5IG9mIFtrZXksIHZhbHVlXSBwYWlycy5cbiAqXG4gKiBFYWNoIGl0ZXJhdGlvbiBzZXRzIHRoZSBrZXkvdmFsIHBhaXIgb24gdGhlIG1lbW8gb2JqZWN0LCB0aGVuIHJldHVybnMgdGhlIG1lbW8gZm9yIHRoZSBuZXh0IGl0ZXJhdGlvbi5cbiAqXG4gKiBFYWNoIGtleVZhbHVlVHVwbGUgc2hvdWxkIGJlIGFuIGFycmF5IHdpdGggdmFsdWVzIFsga2V5OiBzdHJpbmcsIHZhbHVlOiBhbnkgXVxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBcbiAqXG4gKiB2YXIgcGFpcnMgPSBbIFtcImZvb2tleVwiLCBcImZvb3ZhbFwiXSwgW1wiYmFya2V5XCIsIFwiYmFydmFsXCJdIF1cbiAqXG4gKiB2YXIgcGFpcnNUb09iaiA9IHBhaXJzLnJlZHVjZSgobWVtbywgcGFpcikgPT4gYXBwbHlQYWlycyhtZW1vLCBwYWlyKSwge30pXG4gKiAvLyBwYWlyc1RvT2JqID09IHsgZm9va2V5OiBcImZvb3ZhbFwiLCBiYXJrZXk6IFwiYmFydmFsXCIgfVxuICpcbiAqIC8vIE9yLCBtb3JlIHNpbXBseTpcbiAqIHZhciBwYWlyc1RvT2JqID0gcGFpcnMucmVkdWNlKGFwcGx5UGFpcnMsIHt9KVxuICogLy8gcGFpcnNUb09iaiA9PSB7IGZvb2tleTogXCJmb292YWxcIiwgYmFya2V5OiBcImJhcnZhbFwiIH1cbiAqIGBgYFxuICovXG5mdW5jdGlvbiBhcHBseVBhaXJzKG1lbW8sIGtleVZhbFR1cGxlKSB7XG4gICAgdmFyIGtleSwgdmFsdWU7XG4gICAgaWYgKHByZWRpY2F0ZXNfMS5pc0FycmF5KGtleVZhbFR1cGxlKSlcbiAgICAgICAga2V5ID0ga2V5VmFsVHVwbGVbMF0sIHZhbHVlID0ga2V5VmFsVHVwbGVbMV07XG4gICAgaWYgKCFwcmVkaWNhdGVzXzEuaXNTdHJpbmcoa2V5KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHBhcmFtZXRlcnMgdG8gYXBwbHlQYWlycycpO1xuICAgIG1lbW9ba2V5XSA9IHZhbHVlO1xuICAgIHJldHVybiBtZW1vO1xufVxuZXhwb3J0cy5hcHBseVBhaXJzID0gYXBwbHlQYWlycztcbi8qKiBHZXQgdGhlIGxhc3QgZWxlbWVudCBvZiBhbiBhcnJheSAqL1xuZnVuY3Rpb24gdGFpbChhcnIpIHtcbiAgICByZXR1cm4gYXJyLmxlbmd0aCAmJiBhcnJbYXJyLmxlbmd0aCAtIDFdIHx8IHVuZGVmaW5lZDtcbn1cbmV4cG9ydHMudGFpbCA9IHRhaWw7XG4vKipcbiAqIHNoYWxsb3cgY29weSBmcm9tIHNyYyB0byBkZXN0XG4gKi9cbmZ1bmN0aW9uIGNvcHkoc3JjLCBkZXN0KSB7XG4gICAgaWYgKGRlc3QpXG4gICAgICAgIE9iamVjdC5rZXlzKGRlc3QpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gZGVsZXRlIGRlc3Rba2V5XTsgfSk7XG4gICAgaWYgKCFkZXN0KVxuICAgICAgICBkZXN0ID0ge307XG4gICAgcmV0dXJuIGV4cG9ydHMuZXh0ZW5kKGRlc3QsIHNyYyk7XG59XG5leHBvcnRzLmNvcHkgPSBjb3B5O1xuLyoqIE5haXZlIGZvckVhY2ggaW1wbGVtZW50YXRpb24gd29ya3Mgd2l0aCBPYmplY3RzIG9yIEFycmF5cyAqL1xuZnVuY3Rpb24gX2ZvckVhY2gob2JqLCBjYiwgX3RoaXMpIHtcbiAgICBpZiAocHJlZGljYXRlc18xLmlzQXJyYXkob2JqKSlcbiAgICAgICAgcmV0dXJuIG9iai5mb3JFYWNoKGNiLCBfdGhpcyk7XG4gICAgT2JqZWN0LmtleXMob2JqKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGNiKG9ialtrZXldLCBrZXkpOyB9KTtcbn1cbmZ1bmN0aW9uIF9leHRlbmQodG9PYmopIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgb2JqID0gYXJndW1lbnRzW2ldO1xuICAgICAgICBpZiAoIW9iailcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwga2V5cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdG9PYmpba2V5c1tqXV0gPSBvYmpba2V5c1tqXV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvT2JqO1xufVxuZXhwb3J0cy5fZXh0ZW5kID0gX2V4dGVuZDtcbmZ1bmN0aW9uIF9lcXVhbHMobzEsIG8yKSB7XG4gICAgaWYgKG8xID09PSBvMilcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKG8xID09PSBudWxsIHx8IG8yID09PSBudWxsKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKG8xICE9PSBvMSAmJiBvMiAhPT0gbzIpXG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBOYU4gPT09IE5hTlxuICAgIHZhciB0MSA9IHR5cGVvZiBvMSwgdDIgPSB0eXBlb2YgbzI7XG4gICAgaWYgKHQxICE9PSB0MiB8fCB0MSAhPT0gJ29iamVjdCcpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB2YXIgdHVwID0gW28xLCBvMl07XG4gICAgaWYgKGhvZl8xLmFsbChwcmVkaWNhdGVzXzEuaXNBcnJheSkodHVwKSlcbiAgICAgICAgcmV0dXJuIF9hcnJheXNFcShvMSwgbzIpO1xuICAgIGlmIChob2ZfMS5hbGwocHJlZGljYXRlc18xLmlzRGF0ZSkodHVwKSlcbiAgICAgICAgcmV0dXJuIG8xLmdldFRpbWUoKSA9PT0gbzIuZ2V0VGltZSgpO1xuICAgIGlmIChob2ZfMS5hbGwocHJlZGljYXRlc18xLmlzUmVnRXhwKSh0dXApKVxuICAgICAgICByZXR1cm4gbzEudG9TdHJpbmcoKSA9PT0gbzIudG9TdHJpbmcoKTtcbiAgICBpZiAoaG9mXzEuYWxsKHByZWRpY2F0ZXNfMS5pc0Z1bmN0aW9uKSh0dXApKVxuICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gbWVoXG4gICAgdmFyIHByZWRpY2F0ZXMgPSBbcHJlZGljYXRlc18xLmlzRnVuY3Rpb24sIHByZWRpY2F0ZXNfMS5pc0FycmF5LCBwcmVkaWNhdGVzXzEuaXNEYXRlLCBwcmVkaWNhdGVzXzEuaXNSZWdFeHBdO1xuICAgIGlmIChwcmVkaWNhdGVzLm1hcChob2ZfMS5hbnkpLnJlZHVjZShmdW5jdGlvbiAoYiwgZm4pIHsgcmV0dXJuIGIgfHwgISFmbih0dXApOyB9LCBmYWxzZSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB2YXIga2V5cyA9IHt9O1xuICAgIGZvciAodmFyIGtleSBpbiBvMSkge1xuICAgICAgICBpZiAoIV9lcXVhbHMobzFba2V5XSwgbzJba2V5XSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGtleXNba2V5XSA9IHRydWU7XG4gICAgfVxuICAgIGZvciAodmFyIGtleSBpbiBvMikge1xuICAgICAgICBpZiAoIWtleXNba2V5XSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBfYXJyYXlzRXEoYTEsIGEyKSB7XG4gICAgaWYgKGExLmxlbmd0aCAhPT0gYTIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIGFycmF5VHVwbGVzKGExLCBhMikucmVkdWNlKGZ1bmN0aW9uIChiLCB0KSB7IHJldHVybiBiICYmIF9lcXVhbHModFswXSwgdFsxXSk7IH0sIHRydWUpO1xufVxuLy8gaXNzdWUgIzI2NzZcbmV4cG9ydHMuc2lsZW5jZVVuY2F1Z2h0SW5Qcm9taXNlID0gZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgICByZXR1cm4gcHJvbWlzZS5jYXRjaChmdW5jdGlvbiAoZSkgeyByZXR1cm4gMDsgfSkgJiYgcHJvbWlzZTtcbn07XG5leHBvcnRzLnNpbGVudFJlamVjdGlvbiA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgIHJldHVybiBleHBvcnRzLnNpbGVuY2VVbmNhdWdodEluUHJvbWlzZShjb3Jlc2VydmljZXNfMS5zZXJ2aWNlcy4kcS5yZWplY3QoZXJyb3IpKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21tb24uanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2NvbW1vbi9jb21tb24uanNcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n')},function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** Predicates\n *\n * These predicates return true/false based on the input.\n * Although these functions are exported, they are subject to change without notice.\n *\n * @module common_predicates\n */\n/** */\nvar hof_1 = __webpack_require__(2);\nvar stateObject_1 = __webpack_require__(42);\nvar toStr = Object.prototype.toString;\nvar tis = function (t) { return function (x) { return typeof (x) === t; }; };\nexports.isUndefined = tis('undefined');\nexports.isDefined = hof_1.not(exports.isUndefined);\nexports.isNull = function (o) { return o === null; };\nexports.isNullOrUndefined = hof_1.or(exports.isNull, exports.isUndefined);\nexports.isFunction = tis('function');\nexports.isNumber = tis('number');\nexports.isString = tis('string');\nexports.isObject = function (x) { return x !== null && typeof x === 'object'; };\nexports.isArray = Array.isArray;\nexports.isDate = (function (x) { return toStr.call(x) === '[object Date]'; });\nexports.isRegExp = (function (x) { return toStr.call(x) === '[object RegExp]'; });\nexports.isState = stateObject_1.StateObject.isState;\n/**\n * Predicate which checks if a value is injectable\n *\n * A value is \"injectable\" if it is a function, or if it is an ng1 array-notation-style array\n * where all the elements in the array are Strings, except the last one, which is a Function\n */\nfunction isInjectable(val) {\n    if (exports.isArray(val) && val.length) {\n        var head = val.slice(0, -1), tail = val.slice(-1);\n        return !(head.filter(hof_1.not(exports.isString)).length || tail.filter(hof_1.not(exports.isFunction)).length);\n    }\n    return exports.isFunction(val);\n}\nexports.isInjectable = isInjectable;\n/**\n * Predicate which checks if a value looks like a Promise\n *\n * It is probably a Promise if it's an object, and it has a `then` property which is a Function\n */\nexports.isPromise = hof_1.and(exports.isObject, hof_1.pipe(hof_1.prop('then'), exports.isFunction));\n//# sourceMappingURL=predicates.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvY29tbW9uL3ByZWRpY2F0ZXMuanM/ZTdjZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKiBQcmVkaWNhdGVzXG4gKlxuICogVGhlc2UgcHJlZGljYXRlcyByZXR1cm4gdHJ1ZS9mYWxzZSBiYXNlZCBvbiB0aGUgaW5wdXQuXG4gKiBBbHRob3VnaCB0aGVzZSBmdW5jdGlvbnMgYXJlIGV4cG9ydGVkLCB0aGV5IGFyZSBzdWJqZWN0IHRvIGNoYW5nZSB3aXRob3V0IG5vdGljZS5cbiAqXG4gKiBAbW9kdWxlIGNvbW1vbl9wcmVkaWNhdGVzXG4gKi9cbi8qKiAqL1xudmFyIGhvZl8xID0gcmVxdWlyZShcIi4vaG9mXCIpO1xudmFyIHN0YXRlT2JqZWN0XzEgPSByZXF1aXJlKFwiLi4vc3RhdGUvc3RhdGVPYmplY3RcIik7XG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIHRpcyA9IGZ1bmN0aW9uICh0KSB7IHJldHVybiBmdW5jdGlvbiAoeCkgeyByZXR1cm4gdHlwZW9mICh4KSA9PT0gdDsgfTsgfTtcbmV4cG9ydHMuaXNVbmRlZmluZWQgPSB0aXMoJ3VuZGVmaW5lZCcpO1xuZXhwb3J0cy5pc0RlZmluZWQgPSBob2ZfMS5ub3QoZXhwb3J0cy5pc1VuZGVmaW5lZCk7XG5leHBvcnRzLmlzTnVsbCA9IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvID09PSBudWxsOyB9O1xuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGhvZl8xLm9yKGV4cG9ydHMuaXNOdWxsLCBleHBvcnRzLmlzVW5kZWZpbmVkKTtcbmV4cG9ydHMuaXNGdW5jdGlvbiA9IHRpcygnZnVuY3Rpb24nKTtcbmV4cG9ydHMuaXNOdW1iZXIgPSB0aXMoJ251bWJlcicpO1xuZXhwb3J0cy5pc1N0cmluZyA9IHRpcygnc3RyaW5nJyk7XG5leHBvcnRzLmlzT2JqZWN0ID0gZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggIT09IG51bGwgJiYgdHlwZW9mIHggPT09ICdvYmplY3QnOyB9O1xuZXhwb3J0cy5pc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbmV4cG9ydHMuaXNEYXRlID0gKGZ1bmN0aW9uICh4KSB7IHJldHVybiB0b1N0ci5jYWxsKHgpID09PSAnW29iamVjdCBEYXRlXSc7IH0pO1xuZXhwb3J0cy5pc1JlZ0V4cCA9IChmdW5jdGlvbiAoeCkgeyByZXR1cm4gdG9TdHIuY2FsbCh4KSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7IH0pO1xuZXhwb3J0cy5pc1N0YXRlID0gc3RhdGVPYmplY3RfMS5TdGF0ZU9iamVjdC5pc1N0YXRlO1xuLyoqXG4gKiBQcmVkaWNhdGUgd2hpY2ggY2hlY2tzIGlmIGEgdmFsdWUgaXMgaW5qZWN0YWJsZVxuICpcbiAqIEEgdmFsdWUgaXMgXCJpbmplY3RhYmxlXCIgaWYgaXQgaXMgYSBmdW5jdGlvbiwgb3IgaWYgaXQgaXMgYW4gbmcxIGFycmF5LW5vdGF0aW9uLXN0eWxlIGFycmF5XG4gKiB3aGVyZSBhbGwgdGhlIGVsZW1lbnRzIGluIHRoZSBhcnJheSBhcmUgU3RyaW5ncywgZXhjZXB0IHRoZSBsYXN0IG9uZSwgd2hpY2ggaXMgYSBGdW5jdGlvblxuICovXG5mdW5jdGlvbiBpc0luamVjdGFibGUodmFsKSB7XG4gICAgaWYgKGV4cG9ydHMuaXNBcnJheSh2YWwpICYmIHZhbC5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGhlYWQgPSB2YWwuc2xpY2UoMCwgLTEpLCB0YWlsID0gdmFsLnNsaWNlKC0xKTtcbiAgICAgICAgcmV0dXJuICEoaGVhZC5maWx0ZXIoaG9mXzEubm90KGV4cG9ydHMuaXNTdHJpbmcpKS5sZW5ndGggfHwgdGFpbC5maWx0ZXIoaG9mXzEubm90KGV4cG9ydHMuaXNGdW5jdGlvbikpLmxlbmd0aCk7XG4gICAgfVxuICAgIHJldHVybiBleHBvcnRzLmlzRnVuY3Rpb24odmFsKTtcbn1cbmV4cG9ydHMuaXNJbmplY3RhYmxlID0gaXNJbmplY3RhYmxlO1xuLyoqXG4gKiBQcmVkaWNhdGUgd2hpY2ggY2hlY2tzIGlmIGEgdmFsdWUgbG9va3MgbGlrZSBhIFByb21pc2VcbiAqXG4gKiBJdCBpcyBwcm9iYWJseSBhIFByb21pc2UgaWYgaXQncyBhbiBvYmplY3QsIGFuZCBpdCBoYXMgYSBgdGhlbmAgcHJvcGVydHkgd2hpY2ggaXMgYSBGdW5jdGlvblxuICovXG5leHBvcnRzLmlzUHJvbWlzZSA9IGhvZl8xLmFuZChleHBvcnRzLmlzT2JqZWN0LCBob2ZfMS5waXBlKGhvZl8xLnByb3AoJ3RoZW4nKSwgZXhwb3J0cy5pc0Z1bmN0aW9uKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcmVkaWNhdGVzLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9jb21tb24vcHJlZGljYXRlcy5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1\n")},function(module,exports,__webpack_require__){"use strict";eval('\n/**\n * Higher order functions\n *\n * These utility functions are exported, but are subject to change without notice.\n *\n * @module common_hof\n */ /** */\nObject.defineProperty(exports, "__esModule", { value: true });\n/**\n * Returns a new function for [Partial Application](https://en.wikipedia.org/wiki/Partial_application) of the original function.\n *\n * Given a function with N parameters, returns a new function that supports partial application.\n * The new function accepts anywhere from 1 to N parameters.  When that function is called with M parameters,\n * where M is less than N, it returns a new function that accepts the remaining parameters.  It continues to\n * accept more parameters until all N parameters have been supplied.\n *\n *\n * This contrived example uses a partially applied function as an predicate, which returns true\n * if an object is found in both arrays.\n * @example\n * ```\n * // returns true if an object is in both of the two arrays\n * function inBoth(array1, array2, object) {\n *   return array1.indexOf(object) !== -1 &&\n *          array2.indexOf(object) !== 1;\n * }\n * let obj1, obj2, obj3, obj4, obj5, obj6, obj7\n * let foos = [obj1, obj3]\n * let bars = [obj3, obj4, obj5]\n *\n * // A curried "copy" of inBoth\n * let curriedInBoth = curry(inBoth);\n * // Partially apply both the array1 and array2\n * let inFoosAndBars = curriedInBoth(foos, bars);\n *\n * // Supply the final argument; since all arguments are\n * // supplied, the original inBoth function is then called.\n * let obj1InBoth = inFoosAndBars(obj1); // false\n *\n * // Use the inFoosAndBars as a predicate.\n * // Filter, on each iteration, supplies the final argument\n * let allObjs = [ obj1, obj2, obj3, obj4, obj5, obj6, obj7 ];\n * let foundInBoth = allObjs.filter(inFoosAndBars); // [ obj3 ]\n *\n * ```\n *\n * Stolen from: http://stackoverflow.com/questions/4394747/javascript-curry-function\n *\n * @param fn\n * @returns {*|function(): (*|any)}\n */\nfunction curry(fn) {\n    var initial_args = [].slice.apply(arguments, [1]);\n    var func_args_length = fn.length;\n    function curried(args) {\n        if (args.length >= func_args_length)\n            return fn.apply(null, args);\n        return function () {\n            return curried(args.concat([].slice.apply(arguments)));\n        };\n    }\n    return curried(initial_args);\n}\nexports.curry = curry;\n/**\n * Given a varargs list of functions, returns a function that composes the argument functions, right-to-left\n * given: f(x), g(x), h(x)\n * let composed = compose(f,g,h)\n * then, composed is: f(g(h(x)))\n */\nfunction compose() {\n    var args = arguments;\n    var start = args.length - 1;\n    return function () {\n        var i = start, result = args[start].apply(this, arguments);\n        while (i--)\n            result = args[i].call(this, result);\n        return result;\n    };\n}\nexports.compose = compose;\n/**\n * Given a varargs list of functions, returns a function that is composes the argument functions, left-to-right\n * given: f(x), g(x), h(x)\n * let piped = pipe(f,g,h);\n * then, piped is: h(g(f(x)))\n */\nfunction pipe() {\n    var funcs = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        funcs[_i] = arguments[_i];\n    }\n    return compose.apply(null, [].slice.call(arguments).reverse());\n}\nexports.pipe = pipe;\n/**\n * Given a property name, returns a function that returns that property from an object\n * let obj = { foo: 1, name: "blarg" };\n * let getName = prop("name");\n * getName(obj) === "blarg"\n */\nexports.prop = function (name) {\n    return function (obj) { return obj && obj[name]; };\n};\n/**\n * Given a property name and a value, returns a function that returns a boolean based on whether\n * the passed object has a property that matches the value\n * let obj = { foo: 1, name: "blarg" };\n * let getName = propEq("name", "blarg");\n * getName(obj) === true\n */\nexports.propEq = curry(function (name, _val, obj) { return obj && obj[name] === _val; });\n/**\n * Given a dotted property name, returns a function that returns a nested property from an object, or undefined\n * let obj = { id: 1, nestedObj: { foo: 1, name: "blarg" }, };\n * let getName = prop("nestedObj.name");\n * getName(obj) === "blarg"\n * let propNotFound = prop("this.property.doesnt.exist");\n * propNotFound(obj) === undefined\n */\nexports.parse = function (name) {\n    return pipe.apply(null, name.split(\'.\').map(exports.prop));\n};\n/**\n * Given a function that returns a truthy or falsey value, returns a\n * function that returns the opposite (falsey or truthy) value given the same inputs\n */\nexports.not = function (fn) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        return !fn.apply(null, args);\n    };\n};\n/**\n * Given two functions that return truthy or falsey values, returns a function that returns truthy\n * if both functions return truthy for the given arguments\n */\nfunction and(fn1, fn2) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        return fn1.apply(null, args) && fn2.apply(null, args);\n    };\n}\nexports.and = and;\n/**\n * Given two functions that return truthy or falsey values, returns a function that returns truthy\n * if at least one of the functions returns truthy for the given arguments\n */\nfunction or(fn1, fn2) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        return fn1.apply(null, args) || fn2.apply(null, args);\n    };\n}\nexports.or = or;\n/**\n * Check if all the elements of an array match a predicate function\n *\n * @param fn1 a predicate function `fn1`\n * @returns a function which takes an array and returns true if `fn1` is true for all elements of the array\n */\nexports.all = function (fn1) {\n    return function (arr) { return arr.reduce(function (b, x) { return b && !!fn1(x); }, true); };\n};\n// tslint:disable-next-line:variable-name\nexports.any = function (fn1) {\n    return function (arr) { return arr.reduce(function (b, x) { return b || !!fn1(x); }, false); };\n};\n/** Given a class, returns a Predicate function that returns true if the object is of that class */\nexports.is = function (ctor) {\n    return function (obj) {\n        return (obj != null && obj.constructor === ctor || obj instanceof ctor);\n    };\n};\n/** Given a value, returns a Predicate function that returns true if another value is === equal to the original value */\nexports.eq = function (value) { return function (other) {\n    return value === other;\n}; };\n/** Given a value, returns a function which returns the value */\nexports.val = function (v) { return function () { return v; }; };\nfunction invoke(fnName, args) {\n    return function (obj) {\n        return obj[fnName].apply(obj, args);\n    };\n}\nexports.invoke = invoke;\n/**\n * Sorta like Pattern Matching (a functional programming conditional construct)\n *\n * See http://c2.com/cgi/wiki?PatternMatching\n *\n * This is a conditional construct which allows a series of predicates and output functions\n * to be checked and then applied.  Each predicate receives the input.  If the predicate\n * returns truthy, then its matching output function (mapping function) is provided with\n * the input and, then the result is returned.\n *\n * Each combination (2-tuple) of predicate + output function should be placed in an array\n * of size 2: [ predicate, mapFn ]\n *\n * These 2-tuples should be put in an outer array.\n *\n * @example\n * ```\n *\n * // Here\'s a 2-tuple where the first element is the isString predicate\n * // and the second element is a function that returns a description of the input\n * let firstTuple = [ angular.isString, (input) => `Heres your string ${input}` ];\n *\n * // Second tuple: predicate "isNumber", mapfn returns a description\n * let secondTuple = [ angular.isNumber, (input) => `(${input}) That\'s a number!` ];\n *\n * let third = [ (input) => input === null,  (input) => `Oh, null...` ];\n *\n * let fourth = [ (input) => input === undefined,  (input) => `notdefined` ];\n *\n * let descriptionOf = pattern([ firstTuple, secondTuple, third, fourth ]);\n *\n * console.log(descriptionOf(undefined)); // \'notdefined\'\n * console.log(descriptionOf(55)); // \'(55) That\'s a number!\'\n * console.log(descriptionOf("foo")); // \'Here\'s your string foo\'\n * ```\n *\n * @param struct A 2D array.  Each element of the array should be an array, a 2-tuple,\n * with a Predicate and a mapping/output function\n * @returns {function(any): *}\n */\nfunction pattern(struct) {\n    return function (x) {\n        for (var i = 0; i < struct.length; i++) {\n            if (struct[i][0](x))\n                return struct[i][1](x);\n        }\n    };\n}\nexports.pattern = pattern;\n//# sourceMappingURL=hof.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvY29tbW9uL2hvZi5qcz8zOGY2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBIaWdoZXIgb3JkZXIgZnVuY3Rpb25zXG4gKlxuICogVGhlc2UgdXRpbGl0eSBmdW5jdGlvbnMgYXJlIGV4cG9ydGVkLCBidXQgYXJlIHN1YmplY3QgdG8gY2hhbmdlIHdpdGhvdXQgbm90aWNlLlxuICpcbiAqIEBtb2R1bGUgY29tbW9uX2hvZlxuICovIC8qKiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IGZ1bmN0aW9uIGZvciBbUGFydGlhbCBBcHBsaWNhdGlvbl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUGFydGlhbF9hcHBsaWNhdGlvbikgb2YgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uLlxuICpcbiAqIEdpdmVuIGEgZnVuY3Rpb24gd2l0aCBOIHBhcmFtZXRlcnMsIHJldHVybnMgYSBuZXcgZnVuY3Rpb24gdGhhdCBzdXBwb3J0cyBwYXJ0aWFsIGFwcGxpY2F0aW9uLlxuICogVGhlIG5ldyBmdW5jdGlvbiBhY2NlcHRzIGFueXdoZXJlIGZyb20gMSB0byBOIHBhcmFtZXRlcnMuICBXaGVuIHRoYXQgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggTSBwYXJhbWV0ZXJzLFxuICogd2hlcmUgTSBpcyBsZXNzIHRoYW4gTiwgaXQgcmV0dXJucyBhIG5ldyBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgdGhlIHJlbWFpbmluZyBwYXJhbWV0ZXJzLiAgSXQgY29udGludWVzIHRvXG4gKiBhY2NlcHQgbW9yZSBwYXJhbWV0ZXJzIHVudGlsIGFsbCBOIHBhcmFtZXRlcnMgaGF2ZSBiZWVuIHN1cHBsaWVkLlxuICpcbiAqXG4gKiBUaGlzIGNvbnRyaXZlZCBleGFtcGxlIHVzZXMgYSBwYXJ0aWFsbHkgYXBwbGllZCBmdW5jdGlvbiBhcyBhbiBwcmVkaWNhdGUsIHdoaWNoIHJldHVybnMgdHJ1ZVxuICogaWYgYW4gb2JqZWN0IGlzIGZvdW5kIGluIGJvdGggYXJyYXlzLlxuICogQGV4YW1wbGVcbiAqIGBgYFxuICogLy8gcmV0dXJucyB0cnVlIGlmIGFuIG9iamVjdCBpcyBpbiBib3RoIG9mIHRoZSB0d28gYXJyYXlzXG4gKiBmdW5jdGlvbiBpbkJvdGgoYXJyYXkxLCBhcnJheTIsIG9iamVjdCkge1xuICogICByZXR1cm4gYXJyYXkxLmluZGV4T2Yob2JqZWN0KSAhPT0gLTEgJiZcbiAqICAgICAgICAgIGFycmF5Mi5pbmRleE9mKG9iamVjdCkgIT09IDE7XG4gKiB9XG4gKiBsZXQgb2JqMSwgb2JqMiwgb2JqMywgb2JqNCwgb2JqNSwgb2JqNiwgb2JqN1xuICogbGV0IGZvb3MgPSBbb2JqMSwgb2JqM11cbiAqIGxldCBiYXJzID0gW29iajMsIG9iajQsIG9iajVdXG4gKlxuICogLy8gQSBjdXJyaWVkIFwiY29weVwiIG9mIGluQm90aFxuICogbGV0IGN1cnJpZWRJbkJvdGggPSBjdXJyeShpbkJvdGgpO1xuICogLy8gUGFydGlhbGx5IGFwcGx5IGJvdGggdGhlIGFycmF5MSBhbmQgYXJyYXkyXG4gKiBsZXQgaW5Gb29zQW5kQmFycyA9IGN1cnJpZWRJbkJvdGgoZm9vcywgYmFycyk7XG4gKlxuICogLy8gU3VwcGx5IHRoZSBmaW5hbCBhcmd1bWVudDsgc2luY2UgYWxsIGFyZ3VtZW50cyBhcmVcbiAqIC8vIHN1cHBsaWVkLCB0aGUgb3JpZ2luYWwgaW5Cb3RoIGZ1bmN0aW9uIGlzIHRoZW4gY2FsbGVkLlxuICogbGV0IG9iajFJbkJvdGggPSBpbkZvb3NBbmRCYXJzKG9iajEpOyAvLyBmYWxzZVxuICpcbiAqIC8vIFVzZSB0aGUgaW5Gb29zQW5kQmFycyBhcyBhIHByZWRpY2F0ZS5cbiAqIC8vIEZpbHRlciwgb24gZWFjaCBpdGVyYXRpb24sIHN1cHBsaWVzIHRoZSBmaW5hbCBhcmd1bWVudFxuICogbGV0IGFsbE9ianMgPSBbIG9iajEsIG9iajIsIG9iajMsIG9iajQsIG9iajUsIG9iajYsIG9iajcgXTtcbiAqIGxldCBmb3VuZEluQm90aCA9IGFsbE9ianMuZmlsdGVyKGluRm9vc0FuZEJhcnMpOyAvLyBbIG9iajMgXVxuICpcbiAqIGBgYFxuICpcbiAqIFN0b2xlbiBmcm9tOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQzOTQ3NDcvamF2YXNjcmlwdC1jdXJyeS1mdW5jdGlvblxuICpcbiAqIEBwYXJhbSBmblxuICogQHJldHVybnMgeyp8ZnVuY3Rpb24oKTogKCp8YW55KX1cbiAqL1xuZnVuY3Rpb24gY3VycnkoZm4pIHtcbiAgICB2YXIgaW5pdGlhbF9hcmdzID0gW10uc2xpY2UuYXBwbHkoYXJndW1lbnRzLCBbMV0pO1xuICAgIHZhciBmdW5jX2FyZ3NfbGVuZ3RoID0gZm4ubGVuZ3RoO1xuICAgIGZ1bmN0aW9uIGN1cnJpZWQoYXJncykge1xuICAgICAgICBpZiAoYXJncy5sZW5ndGggPj0gZnVuY19hcmdzX2xlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBjdXJyaWVkKGFyZ3MuY29uY2F0KFtdLnNsaWNlLmFwcGx5KGFyZ3VtZW50cykpKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGN1cnJpZWQoaW5pdGlhbF9hcmdzKTtcbn1cbmV4cG9ydHMuY3VycnkgPSBjdXJyeTtcbi8qKlxuICogR2l2ZW4gYSB2YXJhcmdzIGxpc3Qgb2YgZnVuY3Rpb25zLCByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBjb21wb3NlcyB0aGUgYXJndW1lbnQgZnVuY3Rpb25zLCByaWdodC10by1sZWZ0XG4gKiBnaXZlbjogZih4KSwgZyh4KSwgaCh4KVxuICogbGV0IGNvbXBvc2VkID0gY29tcG9zZShmLGcsaClcbiAqIHRoZW4sIGNvbXBvc2VkIGlzOiBmKGcoaCh4KSkpXG4gKi9cbmZ1bmN0aW9uIGNvbXBvc2UoKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgdmFyIHN0YXJ0ID0gYXJncy5sZW5ndGggLSAxO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpID0gc3RhcnQsIHJlc3VsdCA9IGFyZ3Nbc3RhcnRdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHdoaWxlIChpLS0pXG4gICAgICAgICAgICByZXN1bHQgPSBhcmdzW2ldLmNhbGwodGhpcywgcmVzdWx0KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xufVxuZXhwb3J0cy5jb21wb3NlID0gY29tcG9zZTtcbi8qKlxuICogR2l2ZW4gYSB2YXJhcmdzIGxpc3Qgb2YgZnVuY3Rpb25zLCByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBpcyBjb21wb3NlcyB0aGUgYXJndW1lbnQgZnVuY3Rpb25zLCBsZWZ0LXRvLXJpZ2h0XG4gKiBnaXZlbjogZih4KSwgZyh4KSwgaCh4KVxuICogbGV0IHBpcGVkID0gcGlwZShmLGcsaCk7XG4gKiB0aGVuLCBwaXBlZCBpczogaChnKGYoeCkpKVxuICovXG5mdW5jdGlvbiBwaXBlKCkge1xuICAgIHZhciBmdW5jcyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIGZ1bmNzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHJldHVybiBjb21wb3NlLmFwcGx5KG51bGwsIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5yZXZlcnNlKCkpO1xufVxuZXhwb3J0cy5waXBlID0gcGlwZTtcbi8qKlxuICogR2l2ZW4gYSBwcm9wZXJ0eSBuYW1lLCByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoYXQgcHJvcGVydHkgZnJvbSBhbiBvYmplY3RcbiAqIGxldCBvYmogPSB7IGZvbzogMSwgbmFtZTogXCJibGFyZ1wiIH07XG4gKiBsZXQgZ2V0TmFtZSA9IHByb3AoXCJuYW1lXCIpO1xuICogZ2V0TmFtZShvYmopID09PSBcImJsYXJnXCJcbiAqL1xuZXhwb3J0cy5wcm9wID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIG9ialtuYW1lXTsgfTtcbn07XG4vKipcbiAqIEdpdmVuIGEgcHJvcGVydHkgbmFtZSBhbmQgYSB2YWx1ZSwgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGJvb2xlYW4gYmFzZWQgb24gd2hldGhlclxuICogdGhlIHBhc3NlZCBvYmplY3QgaGFzIGEgcHJvcGVydHkgdGhhdCBtYXRjaGVzIHRoZSB2YWx1ZVxuICogbGV0IG9iaiA9IHsgZm9vOiAxLCBuYW1lOiBcImJsYXJnXCIgfTtcbiAqIGxldCBnZXROYW1lID0gcHJvcEVxKFwibmFtZVwiLCBcImJsYXJnXCIpO1xuICogZ2V0TmFtZShvYmopID09PSB0cnVlXG4gKi9cbmV4cG9ydHMucHJvcEVxID0gY3VycnkoZnVuY3Rpb24gKG5hbWUsIF92YWwsIG9iaikgeyByZXR1cm4gb2JqICYmIG9ialtuYW1lXSA9PT0gX3ZhbDsgfSk7XG4vKipcbiAqIEdpdmVuIGEgZG90dGVkIHByb3BlcnR5IG5hbWUsIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBuZXN0ZWQgcHJvcGVydHkgZnJvbSBhbiBvYmplY3QsIG9yIHVuZGVmaW5lZFxuICogbGV0IG9iaiA9IHsgaWQ6IDEsIG5lc3RlZE9iajogeyBmb286IDEsIG5hbWU6IFwiYmxhcmdcIiB9LCB9O1xuICogbGV0IGdldE5hbWUgPSBwcm9wKFwibmVzdGVkT2JqLm5hbWVcIik7XG4gKiBnZXROYW1lKG9iaikgPT09IFwiYmxhcmdcIlxuICogbGV0IHByb3BOb3RGb3VuZCA9IHByb3AoXCJ0aGlzLnByb3BlcnR5LmRvZXNudC5leGlzdFwiKTtcbiAqIHByb3BOb3RGb3VuZChvYmopID09PSB1bmRlZmluZWRcbiAqL1xuZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIHBpcGUuYXBwbHkobnVsbCwgbmFtZS5zcGxpdCgnLicpLm1hcChleHBvcnRzLnByb3ApKTtcbn07XG4vKipcbiAqIEdpdmVuIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgdHJ1dGh5IG9yIGZhbHNleSB2YWx1ZSwgcmV0dXJucyBhXG4gKiBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIG9wcG9zaXRlIChmYWxzZXkgb3IgdHJ1dGh5KSB2YWx1ZSBnaXZlbiB0aGUgc2FtZSBpbnB1dHNcbiAqL1xuZXhwb3J0cy5ub3QgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfTtcbn07XG4vKipcbiAqIEdpdmVuIHR3byBmdW5jdGlvbnMgdGhhdCByZXR1cm4gdHJ1dGh5IG9yIGZhbHNleSB2YWx1ZXMsIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdHJ1dGh5XG4gKiBpZiBib3RoIGZ1bmN0aW9ucyByZXR1cm4gdHJ1dGh5IGZvciB0aGUgZ2l2ZW4gYXJndW1lbnRzXG4gKi9cbmZ1bmN0aW9uIGFuZChmbjEsIGZuMikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZuMS5hcHBseShudWxsLCBhcmdzKSAmJiBmbjIuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfTtcbn1cbmV4cG9ydHMuYW5kID0gYW5kO1xuLyoqXG4gKiBHaXZlbiB0d28gZnVuY3Rpb25zIHRoYXQgcmV0dXJuIHRydXRoeSBvciBmYWxzZXkgdmFsdWVzLCByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRydXRoeVxuICogaWYgYXQgbGVhc3Qgb25lIG9mIHRoZSBmdW5jdGlvbnMgcmV0dXJucyB0cnV0aHkgZm9yIHRoZSBnaXZlbiBhcmd1bWVudHNcbiAqL1xuZnVuY3Rpb24gb3IoZm4xLCBmbjIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmbjEuYXBwbHkobnVsbCwgYXJncykgfHwgZm4yLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH07XG59XG5leHBvcnRzLm9yID0gb3I7XG4vKipcbiAqIENoZWNrIGlmIGFsbCB0aGUgZWxlbWVudHMgb2YgYW4gYXJyYXkgbWF0Y2ggYSBwcmVkaWNhdGUgZnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0gZm4xIGEgcHJlZGljYXRlIGZ1bmN0aW9uIGBmbjFgXG4gKiBAcmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIHRha2VzIGFuIGFycmF5IGFuZCByZXR1cm5zIHRydWUgaWYgYGZuMWAgaXMgdHJ1ZSBmb3IgYWxsIGVsZW1lbnRzIG9mIHRoZSBhcnJheVxuICovXG5leHBvcnRzLmFsbCA9IGZ1bmN0aW9uIChmbjEpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFycikgeyByZXR1cm4gYXJyLnJlZHVjZShmdW5jdGlvbiAoYiwgeCkgeyByZXR1cm4gYiAmJiAhIWZuMSh4KTsgfSwgdHJ1ZSk7IH07XG59O1xuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnZhcmlhYmxlLW5hbWVcbmV4cG9ydHMuYW55ID0gZnVuY3Rpb24gKGZuMSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYXJyKSB7IHJldHVybiBhcnIucmVkdWNlKGZ1bmN0aW9uIChiLCB4KSB7IHJldHVybiBiIHx8ICEhZm4xKHgpOyB9LCBmYWxzZSk7IH07XG59O1xuLyoqIEdpdmVuIGEgY2xhc3MsIHJldHVybnMgYSBQcmVkaWNhdGUgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRydWUgaWYgdGhlIG9iamVjdCBpcyBvZiB0aGF0IGNsYXNzICovXG5leHBvcnRzLmlzID0gZnVuY3Rpb24gKGN0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gKG9iaiAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gY3RvciB8fCBvYmogaW5zdGFuY2VvZiBjdG9yKTtcbiAgICB9O1xufTtcbi8qKiBHaXZlbiBhIHZhbHVlLCByZXR1cm5zIGEgUHJlZGljYXRlIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0cnVlIGlmIGFub3RoZXIgdmFsdWUgaXMgPT09IGVxdWFsIHRvIHRoZSBvcmlnaW5hbCB2YWx1ZSAqL1xuZXhwb3J0cy5lcSA9IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBvdGhlcjtcbn07IH07XG4vKiogR2l2ZW4gYSB2YWx1ZSwgcmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgdGhlIHZhbHVlICovXG5leHBvcnRzLnZhbCA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiB2OyB9OyB9O1xuZnVuY3Rpb24gaW52b2tlKGZuTmFtZSwgYXJncykge1xuICAgIHJldHVybiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmpbZm5OYW1lXS5hcHBseShvYmosIGFyZ3MpO1xuICAgIH07XG59XG5leHBvcnRzLmludm9rZSA9IGludm9rZTtcbi8qKlxuICogU29ydGEgbGlrZSBQYXR0ZXJuIE1hdGNoaW5nIChhIGZ1bmN0aW9uYWwgcHJvZ3JhbW1pbmcgY29uZGl0aW9uYWwgY29uc3RydWN0KVxuICpcbiAqIFNlZSBodHRwOi8vYzIuY29tL2NnaS93aWtpP1BhdHRlcm5NYXRjaGluZ1xuICpcbiAqIFRoaXMgaXMgYSBjb25kaXRpb25hbCBjb25zdHJ1Y3Qgd2hpY2ggYWxsb3dzIGEgc2VyaWVzIG9mIHByZWRpY2F0ZXMgYW5kIG91dHB1dCBmdW5jdGlvbnNcbiAqIHRvIGJlIGNoZWNrZWQgYW5kIHRoZW4gYXBwbGllZC4gIEVhY2ggcHJlZGljYXRlIHJlY2VpdmVzIHRoZSBpbnB1dC4gIElmIHRoZSBwcmVkaWNhdGVcbiAqIHJldHVybnMgdHJ1dGh5LCB0aGVuIGl0cyBtYXRjaGluZyBvdXRwdXQgZnVuY3Rpb24gKG1hcHBpbmcgZnVuY3Rpb24pIGlzIHByb3ZpZGVkIHdpdGhcbiAqIHRoZSBpbnB1dCBhbmQsIHRoZW4gdGhlIHJlc3VsdCBpcyByZXR1cm5lZC5cbiAqXG4gKiBFYWNoIGNvbWJpbmF0aW9uICgyLXR1cGxlKSBvZiBwcmVkaWNhdGUgKyBvdXRwdXQgZnVuY3Rpb24gc2hvdWxkIGJlIHBsYWNlZCBpbiBhbiBhcnJheVxuICogb2Ygc2l6ZSAyOiBbIHByZWRpY2F0ZSwgbWFwRm4gXVxuICpcbiAqIFRoZXNlIDItdHVwbGVzIHNob3VsZCBiZSBwdXQgaW4gYW4gb3V0ZXIgYXJyYXkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYFxuICpcbiAqIC8vIEhlcmUncyBhIDItdHVwbGUgd2hlcmUgdGhlIGZpcnN0IGVsZW1lbnQgaXMgdGhlIGlzU3RyaW5nIHByZWRpY2F0ZVxuICogLy8gYW5kIHRoZSBzZWNvbmQgZWxlbWVudCBpcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGRlc2NyaXB0aW9uIG9mIHRoZSBpbnB1dFxuICogbGV0IGZpcnN0VHVwbGUgPSBbIGFuZ3VsYXIuaXNTdHJpbmcsIChpbnB1dCkgPT4gYEhlcmVzIHlvdXIgc3RyaW5nICR7aW5wdXR9YCBdO1xuICpcbiAqIC8vIFNlY29uZCB0dXBsZTogcHJlZGljYXRlIFwiaXNOdW1iZXJcIiwgbWFwZm4gcmV0dXJucyBhIGRlc2NyaXB0aW9uXG4gKiBsZXQgc2Vjb25kVHVwbGUgPSBbIGFuZ3VsYXIuaXNOdW1iZXIsIChpbnB1dCkgPT4gYCgke2lucHV0fSkgVGhhdCdzIGEgbnVtYmVyIWAgXTtcbiAqXG4gKiBsZXQgdGhpcmQgPSBbIChpbnB1dCkgPT4gaW5wdXQgPT09IG51bGwsICAoaW5wdXQpID0+IGBPaCwgbnVsbC4uLmAgXTtcbiAqXG4gKiBsZXQgZm91cnRoID0gWyAoaW5wdXQpID0+IGlucHV0ID09PSB1bmRlZmluZWQsICAoaW5wdXQpID0+IGBub3RkZWZpbmVkYCBdO1xuICpcbiAqIGxldCBkZXNjcmlwdGlvbk9mID0gcGF0dGVybihbIGZpcnN0VHVwbGUsIHNlY29uZFR1cGxlLCB0aGlyZCwgZm91cnRoIF0pO1xuICpcbiAqIGNvbnNvbGUubG9nKGRlc2NyaXB0aW9uT2YodW5kZWZpbmVkKSk7IC8vICdub3RkZWZpbmVkJ1xuICogY29uc29sZS5sb2coZGVzY3JpcHRpb25PZig1NSkpOyAvLyAnKDU1KSBUaGF0J3MgYSBudW1iZXIhJ1xuICogY29uc29sZS5sb2coZGVzY3JpcHRpb25PZihcImZvb1wiKSk7IC8vICdIZXJlJ3MgeW91ciBzdHJpbmcgZm9vJ1xuICogYGBgXG4gKlxuICogQHBhcmFtIHN0cnVjdCBBIDJEIGFycmF5LiAgRWFjaCBlbGVtZW50IG9mIHRoZSBhcnJheSBzaG91bGQgYmUgYW4gYXJyYXksIGEgMi10dXBsZSxcbiAqIHdpdGggYSBQcmVkaWNhdGUgYW5kIGEgbWFwcGluZy9vdXRwdXQgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtmdW5jdGlvbihhbnkpOiAqfVxuICovXG5mdW5jdGlvbiBwYXR0ZXJuKHN0cnVjdCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoeCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cnVjdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHN0cnVjdFtpXVswXSh4KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RydWN0W2ldWzFdKHgpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmV4cG9ydHMucGF0dGVybiA9IHBhdHRlcm47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ob2YuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2NvbW1vbi9ob2YuanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///2\n')},function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\nexports.notImplemented = function (fnname) { return function () {\n    throw new Error(fnname + "(): No coreservices implementation for UI-Router is loaded.");\n}; };\nvar services = {\n    $q: undefined,\n    $injector: undefined,\n};\nexports.services = services;\n//# sourceMappingURL=coreservices.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvY29tbW9uL2NvcmVzZXJ2aWNlcy5qcz8yZDIzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ub3RJbXBsZW1lbnRlZCA9IGZ1bmN0aW9uIChmbm5hbWUpIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZm5uYW1lICsgXCIoKTogTm8gY29yZXNlcnZpY2VzIGltcGxlbWVudGF0aW9uIGZvciBVSS1Sb3V0ZXIgaXMgbG9hZGVkLlwiKTtcbn07IH07XG52YXIgc2VydmljZXMgPSB7XG4gICAgJHE6IHVuZGVmaW5lZCxcbiAgICAkaW5qZWN0b3I6IHVuZGVmaW5lZCxcbn07XG5leHBvcnRzLnNlcnZpY2VzID0gc2VydmljZXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb3Jlc2VydmljZXMuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2NvbW1vbi9jb3Jlc2VydmljZXMuanNcbi8vIG1vZHVsZSBpZCA9IDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3\n')},function(module,exports){eval("var core = module.exports = { version: '2.5.3' };\nif (typeof __e == 'number') __e = core; // eslint-disable-line no-undef\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29yZS5qcz8xNWUwIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBjb3JlID0gbW9kdWxlLmV4cG9ydHMgPSB7IHZlcnNpb246ICcyLjUuMycgfTtcbmlmICh0eXBlb2YgX19lID09ICdudW1iZXInKSBfX2UgPSBjb3JlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fY29yZS5qc1xuLy8gbW9kdWxlIGlkID0gNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///4\n")},function(module,exports,__webpack_require__){"use strict";eval('\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, "__esModule", { value: true });\n/** @module common */ /** for typedoc */\n__export(__webpack_require__(0));\n__export(__webpack_require__(3));\n__export(__webpack_require__(28));\n__export(__webpack_require__(2));\n__export(__webpack_require__(1));\n__export(__webpack_require__(43));\n__export(__webpack_require__(6));\n__export(__webpack_require__(8));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvY29tbW9uL2luZGV4LmpzPzkxOTkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqIEBtb2R1bGUgY29tbW9uICovIC8qKiBmb3IgdHlwZWRvYyAqL1xuX19leHBvcnQocmVxdWlyZShcIi4vY29tbW9uXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2NvcmVzZXJ2aWNlc1wiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9nbG9iXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2hvZlwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9wcmVkaWNhdGVzXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3F1ZXVlXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3N0cmluZ3NcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vdHJhY2VcIikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2NvbW1vbi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5\n')},function(module,exports,__webpack_require__){"use strict";eval("\n/**\n * Functions that manipulate strings\n *\n * Although these functions are exported, they are subject to change without notice.\n *\n * @module common_strings\n */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar predicates_1 = __webpack_require__(1);\nvar rejectFactory_1 = __webpack_require__(24);\nvar common_1 = __webpack_require__(0);\nvar hof_1 = __webpack_require__(2);\nvar transition_1 = __webpack_require__(29);\nvar resolvable_1 = __webpack_require__(26);\n/**\n * Returns a string shortened to a maximum length\n *\n * If the string is already less than the `max` length, return the string.\n * Else return the string, shortened to `max - 3` and append three dots (\"...\").\n *\n * @param max the maximum length of the string to return\n * @param str the input string\n */\nfunction maxLength(max, str) {\n    if (str.length <= max)\n        return str;\n    return str.substr(0, max - 3) + '...';\n}\nexports.maxLength = maxLength;\n/**\n * Returns a string, with spaces added to the end, up to a desired str length\n *\n * If the string is already longer than the desired length, return the string.\n * Else returns the string, with extra spaces on the end, such that it reaches `length` characters.\n *\n * @param length the desired length of the string to return\n * @param str the input string\n */\nfunction padString(length, str) {\n    while (str.length < length)\n        str += ' ';\n    return str;\n}\nexports.padString = padString;\nfunction kebobString(camelCase) {\n    return camelCase\n        .replace(/^([A-Z])/, function ($1) { return $1.toLowerCase(); }) // replace first char\n        .replace(/([A-Z])/g, function ($1) { return '-' + $1.toLowerCase(); }); // replace rest\n}\nexports.kebobString = kebobString;\nfunction _toJson(obj) {\n    return JSON.stringify(obj);\n}\nfunction _fromJson(json) {\n    return predicates_1.isString(json) ? JSON.parse(json) : json;\n}\nfunction promiseToString(p) {\n    return \"Promise(\" + JSON.stringify(p) + \")\";\n}\nfunction functionToString(fn) {\n    var fnStr = fnToString(fn);\n    var namedFunctionMatch = fnStr.match(/^(function [^ ]+\\([^)]*\\))/);\n    var toStr = namedFunctionMatch ? namedFunctionMatch[1] : fnStr;\n    var fnName = fn['name'] || '';\n    if (fnName && toStr.match(/function \\(/)) {\n        return 'function ' + fnName + toStr.substr(9);\n    }\n    return toStr;\n}\nexports.functionToString = functionToString;\nfunction fnToString(fn) {\n    var _fn = predicates_1.isArray(fn) ? fn.slice(-1)[0] : fn;\n    return _fn && _fn.toString() || 'undefined';\n}\nexports.fnToString = fnToString;\nvar stringifyPatternFn = null;\nvar stringifyPattern = function (value) {\n    var isRejection = rejectFactory_1.Rejection.isRejectionPromise;\n    stringifyPatternFn = stringifyPatternFn || hof_1.pattern([\n        [hof_1.not(predicates_1.isDefined), hof_1.val('undefined')],\n        [predicates_1.isNull, hof_1.val('null')],\n        [predicates_1.isPromise, hof_1.val('[Promise]')],\n        [isRejection, function (x) { return x._transitionRejection.toString(); }],\n        [hof_1.is(rejectFactory_1.Rejection), hof_1.invoke('toString')],\n        [hof_1.is(transition_1.Transition), hof_1.invoke('toString')],\n        [hof_1.is(resolvable_1.Resolvable), hof_1.invoke('toString')],\n        [predicates_1.isInjectable, functionToString],\n        [hof_1.val(true), common_1.identity],\n    ]);\n    return stringifyPatternFn(value);\n};\nfunction stringify(o) {\n    var seen = [];\n    function format(value) {\n        if (predicates_1.isObject(value)) {\n            if (seen.indexOf(value) !== -1)\n                return '[circular ref]';\n            seen.push(value);\n        }\n        return stringifyPattern(value);\n    }\n    return JSON.stringify(o, function (key, value) { return format(value); }).replace(/\\\\\"/g, '\"');\n}\nexports.stringify = stringify;\n/** Returns a function that splits a string on a character or substring */\nexports.beforeAfterSubstr = function (char) { return function (str) {\n    if (!str)\n        return ['', ''];\n    var idx = str.indexOf(char);\n    if (idx === -1)\n        return [str, ''];\n    return [str.substr(0, idx), str.substr(idx + 1)];\n}; };\nexports.hostRegex = new RegExp('^(?:[a-z]+:)?//[^/]+/');\nexports.stripLastPathElement = function (str) { return str.replace(/\\/[^/]*$/, ''); };\nexports.splitHash = exports.beforeAfterSubstr('#');\nexports.splitQuery = exports.beforeAfterSubstr('?');\nexports.splitEqual = exports.beforeAfterSubstr('=');\nexports.trimHashVal = function (str) { return str ? str.replace(/^#/, '') : ''; };\n/**\n * Splits on a delimiter, but returns the delimiters in the array\n *\n * #### Example:\n * ```js\n * var splitOnSlashes = splitOnDelim('/');\n * splitOnSlashes(\"/foo\"); // [\"/\", \"foo\"]\n * splitOnSlashes(\"/foo/\"); // [\"/\", \"foo\", \"/\"]\n * ```\n */\nfunction splitOnDelim(delim) {\n    var re = new RegExp('(' + delim + ')', 'g');\n    return function (str) {\n        return str.split(re).filter(common_1.identity);\n    };\n}\nexports.splitOnDelim = splitOnDelim;\n/**\n * Reduce fn that joins neighboring strings\n *\n * Given an array of strings, returns a new array\n * where all neighboring strings have been joined.\n *\n * #### Example:\n * ```js\n * let arr = [\"foo\", \"bar\", 1, \"baz\", \"\", \"qux\" ];\n * arr.reduce(joinNeighborsR, []) // [\"foobar\", 1, \"bazqux\" ]\n * ```\n */\nfunction joinNeighborsR(acc, x) {\n    if (predicates_1.isString(common_1.tail(acc)) && predicates_1.isString(x))\n        return acc.slice(0, -1).concat(common_1.tail(acc) + x);\n    return common_1.pushR(acc, x);\n}\nexports.joinNeighborsR = joinNeighborsR;\n//# sourceMappingURL=strings.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvY29tbW9uL3N0cmluZ3MuanM/N2MzMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogRnVuY3Rpb25zIHRoYXQgbWFuaXB1bGF0ZSBzdHJpbmdzXG4gKlxuICogQWx0aG91Z2ggdGhlc2UgZnVuY3Rpb25zIGFyZSBleHBvcnRlZCwgdGhleSBhcmUgc3ViamVjdCB0byBjaGFuZ2Ugd2l0aG91dCBub3RpY2UuXG4gKlxuICogQG1vZHVsZSBjb21tb25fc3RyaW5nc1xuICovIC8qKiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHByZWRpY2F0ZXNfMSA9IHJlcXVpcmUoXCIuL3ByZWRpY2F0ZXNcIik7XG52YXIgcmVqZWN0RmFjdG9yeV8xID0gcmVxdWlyZShcIi4uL3RyYW5zaXRpb24vcmVqZWN0RmFjdG9yeVwiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuL2NvbW1vblwiKTtcbnZhciBob2ZfMSA9IHJlcXVpcmUoXCIuL2hvZlwiKTtcbnZhciB0cmFuc2l0aW9uXzEgPSByZXF1aXJlKFwiLi4vdHJhbnNpdGlvbi90cmFuc2l0aW9uXCIpO1xudmFyIHJlc29sdmFibGVfMSA9IHJlcXVpcmUoXCIuLi9yZXNvbHZlL3Jlc29sdmFibGVcIik7XG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgc2hvcnRlbmVkIHRvIGEgbWF4aW11bSBsZW5ndGhcbiAqXG4gKiBJZiB0aGUgc3RyaW5nIGlzIGFscmVhZHkgbGVzcyB0aGFuIHRoZSBgbWF4YCBsZW5ndGgsIHJldHVybiB0aGUgc3RyaW5nLlxuICogRWxzZSByZXR1cm4gdGhlIHN0cmluZywgc2hvcnRlbmVkIHRvIGBtYXggLSAzYCBhbmQgYXBwZW5kIHRocmVlIGRvdHMgKFwiLi4uXCIpLlxuICpcbiAqIEBwYXJhbSBtYXggdGhlIG1heGltdW0gbGVuZ3RoIG9mIHRoZSBzdHJpbmcgdG8gcmV0dXJuXG4gKiBAcGFyYW0gc3RyIHRoZSBpbnB1dCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gbWF4TGVuZ3RoKG1heCwgc3RyKSB7XG4gICAgaWYgKHN0ci5sZW5ndGggPD0gbWF4KVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIHJldHVybiBzdHIuc3Vic3RyKDAsIG1heCAtIDMpICsgJy4uLic7XG59XG5leHBvcnRzLm1heExlbmd0aCA9IG1heExlbmd0aDtcbi8qKlxuICogUmV0dXJucyBhIHN0cmluZywgd2l0aCBzcGFjZXMgYWRkZWQgdG8gdGhlIGVuZCwgdXAgdG8gYSBkZXNpcmVkIHN0ciBsZW5ndGhcbiAqXG4gKiBJZiB0aGUgc3RyaW5nIGlzIGFscmVhZHkgbG9uZ2VyIHRoYW4gdGhlIGRlc2lyZWQgbGVuZ3RoLCByZXR1cm4gdGhlIHN0cmluZy5cbiAqIEVsc2UgcmV0dXJucyB0aGUgc3RyaW5nLCB3aXRoIGV4dHJhIHNwYWNlcyBvbiB0aGUgZW5kLCBzdWNoIHRoYXQgaXQgcmVhY2hlcyBgbGVuZ3RoYCBjaGFyYWN0ZXJzLlxuICpcbiAqIEBwYXJhbSBsZW5ndGggdGhlIGRlc2lyZWQgbGVuZ3RoIG9mIHRoZSBzdHJpbmcgdG8gcmV0dXJuXG4gKiBAcGFyYW0gc3RyIHRoZSBpbnB1dCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gcGFkU3RyaW5nKGxlbmd0aCwgc3RyKSB7XG4gICAgd2hpbGUgKHN0ci5sZW5ndGggPCBsZW5ndGgpXG4gICAgICAgIHN0ciArPSAnICc7XG4gICAgcmV0dXJuIHN0cjtcbn1cbmV4cG9ydHMucGFkU3RyaW5nID0gcGFkU3RyaW5nO1xuZnVuY3Rpb24ga2Vib2JTdHJpbmcoY2FtZWxDYXNlKSB7XG4gICAgcmV0dXJuIGNhbWVsQ2FzZVxuICAgICAgICAucmVwbGFjZSgvXihbQS1aXSkvLCBmdW5jdGlvbiAoJDEpIHsgcmV0dXJuICQxLnRvTG93ZXJDYXNlKCk7IH0pIC8vIHJlcGxhY2UgZmlyc3QgY2hhclxuICAgICAgICAucmVwbGFjZSgvKFtBLVpdKS9nLCBmdW5jdGlvbiAoJDEpIHsgcmV0dXJuICctJyArICQxLnRvTG93ZXJDYXNlKCk7IH0pOyAvLyByZXBsYWNlIHJlc3Rcbn1cbmV4cG9ydHMua2Vib2JTdHJpbmcgPSBrZWJvYlN0cmluZztcbmZ1bmN0aW9uIF90b0pzb24ob2JqKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iaik7XG59XG5mdW5jdGlvbiBfZnJvbUpzb24oanNvbikge1xuICAgIHJldHVybiBwcmVkaWNhdGVzXzEuaXNTdHJpbmcoanNvbikgPyBKU09OLnBhcnNlKGpzb24pIDoganNvbjtcbn1cbmZ1bmN0aW9uIHByb21pc2VUb1N0cmluZyhwKSB7XG4gICAgcmV0dXJuIFwiUHJvbWlzZShcIiArIEpTT04uc3RyaW5naWZ5KHApICsgXCIpXCI7XG59XG5mdW5jdGlvbiBmdW5jdGlvblRvU3RyaW5nKGZuKSB7XG4gICAgdmFyIGZuU3RyID0gZm5Ub1N0cmluZyhmbik7XG4gICAgdmFyIG5hbWVkRnVuY3Rpb25NYXRjaCA9IGZuU3RyLm1hdGNoKC9eKGZ1bmN0aW9uIFteIF0rXFwoW14pXSpcXCkpLyk7XG4gICAgdmFyIHRvU3RyID0gbmFtZWRGdW5jdGlvbk1hdGNoID8gbmFtZWRGdW5jdGlvbk1hdGNoWzFdIDogZm5TdHI7XG4gICAgdmFyIGZuTmFtZSA9IGZuWyduYW1lJ10gfHwgJyc7XG4gICAgaWYgKGZuTmFtZSAmJiB0b1N0ci5tYXRjaCgvZnVuY3Rpb24gXFwoLykpIHtcbiAgICAgICAgcmV0dXJuICdmdW5jdGlvbiAnICsgZm5OYW1lICsgdG9TdHIuc3Vic3RyKDkpO1xuICAgIH1cbiAgICByZXR1cm4gdG9TdHI7XG59XG5leHBvcnRzLmZ1bmN0aW9uVG9TdHJpbmcgPSBmdW5jdGlvblRvU3RyaW5nO1xuZnVuY3Rpb24gZm5Ub1N0cmluZyhmbikge1xuICAgIHZhciBfZm4gPSBwcmVkaWNhdGVzXzEuaXNBcnJheShmbikgPyBmbi5zbGljZSgtMSlbMF0gOiBmbjtcbiAgICByZXR1cm4gX2ZuICYmIF9mbi50b1N0cmluZygpIHx8ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5mblRvU3RyaW5nID0gZm5Ub1N0cmluZztcbnZhciBzdHJpbmdpZnlQYXR0ZXJuRm4gPSBudWxsO1xudmFyIHN0cmluZ2lmeVBhdHRlcm4gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YXIgaXNSZWplY3Rpb24gPSByZWplY3RGYWN0b3J5XzEuUmVqZWN0aW9uLmlzUmVqZWN0aW9uUHJvbWlzZTtcbiAgICBzdHJpbmdpZnlQYXR0ZXJuRm4gPSBzdHJpbmdpZnlQYXR0ZXJuRm4gfHwgaG9mXzEucGF0dGVybihbXG4gICAgICAgIFtob2ZfMS5ub3QocHJlZGljYXRlc18xLmlzRGVmaW5lZCksIGhvZl8xLnZhbCgndW5kZWZpbmVkJyldLFxuICAgICAgICBbcHJlZGljYXRlc18xLmlzTnVsbCwgaG9mXzEudmFsKCdudWxsJyldLFxuICAgICAgICBbcHJlZGljYXRlc18xLmlzUHJvbWlzZSwgaG9mXzEudmFsKCdbUHJvbWlzZV0nKV0sXG4gICAgICAgIFtpc1JlamVjdGlvbiwgZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHguX3RyYW5zaXRpb25SZWplY3Rpb24udG9TdHJpbmcoKTsgfV0sXG4gICAgICAgIFtob2ZfMS5pcyhyZWplY3RGYWN0b3J5XzEuUmVqZWN0aW9uKSwgaG9mXzEuaW52b2tlKCd0b1N0cmluZycpXSxcbiAgICAgICAgW2hvZl8xLmlzKHRyYW5zaXRpb25fMS5UcmFuc2l0aW9uKSwgaG9mXzEuaW52b2tlKCd0b1N0cmluZycpXSxcbiAgICAgICAgW2hvZl8xLmlzKHJlc29sdmFibGVfMS5SZXNvbHZhYmxlKSwgaG9mXzEuaW52b2tlKCd0b1N0cmluZycpXSxcbiAgICAgICAgW3ByZWRpY2F0ZXNfMS5pc0luamVjdGFibGUsIGZ1bmN0aW9uVG9TdHJpbmddLFxuICAgICAgICBbaG9mXzEudmFsKHRydWUpLCBjb21tb25fMS5pZGVudGl0eV0sXG4gICAgXSk7XG4gICAgcmV0dXJuIHN0cmluZ2lmeVBhdHRlcm5Gbih2YWx1ZSk7XG59O1xuZnVuY3Rpb24gc3RyaW5naWZ5KG8pIHtcbiAgICB2YXIgc2VlbiA9IFtdO1xuICAgIGZ1bmN0aW9uIGZvcm1hdCh2YWx1ZSkge1xuICAgICAgICBpZiAocHJlZGljYXRlc18xLmlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKHNlZW4uaW5kZXhPZih2YWx1ZSkgIT09IC0xKVxuICAgICAgICAgICAgICAgIHJldHVybiAnW2NpcmN1bGFyIHJlZl0nO1xuICAgICAgICAgICAgc2Vlbi5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyaW5naWZ5UGF0dGVybih2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkgeyByZXR1cm4gZm9ybWF0KHZhbHVlKTsgfSkucmVwbGFjZSgvXFxcXFwiL2csICdcIicpO1xufVxuZXhwb3J0cy5zdHJpbmdpZnkgPSBzdHJpbmdpZnk7XG4vKiogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgc3BsaXRzIGEgc3RyaW5nIG9uIGEgY2hhcmFjdGVyIG9yIHN1YnN0cmluZyAqL1xuZXhwb3J0cy5iZWZvcmVBZnRlclN1YnN0ciA9IGZ1bmN0aW9uIChjaGFyKSB7IHJldHVybiBmdW5jdGlvbiAoc3RyKSB7XG4gICAgaWYgKCFzdHIpXG4gICAgICAgIHJldHVybiBbJycsICcnXTtcbiAgICB2YXIgaWR4ID0gc3RyLmluZGV4T2YoY2hhcik7XG4gICAgaWYgKGlkeCA9PT0gLTEpXG4gICAgICAgIHJldHVybiBbc3RyLCAnJ107XG4gICAgcmV0dXJuIFtzdHIuc3Vic3RyKDAsIGlkeCksIHN0ci5zdWJzdHIoaWR4ICsgMSldO1xufTsgfTtcbmV4cG9ydHMuaG9zdFJlZ2V4ID0gbmV3IFJlZ0V4cCgnXig/OlthLXpdKzopPy8vW14vXSsvJyk7XG5leHBvcnRzLnN0cmlwTGFzdFBhdGhFbGVtZW50ID0gZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gc3RyLnJlcGxhY2UoL1xcL1teL10qJC8sICcnKTsgfTtcbmV4cG9ydHMuc3BsaXRIYXNoID0gZXhwb3J0cy5iZWZvcmVBZnRlclN1YnN0cignIycpO1xuZXhwb3J0cy5zcGxpdFF1ZXJ5ID0gZXhwb3J0cy5iZWZvcmVBZnRlclN1YnN0cignPycpO1xuZXhwb3J0cy5zcGxpdEVxdWFsID0gZXhwb3J0cy5iZWZvcmVBZnRlclN1YnN0cignPScpO1xuZXhwb3J0cy50cmltSGFzaFZhbCA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIHN0ciA/IHN0ci5yZXBsYWNlKC9eIy8sICcnKSA6ICcnOyB9O1xuLyoqXG4gKiBTcGxpdHMgb24gYSBkZWxpbWl0ZXIsIGJ1dCByZXR1cm5zIHRoZSBkZWxpbWl0ZXJzIGluIHRoZSBhcnJheVxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqIGBgYGpzXG4gKiB2YXIgc3BsaXRPblNsYXNoZXMgPSBzcGxpdE9uRGVsaW0oJy8nKTtcbiAqIHNwbGl0T25TbGFzaGVzKFwiL2Zvb1wiKTsgLy8gW1wiL1wiLCBcImZvb1wiXVxuICogc3BsaXRPblNsYXNoZXMoXCIvZm9vL1wiKTsgLy8gW1wiL1wiLCBcImZvb1wiLCBcIi9cIl1cbiAqIGBgYFxuICovXG5mdW5jdGlvbiBzcGxpdE9uRGVsaW0oZGVsaW0pIHtcbiAgICB2YXIgcmUgPSBuZXcgUmVnRXhwKCcoJyArIGRlbGltICsgJyknLCAnZycpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIHJldHVybiBzdHIuc3BsaXQocmUpLmZpbHRlcihjb21tb25fMS5pZGVudGl0eSk7XG4gICAgfTtcbn1cbmV4cG9ydHMuc3BsaXRPbkRlbGltID0gc3BsaXRPbkRlbGltO1xuLyoqXG4gKiBSZWR1Y2UgZm4gdGhhdCBqb2lucyBuZWlnaGJvcmluZyBzdHJpbmdzXG4gKlxuICogR2l2ZW4gYW4gYXJyYXkgb2Ygc3RyaW5ncywgcmV0dXJucyBhIG5ldyBhcnJheVxuICogd2hlcmUgYWxsIG5laWdoYm9yaW5nIHN0cmluZ3MgaGF2ZSBiZWVuIGpvaW5lZC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKiBgYGBqc1xuICogbGV0IGFyciA9IFtcImZvb1wiLCBcImJhclwiLCAxLCBcImJhelwiLCBcIlwiLCBcInF1eFwiIF07XG4gKiBhcnIucmVkdWNlKGpvaW5OZWlnaGJvcnNSLCBbXSkgLy8gW1wiZm9vYmFyXCIsIDEsIFwiYmF6cXV4XCIgXVxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIGpvaW5OZWlnaGJvcnNSKGFjYywgeCkge1xuICAgIGlmIChwcmVkaWNhdGVzXzEuaXNTdHJpbmcoY29tbW9uXzEudGFpbChhY2MpKSAmJiBwcmVkaWNhdGVzXzEuaXNTdHJpbmcoeCkpXG4gICAgICAgIHJldHVybiBhY2Muc2xpY2UoMCwgLTEpLmNvbmNhdChjb21tb25fMS50YWlsKGFjYykgKyB4KTtcbiAgICByZXR1cm4gY29tbW9uXzEucHVzaFIoYWNjLCB4KTtcbn1cbmV4cG9ydHMuam9pbk5laWdoYm9yc1IgPSBqb2luTmVpZ2hib3JzUjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0cmluZ3MuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2NvbW1vbi9zdHJpbmdzLmpzXG4vLyBtb2R1bGUgaWQgPSA2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6\n")},function(module,exports){eval("module.exports = angular;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9leHRlcm5hbCBcImFuZ3VsYXJcIj8xMWQyIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gYW5ndWxhcjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcImFuZ3VsYXJcIlxuLy8gbW9kdWxlIGlkID0gN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///7\n")},function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\n/**\n * # Transition tracing (debug)\n *\n * Enable transition tracing to print transition information to the console,\n * in order to help debug your application.\n * Tracing logs detailed information about each Transition to your console.\n *\n * To enable tracing, import the [[Trace]] singleton and enable one or more categories.\n *\n * ### ES6\n * ```js\n * import {trace} from "ui-router-ng2"; // or "angular-ui-router"\n * trace.enable(1, 5); // TRANSITION and VIEWCONFIG\n * ```\n *\n * ### CJS\n * ```js\n * let trace = require("angular-ui-router").trace; // or "ui-router-ng2"\n * trace.enable("TRANSITION", "VIEWCONFIG");\n * ```\n *\n * ### Globals\n * ```js\n * let trace = window["angular-ui-router"].trace; // or "ui-router-ng2"\n * trace.enable(); // Trace everything (very verbose)\n * ```\n *\n * ### Angular 1:\n * ```js\n * app.run($trace => $trace.enable());\n * ```\n *\n * @coreapi\n * @module trace\n */\n/* tslint:disable:no-console */\nvar hof_1 = __webpack_require__(2);\nvar predicates_1 = __webpack_require__(1);\nvar strings_1 = __webpack_require__(6);\n/** @hidden */\nfunction uiViewString(uiview) {\n    if (!uiview)\n        return \'ui-view (defunct)\';\n    var state = uiview.creationContext ? uiview.creationContext.name || \'(root)\' : \'(none)\';\n    return "[ui-view#" + uiview.id + " " + uiview.$type + ":" + uiview.fqn + " (" + uiview.name + "@" + state + ")]";\n}\n/** @hidden */\nvar viewConfigString = function (viewConfig) {\n    var view = viewConfig.viewDecl;\n    var state = view.$context.name || \'(root)\';\n    return "[View#" + viewConfig.$id + " from \'" + state + "\' state]: target ui-view: \'" + view.$uiViewName + "@" + view.$uiViewContextAnchor + "\'";\n};\n/** @hidden */\nfunction normalizedCat(input) {\n    return predicates_1.isNumber(input) ? Category[input] : Category[Category[input]];\n}\n/** @hidden */\nvar consoleLog = Function.prototype.bind.call(console.log, console);\n/** @hidden */\nvar consoletable = predicates_1.isFunction(console.table) ? console.table.bind(console) : consoleLog.bind(console);\n/**\n * Trace categories Enum\n *\n * Enable or disable a category using [[Trace.enable]] or [[Trace.disable]]\n *\n * `trace.enable(Category.TRANSITION)`\n *\n * These can also be provided using a matching string, or position ordinal\n *\n * `trace.enable("TRANSITION")`\n *\n * `trace.enable(1)`\n */\nvar Category;\n(function (Category) {\n    Category[Category["RESOLVE"] = 0] = "RESOLVE";\n    Category[Category["TRANSITION"] = 1] = "TRANSITION";\n    Category[Category["HOOK"] = 2] = "HOOK";\n    Category[Category["UIVIEW"] = 3] = "UIVIEW";\n    Category[Category["VIEWCONFIG"] = 4] = "VIEWCONFIG";\n})(Category = exports.Category || (exports.Category = {}));\n/** @hidden */\nvar _tid = hof_1.parse(\'$id\');\n/** @hidden */\nvar _rid = hof_1.parse(\'router.$id\');\n/** @hidden */\nvar transLbl = function (trans) { return "Transition #" + _tid(trans) + "-" + _rid(trans); };\n/**\n * Prints UI-Router Transition trace information to the console.\n */\nvar Trace = /** @class */ (function () {\n    /** @hidden */\n    function Trace() {\n        /** @hidden */\n        this._enabled = {};\n        this.approximateDigests = 0;\n    }\n    /** @hidden */\n    Trace.prototype._set = function (enabled, categories) {\n        var _this = this;\n        if (!categories.length) {\n            categories = Object.keys(Category)\n                .map(function (k) { return parseInt(k, 10); })\n                .filter(function (k) { return !isNaN(k); })\n                .map(function (key) { return Category[key]; });\n        }\n        categories.map(normalizedCat).forEach(function (category) { return _this._enabled[category] = enabled; });\n    };\n    Trace.prototype.enable = function () {\n        var categories = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            categories[_i] = arguments[_i];\n        }\n        this._set(true, categories);\n    };\n    Trace.prototype.disable = function () {\n        var categories = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            categories[_i] = arguments[_i];\n        }\n        this._set(false, categories);\n    };\n    /**\n     * Retrieves the enabled stateus of a [[Category]]\n     *\n     * ```js\n     * trace.enabled("VIEWCONFIG"); // true or false\n     * ```\n     *\n     * @returns boolean true if the category is enabled\n     */\n    Trace.prototype.enabled = function (category) {\n        return !!this._enabled[normalizedCat(category)];\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceTransitionStart = function (trans) {\n        if (!this.enabled(Category.TRANSITION))\n            return;\n        console.log(transLbl(trans) + ": Started  -> " + strings_1.stringify(trans));\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceTransitionIgnored = function (trans) {\n        if (!this.enabled(Category.TRANSITION))\n            return;\n        console.log(transLbl(trans) + ": Ignored  <> " + strings_1.stringify(trans));\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceHookInvocation = function (step, trans, options) {\n        if (!this.enabled(Category.HOOK))\n            return;\n        var event = hof_1.parse(\'traceData.hookType\')(options) || \'internal\', context = hof_1.parse(\'traceData.context.state.name\')(options) || hof_1.parse(\'traceData.context\')(options) || \'unknown\', name = strings_1.functionToString(step.registeredHook.callback);\n        console.log(transLbl(trans) + ":   Hook -> " + event + " context: " + context + ", " + strings_1.maxLength(200, name));\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceHookResult = function (hookResult, trans, transitionOptions) {\n        if (!this.enabled(Category.HOOK))\n            return;\n        console.log(transLbl(trans) + ":   <- Hook returned: " + strings_1.maxLength(200, strings_1.stringify(hookResult)));\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceResolvePath = function (path, when, trans) {\n        if (!this.enabled(Category.RESOLVE))\n            return;\n        console.log(transLbl(trans) + ":         Resolving " + path + " (" + when + ")");\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceResolvableResolved = function (resolvable, trans) {\n        if (!this.enabled(Category.RESOLVE))\n            return;\n        console.log(transLbl(trans) + ":               <- Resolved  " + resolvable + " to: " + strings_1.maxLength(200, strings_1.stringify(resolvable.data)));\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceError = function (reason, trans) {\n        if (!this.enabled(Category.TRANSITION))\n            return;\n        console.log(transLbl(trans) + ": <- Rejected " + strings_1.stringify(trans) + ", reason: " + reason);\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceSuccess = function (finalState, trans) {\n        if (!this.enabled(Category.TRANSITION))\n            return;\n        console.log(transLbl(trans) + ": <- Success  " + strings_1.stringify(trans) + ", final state: " + finalState.name);\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceUIViewEvent = function (event, viewData, extra) {\n        if (extra === void 0) { extra = \'\'; }\n        if (!this.enabled(Category.UIVIEW))\n            return;\n        console.log("ui-view: " + strings_1.padString(30, event) + " " + uiViewString(viewData) + extra);\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceUIViewConfigUpdated = function (viewData, context) {\n        if (!this.enabled(Category.UIVIEW))\n            return;\n        this.traceUIViewEvent(\'Updating\', viewData, " with ViewConfig from context=\'" + context + "\'");\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceUIViewFill = function (viewData, html) {\n        if (!this.enabled(Category.UIVIEW))\n            return;\n        this.traceUIViewEvent(\'Fill\', viewData, " with: " + strings_1.maxLength(200, html));\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceViewSync = function (pairs) {\n        if (!this.enabled(Category.VIEWCONFIG))\n            return;\n        var uivheader = \'uiview component fqn\';\n        var cfgheader = \'view config state (view name)\';\n        var mapping = pairs.map(function (_a) {\n            var uiView = _a.uiView, viewConfig = _a.viewConfig;\n            var uiv = uiView && uiView.fqn;\n            var cfg = viewConfig && viewConfig.viewDecl.$context.name + ": (" + viewConfig.viewDecl.$name + ")";\n            return _b = {}, _b[uivheader] = uiv, _b[cfgheader] = cfg, _b;\n            var _b;\n        }).sort(function (a, b) { return (a[uivheader] || \'\').localeCompare(b[uivheader] || \'\'); });\n        consoletable(mapping);\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceViewServiceEvent = function (event, viewConfig) {\n        if (!this.enabled(Category.VIEWCONFIG))\n            return;\n        console.log("VIEWCONFIG: " + event + " " + viewConfigString(viewConfig));\n    };\n    /** @internalapi called by ui-router code */\n    Trace.prototype.traceViewServiceUIViewEvent = function (event, viewData) {\n        if (!this.enabled(Category.VIEWCONFIG))\n            return;\n        console.log("VIEWCONFIG: " + event + " " + uiViewString(viewData));\n    };\n    return Trace;\n}());\nexports.Trace = Trace;\n/**\n * The [[Trace]] singleton\n *\n * #### Example:\n * ```js\n * import {trace} from "angular-ui-router";\n * trace.enable(1, 5);\n * ```\n */\nvar trace = new Trace();\nexports.trace = trace;\n//# sourceMappingURL=trace.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvY29tbW9uL3RyYWNlLmpzPzM2MDciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqICMgVHJhbnNpdGlvbiB0cmFjaW5nIChkZWJ1ZylcbiAqXG4gKiBFbmFibGUgdHJhbnNpdGlvbiB0cmFjaW5nIHRvIHByaW50IHRyYW5zaXRpb24gaW5mb3JtYXRpb24gdG8gdGhlIGNvbnNvbGUsXG4gKiBpbiBvcmRlciB0byBoZWxwIGRlYnVnIHlvdXIgYXBwbGljYXRpb24uXG4gKiBUcmFjaW5nIGxvZ3MgZGV0YWlsZWQgaW5mb3JtYXRpb24gYWJvdXQgZWFjaCBUcmFuc2l0aW9uIHRvIHlvdXIgY29uc29sZS5cbiAqXG4gKiBUbyBlbmFibGUgdHJhY2luZywgaW1wb3J0IHRoZSBbW1RyYWNlXV0gc2luZ2xldG9uIGFuZCBlbmFibGUgb25lIG9yIG1vcmUgY2F0ZWdvcmllcy5cbiAqXG4gKiAjIyMgRVM2XG4gKiBgYGBqc1xuICogaW1wb3J0IHt0cmFjZX0gZnJvbSBcInVpLXJvdXRlci1uZzJcIjsgLy8gb3IgXCJhbmd1bGFyLXVpLXJvdXRlclwiXG4gKiB0cmFjZS5lbmFibGUoMSwgNSk7IC8vIFRSQU5TSVRJT04gYW5kIFZJRVdDT05GSUdcbiAqIGBgYFxuICpcbiAqICMjIyBDSlNcbiAqIGBgYGpzXG4gKiBsZXQgdHJhY2UgPSByZXF1aXJlKFwiYW5ndWxhci11aS1yb3V0ZXJcIikudHJhY2U7IC8vIG9yIFwidWktcm91dGVyLW5nMlwiXG4gKiB0cmFjZS5lbmFibGUoXCJUUkFOU0lUSU9OXCIsIFwiVklFV0NPTkZJR1wiKTtcbiAqIGBgYFxuICpcbiAqICMjIyBHbG9iYWxzXG4gKiBgYGBqc1xuICogbGV0IHRyYWNlID0gd2luZG93W1wiYW5ndWxhci11aS1yb3V0ZXJcIl0udHJhY2U7IC8vIG9yIFwidWktcm91dGVyLW5nMlwiXG4gKiB0cmFjZS5lbmFibGUoKTsgLy8gVHJhY2UgZXZlcnl0aGluZyAodmVyeSB2ZXJib3NlKVxuICogYGBgXG4gKlxuICogIyMjIEFuZ3VsYXIgMTpcbiAqIGBgYGpzXG4gKiBhcHAucnVuKCR0cmFjZSA9PiAkdHJhY2UuZW5hYmxlKCkpO1xuICogYGBgXG4gKlxuICogQGNvcmVhcGlcbiAqIEBtb2R1bGUgdHJhY2VcbiAqL1xuLyogdHNsaW50OmRpc2FibGU6bm8tY29uc29sZSAqL1xudmFyIGhvZl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9ob2ZcIik7XG52YXIgcHJlZGljYXRlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9wcmVkaWNhdGVzXCIpO1xudmFyIHN0cmluZ3NfMSA9IHJlcXVpcmUoXCIuL3N0cmluZ3NcIik7XG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gdWlWaWV3U3RyaW5nKHVpdmlldykge1xuICAgIGlmICghdWl2aWV3KVxuICAgICAgICByZXR1cm4gJ3VpLXZpZXcgKGRlZnVuY3QpJztcbiAgICB2YXIgc3RhdGUgPSB1aXZpZXcuY3JlYXRpb25Db250ZXh0ID8gdWl2aWV3LmNyZWF0aW9uQ29udGV4dC5uYW1lIHx8ICcocm9vdCknIDogJyhub25lKSc7XG4gICAgcmV0dXJuIFwiW3VpLXZpZXcjXCIgKyB1aXZpZXcuaWQgKyBcIiBcIiArIHVpdmlldy4kdHlwZSArIFwiOlwiICsgdWl2aWV3LmZxbiArIFwiIChcIiArIHVpdmlldy5uYW1lICsgXCJAXCIgKyBzdGF0ZSArIFwiKV1cIjtcbn1cbi8qKiBAaGlkZGVuICovXG52YXIgdmlld0NvbmZpZ1N0cmluZyA9IGZ1bmN0aW9uICh2aWV3Q29uZmlnKSB7XG4gICAgdmFyIHZpZXcgPSB2aWV3Q29uZmlnLnZpZXdEZWNsO1xuICAgIHZhciBzdGF0ZSA9IHZpZXcuJGNvbnRleHQubmFtZSB8fCAnKHJvb3QpJztcbiAgICByZXR1cm4gXCJbVmlldyNcIiArIHZpZXdDb25maWcuJGlkICsgXCIgZnJvbSAnXCIgKyBzdGF0ZSArIFwiJyBzdGF0ZV06IHRhcmdldCB1aS12aWV3OiAnXCIgKyB2aWV3LiR1aVZpZXdOYW1lICsgXCJAXCIgKyB2aWV3LiR1aVZpZXdDb250ZXh0QW5jaG9yICsgXCInXCI7XG59O1xuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZWRDYXQoaW5wdXQpIHtcbiAgICByZXR1cm4gcHJlZGljYXRlc18xLmlzTnVtYmVyKGlucHV0KSA/IENhdGVnb3J5W2lucHV0XSA6IENhdGVnb3J5W0NhdGVnb3J5W2lucHV0XV07XG59XG4vKiogQGhpZGRlbiAqL1xudmFyIGNvbnNvbGVMb2cgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5jYWxsKGNvbnNvbGUubG9nLCBjb25zb2xlKTtcbi8qKiBAaGlkZGVuICovXG52YXIgY29uc29sZXRhYmxlID0gcHJlZGljYXRlc18xLmlzRnVuY3Rpb24oY29uc29sZS50YWJsZSkgPyBjb25zb2xlLnRhYmxlLmJpbmQoY29uc29sZSkgOiBjb25zb2xlTG9nLmJpbmQoY29uc29sZSk7XG4vKipcbiAqIFRyYWNlIGNhdGVnb3JpZXMgRW51bVxuICpcbiAqIEVuYWJsZSBvciBkaXNhYmxlIGEgY2F0ZWdvcnkgdXNpbmcgW1tUcmFjZS5lbmFibGVdXSBvciBbW1RyYWNlLmRpc2FibGVdXVxuICpcbiAqIGB0cmFjZS5lbmFibGUoQ2F0ZWdvcnkuVFJBTlNJVElPTilgXG4gKlxuICogVGhlc2UgY2FuIGFsc28gYmUgcHJvdmlkZWQgdXNpbmcgYSBtYXRjaGluZyBzdHJpbmcsIG9yIHBvc2l0aW9uIG9yZGluYWxcbiAqXG4gKiBgdHJhY2UuZW5hYmxlKFwiVFJBTlNJVElPTlwiKWBcbiAqXG4gKiBgdHJhY2UuZW5hYmxlKDEpYFxuICovXG52YXIgQ2F0ZWdvcnk7XG4oZnVuY3Rpb24gKENhdGVnb3J5KSB7XG4gICAgQ2F0ZWdvcnlbQ2F0ZWdvcnlbXCJSRVNPTFZFXCJdID0gMF0gPSBcIlJFU09MVkVcIjtcbiAgICBDYXRlZ29yeVtDYXRlZ29yeVtcIlRSQU5TSVRJT05cIl0gPSAxXSA9IFwiVFJBTlNJVElPTlwiO1xuICAgIENhdGVnb3J5W0NhdGVnb3J5W1wiSE9PS1wiXSA9IDJdID0gXCJIT09LXCI7XG4gICAgQ2F0ZWdvcnlbQ2F0ZWdvcnlbXCJVSVZJRVdcIl0gPSAzXSA9IFwiVUlWSUVXXCI7XG4gICAgQ2F0ZWdvcnlbQ2F0ZWdvcnlbXCJWSUVXQ09ORklHXCJdID0gNF0gPSBcIlZJRVdDT05GSUdcIjtcbn0pKENhdGVnb3J5ID0gZXhwb3J0cy5DYXRlZ29yeSB8fCAoZXhwb3J0cy5DYXRlZ29yeSA9IHt9KSk7XG4vKiogQGhpZGRlbiAqL1xudmFyIF90aWQgPSBob2ZfMS5wYXJzZSgnJGlkJyk7XG4vKiogQGhpZGRlbiAqL1xudmFyIF9yaWQgPSBob2ZfMS5wYXJzZSgncm91dGVyLiRpZCcpO1xuLyoqIEBoaWRkZW4gKi9cbnZhciB0cmFuc0xibCA9IGZ1bmN0aW9uICh0cmFucykgeyByZXR1cm4gXCJUcmFuc2l0aW9uICNcIiArIF90aWQodHJhbnMpICsgXCItXCIgKyBfcmlkKHRyYW5zKTsgfTtcbi8qKlxuICogUHJpbnRzIFVJLVJvdXRlciBUcmFuc2l0aW9uIHRyYWNlIGluZm9ybWF0aW9uIHRvIHRoZSBjb25zb2xlLlxuICovXG52YXIgVHJhY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBmdW5jdGlvbiBUcmFjZSgpIHtcbiAgICAgICAgLyoqIEBoaWRkZW4gKi9cbiAgICAgICAgdGhpcy5fZW5hYmxlZCA9IHt9O1xuICAgICAgICB0aGlzLmFwcHJveGltYXRlRGlnZXN0cyA9IDA7XG4gICAgfVxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgVHJhY2UucHJvdG90eXBlLl9zZXQgPSBmdW5jdGlvbiAoZW5hYmxlZCwgY2F0ZWdvcmllcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIWNhdGVnb3JpZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXRlZ29yaWVzID0gT2JqZWN0LmtleXMoQ2F0ZWdvcnkpXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoaykgeyByZXR1cm4gcGFyc2VJbnQoaywgMTApOyB9KVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGspIHsgcmV0dXJuICFpc05hTihrKTsgfSlcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIENhdGVnb3J5W2tleV07IH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGVnb3JpZXMubWFwKG5vcm1hbGl6ZWRDYXQpLmZvckVhY2goZnVuY3Rpb24gKGNhdGVnb3J5KSB7IHJldHVybiBfdGhpcy5fZW5hYmxlZFtjYXRlZ29yeV0gPSBlbmFibGVkOyB9KTtcbiAgICB9O1xuICAgIFRyYWNlLnByb3RvdHlwZS5lbmFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjYXRlZ29yaWVzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBjYXRlZ29yaWVzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2V0KHRydWUsIGNhdGVnb3JpZXMpO1xuICAgIH07XG4gICAgVHJhY2UucHJvdG90eXBlLmRpc2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjYXRlZ29yaWVzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBjYXRlZ29yaWVzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2V0KGZhbHNlLCBjYXRlZ29yaWVzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgZW5hYmxlZCBzdGF0ZXVzIG9mIGEgW1tDYXRlZ29yeV1dXG4gICAgICpcbiAgICAgKiBgYGBqc1xuICAgICAqIHRyYWNlLmVuYWJsZWQoXCJWSUVXQ09ORklHXCIpOyAvLyB0cnVlIG9yIGZhbHNlXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBib29sZWFuIHRydWUgaWYgdGhlIGNhdGVnb3J5IGlzIGVuYWJsZWRcbiAgICAgKi9cbiAgICBUcmFjZS5wcm90b3R5cGUuZW5hYmxlZCA9IGZ1bmN0aW9uIChjYXRlZ29yeSkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9lbmFibGVkW25vcm1hbGl6ZWRDYXQoY2F0ZWdvcnkpXTtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWxhcGkgY2FsbGVkIGJ5IHVpLXJvdXRlciBjb2RlICovXG4gICAgVHJhY2UucHJvdG90eXBlLnRyYWNlVHJhbnNpdGlvblN0YXJ0ID0gZnVuY3Rpb24gKHRyYW5zKSB7XG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKENhdGVnb3J5LlRSQU5TSVRJT04pKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zb2xlLmxvZyh0cmFuc0xibCh0cmFucykgKyBcIjogU3RhcnRlZCAgLT4gXCIgKyBzdHJpbmdzXzEuc3RyaW5naWZ5KHRyYW5zKSk7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsYXBpIGNhbGxlZCBieSB1aS1yb3V0ZXIgY29kZSAqL1xuICAgIFRyYWNlLnByb3RvdHlwZS50cmFjZVRyYW5zaXRpb25JZ25vcmVkID0gZnVuY3Rpb24gKHRyYW5zKSB7XG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKENhdGVnb3J5LlRSQU5TSVRJT04pKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zb2xlLmxvZyh0cmFuc0xibCh0cmFucykgKyBcIjogSWdub3JlZCAgPD4gXCIgKyBzdHJpbmdzXzEuc3RyaW5naWZ5KHRyYW5zKSk7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsYXBpIGNhbGxlZCBieSB1aS1yb3V0ZXIgY29kZSAqL1xuICAgIFRyYWNlLnByb3RvdHlwZS50cmFjZUhvb2tJbnZvY2F0aW9uID0gZnVuY3Rpb24gKHN0ZXAsIHRyYW5zLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKENhdGVnb3J5LkhPT0spKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgZXZlbnQgPSBob2ZfMS5wYXJzZSgndHJhY2VEYXRhLmhvb2tUeXBlJykob3B0aW9ucykgfHwgJ2ludGVybmFsJywgY29udGV4dCA9IGhvZl8xLnBhcnNlKCd0cmFjZURhdGEuY29udGV4dC5zdGF0ZS5uYW1lJykob3B0aW9ucykgfHwgaG9mXzEucGFyc2UoJ3RyYWNlRGF0YS5jb250ZXh0Jykob3B0aW9ucykgfHwgJ3Vua25vd24nLCBuYW1lID0gc3RyaW5nc18xLmZ1bmN0aW9uVG9TdHJpbmcoc3RlcC5yZWdpc3RlcmVkSG9vay5jYWxsYmFjayk7XG4gICAgICAgIGNvbnNvbGUubG9nKHRyYW5zTGJsKHRyYW5zKSArIFwiOiAgIEhvb2sgLT4gXCIgKyBldmVudCArIFwiIGNvbnRleHQ6IFwiICsgY29udGV4dCArIFwiLCBcIiArIHN0cmluZ3NfMS5tYXhMZW5ndGgoMjAwLCBuYW1lKSk7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsYXBpIGNhbGxlZCBieSB1aS1yb3V0ZXIgY29kZSAqL1xuICAgIFRyYWNlLnByb3RvdHlwZS50cmFjZUhvb2tSZXN1bHQgPSBmdW5jdGlvbiAoaG9va1Jlc3VsdCwgdHJhbnMsIHRyYW5zaXRpb25PcHRpb25zKSB7XG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKENhdGVnb3J5LkhPT0spKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zb2xlLmxvZyh0cmFuc0xibCh0cmFucykgKyBcIjogICA8LSBIb29rIHJldHVybmVkOiBcIiArIHN0cmluZ3NfMS5tYXhMZW5ndGgoMjAwLCBzdHJpbmdzXzEuc3RyaW5naWZ5KGhvb2tSZXN1bHQpKSk7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsYXBpIGNhbGxlZCBieSB1aS1yb3V0ZXIgY29kZSAqL1xuICAgIFRyYWNlLnByb3RvdHlwZS50cmFjZVJlc29sdmVQYXRoID0gZnVuY3Rpb24gKHBhdGgsIHdoZW4sIHRyYW5zKSB7XG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKENhdGVnb3J5LlJFU09MVkUpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zb2xlLmxvZyh0cmFuc0xibCh0cmFucykgKyBcIjogICAgICAgICBSZXNvbHZpbmcgXCIgKyBwYXRoICsgXCIgKFwiICsgd2hlbiArIFwiKVwiKTtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWxhcGkgY2FsbGVkIGJ5IHVpLXJvdXRlciBjb2RlICovXG4gICAgVHJhY2UucHJvdG90eXBlLnRyYWNlUmVzb2x2YWJsZVJlc29sdmVkID0gZnVuY3Rpb24gKHJlc29sdmFibGUsIHRyYW5zKSB7XG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKENhdGVnb3J5LlJFU09MVkUpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zb2xlLmxvZyh0cmFuc0xibCh0cmFucykgKyBcIjogICAgICAgICAgICAgICA8LSBSZXNvbHZlZCAgXCIgKyByZXNvbHZhYmxlICsgXCIgdG86IFwiICsgc3RyaW5nc18xLm1heExlbmd0aCgyMDAsIHN0cmluZ3NfMS5zdHJpbmdpZnkocmVzb2x2YWJsZS5kYXRhKSkpO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbGFwaSBjYWxsZWQgYnkgdWktcm91dGVyIGNvZGUgKi9cbiAgICBUcmFjZS5wcm90b3R5cGUudHJhY2VFcnJvciA9IGZ1bmN0aW9uIChyZWFzb24sIHRyYW5zKSB7XG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKENhdGVnb3J5LlRSQU5TSVRJT04pKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zb2xlLmxvZyh0cmFuc0xibCh0cmFucykgKyBcIjogPC0gUmVqZWN0ZWQgXCIgKyBzdHJpbmdzXzEuc3RyaW5naWZ5KHRyYW5zKSArIFwiLCByZWFzb246IFwiICsgcmVhc29uKTtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWxhcGkgY2FsbGVkIGJ5IHVpLXJvdXRlciBjb2RlICovXG4gICAgVHJhY2UucHJvdG90eXBlLnRyYWNlU3VjY2VzcyA9IGZ1bmN0aW9uIChmaW5hbFN0YXRlLCB0cmFucykge1xuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZChDYXRlZ29yeS5UUkFOU0lUSU9OKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc29sZS5sb2codHJhbnNMYmwodHJhbnMpICsgXCI6IDwtIFN1Y2Nlc3MgIFwiICsgc3RyaW5nc18xLnN0cmluZ2lmeSh0cmFucykgKyBcIiwgZmluYWwgc3RhdGU6IFwiICsgZmluYWxTdGF0ZS5uYW1lKTtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWxhcGkgY2FsbGVkIGJ5IHVpLXJvdXRlciBjb2RlICovXG4gICAgVHJhY2UucHJvdG90eXBlLnRyYWNlVUlWaWV3RXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQsIHZpZXdEYXRhLCBleHRyYSkge1xuICAgICAgICBpZiAoZXh0cmEgPT09IHZvaWQgMCkgeyBleHRyYSA9ICcnOyB9XG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKENhdGVnb3J5LlVJVklFVykpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnNvbGUubG9nKFwidWktdmlldzogXCIgKyBzdHJpbmdzXzEucGFkU3RyaW5nKDMwLCBldmVudCkgKyBcIiBcIiArIHVpVmlld1N0cmluZyh2aWV3RGF0YSkgKyBleHRyYSk7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsYXBpIGNhbGxlZCBieSB1aS1yb3V0ZXIgY29kZSAqL1xuICAgIFRyYWNlLnByb3RvdHlwZS50cmFjZVVJVmlld0NvbmZpZ1VwZGF0ZWQgPSBmdW5jdGlvbiAodmlld0RhdGEsIGNvbnRleHQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWQoQ2F0ZWdvcnkuVUlWSUVXKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy50cmFjZVVJVmlld0V2ZW50KCdVcGRhdGluZycsIHZpZXdEYXRhLCBcIiB3aXRoIFZpZXdDb25maWcgZnJvbSBjb250ZXh0PSdcIiArIGNvbnRleHQgKyBcIidcIik7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsYXBpIGNhbGxlZCBieSB1aS1yb3V0ZXIgY29kZSAqL1xuICAgIFRyYWNlLnByb3RvdHlwZS50cmFjZVVJVmlld0ZpbGwgPSBmdW5jdGlvbiAodmlld0RhdGEsIGh0bWwpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWQoQ2F0ZWdvcnkuVUlWSUVXKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy50cmFjZVVJVmlld0V2ZW50KCdGaWxsJywgdmlld0RhdGEsIFwiIHdpdGg6IFwiICsgc3RyaW5nc18xLm1heExlbmd0aCgyMDAsIGh0bWwpKTtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWxhcGkgY2FsbGVkIGJ5IHVpLXJvdXRlciBjb2RlICovXG4gICAgVHJhY2UucHJvdG90eXBlLnRyYWNlVmlld1N5bmMgPSBmdW5jdGlvbiAocGFpcnMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWQoQ2F0ZWdvcnkuVklFV0NPTkZJRykpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciB1aXZoZWFkZXIgPSAndWl2aWV3IGNvbXBvbmVudCBmcW4nO1xuICAgICAgICB2YXIgY2ZnaGVhZGVyID0gJ3ZpZXcgY29uZmlnIHN0YXRlICh2aWV3IG5hbWUpJztcbiAgICAgICAgdmFyIG1hcHBpbmcgPSBwYWlycy5tYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgdWlWaWV3ID0gX2EudWlWaWV3LCB2aWV3Q29uZmlnID0gX2Eudmlld0NvbmZpZztcbiAgICAgICAgICAgIHZhciB1aXYgPSB1aVZpZXcgJiYgdWlWaWV3LmZxbjtcbiAgICAgICAgICAgIHZhciBjZmcgPSB2aWV3Q29uZmlnICYmIHZpZXdDb25maWcudmlld0RlY2wuJGNvbnRleHQubmFtZSArIFwiOiAoXCIgKyB2aWV3Q29uZmlnLnZpZXdEZWNsLiRuYW1lICsgXCIpXCI7XG4gICAgICAgICAgICByZXR1cm4gX2IgPSB7fSwgX2JbdWl2aGVhZGVyXSA9IHVpdiwgX2JbY2ZnaGVhZGVyXSA9IGNmZywgX2I7XG4gICAgICAgICAgICB2YXIgX2I7XG4gICAgICAgIH0pLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIChhW3VpdmhlYWRlcl0gfHwgJycpLmxvY2FsZUNvbXBhcmUoYlt1aXZoZWFkZXJdIHx8ICcnKTsgfSk7XG4gICAgICAgIGNvbnNvbGV0YWJsZShtYXBwaW5nKTtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWxhcGkgY2FsbGVkIGJ5IHVpLXJvdXRlciBjb2RlICovXG4gICAgVHJhY2UucHJvdG90eXBlLnRyYWNlVmlld1NlcnZpY2VFdmVudCA9IGZ1bmN0aW9uIChldmVudCwgdmlld0NvbmZpZykge1xuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZChDYXRlZ29yeS5WSUVXQ09ORklHKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc29sZS5sb2coXCJWSUVXQ09ORklHOiBcIiArIGV2ZW50ICsgXCIgXCIgKyB2aWV3Q29uZmlnU3RyaW5nKHZpZXdDb25maWcpKTtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWxhcGkgY2FsbGVkIGJ5IHVpLXJvdXRlciBjb2RlICovXG4gICAgVHJhY2UucHJvdG90eXBlLnRyYWNlVmlld1NlcnZpY2VVSVZpZXdFdmVudCA9IGZ1bmN0aW9uIChldmVudCwgdmlld0RhdGEpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWQoQ2F0ZWdvcnkuVklFV0NPTkZJRykpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnNvbGUubG9nKFwiVklFV0NPTkZJRzogXCIgKyBldmVudCArIFwiIFwiICsgdWlWaWV3U3RyaW5nKHZpZXdEYXRhKSk7XG4gICAgfTtcbiAgICByZXR1cm4gVHJhY2U7XG59KCkpO1xuZXhwb3J0cy5UcmFjZSA9IFRyYWNlO1xuLyoqXG4gKiBUaGUgW1tUcmFjZV1dIHNpbmdsZXRvblxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqIGBgYGpzXG4gKiBpbXBvcnQge3RyYWNlfSBmcm9tIFwiYW5ndWxhci11aS1yb3V0ZXJcIjtcbiAqIHRyYWNlLmVuYWJsZSgxLCA1KTtcbiAqIGBgYFxuICovXG52YXIgdHJhY2UgPSBuZXcgVHJhY2UoKTtcbmV4cG9ydHMudHJhY2UgPSB0cmFjZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYWNlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9jb21tb24vdHJhY2UuanNcbi8vIG1vZHVsZSBpZCA9IDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8\n')},function(module,exports){eval("// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n  ? window : typeof self != 'undefined' && self.Math == Math ? self\n  // eslint-disable-next-line no-new-func\n  : Function('return this')();\nif (typeof __g == 'number') __g = global; // eslint-disable-line no-undef\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZ2xvYmFsLmpzP2VjYWIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzg2I2lzc3VlY29tbWVudC0xMTU3NTkwMjhcbnZhciBnbG9iYWwgPSBtb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93Lk1hdGggPT0gTWF0aFxuICA/IHdpbmRvdyA6IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYuTWF0aCA9PSBNYXRoID8gc2VsZlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcbiAgOiBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuaWYgKHR5cGVvZiBfX2cgPT0gJ251bWJlcicpIF9fZyA9IGdsb2JhbDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2dsb2JhbC5qc1xuLy8gbW9kdWxlIGlkID0gOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9\n")},function(module,exports,__webpack_require__){eval("var store = __webpack_require__(54)('wks');\nvar uid = __webpack_require__(37);\nvar Symbol = __webpack_require__(9).Symbol;\nvar USE_SYMBOL = typeof Symbol == 'function';\n\nvar $exports = module.exports = function (name) {\n  return store[name] || (store[name] =\n    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));\n};\n\n$exports.store = store;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy5qcz83NTJjIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBzdG9yZSA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCd3a3MnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcbnZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5TeW1ib2w7XG52YXIgVVNFX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT0gJ2Z1bmN0aW9uJztcblxudmFyICRleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gc3RvcmVbbmFtZV0gfHwgKHN0b3JlW25hbWVdID1cbiAgICBVU0VfU1lNQk9MICYmIFN5bWJvbFtuYW1lXSB8fCAoVVNFX1NZTUJPTCA/IFN5bWJvbCA6IHVpZCkoJ1N5bWJvbC4nICsgbmFtZSkpO1xufTtcblxuJGV4cG9ydHMuc3RvcmUgPSBzdG9yZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL193a3MuanNcbi8vIG1vZHVsZSBpZCA9IDEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///10\n")},function(module,exports,__webpack_require__){eval("var global = __webpack_require__(9);\nvar core = __webpack_require__(4);\nvar ctx = __webpack_require__(95);\nvar hide = __webpack_require__(20);\nvar PROTOTYPE = 'prototype';\n\nvar $export = function (type, name, source) {\n  var IS_FORCED = type & $export.F;\n  var IS_GLOBAL = type & $export.G;\n  var IS_STATIC = type & $export.S;\n  var IS_PROTO = type & $export.P;\n  var IS_BIND = type & $export.B;\n  var IS_WRAP = type & $export.W;\n  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});\n  var expProto = exports[PROTOTYPE];\n  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];\n  var key, own, out;\n  if (IS_GLOBAL) source = name;\n  for (key in source) {\n    // contains in native\n    own = !IS_FORCED && target && target[key] !== undefined;\n    if (own && key in exports) continue;\n    // export native or passed\n    out = own ? target[key] : source[key];\n    // prevent global pollution for namespaces\n    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]\n    // bind timers to global for call from export context\n    : IS_BIND && own ? ctx(out, global)\n    // wrap global constructors for prevent change them in library\n    : IS_WRAP && target[key] == out ? (function (C) {\n      var F = function (a, b, c) {\n        if (this instanceof C) {\n          switch (arguments.length) {\n            case 0: return new C();\n            case 1: return new C(a);\n            case 2: return new C(a, b);\n          } return new C(a, b, c);\n        } return C.apply(this, arguments);\n      };\n      F[PROTOTYPE] = C[PROTOTYPE];\n      return F;\n    // make static versions for prototype methods\n    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%\n    if (IS_PROTO) {\n      (exports.virtual || (exports.virtual = {}))[key] = out;\n      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%\n      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);\n    }\n  }\n};\n// type bitmap\n$export.F = 1;   // forced\n$export.G = 2;   // global\n$export.S = 4;   // static\n$export.P = 8;   // proto\n$export.B = 16;  // bind\n$export.W = 32;  // wrap\n$export.U = 64;  // safe\n$export.R = 128; // real proto method for `library`\nmodule.exports = $export;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2V4cG9ydC5qcz85MGNkIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG5cbnZhciAkZXhwb3J0ID0gZnVuY3Rpb24gKHR5cGUsIG5hbWUsIHNvdXJjZSkge1xuICB2YXIgSVNfRk9SQ0VEID0gdHlwZSAmICRleHBvcnQuRjtcbiAgdmFyIElTX0dMT0JBTCA9IHR5cGUgJiAkZXhwb3J0Lkc7XG4gIHZhciBJU19TVEFUSUMgPSB0eXBlICYgJGV4cG9ydC5TO1xuICB2YXIgSVNfUFJPVE8gPSB0eXBlICYgJGV4cG9ydC5QO1xuICB2YXIgSVNfQklORCA9IHR5cGUgJiAkZXhwb3J0LkI7XG4gIHZhciBJU19XUkFQID0gdHlwZSAmICRleHBvcnQuVztcbiAgdmFyIGV4cG9ydHMgPSBJU19HTE9CQUwgPyBjb3JlIDogY29yZVtuYW1lXSB8fCAoY29yZVtuYW1lXSA9IHt9KTtcbiAgdmFyIGV4cFByb3RvID0gZXhwb3J0c1tQUk9UT1RZUEVdO1xuICB2YXIgdGFyZ2V0ID0gSVNfR0xPQkFMID8gZ2xvYmFsIDogSVNfU1RBVElDID8gZ2xvYmFsW25hbWVdIDogKGdsb2JhbFtuYW1lXSB8fCB7fSlbUFJPVE9UWVBFXTtcbiAgdmFyIGtleSwgb3duLCBvdXQ7XG4gIGlmIChJU19HTE9CQUwpIHNvdXJjZSA9IG5hbWU7XG4gIGZvciAoa2V5IGluIHNvdXJjZSkge1xuICAgIC8vIGNvbnRhaW5zIGluIG5hdGl2ZVxuICAgIG93biA9ICFJU19GT1JDRUQgJiYgdGFyZ2V0ICYmIHRhcmdldFtrZXldICE9PSB1bmRlZmluZWQ7XG4gICAgaWYgKG93biAmJiBrZXkgaW4gZXhwb3J0cykgY29udGludWU7XG4gICAgLy8gZXhwb3J0IG5hdGl2ZSBvciBwYXNzZWRcbiAgICBvdXQgPSBvd24gPyB0YXJnZXRba2V5XSA6IHNvdXJjZVtrZXldO1xuICAgIC8vIHByZXZlbnQgZ2xvYmFsIHBvbGx1dGlvbiBmb3IgbmFtZXNwYWNlc1xuICAgIGV4cG9ydHNba2V5XSA9IElTX0dMT0JBTCAmJiB0eXBlb2YgdGFyZ2V0W2tleV0gIT0gJ2Z1bmN0aW9uJyA/IHNvdXJjZVtrZXldXG4gICAgLy8gYmluZCB0aW1lcnMgdG8gZ2xvYmFsIGZvciBjYWxsIGZyb20gZXhwb3J0IGNvbnRleHRcbiAgICA6IElTX0JJTkQgJiYgb3duID8gY3R4KG91dCwgZ2xvYmFsKVxuICAgIC8vIHdyYXAgZ2xvYmFsIGNvbnN0cnVjdG9ycyBmb3IgcHJldmVudCBjaGFuZ2UgdGhlbSBpbiBsaWJyYXJ5XG4gICAgOiBJU19XUkFQICYmIHRhcmdldFtrZXldID09IG91dCA/IChmdW5jdGlvbiAoQykge1xuICAgICAgdmFyIEYgPSBmdW5jdGlvbiAoYSwgYiwgYykge1xuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIEMpIHtcbiAgICAgICAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIG5ldyBDKCk7XG4gICAgICAgICAgICBjYXNlIDE6IHJldHVybiBuZXcgQyhhKTtcbiAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIG5ldyBDKGEsIGIpO1xuICAgICAgICAgIH0gcmV0dXJuIG5ldyBDKGEsIGIsIGMpO1xuICAgICAgICB9IHJldHVybiBDLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgICAgRltQUk9UT1RZUEVdID0gQ1tQUk9UT1RZUEVdO1xuICAgICAgcmV0dXJuIEY7XG4gICAgLy8gbWFrZSBzdGF0aWMgdmVyc2lvbnMgZm9yIHByb3RvdHlwZSBtZXRob2RzXG4gICAgfSkob3V0KSA6IElTX1BST1RPICYmIHR5cGVvZiBvdXQgPT0gJ2Z1bmN0aW9uJyA/IGN0eChGdW5jdGlvbi5jYWxsLCBvdXQpIDogb3V0O1xuICAgIC8vIGV4cG9ydCBwcm90byBtZXRob2RzIHRvIGNvcmUuJUNPTlNUUlVDVE9SJS5tZXRob2RzLiVOQU1FJVxuICAgIGlmIChJU19QUk9UTykge1xuICAgICAgKGV4cG9ydHMudmlydHVhbCB8fCAoZXhwb3J0cy52aXJ0dWFsID0ge30pKVtrZXldID0gb3V0O1xuICAgICAgLy8gZXhwb3J0IHByb3RvIG1ldGhvZHMgdG8gY29yZS4lQ09OU1RSVUNUT1IlLnByb3RvdHlwZS4lTkFNRSVcbiAgICAgIGlmICh0eXBlICYgJGV4cG9ydC5SICYmIGV4cFByb3RvICYmICFleHBQcm90b1trZXldKSBoaWRlKGV4cFByb3RvLCBrZXksIG91dCk7XG4gICAgfVxuICB9XG59O1xuLy8gdHlwZSBiaXRtYXBcbiRleHBvcnQuRiA9IDE7ICAgLy8gZm9yY2VkXG4kZXhwb3J0LkcgPSAyOyAgIC8vIGdsb2JhbFxuJGV4cG9ydC5TID0gNDsgICAvLyBzdGF0aWNcbiRleHBvcnQuUCA9IDg7ICAgLy8gcHJvdG9cbiRleHBvcnQuQiA9IDE2OyAgLy8gYmluZFxuJGV4cG9ydC5XID0gMzI7ICAvLyB3cmFwXG4kZXhwb3J0LlUgPSA2NDsgIC8vIHNhZmVcbiRleHBvcnQuUiA9IDEyODsgLy8gcmVhbCBwcm90byBtZXRob2QgZm9yIGBsaWJyYXJ5YFxubW9kdWxlLmV4cG9ydHMgPSAkZXhwb3J0O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2V4cG9ydC5qc1xuLy8gbW9kdWxlIGlkID0gMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///11\n")},function(module,exports,__webpack_require__){eval("var anObject = __webpack_require__(21);\nvar IE8_DOM_DEFINE = __webpack_require__(96);\nvar toPrimitive = __webpack_require__(49);\nvar dP = Object.defineProperty;\n\nexports.f = __webpack_require__(13) ? Object.defineProperty : function defineProperty(O, P, Attributes) {\n  anObject(O);\n  P = toPrimitive(P, true);\n  anObject(Attributes);\n  if (IE8_DOM_DEFINE) try {\n    return dP(O, P, Attributes);\n  } catch (e) { /* empty */ }\n  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1kcC5qcz83YWYwIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi9faWU4LWRvbS1kZWZpbmUnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xudmFyIGRQID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG5leHBvcnRzLmYgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xuICBhbk9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBhbk9iamVjdChBdHRyaWJ1dGVzKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiBkUChPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG4gIGlmICgnZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpIHRocm93IFR5cGVFcnJvcignQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQhJyk7XG4gIGlmICgndmFsdWUnIGluIEF0dHJpYnV0ZXMpIE9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICByZXR1cm4gTztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWRwLmpzXG4vLyBtb2R1bGUgaWQgPSAxMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///12\n")},function(module,exports,__webpack_require__){eval("// Thank's IE8 for his funny defineProperty\nmodule.exports = !__webpack_require__(23)(function () {\n  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2Rlc2NyaXB0b3JzLmpzP2Y4NGQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxubW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdhJywgeyBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH0gfSkuYSAhPSA3O1xufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fZGVzY3JpcHRvcnMuanNcbi8vIG1vZHVsZSBpZCA9IDEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///13\n")},function(module,exports){eval("var hasOwnProperty = {}.hasOwnProperty;\nmodule.exports = function (it, key) {\n  return hasOwnProperty.call(it, key);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2hhcy5qcz8wZjYyIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChpdCwga2V5KTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGFzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///14\n")},function(module,exports,__webpack_require__){eval("// to indexed object, toObject with fallback for non-array-like ES3 strings\nvar IObject = __webpack_require__(99);\nvar defined = __webpack_require__(51);\nmodule.exports = function (it) {\n  return IObject(defined(it));\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWlvYmplY3QuanM/NGRjNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyB0byBpbmRleGVkIG9iamVjdCwgdG9PYmplY3Qgd2l0aCBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIHN0cmluZ3NcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gSU9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWlvYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///15\n")},function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\nvar TransitionHookPhase;\n(function (TransitionHookPhase) {\n    TransitionHookPhase[TransitionHookPhase["CREATE"] = 0] = "CREATE";\n    TransitionHookPhase[TransitionHookPhase["BEFORE"] = 1] = "BEFORE";\n    TransitionHookPhase[TransitionHookPhase["RUN"] = 2] = "RUN";\n    TransitionHookPhase[TransitionHookPhase["SUCCESS"] = 3] = "SUCCESS";\n    TransitionHookPhase[TransitionHookPhase["ERROR"] = 4] = "ERROR";\n})(TransitionHookPhase = exports.TransitionHookPhase || (exports.TransitionHookPhase = {}));\nvar TransitionHookScope;\n(function (TransitionHookScope) {\n    TransitionHookScope[TransitionHookScope["TRANSITION"] = 0] = "TRANSITION";\n    TransitionHookScope[TransitionHookScope["STATE"] = 1] = "STATE";\n})(TransitionHookScope = exports.TransitionHookScope || (exports.TransitionHookScope = {}));\n//# sourceMappingURL=interface.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3RyYW5zaXRpb24vaW50ZXJmYWNlLmpzP2QwMjUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgVHJhbnNpdGlvbkhvb2tQaGFzZTtcbihmdW5jdGlvbiAoVHJhbnNpdGlvbkhvb2tQaGFzZSkge1xuICAgIFRyYW5zaXRpb25Ib29rUGhhc2VbVHJhbnNpdGlvbkhvb2tQaGFzZVtcIkNSRUFURVwiXSA9IDBdID0gXCJDUkVBVEVcIjtcbiAgICBUcmFuc2l0aW9uSG9va1BoYXNlW1RyYW5zaXRpb25Ib29rUGhhc2VbXCJCRUZPUkVcIl0gPSAxXSA9IFwiQkVGT1JFXCI7XG4gICAgVHJhbnNpdGlvbkhvb2tQaGFzZVtUcmFuc2l0aW9uSG9va1BoYXNlW1wiUlVOXCJdID0gMl0gPSBcIlJVTlwiO1xuICAgIFRyYW5zaXRpb25Ib29rUGhhc2VbVHJhbnNpdGlvbkhvb2tQaGFzZVtcIlNVQ0NFU1NcIl0gPSAzXSA9IFwiU1VDQ0VTU1wiO1xuICAgIFRyYW5zaXRpb25Ib29rUGhhc2VbVHJhbnNpdGlvbkhvb2tQaGFzZVtcIkVSUk9SXCJdID0gNF0gPSBcIkVSUk9SXCI7XG59KShUcmFuc2l0aW9uSG9va1BoYXNlID0gZXhwb3J0cy5UcmFuc2l0aW9uSG9va1BoYXNlIHx8IChleHBvcnRzLlRyYW5zaXRpb25Ib29rUGhhc2UgPSB7fSkpO1xudmFyIFRyYW5zaXRpb25Ib29rU2NvcGU7XG4oZnVuY3Rpb24gKFRyYW5zaXRpb25Ib29rU2NvcGUpIHtcbiAgICBUcmFuc2l0aW9uSG9va1Njb3BlW1RyYW5zaXRpb25Ib29rU2NvcGVbXCJUUkFOU0lUSU9OXCJdID0gMF0gPSBcIlRSQU5TSVRJT05cIjtcbiAgICBUcmFuc2l0aW9uSG9va1Njb3BlW1RyYW5zaXRpb25Ib29rU2NvcGVbXCJTVEFURVwiXSA9IDFdID0gXCJTVEFURVwiO1xufSkoVHJhbnNpdGlvbkhvb2tTY29wZSA9IGV4cG9ydHMuVHJhbnNpdGlvbkhvb2tTY29wZSB8fCAoZXhwb3J0cy5UcmFuc2l0aW9uSG9va1Njb3BlID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVyZmFjZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvdHJhbnNpdGlvbi9pbnRlcmZhY2UuanNcbi8vIG1vZHVsZSBpZCA9IDE2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///16\n')},function(module,exports,__webpack_require__){"use strict";eval('\n/**\n * @coreapi\n * @module state\n */ /** for typedoc */\nObject.defineProperty(exports, "__esModule", { value: true });\nvar predicates_1 = __webpack_require__(1);\nvar strings_1 = __webpack_require__(6);\nvar common_1 = __webpack_require__(5);\n/**\n * Encapsulate the target (destination) state/params/options of a [[Transition]].\n *\n * This class is frequently used to redirect a transition to a new destination.\n *\n * See:\n *\n * - [[HookResult]]\n * - [[TransitionHookFn]]\n * - [[TransitionService.onStart]]\n *\n * To create a `TargetState`, use [[StateService.target]].\n *\n * ---\n *\n * This class wraps:\n *\n * 1) an identifier for a state\n * 2) a set of parameters\n * 3) and transition options\n * 4) the registered state object (the [[StateDeclaration]])\n *\n * Many UI-Router APIs such as [[StateService.go]] take a [[StateOrName]] argument which can\n * either be a *state object* (a [[StateDeclaration]] or [[StateObject]]) or a *state name* (a string).\n * The `TargetState` class normalizes those options.\n *\n * A `TargetState` may be valid (the state being targeted exists in the registry)\n * or invalid (the state being targeted is not registered).\n */\nvar TargetState = /** @class */ (function () {\n    /**\n     * The TargetState constructor\n     *\n     * Note: Do not construct a `TargetState` manually.\n     * To create a `TargetState`, use the [[StateService.target]] factory method.\n     *\n     * @param _stateRegistry The StateRegistry to use to look up the _definition\n     * @param _identifier An identifier for a state.\n     *    Either a fully-qualified state name, or the object used to define the state.\n     * @param _params Parameters for the target state\n     * @param _options Transition options.\n     *\n     * @internalapi\n     */\n    function TargetState(_stateRegistry, _identifier, _params, _options) {\n        this._stateRegistry = _stateRegistry;\n        this._identifier = _identifier;\n        this._identifier = _identifier;\n        this._params = common_1.extend({}, _params || {});\n        this._options = common_1.extend({}, _options || {});\n        this._definition = _stateRegistry.matcher.find(_identifier, this._options.relative);\n    }\n    /** The name of the state this object targets */\n    TargetState.prototype.name = function () {\n        return this._definition && this._definition.name || this._identifier;\n    };\n    /** The identifier used when creating this TargetState */\n    TargetState.prototype.identifier = function () {\n        return this._identifier;\n    };\n    /** The target parameter values */\n    TargetState.prototype.params = function () {\n        return this._params;\n    };\n    /** The internal state object (if it was found) */\n    TargetState.prototype.$state = function () {\n        return this._definition;\n    };\n    /** The internal state declaration (if it was found) */\n    TargetState.prototype.state = function () {\n        return this._definition && this._definition.self;\n    };\n    /** The target options */\n    TargetState.prototype.options = function () {\n        return this._options;\n    };\n    /** True if the target state was found */\n    TargetState.prototype.exists = function () {\n        return !!(this._definition && this._definition.self);\n    };\n    /** True if the object is valid */\n    TargetState.prototype.valid = function () {\n        return !this.error();\n    };\n    /** If the object is invalid, returns the reason why */\n    TargetState.prototype.error = function () {\n        var base = this.options().relative;\n        if (!this._definition && !!base) {\n            var stateName = base.name ? base.name : base;\n            return "Could not resolve \'" + this.name() + "\' from state \'" + stateName + "\'";\n        }\n        if (!this._definition)\n            return "No such state \'" + this.name() + "\'";\n        if (!this._definition.self)\n            return "State \'" + this.name() + "\' has an invalid definition";\n    };\n    TargetState.prototype.toString = function () {\n        return "\'" + this.name() + "\'" + strings_1.stringify(this.params());\n    };\n    /**\n     * Returns a copy of this TargetState which targets a different state.\n     * The new TargetState has the same parameter values and transition options.\n     *\n     * @param state The new state that should be targeted\n     */\n    TargetState.prototype.withState = function (state) {\n        return new TargetState(this._stateRegistry, state, this._params, this._options);\n    };\n    /**\n     * Returns a copy of this TargetState, using the specified parameter values.\n     *\n     * @param params the new parameter values to use\n     * @param replace When false (default) the new parameter values will be merged with the current values.\n     *                When true the parameter values will be used instead of the current values.\n     */\n    TargetState.prototype.withParams = function (params, replace) {\n        if (replace === void 0) { replace = false; }\n        var newParams = replace ? params : common_1.extend({}, this._params, params);\n        return new TargetState(this._stateRegistry, this._identifier, newParams, this._options);\n    };\n    /**\n     * Returns a copy of this TargetState, using the specified Transition Options.\n     *\n     * @param options the new options to use\n     * @param replace When false (default) the new options will be merged with the current options.\n     *                When true the options will be used instead of the current options.\n     */\n    TargetState.prototype.withOptions = function (options, replace) {\n        if (replace === void 0) { replace = false; }\n        var newOpts = replace ? options : common_1.extend({}, this._options, options);\n        return new TargetState(this._stateRegistry, this._identifier, this._params, newOpts);\n    };\n    /** Returns true if the object has a state property that might be a state or state name */\n    TargetState.isDef = function (obj) {\n        return obj && obj.state && (predicates_1.isString(obj.state) || predicates_1.isString(obj.state.name));\n    };\n    return TargetState;\n}());\nexports.TargetState = TargetState;\n//# sourceMappingURL=targetState.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3N0YXRlL3RhcmdldFN0YXRlLmpzP2FmMmUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBjb3JlYXBpXG4gKiBAbW9kdWxlIHN0YXRlXG4gKi8gLyoqIGZvciB0eXBlZG9jICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgcHJlZGljYXRlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9wcmVkaWNhdGVzXCIpO1xudmFyIHN0cmluZ3NfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vc3RyaW5nc1wiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb25cIik7XG4vKipcbiAqIEVuY2Fwc3VsYXRlIHRoZSB0YXJnZXQgKGRlc3RpbmF0aW9uKSBzdGF0ZS9wYXJhbXMvb3B0aW9ucyBvZiBhIFtbVHJhbnNpdGlvbl1dLlxuICpcbiAqIFRoaXMgY2xhc3MgaXMgZnJlcXVlbnRseSB1c2VkIHRvIHJlZGlyZWN0IGEgdHJhbnNpdGlvbiB0byBhIG5ldyBkZXN0aW5hdGlvbi5cbiAqXG4gKiBTZWU6XG4gKlxuICogLSBbW0hvb2tSZXN1bHRdXVxuICogLSBbW1RyYW5zaXRpb25Ib29rRm5dXVxuICogLSBbW1RyYW5zaXRpb25TZXJ2aWNlLm9uU3RhcnRdXVxuICpcbiAqIFRvIGNyZWF0ZSBhIGBUYXJnZXRTdGF0ZWAsIHVzZSBbW1N0YXRlU2VydmljZS50YXJnZXRdXS5cbiAqXG4gKiAtLS1cbiAqXG4gKiBUaGlzIGNsYXNzIHdyYXBzOlxuICpcbiAqIDEpIGFuIGlkZW50aWZpZXIgZm9yIGEgc3RhdGVcbiAqIDIpIGEgc2V0IG9mIHBhcmFtZXRlcnNcbiAqIDMpIGFuZCB0cmFuc2l0aW9uIG9wdGlvbnNcbiAqIDQpIHRoZSByZWdpc3RlcmVkIHN0YXRlIG9iamVjdCAodGhlIFtbU3RhdGVEZWNsYXJhdGlvbl1dKVxuICpcbiAqIE1hbnkgVUktUm91dGVyIEFQSXMgc3VjaCBhcyBbW1N0YXRlU2VydmljZS5nb11dIHRha2UgYSBbW1N0YXRlT3JOYW1lXV0gYXJndW1lbnQgd2hpY2ggY2FuXG4gKiBlaXRoZXIgYmUgYSAqc3RhdGUgb2JqZWN0KiAoYSBbW1N0YXRlRGVjbGFyYXRpb25dXSBvciBbW1N0YXRlT2JqZWN0XV0pIG9yIGEgKnN0YXRlIG5hbWUqIChhIHN0cmluZykuXG4gKiBUaGUgYFRhcmdldFN0YXRlYCBjbGFzcyBub3JtYWxpemVzIHRob3NlIG9wdGlvbnMuXG4gKlxuICogQSBgVGFyZ2V0U3RhdGVgIG1heSBiZSB2YWxpZCAodGhlIHN0YXRlIGJlaW5nIHRhcmdldGVkIGV4aXN0cyBpbiB0aGUgcmVnaXN0cnkpXG4gKiBvciBpbnZhbGlkICh0aGUgc3RhdGUgYmVpbmcgdGFyZ2V0ZWQgaXMgbm90IHJlZ2lzdGVyZWQpLlxuICovXG52YXIgVGFyZ2V0U3RhdGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogVGhlIFRhcmdldFN0YXRlIGNvbnN0cnVjdG9yXG4gICAgICpcbiAgICAgKiBOb3RlOiBEbyBub3QgY29uc3RydWN0IGEgYFRhcmdldFN0YXRlYCBtYW51YWxseS5cbiAgICAgKiBUbyBjcmVhdGUgYSBgVGFyZ2V0U3RhdGVgLCB1c2UgdGhlIFtbU3RhdGVTZXJ2aWNlLnRhcmdldF1dIGZhY3RvcnkgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHBhcmFtIF9zdGF0ZVJlZ2lzdHJ5IFRoZSBTdGF0ZVJlZ2lzdHJ5IHRvIHVzZSB0byBsb29rIHVwIHRoZSBfZGVmaW5pdGlvblxuICAgICAqIEBwYXJhbSBfaWRlbnRpZmllciBBbiBpZGVudGlmaWVyIGZvciBhIHN0YXRlLlxuICAgICAqICAgIEVpdGhlciBhIGZ1bGx5LXF1YWxpZmllZCBzdGF0ZSBuYW1lLCBvciB0aGUgb2JqZWN0IHVzZWQgdG8gZGVmaW5lIHRoZSBzdGF0ZS5cbiAgICAgKiBAcGFyYW0gX3BhcmFtcyBQYXJhbWV0ZXJzIGZvciB0aGUgdGFyZ2V0IHN0YXRlXG4gICAgICogQHBhcmFtIF9vcHRpb25zIFRyYW5zaXRpb24gb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbGFwaVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFRhcmdldFN0YXRlKF9zdGF0ZVJlZ2lzdHJ5LCBfaWRlbnRpZmllciwgX3BhcmFtcywgX29wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fc3RhdGVSZWdpc3RyeSA9IF9zdGF0ZVJlZ2lzdHJ5O1xuICAgICAgICB0aGlzLl9pZGVudGlmaWVyID0gX2lkZW50aWZpZXI7XG4gICAgICAgIHRoaXMuX2lkZW50aWZpZXIgPSBfaWRlbnRpZmllcjtcbiAgICAgICAgdGhpcy5fcGFyYW1zID0gY29tbW9uXzEuZXh0ZW5kKHt9LCBfcGFyYW1zIHx8IHt9KTtcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IGNvbW1vbl8xLmV4dGVuZCh7fSwgX29wdGlvbnMgfHwge30pO1xuICAgICAgICB0aGlzLl9kZWZpbml0aW9uID0gX3N0YXRlUmVnaXN0cnkubWF0Y2hlci5maW5kKF9pZGVudGlmaWVyLCB0aGlzLl9vcHRpb25zLnJlbGF0aXZlKTtcbiAgICB9XG4gICAgLyoqIFRoZSBuYW1lIG9mIHRoZSBzdGF0ZSB0aGlzIG9iamVjdCB0YXJnZXRzICovXG4gICAgVGFyZ2V0U3RhdGUucHJvdG90eXBlLm5hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWZpbml0aW9uICYmIHRoaXMuX2RlZmluaXRpb24ubmFtZSB8fCB0aGlzLl9pZGVudGlmaWVyO1xuICAgIH07XG4gICAgLyoqIFRoZSBpZGVudGlmaWVyIHVzZWQgd2hlbiBjcmVhdGluZyB0aGlzIFRhcmdldFN0YXRlICovXG4gICAgVGFyZ2V0U3RhdGUucHJvdG90eXBlLmlkZW50aWZpZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pZGVudGlmaWVyO1xuICAgIH07XG4gICAgLyoqIFRoZSB0YXJnZXQgcGFyYW1ldGVyIHZhbHVlcyAqL1xuICAgIFRhcmdldFN0YXRlLnByb3RvdHlwZS5wYXJhbXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJhbXM7XG4gICAgfTtcbiAgICAvKiogVGhlIGludGVybmFsIHN0YXRlIG9iamVjdCAoaWYgaXQgd2FzIGZvdW5kKSAqL1xuICAgIFRhcmdldFN0YXRlLnByb3RvdHlwZS4kc3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWZpbml0aW9uO1xuICAgIH07XG4gICAgLyoqIFRoZSBpbnRlcm5hbCBzdGF0ZSBkZWNsYXJhdGlvbiAoaWYgaXQgd2FzIGZvdW5kKSAqL1xuICAgIFRhcmdldFN0YXRlLnByb3RvdHlwZS5zdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZmluaXRpb24gJiYgdGhpcy5fZGVmaW5pdGlvbi5zZWxmO1xuICAgIH07XG4gICAgLyoqIFRoZSB0YXJnZXQgb3B0aW9ucyAqL1xuICAgIFRhcmdldFN0YXRlLnByb3RvdHlwZS5vcHRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb3B0aW9ucztcbiAgICB9O1xuICAgIC8qKiBUcnVlIGlmIHRoZSB0YXJnZXQgc3RhdGUgd2FzIGZvdW5kICovXG4gICAgVGFyZ2V0U3RhdGUucHJvdG90eXBlLmV4aXN0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICEhKHRoaXMuX2RlZmluaXRpb24gJiYgdGhpcy5fZGVmaW5pdGlvbi5zZWxmKTtcbiAgICB9O1xuICAgIC8qKiBUcnVlIGlmIHRoZSBvYmplY3QgaXMgdmFsaWQgKi9cbiAgICBUYXJnZXRTdGF0ZS5wcm90b3R5cGUudmFsaWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5lcnJvcigpO1xuICAgIH07XG4gICAgLyoqIElmIHRoZSBvYmplY3QgaXMgaW52YWxpZCwgcmV0dXJucyB0aGUgcmVhc29uIHdoeSAqL1xuICAgIFRhcmdldFN0YXRlLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGJhc2UgPSB0aGlzLm9wdGlvbnMoKS5yZWxhdGl2ZTtcbiAgICAgICAgaWYgKCF0aGlzLl9kZWZpbml0aW9uICYmICEhYmFzZSkge1xuICAgICAgICAgICAgdmFyIHN0YXRlTmFtZSA9IGJhc2UubmFtZSA/IGJhc2UubmFtZSA6IGJhc2U7XG4gICAgICAgICAgICByZXR1cm4gXCJDb3VsZCBub3QgcmVzb2x2ZSAnXCIgKyB0aGlzLm5hbWUoKSArIFwiJyBmcm9tIHN0YXRlICdcIiArIHN0YXRlTmFtZSArIFwiJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fZGVmaW5pdGlvbilcbiAgICAgICAgICAgIHJldHVybiBcIk5vIHN1Y2ggc3RhdGUgJ1wiICsgdGhpcy5uYW1lKCkgKyBcIidcIjtcbiAgICAgICAgaWYgKCF0aGlzLl9kZWZpbml0aW9uLnNlbGYpXG4gICAgICAgICAgICByZXR1cm4gXCJTdGF0ZSAnXCIgKyB0aGlzLm5hbWUoKSArIFwiJyBoYXMgYW4gaW52YWxpZCBkZWZpbml0aW9uXCI7XG4gICAgfTtcbiAgICBUYXJnZXRTdGF0ZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIidcIiArIHRoaXMubmFtZSgpICsgXCInXCIgKyBzdHJpbmdzXzEuc3RyaW5naWZ5KHRoaXMucGFyYW1zKCkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhpcyBUYXJnZXRTdGF0ZSB3aGljaCB0YXJnZXRzIGEgZGlmZmVyZW50IHN0YXRlLlxuICAgICAqIFRoZSBuZXcgVGFyZ2V0U3RhdGUgaGFzIHRoZSBzYW1lIHBhcmFtZXRlciB2YWx1ZXMgYW5kIHRyYW5zaXRpb24gb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdGF0ZSBUaGUgbmV3IHN0YXRlIHRoYXQgc2hvdWxkIGJlIHRhcmdldGVkXG4gICAgICovXG4gICAgVGFyZ2V0U3RhdGUucHJvdG90eXBlLndpdGhTdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFRhcmdldFN0YXRlKHRoaXMuX3N0YXRlUmVnaXN0cnksIHN0YXRlLCB0aGlzLl9wYXJhbXMsIHRoaXMuX29wdGlvbnMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGNvcHkgb2YgdGhpcyBUYXJnZXRTdGF0ZSwgdXNpbmcgdGhlIHNwZWNpZmllZCBwYXJhbWV0ZXIgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyB0aGUgbmV3IHBhcmFtZXRlciB2YWx1ZXMgdG8gdXNlXG4gICAgICogQHBhcmFtIHJlcGxhY2UgV2hlbiBmYWxzZSAoZGVmYXVsdCkgdGhlIG5ldyBwYXJhbWV0ZXIgdmFsdWVzIHdpbGwgYmUgbWVyZ2VkIHdpdGggdGhlIGN1cnJlbnQgdmFsdWVzLlxuICAgICAqICAgICAgICAgICAgICAgIFdoZW4gdHJ1ZSB0aGUgcGFyYW1ldGVyIHZhbHVlcyB3aWxsIGJlIHVzZWQgaW5zdGVhZCBvZiB0aGUgY3VycmVudCB2YWx1ZXMuXG4gICAgICovXG4gICAgVGFyZ2V0U3RhdGUucHJvdG90eXBlLndpdGhQYXJhbXMgPSBmdW5jdGlvbiAocGFyYW1zLCByZXBsYWNlKSB7XG4gICAgICAgIGlmIChyZXBsYWNlID09PSB2b2lkIDApIHsgcmVwbGFjZSA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBuZXdQYXJhbXMgPSByZXBsYWNlID8gcGFyYW1zIDogY29tbW9uXzEuZXh0ZW5kKHt9LCB0aGlzLl9wYXJhbXMsIHBhcmFtcyk7XG4gICAgICAgIHJldHVybiBuZXcgVGFyZ2V0U3RhdGUodGhpcy5fc3RhdGVSZWdpc3RyeSwgdGhpcy5faWRlbnRpZmllciwgbmV3UGFyYW1zLCB0aGlzLl9vcHRpb25zKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBjb3B5IG9mIHRoaXMgVGFyZ2V0U3RhdGUsIHVzaW5nIHRoZSBzcGVjaWZpZWQgVHJhbnNpdGlvbiBPcHRpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgdGhlIG5ldyBvcHRpb25zIHRvIHVzZVxuICAgICAqIEBwYXJhbSByZXBsYWNlIFdoZW4gZmFsc2UgKGRlZmF1bHQpIHRoZSBuZXcgb3B0aW9ucyB3aWxsIGJlIG1lcmdlZCB3aXRoIHRoZSBjdXJyZW50IG9wdGlvbnMuXG4gICAgICogICAgICAgICAgICAgICAgV2hlbiB0cnVlIHRoZSBvcHRpb25zIHdpbGwgYmUgdXNlZCBpbnN0ZWFkIG9mIHRoZSBjdXJyZW50IG9wdGlvbnMuXG4gICAgICovXG4gICAgVGFyZ2V0U3RhdGUucHJvdG90eXBlLndpdGhPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMsIHJlcGxhY2UpIHtcbiAgICAgICAgaWYgKHJlcGxhY2UgPT09IHZvaWQgMCkgeyByZXBsYWNlID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIG5ld09wdHMgPSByZXBsYWNlID8gb3B0aW9ucyA6IGNvbW1vbl8xLmV4dGVuZCh7fSwgdGhpcy5fb3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBuZXcgVGFyZ2V0U3RhdGUodGhpcy5fc3RhdGVSZWdpc3RyeSwgdGhpcy5faWRlbnRpZmllciwgdGhpcy5fcGFyYW1zLCBuZXdPcHRzKTtcbiAgICB9O1xuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgdGhlIG9iamVjdCBoYXMgYSBzdGF0ZSBwcm9wZXJ0eSB0aGF0IG1pZ2h0IGJlIGEgc3RhdGUgb3Igc3RhdGUgbmFtZSAqL1xuICAgIFRhcmdldFN0YXRlLmlzRGVmID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqICYmIG9iai5zdGF0ZSAmJiAocHJlZGljYXRlc18xLmlzU3RyaW5nKG9iai5zdGF0ZSkgfHwgcHJlZGljYXRlc18xLmlzU3RyaW5nKG9iai5zdGF0ZS5uYW1lKSk7XG4gICAgfTtcbiAgICByZXR1cm4gVGFyZ2V0U3RhdGU7XG59KCkpO1xuZXhwb3J0cy5UYXJnZXRTdGF0ZSA9IFRhcmdldFN0YXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFyZ2V0U3RhdGUuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3N0YXRlL3RhcmdldFN0YXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///17\n')},function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @coreapi\n * @module params\n */ /** for typedoc */\nvar common_1 = __webpack_require__(0);\nvar hof_1 = __webpack_require__(2);\nvar predicates_1 = __webpack_require__(1);\nvar coreservices_1 = __webpack_require__(3);\nvar paramType_1 = __webpack_require__(46);\n/** @hidden */\nvar hasOwn = Object.prototype.hasOwnProperty;\n/** @hidden */\nvar isShorthand = function (cfg) {\n    return ['value', 'type', 'squash', 'array', 'dynamic'].filter(hasOwn.bind(cfg || {})).length === 0;\n};\n/** @internalapi */\nvar DefType;\n(function (DefType) {\n    DefType[DefType[\"PATH\"] = 0] = \"PATH\";\n    DefType[DefType[\"SEARCH\"] = 1] = \"SEARCH\";\n    DefType[DefType[\"CONFIG\"] = 2] = \"CONFIG\";\n})(DefType = exports.DefType || (exports.DefType = {}));\n/** @hidden */\nfunction unwrapShorthand(cfg) {\n    cfg = isShorthand(cfg) && { value: cfg } || cfg;\n    getStaticDefaultValue['__cacheable'] = true;\n    function getStaticDefaultValue() {\n        return cfg.value;\n    }\n    return common_1.extend(cfg, {\n        $$fn: predicates_1.isInjectable(cfg.value) ? cfg.value : getStaticDefaultValue,\n    });\n}\n/** @hidden */\nfunction getType(cfg, urlType, location, id, paramTypes) {\n    if (cfg.type && urlType && urlType.name !== 'string')\n        throw new Error(\"Param '\" + id + \"' has two type configurations.\");\n    if (cfg.type && urlType && urlType.name === 'string' && paramTypes.type(cfg.type))\n        return paramTypes.type(cfg.type);\n    if (urlType)\n        return urlType;\n    if (!cfg.type) {\n        var type = location === DefType.CONFIG ? 'any' :\n            location === DefType.PATH ? 'path' :\n                location === DefType.SEARCH ? 'query' : 'string';\n        return paramTypes.type(type);\n    }\n    return cfg.type instanceof paramType_1.ParamType ? cfg.type : paramTypes.type(cfg.type);\n}\n/**\n * @internalapi\n * returns false, true, or the squash value to indicate the \"default parameter url squash policy\".\n */\nfunction getSquashPolicy(config, isOptional, defaultPolicy) {\n    var squash = config.squash;\n    if (!isOptional || squash === false)\n        return false;\n    if (!predicates_1.isDefined(squash) || squash == null)\n        return defaultPolicy;\n    if (squash === true || predicates_1.isString(squash))\n        return squash;\n    throw new Error(\"Invalid squash policy: '\" + squash + \"'. Valid policies: false, true, or arbitrary string\");\n}\n/** @internalapi */\nfunction getReplace(config, arrayMode, isOptional, squash) {\n    var defaultPolicy = [\n        { from: '', to: (isOptional || arrayMode ? undefined : '') },\n        { from: null, to: (isOptional || arrayMode ? undefined : '') },\n    ];\n    var replace = predicates_1.isArray(config.replace) ? config.replace : [];\n    if (predicates_1.isString(squash))\n        replace.push({ from: squash, to: undefined });\n    var configuredKeys = common_1.map(replace, hof_1.prop('from'));\n    return common_1.filter(defaultPolicy, function (item) { return configuredKeys.indexOf(item.from) === -1; }).concat(replace);\n}\n/** @internalapi */\nvar Param = /** @class */ (function () {\n    function Param(id, type, config, location, urlMatcherFactory) {\n        config = unwrapShorthand(config);\n        type = getType(config, type, location, id, urlMatcherFactory.paramTypes);\n        var arrayMode = getArrayMode();\n        type = arrayMode ? type.$asArray(arrayMode, location === DefType.SEARCH) : type;\n        var isOptional = config.value !== undefined || location === DefType.SEARCH;\n        var dynamic = predicates_1.isDefined(config.dynamic) ? !!config.dynamic : !!type.dynamic;\n        var raw = predicates_1.isDefined(config.raw) ? !!config.raw : !!type.raw;\n        var squash = getSquashPolicy(config, isOptional, urlMatcherFactory.defaultSquashPolicy());\n        var replace = getReplace(config, arrayMode, isOptional, squash);\n        var inherit = predicates_1.isDefined(config.inherit) ? !!config.inherit : !!type.inherit;\n        // array config: param name (param[]) overrides default settings.  explicit config overrides param name.\n        function getArrayMode() {\n            var arrayDefaults = { array: (location === DefType.SEARCH ? 'auto' : false) };\n            var arrayParamNomenclature = id.match(/\\[\\]$/) ? { array: true } : {};\n            return common_1.extend(arrayDefaults, arrayParamNomenclature, config).array;\n        }\n        common_1.extend(this, { id: id, type: type, location: location, isOptional: isOptional, dynamic: dynamic, raw: raw, squash: squash, replace: replace, inherit: inherit, array: arrayMode, config: config });\n    }\n    Param.values = function (params, values) {\n        if (values === void 0) { values = {}; }\n        var paramValues = {};\n        for (var _i = 0, params_1 = params; _i < params_1.length; _i++) {\n            var param = params_1[_i];\n            paramValues[param.id] = param.value(values[param.id]);\n        }\n        return paramValues;\n    };\n    /**\n     * Finds [[Param]] objects which have different param values\n     *\n     * Filters a list of [[Param]] objects to only those whose parameter values differ in two param value objects\n     *\n     * @param params: The list of Param objects to filter\n     * @param values1: The first set of parameter values\n     * @param values2: the second set of parameter values\n     *\n     * @returns any Param objects whose values were different between values1 and values2\n     */\n    Param.changed = function (params, values1, values2) {\n        if (values1 === void 0) { values1 = {}; }\n        if (values2 === void 0) { values2 = {}; }\n        return params.filter(function (param) { return !param.type.equals(values1[param.id], values2[param.id]); });\n    };\n    /**\n     * Checks if two param value objects are equal (for a set of [[Param]] objects)\n     *\n     * @param params The list of [[Param]] objects to check\n     * @param values1 The first set of param values\n     * @param values2 The second set of param values\n     *\n     * @returns true if the param values in values1 and values2 are equal\n     */\n    Param.equals = function (params, values1, values2) {\n        if (values1 === void 0) { values1 = {}; }\n        if (values2 === void 0) { values2 = {}; }\n        return Param.changed(params, values1, values2).length === 0;\n    };\n    /** Returns true if a the parameter values are valid, according to the Param definitions */\n    Param.validates = function (params, values) {\n        if (values === void 0) { values = {}; }\n        return params.map(function (param) { return param.validates(values[param.id]); }).reduce(common_1.allTrueR, true);\n    };\n    Param.prototype.isDefaultValue = function (value) {\n        return this.isOptional && this.type.equals(this.value(), value);\n    };\n    /**\n     * [Internal] Gets the decoded representation of a value if the value is defined, otherwise, returns the\n     * default value, which may be the result of an injectable function.\n     */\n    Param.prototype.value = function (value) {\n        var _this = this;\n        /**\n         * [Internal] Get the default value of a parameter, which may be an injectable function.\n         */\n        var getDefaultValue = function () {\n            if (_this._defaultValueCache)\n                return _this._defaultValueCache.defaultValue;\n            if (!coreservices_1.services.$injector)\n                throw new Error('Injectable functions cannot be called at configuration time');\n            var defaultValue = coreservices_1.services.$injector.invoke(_this.config.$$fn);\n            if (defaultValue !== null && defaultValue !== undefined && !_this.type.is(defaultValue))\n                throw new Error(\"Default value (\" + defaultValue + \") for parameter '\" + _this.id + \"' is not an instance of ParamType (\" + _this.type.name + \")\");\n            if (_this.config.$$fn['__cacheable']) {\n                _this._defaultValueCache = { defaultValue: defaultValue };\n            }\n            return defaultValue;\n        };\n        var replaceSpecialValues = function (val) {\n            for (var _i = 0, _a = _this.replace; _i < _a.length; _i++) {\n                var tuple = _a[_i];\n                if (tuple.from === val)\n                    return tuple.to;\n            }\n            return val;\n        };\n        value = replaceSpecialValues(value);\n        return predicates_1.isUndefined(value) ? getDefaultValue() : this.type.$normalize(value);\n    };\n    Param.prototype.isSearch = function () {\n        return this.location === DefType.SEARCH;\n    };\n    Param.prototype.validates = function (value) {\n        // There was no parameter value, but the param is optional\n        if ((predicates_1.isUndefined(value) || value === null) && this.isOptional)\n            return true;\n        // The value was not of the correct ParamType, and could not be decoded to the correct ParamType\n        var normalized = this.type.$normalize(value);\n        if (!this.type.is(normalized))\n            return false;\n        // The value was of the correct type, but when encoded, did not match the ParamType's regexp\n        var encoded = this.type.encode(normalized);\n        return !(predicates_1.isString(encoded) && !this.type.pattern.exec(encoded));\n    };\n    Param.prototype.toString = function () {\n        return \"{Param:\" + this.id + \" \" + this.type + \" squash: '\" + this.squash + \"' optional: \" + this.isOptional + \"}\";\n    };\n    return Param;\n}());\nexports.Param = Param;\n//# sourceMappingURL=param.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3BhcmFtcy9wYXJhbS5qcz9kMzY2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAY29yZWFwaVxuICogQG1vZHVsZSBwYXJhbXNcbiAqLyAvKiogZm9yIHR5cGVkb2MgKi9cbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29tbW9uXCIpO1xudmFyIGhvZl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9ob2ZcIik7XG52YXIgcHJlZGljYXRlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9wcmVkaWNhdGVzXCIpO1xudmFyIGNvcmVzZXJ2aWNlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb3Jlc2VydmljZXNcIik7XG52YXIgcGFyYW1UeXBlXzEgPSByZXF1aXJlKFwiLi9wYXJhbVR5cGVcIik7XG4vKiogQGhpZGRlbiAqL1xudmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4vKiogQGhpZGRlbiAqL1xudmFyIGlzU2hvcnRoYW5kID0gZnVuY3Rpb24gKGNmZykge1xuICAgIHJldHVybiBbJ3ZhbHVlJywgJ3R5cGUnLCAnc3F1YXNoJywgJ2FycmF5JywgJ2R5bmFtaWMnXS5maWx0ZXIoaGFzT3duLmJpbmQoY2ZnIHx8IHt9KSkubGVuZ3RoID09PSAwO1xufTtcbi8qKiBAaW50ZXJuYWxhcGkgKi9cbnZhciBEZWZUeXBlO1xuKGZ1bmN0aW9uIChEZWZUeXBlKSB7XG4gICAgRGVmVHlwZVtEZWZUeXBlW1wiUEFUSFwiXSA9IDBdID0gXCJQQVRIXCI7XG4gICAgRGVmVHlwZVtEZWZUeXBlW1wiU0VBUkNIXCJdID0gMV0gPSBcIlNFQVJDSFwiO1xuICAgIERlZlR5cGVbRGVmVHlwZVtcIkNPTkZJR1wiXSA9IDJdID0gXCJDT05GSUdcIjtcbn0pKERlZlR5cGUgPSBleHBvcnRzLkRlZlR5cGUgfHwgKGV4cG9ydHMuRGVmVHlwZSA9IHt9KSk7XG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gdW53cmFwU2hvcnRoYW5kKGNmZykge1xuICAgIGNmZyA9IGlzU2hvcnRoYW5kKGNmZykgJiYgeyB2YWx1ZTogY2ZnIH0gfHwgY2ZnO1xuICAgIGdldFN0YXRpY0RlZmF1bHRWYWx1ZVsnX19jYWNoZWFibGUnXSA9IHRydWU7XG4gICAgZnVuY3Rpb24gZ2V0U3RhdGljRGVmYXVsdFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gY2ZnLnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gY29tbW9uXzEuZXh0ZW5kKGNmZywge1xuICAgICAgICAkJGZuOiBwcmVkaWNhdGVzXzEuaXNJbmplY3RhYmxlKGNmZy52YWx1ZSkgPyBjZmcudmFsdWUgOiBnZXRTdGF0aWNEZWZhdWx0VmFsdWUsXG4gICAgfSk7XG59XG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gZ2V0VHlwZShjZmcsIHVybFR5cGUsIGxvY2F0aW9uLCBpZCwgcGFyYW1UeXBlcykge1xuICAgIGlmIChjZmcudHlwZSAmJiB1cmxUeXBlICYmIHVybFR5cGUubmFtZSAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhcmFtICdcIiArIGlkICsgXCInIGhhcyB0d28gdHlwZSBjb25maWd1cmF0aW9ucy5cIik7XG4gICAgaWYgKGNmZy50eXBlICYmIHVybFR5cGUgJiYgdXJsVHlwZS5uYW1lID09PSAnc3RyaW5nJyAmJiBwYXJhbVR5cGVzLnR5cGUoY2ZnLnR5cGUpKVxuICAgICAgICByZXR1cm4gcGFyYW1UeXBlcy50eXBlKGNmZy50eXBlKTtcbiAgICBpZiAodXJsVHlwZSlcbiAgICAgICAgcmV0dXJuIHVybFR5cGU7XG4gICAgaWYgKCFjZmcudHlwZSkge1xuICAgICAgICB2YXIgdHlwZSA9IGxvY2F0aW9uID09PSBEZWZUeXBlLkNPTkZJRyA/ICdhbnknIDpcbiAgICAgICAgICAgIGxvY2F0aW9uID09PSBEZWZUeXBlLlBBVEggPyAncGF0aCcgOlxuICAgICAgICAgICAgICAgIGxvY2F0aW9uID09PSBEZWZUeXBlLlNFQVJDSCA/ICdxdWVyeScgOiAnc3RyaW5nJztcbiAgICAgICAgcmV0dXJuIHBhcmFtVHlwZXMudHlwZSh0eXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIGNmZy50eXBlIGluc3RhbmNlb2YgcGFyYW1UeXBlXzEuUGFyYW1UeXBlID8gY2ZnLnR5cGUgOiBwYXJhbVR5cGVzLnR5cGUoY2ZnLnR5cGUpO1xufVxuLyoqXG4gKiBAaW50ZXJuYWxhcGlcbiAqIHJldHVybnMgZmFsc2UsIHRydWUsIG9yIHRoZSBzcXVhc2ggdmFsdWUgdG8gaW5kaWNhdGUgdGhlIFwiZGVmYXVsdCBwYXJhbWV0ZXIgdXJsIHNxdWFzaCBwb2xpY3lcIi5cbiAqL1xuZnVuY3Rpb24gZ2V0U3F1YXNoUG9saWN5KGNvbmZpZywgaXNPcHRpb25hbCwgZGVmYXVsdFBvbGljeSkge1xuICAgIHZhciBzcXVhc2ggPSBjb25maWcuc3F1YXNoO1xuICAgIGlmICghaXNPcHRpb25hbCB8fCBzcXVhc2ggPT09IGZhbHNlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCFwcmVkaWNhdGVzXzEuaXNEZWZpbmVkKHNxdWFzaCkgfHwgc3F1YXNoID09IG51bGwpXG4gICAgICAgIHJldHVybiBkZWZhdWx0UG9saWN5O1xuICAgIGlmIChzcXVhc2ggPT09IHRydWUgfHwgcHJlZGljYXRlc18xLmlzU3RyaW5nKHNxdWFzaCkpXG4gICAgICAgIHJldHVybiBzcXVhc2g7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzcXVhc2ggcG9saWN5OiAnXCIgKyBzcXVhc2ggKyBcIicuIFZhbGlkIHBvbGljaWVzOiBmYWxzZSwgdHJ1ZSwgb3IgYXJiaXRyYXJ5IHN0cmluZ1wiKTtcbn1cbi8qKiBAaW50ZXJuYWxhcGkgKi9cbmZ1bmN0aW9uIGdldFJlcGxhY2UoY29uZmlnLCBhcnJheU1vZGUsIGlzT3B0aW9uYWwsIHNxdWFzaCkge1xuICAgIHZhciBkZWZhdWx0UG9saWN5ID0gW1xuICAgICAgICB7IGZyb206ICcnLCB0bzogKGlzT3B0aW9uYWwgfHwgYXJyYXlNb2RlID8gdW5kZWZpbmVkIDogJycpIH0sXG4gICAgICAgIHsgZnJvbTogbnVsbCwgdG86IChpc09wdGlvbmFsIHx8IGFycmF5TW9kZSA/IHVuZGVmaW5lZCA6ICcnKSB9LFxuICAgIF07XG4gICAgdmFyIHJlcGxhY2UgPSBwcmVkaWNhdGVzXzEuaXNBcnJheShjb25maWcucmVwbGFjZSkgPyBjb25maWcucmVwbGFjZSA6IFtdO1xuICAgIGlmIChwcmVkaWNhdGVzXzEuaXNTdHJpbmcoc3F1YXNoKSlcbiAgICAgICAgcmVwbGFjZS5wdXNoKHsgZnJvbTogc3F1YXNoLCB0bzogdW5kZWZpbmVkIH0pO1xuICAgIHZhciBjb25maWd1cmVkS2V5cyA9IGNvbW1vbl8xLm1hcChyZXBsYWNlLCBob2ZfMS5wcm9wKCdmcm9tJykpO1xuICAgIHJldHVybiBjb21tb25fMS5maWx0ZXIoZGVmYXVsdFBvbGljeSwgZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGNvbmZpZ3VyZWRLZXlzLmluZGV4T2YoaXRlbS5mcm9tKSA9PT0gLTE7IH0pLmNvbmNhdChyZXBsYWNlKTtcbn1cbi8qKiBAaW50ZXJuYWxhcGkgKi9cbnZhciBQYXJhbSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQYXJhbShpZCwgdHlwZSwgY29uZmlnLCBsb2NhdGlvbiwgdXJsTWF0Y2hlckZhY3RvcnkpIHtcbiAgICAgICAgY29uZmlnID0gdW53cmFwU2hvcnRoYW5kKGNvbmZpZyk7XG4gICAgICAgIHR5cGUgPSBnZXRUeXBlKGNvbmZpZywgdHlwZSwgbG9jYXRpb24sIGlkLCB1cmxNYXRjaGVyRmFjdG9yeS5wYXJhbVR5cGVzKTtcbiAgICAgICAgdmFyIGFycmF5TW9kZSA9IGdldEFycmF5TW9kZSgpO1xuICAgICAgICB0eXBlID0gYXJyYXlNb2RlID8gdHlwZS4kYXNBcnJheShhcnJheU1vZGUsIGxvY2F0aW9uID09PSBEZWZUeXBlLlNFQVJDSCkgOiB0eXBlO1xuICAgICAgICB2YXIgaXNPcHRpb25hbCA9IGNvbmZpZy52YWx1ZSAhPT0gdW5kZWZpbmVkIHx8IGxvY2F0aW9uID09PSBEZWZUeXBlLlNFQVJDSDtcbiAgICAgICAgdmFyIGR5bmFtaWMgPSBwcmVkaWNhdGVzXzEuaXNEZWZpbmVkKGNvbmZpZy5keW5hbWljKSA/ICEhY29uZmlnLmR5bmFtaWMgOiAhIXR5cGUuZHluYW1pYztcbiAgICAgICAgdmFyIHJhdyA9IHByZWRpY2F0ZXNfMS5pc0RlZmluZWQoY29uZmlnLnJhdykgPyAhIWNvbmZpZy5yYXcgOiAhIXR5cGUucmF3O1xuICAgICAgICB2YXIgc3F1YXNoID0gZ2V0U3F1YXNoUG9saWN5KGNvbmZpZywgaXNPcHRpb25hbCwgdXJsTWF0Y2hlckZhY3RvcnkuZGVmYXVsdFNxdWFzaFBvbGljeSgpKTtcbiAgICAgICAgdmFyIHJlcGxhY2UgPSBnZXRSZXBsYWNlKGNvbmZpZywgYXJyYXlNb2RlLCBpc09wdGlvbmFsLCBzcXVhc2gpO1xuICAgICAgICB2YXIgaW5oZXJpdCA9IHByZWRpY2F0ZXNfMS5pc0RlZmluZWQoY29uZmlnLmluaGVyaXQpID8gISFjb25maWcuaW5oZXJpdCA6ICEhdHlwZS5pbmhlcml0O1xuICAgICAgICAvLyBhcnJheSBjb25maWc6IHBhcmFtIG5hbWUgKHBhcmFtW10pIG92ZXJyaWRlcyBkZWZhdWx0IHNldHRpbmdzLiAgZXhwbGljaXQgY29uZmlnIG92ZXJyaWRlcyBwYXJhbSBuYW1lLlxuICAgICAgICBmdW5jdGlvbiBnZXRBcnJheU1vZGUoKSB7XG4gICAgICAgICAgICB2YXIgYXJyYXlEZWZhdWx0cyA9IHsgYXJyYXk6IChsb2NhdGlvbiA9PT0gRGVmVHlwZS5TRUFSQ0ggPyAnYXV0bycgOiBmYWxzZSkgfTtcbiAgICAgICAgICAgIHZhciBhcnJheVBhcmFtTm9tZW5jbGF0dXJlID0gaWQubWF0Y2goL1xcW1xcXSQvKSA/IHsgYXJyYXk6IHRydWUgfSA6IHt9O1xuICAgICAgICAgICAgcmV0dXJuIGNvbW1vbl8xLmV4dGVuZChhcnJheURlZmF1bHRzLCBhcnJheVBhcmFtTm9tZW5jbGF0dXJlLCBjb25maWcpLmFycmF5O1xuICAgICAgICB9XG4gICAgICAgIGNvbW1vbl8xLmV4dGVuZCh0aGlzLCB7IGlkOiBpZCwgdHlwZTogdHlwZSwgbG9jYXRpb246IGxvY2F0aW9uLCBpc09wdGlvbmFsOiBpc09wdGlvbmFsLCBkeW5hbWljOiBkeW5hbWljLCByYXc6IHJhdywgc3F1YXNoOiBzcXVhc2gsIHJlcGxhY2U6IHJlcGxhY2UsIGluaGVyaXQ6IGluaGVyaXQsIGFycmF5OiBhcnJheU1vZGUsIGNvbmZpZzogY29uZmlnIH0pO1xuICAgIH1cbiAgICBQYXJhbS52YWx1ZXMgPSBmdW5jdGlvbiAocGFyYW1zLCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHZhbHVlcyA9PT0gdm9pZCAwKSB7IHZhbHVlcyA9IHt9OyB9XG4gICAgICAgIHZhciBwYXJhbVZhbHVlcyA9IHt9O1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIHBhcmFtc18xID0gcGFyYW1zOyBfaSA8IHBhcmFtc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIHBhcmFtID0gcGFyYW1zXzFbX2ldO1xuICAgICAgICAgICAgcGFyYW1WYWx1ZXNbcGFyYW0uaWRdID0gcGFyYW0udmFsdWUodmFsdWVzW3BhcmFtLmlkXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmFtVmFsdWVzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRmluZHMgW1tQYXJhbV1dIG9iamVjdHMgd2hpY2ggaGF2ZSBkaWZmZXJlbnQgcGFyYW0gdmFsdWVzXG4gICAgICpcbiAgICAgKiBGaWx0ZXJzIGEgbGlzdCBvZiBbW1BhcmFtXV0gb2JqZWN0cyB0byBvbmx5IHRob3NlIHdob3NlIHBhcmFtZXRlciB2YWx1ZXMgZGlmZmVyIGluIHR3byBwYXJhbSB2YWx1ZSBvYmplY3RzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zOiBUaGUgbGlzdCBvZiBQYXJhbSBvYmplY3RzIHRvIGZpbHRlclxuICAgICAqIEBwYXJhbSB2YWx1ZXMxOiBUaGUgZmlyc3Qgc2V0IG9mIHBhcmFtZXRlciB2YWx1ZXNcbiAgICAgKiBAcGFyYW0gdmFsdWVzMjogdGhlIHNlY29uZCBzZXQgb2YgcGFyYW1ldGVyIHZhbHVlc1xuICAgICAqXG4gICAgICogQHJldHVybnMgYW55IFBhcmFtIG9iamVjdHMgd2hvc2UgdmFsdWVzIHdlcmUgZGlmZmVyZW50IGJldHdlZW4gdmFsdWVzMSBhbmQgdmFsdWVzMlxuICAgICAqL1xuICAgIFBhcmFtLmNoYW5nZWQgPSBmdW5jdGlvbiAocGFyYW1zLCB2YWx1ZXMxLCB2YWx1ZXMyKSB7XG4gICAgICAgIGlmICh2YWx1ZXMxID09PSB2b2lkIDApIHsgdmFsdWVzMSA9IHt9OyB9XG4gICAgICAgIGlmICh2YWx1ZXMyID09PSB2b2lkIDApIHsgdmFsdWVzMiA9IHt9OyB9XG4gICAgICAgIHJldHVybiBwYXJhbXMuZmlsdGVyKGZ1bmN0aW9uIChwYXJhbSkgeyByZXR1cm4gIXBhcmFtLnR5cGUuZXF1YWxzKHZhbHVlczFbcGFyYW0uaWRdLCB2YWx1ZXMyW3BhcmFtLmlkXSk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHR3byBwYXJhbSB2YWx1ZSBvYmplY3RzIGFyZSBlcXVhbCAoZm9yIGEgc2V0IG9mIFtbUGFyYW1dXSBvYmplY3RzKVxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyBUaGUgbGlzdCBvZiBbW1BhcmFtXV0gb2JqZWN0cyB0byBjaGVja1xuICAgICAqIEBwYXJhbSB2YWx1ZXMxIFRoZSBmaXJzdCBzZXQgb2YgcGFyYW0gdmFsdWVzXG4gICAgICogQHBhcmFtIHZhbHVlczIgVGhlIHNlY29uZCBzZXQgb2YgcGFyYW0gdmFsdWVzXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBwYXJhbSB2YWx1ZXMgaW4gdmFsdWVzMSBhbmQgdmFsdWVzMiBhcmUgZXF1YWxcbiAgICAgKi9cbiAgICBQYXJhbS5lcXVhbHMgPSBmdW5jdGlvbiAocGFyYW1zLCB2YWx1ZXMxLCB2YWx1ZXMyKSB7XG4gICAgICAgIGlmICh2YWx1ZXMxID09PSB2b2lkIDApIHsgdmFsdWVzMSA9IHt9OyB9XG4gICAgICAgIGlmICh2YWx1ZXMyID09PSB2b2lkIDApIHsgdmFsdWVzMiA9IHt9OyB9XG4gICAgICAgIHJldHVybiBQYXJhbS5jaGFuZ2VkKHBhcmFtcywgdmFsdWVzMSwgdmFsdWVzMikubGVuZ3RoID09PSAwO1xuICAgIH07XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiBhIHRoZSBwYXJhbWV0ZXIgdmFsdWVzIGFyZSB2YWxpZCwgYWNjb3JkaW5nIHRvIHRoZSBQYXJhbSBkZWZpbml0aW9ucyAqL1xuICAgIFBhcmFtLnZhbGlkYXRlcyA9IGZ1bmN0aW9uIChwYXJhbXMsIHZhbHVlcykge1xuICAgICAgICBpZiAodmFsdWVzID09PSB2b2lkIDApIHsgdmFsdWVzID0ge307IH1cbiAgICAgICAgcmV0dXJuIHBhcmFtcy5tYXAoZnVuY3Rpb24gKHBhcmFtKSB7IHJldHVybiBwYXJhbS52YWxpZGF0ZXModmFsdWVzW3BhcmFtLmlkXSk7IH0pLnJlZHVjZShjb21tb25fMS5hbGxUcnVlUiwgdHJ1ZSk7XG4gICAgfTtcbiAgICBQYXJhbS5wcm90b3R5cGUuaXNEZWZhdWx0VmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNPcHRpb25hbCAmJiB0aGlzLnR5cGUuZXF1YWxzKHRoaXMudmFsdWUoKSwgdmFsdWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogW0ludGVybmFsXSBHZXRzIHRoZSBkZWNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIGEgdmFsdWUgaWYgdGhlIHZhbHVlIGlzIGRlZmluZWQsIG90aGVyd2lzZSwgcmV0dXJucyB0aGVcbiAgICAgKiBkZWZhdWx0IHZhbHVlLCB3aGljaCBtYXkgYmUgdGhlIHJlc3VsdCBvZiBhbiBpbmplY3RhYmxlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIFBhcmFtLnByb3RvdHlwZS52YWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvKipcbiAgICAgICAgICogW0ludGVybmFsXSBHZXQgdGhlIGRlZmF1bHQgdmFsdWUgb2YgYSBwYXJhbWV0ZXIsIHdoaWNoIG1heSBiZSBhbiBpbmplY3RhYmxlIGZ1bmN0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIGdldERlZmF1bHRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5fZGVmYXVsdFZhbHVlQ2FjaGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9kZWZhdWx0VmFsdWVDYWNoZS5kZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICBpZiAoIWNvcmVzZXJ2aWNlc18xLnNlcnZpY2VzLiRpbmplY3RvcilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luamVjdGFibGUgZnVuY3Rpb25zIGNhbm5vdCBiZSBjYWxsZWQgYXQgY29uZmlndXJhdGlvbiB0aW1lJyk7XG4gICAgICAgICAgICB2YXIgZGVmYXVsdFZhbHVlID0gY29yZXNlcnZpY2VzXzEuc2VydmljZXMuJGluamVjdG9yLmludm9rZShfdGhpcy5jb25maWcuJCRmbik7XG4gICAgICAgICAgICBpZiAoZGVmYXVsdFZhbHVlICE9PSBudWxsICYmIGRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICFfdGhpcy50eXBlLmlzKGRlZmF1bHRWYWx1ZSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGVmYXVsdCB2YWx1ZSAoXCIgKyBkZWZhdWx0VmFsdWUgKyBcIikgZm9yIHBhcmFtZXRlciAnXCIgKyBfdGhpcy5pZCArIFwiJyBpcyBub3QgYW4gaW5zdGFuY2Ugb2YgUGFyYW1UeXBlIChcIiArIF90aGlzLnR5cGUubmFtZSArIFwiKVwiKTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5jb25maWcuJCRmblsnX19jYWNoZWFibGUnXSkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9kZWZhdWx0VmFsdWVDYWNoZSA9IHsgZGVmYXVsdFZhbHVlOiBkZWZhdWx0VmFsdWUgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgICAgIH07XG4gICAgICAgIHZhciByZXBsYWNlU3BlY2lhbFZhbHVlcyA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBfdGhpcy5yZXBsYWNlOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciB0dXBsZSA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICBpZiAodHVwbGUuZnJvbSA9PT0gdmFsKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHVwbGUudG87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9O1xuICAgICAgICB2YWx1ZSA9IHJlcGxhY2VTcGVjaWFsVmFsdWVzKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHByZWRpY2F0ZXNfMS5pc1VuZGVmaW5lZCh2YWx1ZSkgPyBnZXREZWZhdWx0VmFsdWUoKSA6IHRoaXMudHlwZS4kbm9ybWFsaXplKHZhbHVlKTtcbiAgICB9O1xuICAgIFBhcmFtLnByb3RvdHlwZS5pc1NlYXJjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYXRpb24gPT09IERlZlR5cGUuU0VBUkNIO1xuICAgIH07XG4gICAgUGFyYW0ucHJvdG90eXBlLnZhbGlkYXRlcyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAvLyBUaGVyZSB3YXMgbm8gcGFyYW1ldGVyIHZhbHVlLCBidXQgdGhlIHBhcmFtIGlzIG9wdGlvbmFsXG4gICAgICAgIGlmICgocHJlZGljYXRlc18xLmlzVW5kZWZpbmVkKHZhbHVlKSB8fCB2YWx1ZSA9PT0gbnVsbCkgJiYgdGhpcy5pc09wdGlvbmFsKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIC8vIFRoZSB2YWx1ZSB3YXMgbm90IG9mIHRoZSBjb3JyZWN0IFBhcmFtVHlwZSwgYW5kIGNvdWxkIG5vdCBiZSBkZWNvZGVkIHRvIHRoZSBjb3JyZWN0IFBhcmFtVHlwZVxuICAgICAgICB2YXIgbm9ybWFsaXplZCA9IHRoaXMudHlwZS4kbm9ybWFsaXplKHZhbHVlKTtcbiAgICAgICAgaWYgKCF0aGlzLnR5cGUuaXMobm9ybWFsaXplZCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIFRoZSB2YWx1ZSB3YXMgb2YgdGhlIGNvcnJlY3QgdHlwZSwgYnV0IHdoZW4gZW5jb2RlZCwgZGlkIG5vdCBtYXRjaCB0aGUgUGFyYW1UeXBlJ3MgcmVnZXhwXG4gICAgICAgIHZhciBlbmNvZGVkID0gdGhpcy50eXBlLmVuY29kZShub3JtYWxpemVkKTtcbiAgICAgICAgcmV0dXJuICEocHJlZGljYXRlc18xLmlzU3RyaW5nKGVuY29kZWQpICYmICF0aGlzLnR5cGUucGF0dGVybi5leGVjKGVuY29kZWQpKTtcbiAgICB9O1xuICAgIFBhcmFtLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFwie1BhcmFtOlwiICsgdGhpcy5pZCArIFwiIFwiICsgdGhpcy50eXBlICsgXCIgc3F1YXNoOiAnXCIgKyB0aGlzLnNxdWFzaCArIFwiJyBvcHRpb25hbDogXCIgKyB0aGlzLmlzT3B0aW9uYWwgKyBcIn1cIjtcbiAgICB9O1xuICAgIHJldHVybiBQYXJhbTtcbn0oKSk7XG5leHBvcnRzLlBhcmFtID0gUGFyYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJhbS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvcGFyYW1zL3BhcmFtLmpzXG4vLyBtb2R1bGUgaWQgPSAxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///18\n")},function(module,exports,__webpack_require__){"use strict";eval('\n\nexports.__esModule = true;\n\nexports.default = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError("Cannot call a class as a function");\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrLmpzPzY2YjkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjay5qc1xuLy8gbW9kdWxlIGlkID0gMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///19\n')},function(module,exports,__webpack_require__){eval("var dP = __webpack_require__(12);\nvar createDesc = __webpack_require__(35);\nmodule.exports = __webpack_require__(13) ? function (object, key, value) {\n  return dP.f(object, key, createDesc(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2hpZGUuanM/ODQ5YyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICByZXR1cm4gZFAuZihvYmplY3QsIGtleSwgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faGlkZS5qc1xuLy8gbW9kdWxlIGlkID0gMjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///20\n")},function(module,exports,__webpack_require__){eval("var isObject = __webpack_require__(22);\nmodule.exports = function (it) {\n  if (!isObject(it)) throw TypeError(it + ' is not an object!');\n  return it;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FuLW9iamVjdC5qcz9lZmIzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGFuIG9iamVjdCEnKTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hbi1vYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDIxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///21\n")},function(module,exports){eval("module.exports = function (it) {\n  return typeof it === 'object' ? it !== null : typeof it === 'function';\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLW9iamVjdC5qcz8xMmE4Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiB0eXBlb2YgaXQgPT09ICdmdW5jdGlvbic7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLW9iamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///22\n")},function(module,exports){eval("module.exports = function (exec) {\n  try {\n    return !!exec();\n  } catch (e) {\n    return true;\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2ZhaWxzLmpzPzRiY2QiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiAhIWV4ZWMoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2ZhaWxzLmpzXG4vLyBtb2R1bGUgaWQgPSAyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///23\n")},function(module,exports,__webpack_require__){"use strict";eval('/**\n * @coreapi\n * @module transition\n */ /** for typedoc */\n\nObject.defineProperty(exports, "__esModule", { value: true });\nvar common_1 = __webpack_require__(0);\nvar strings_1 = __webpack_require__(6);\nvar hof_1 = __webpack_require__(2);\nvar RejectType;\n(function (RejectType) {\n    RejectType[RejectType["SUPERSEDED"] = 2] = "SUPERSEDED";\n    RejectType[RejectType["ABORTED"] = 3] = "ABORTED";\n    RejectType[RejectType["INVALID"] = 4] = "INVALID";\n    RejectType[RejectType["IGNORED"] = 5] = "IGNORED";\n    RejectType[RejectType["ERROR"] = 6] = "ERROR";\n})(RejectType = exports.RejectType || (exports.RejectType = {}));\n/** @hidden */\nvar id = 0;\nvar Rejection = /** @class */ (function () {\n    function Rejection(type, message, detail) {\n        this.$id = id++;\n        this.type = type;\n        this.message = message;\n        this.detail = detail;\n    }\n    /** Returns true if the obj is a rejected promise created from the `asPromise` factory */\n    Rejection.isRejectionPromise = function (obj) {\n        return obj && (typeof obj.then === \'function\') && hof_1.is(Rejection)(obj._transitionRejection);\n    };\n    /** Returns a Rejection due to transition superseded */\n    Rejection.superseded = function (detail, options) {\n        var message = \'The transition has been superseded by a different transition\';\n        var rejection = new Rejection(RejectType.SUPERSEDED, message, detail);\n        if (options && options.redirected) {\n            rejection.redirected = true;\n        }\n        return rejection;\n    };\n    /** Returns a Rejection due to redirected transition */\n    Rejection.redirected = function (detail) {\n        return Rejection.superseded(detail, { redirected: true });\n    };\n    /** Returns a Rejection due to invalid transition */\n    Rejection.invalid = function (detail) {\n        var message = \'This transition is invalid\';\n        return new Rejection(RejectType.INVALID, message, detail);\n    };\n    /** Returns a Rejection due to ignored transition */\n    Rejection.ignored = function (detail) {\n        var message = \'The transition was ignored\';\n        return new Rejection(RejectType.IGNORED, message, detail);\n    };\n    /** Returns a Rejection due to aborted transition */\n    Rejection.aborted = function (detail) {\n        var message = \'The transition has been aborted\';\n        return new Rejection(RejectType.ABORTED, message, detail);\n    };\n    /** Returns a Rejection due to aborted transition */\n    Rejection.errored = function (detail) {\n        var message = \'The transition errored\';\n        return new Rejection(RejectType.ERROR, message, detail);\n    };\n    /**\n     * Returns a Rejection\n     *\n     * Normalizes a value as a Rejection.\n     * If the value is already a Rejection, returns it.\n     * Otherwise, wraps and returns the value as a Rejection (Rejection type: ERROR).\n     *\n     * @returns `detail` if it is already a `Rejection`, else returns an ERROR Rejection.\n     */\n    Rejection.normalize = function (detail) {\n        return hof_1.is(Rejection)(detail) ? detail : Rejection.errored(detail);\n    };\n    Rejection.prototype.toString = function () {\n        var detailString = function (d) {\n            return d && d.toString !== Object.prototype.toString ? d.toString() : strings_1.stringify(d);\n        };\n        var detail = detailString(this.detail);\n        var _a = this, $id = _a.$id, type = _a.type, message = _a.message;\n        return "Transition Rejection($id: " + $id + " type: " + type + ", message: " + message + ", detail: " + detail + ")";\n    };\n    Rejection.prototype.toPromise = function () {\n        return common_1.extend(common_1.silentRejection(this), { _transitionRejection: this });\n    };\n    return Rejection;\n}());\nexports.Rejection = Rejection;\n//# sourceMappingURL=rejectFactory.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3RyYW5zaXRpb24vcmVqZWN0RmFjdG9yeS5qcz85YWI0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGNvcmVhcGlcbiAqIEBtb2R1bGUgdHJhbnNpdGlvblxuICovIC8qKiBmb3IgdHlwZWRvYyAqL1xuJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb21tb25cIik7XG52YXIgc3RyaW5nc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9zdHJpbmdzXCIpO1xudmFyIGhvZl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9ob2ZcIik7XG52YXIgUmVqZWN0VHlwZTtcbihmdW5jdGlvbiAoUmVqZWN0VHlwZSkge1xuICAgIFJlamVjdFR5cGVbUmVqZWN0VHlwZVtcIlNVUEVSU0VERURcIl0gPSAyXSA9IFwiU1VQRVJTRURFRFwiO1xuICAgIFJlamVjdFR5cGVbUmVqZWN0VHlwZVtcIkFCT1JURURcIl0gPSAzXSA9IFwiQUJPUlRFRFwiO1xuICAgIFJlamVjdFR5cGVbUmVqZWN0VHlwZVtcIklOVkFMSURcIl0gPSA0XSA9IFwiSU5WQUxJRFwiO1xuICAgIFJlamVjdFR5cGVbUmVqZWN0VHlwZVtcIklHTk9SRURcIl0gPSA1XSA9IFwiSUdOT1JFRFwiO1xuICAgIFJlamVjdFR5cGVbUmVqZWN0VHlwZVtcIkVSUk9SXCJdID0gNl0gPSBcIkVSUk9SXCI7XG59KShSZWplY3RUeXBlID0gZXhwb3J0cy5SZWplY3RUeXBlIHx8IChleHBvcnRzLlJlamVjdFR5cGUgPSB7fSkpO1xuLyoqIEBoaWRkZW4gKi9cbnZhciBpZCA9IDA7XG52YXIgUmVqZWN0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlamVjdGlvbih0eXBlLCBtZXNzYWdlLCBkZXRhaWwpIHtcbiAgICAgICAgdGhpcy4kaWQgPSBpZCsrO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICB0aGlzLmRldGFpbCA9IGRldGFpbDtcbiAgICB9XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgb2JqIGlzIGEgcmVqZWN0ZWQgcHJvbWlzZSBjcmVhdGVkIGZyb20gdGhlIGBhc1Byb21pc2VgIGZhY3RvcnkgKi9cbiAgICBSZWplY3Rpb24uaXNSZWplY3Rpb25Qcm9taXNlID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqICYmICh0eXBlb2Ygb2JqLnRoZW4gPT09ICdmdW5jdGlvbicpICYmIGhvZl8xLmlzKFJlamVjdGlvbikob2JqLl90cmFuc2l0aW9uUmVqZWN0aW9uKTtcbiAgICB9O1xuICAgIC8qKiBSZXR1cm5zIGEgUmVqZWN0aW9uIGR1ZSB0byB0cmFuc2l0aW9uIHN1cGVyc2VkZWQgKi9cbiAgICBSZWplY3Rpb24uc3VwZXJzZWRlZCA9IGZ1bmN0aW9uIChkZXRhaWwsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSAnVGhlIHRyYW5zaXRpb24gaGFzIGJlZW4gc3VwZXJzZWRlZCBieSBhIGRpZmZlcmVudCB0cmFuc2l0aW9uJztcbiAgICAgICAgdmFyIHJlamVjdGlvbiA9IG5ldyBSZWplY3Rpb24oUmVqZWN0VHlwZS5TVVBFUlNFREVELCBtZXNzYWdlLCBkZXRhaWwpO1xuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlZGlyZWN0ZWQpIHtcbiAgICAgICAgICAgIHJlamVjdGlvbi5yZWRpcmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVqZWN0aW9uO1xuICAgIH07XG4gICAgLyoqIFJldHVybnMgYSBSZWplY3Rpb24gZHVlIHRvIHJlZGlyZWN0ZWQgdHJhbnNpdGlvbiAqL1xuICAgIFJlamVjdGlvbi5yZWRpcmVjdGVkID0gZnVuY3Rpb24gKGRldGFpbCkge1xuICAgICAgICByZXR1cm4gUmVqZWN0aW9uLnN1cGVyc2VkZWQoZGV0YWlsLCB7IHJlZGlyZWN0ZWQ6IHRydWUgfSk7XG4gICAgfTtcbiAgICAvKiogUmV0dXJucyBhIFJlamVjdGlvbiBkdWUgdG8gaW52YWxpZCB0cmFuc2l0aW9uICovXG4gICAgUmVqZWN0aW9uLmludmFsaWQgPSBmdW5jdGlvbiAoZGV0YWlsKSB7XG4gICAgICAgIHZhciBtZXNzYWdlID0gJ1RoaXMgdHJhbnNpdGlvbiBpcyBpbnZhbGlkJztcbiAgICAgICAgcmV0dXJuIG5ldyBSZWplY3Rpb24oUmVqZWN0VHlwZS5JTlZBTElELCBtZXNzYWdlLCBkZXRhaWwpO1xuICAgIH07XG4gICAgLyoqIFJldHVybnMgYSBSZWplY3Rpb24gZHVlIHRvIGlnbm9yZWQgdHJhbnNpdGlvbiAqL1xuICAgIFJlamVjdGlvbi5pZ25vcmVkID0gZnVuY3Rpb24gKGRldGFpbCkge1xuICAgICAgICB2YXIgbWVzc2FnZSA9ICdUaGUgdHJhbnNpdGlvbiB3YXMgaWdub3JlZCc7XG4gICAgICAgIHJldHVybiBuZXcgUmVqZWN0aW9uKFJlamVjdFR5cGUuSUdOT1JFRCwgbWVzc2FnZSwgZGV0YWlsKTtcbiAgICB9O1xuICAgIC8qKiBSZXR1cm5zIGEgUmVqZWN0aW9uIGR1ZSB0byBhYm9ydGVkIHRyYW5zaXRpb24gKi9cbiAgICBSZWplY3Rpb24uYWJvcnRlZCA9IGZ1bmN0aW9uIChkZXRhaWwpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSAnVGhlIHRyYW5zaXRpb24gaGFzIGJlZW4gYWJvcnRlZCc7XG4gICAgICAgIHJldHVybiBuZXcgUmVqZWN0aW9uKFJlamVjdFR5cGUuQUJPUlRFRCwgbWVzc2FnZSwgZGV0YWlsKTtcbiAgICB9O1xuICAgIC8qKiBSZXR1cm5zIGEgUmVqZWN0aW9uIGR1ZSB0byBhYm9ydGVkIHRyYW5zaXRpb24gKi9cbiAgICBSZWplY3Rpb24uZXJyb3JlZCA9IGZ1bmN0aW9uIChkZXRhaWwpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSAnVGhlIHRyYW5zaXRpb24gZXJyb3JlZCc7XG4gICAgICAgIHJldHVybiBuZXcgUmVqZWN0aW9uKFJlamVjdFR5cGUuRVJST1IsIG1lc3NhZ2UsIGRldGFpbCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgUmVqZWN0aW9uXG4gICAgICpcbiAgICAgKiBOb3JtYWxpemVzIGEgdmFsdWUgYXMgYSBSZWplY3Rpb24uXG4gICAgICogSWYgdGhlIHZhbHVlIGlzIGFscmVhZHkgYSBSZWplY3Rpb24sIHJldHVybnMgaXQuXG4gICAgICogT3RoZXJ3aXNlLCB3cmFwcyBhbmQgcmV0dXJucyB0aGUgdmFsdWUgYXMgYSBSZWplY3Rpb24gKFJlamVjdGlvbiB0eXBlOiBFUlJPUikuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBgZGV0YWlsYCBpZiBpdCBpcyBhbHJlYWR5IGEgYFJlamVjdGlvbmAsIGVsc2UgcmV0dXJucyBhbiBFUlJPUiBSZWplY3Rpb24uXG4gICAgICovXG4gICAgUmVqZWN0aW9uLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIChkZXRhaWwpIHtcbiAgICAgICAgcmV0dXJuIGhvZl8xLmlzKFJlamVjdGlvbikoZGV0YWlsKSA/IGRldGFpbCA6IFJlamVjdGlvbi5lcnJvcmVkKGRldGFpbCk7XG4gICAgfTtcbiAgICBSZWplY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGV0YWlsU3RyaW5nID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHJldHVybiBkICYmIGQudG9TdHJpbmcgIT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcgPyBkLnRvU3RyaW5nKCkgOiBzdHJpbmdzXzEuc3RyaW5naWZ5KGQpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgZGV0YWlsID0gZGV0YWlsU3RyaW5nKHRoaXMuZGV0YWlsKTtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgJGlkID0gX2EuJGlkLCB0eXBlID0gX2EudHlwZSwgbWVzc2FnZSA9IF9hLm1lc3NhZ2U7XG4gICAgICAgIHJldHVybiBcIlRyYW5zaXRpb24gUmVqZWN0aW9uKCRpZDogXCIgKyAkaWQgKyBcIiB0eXBlOiBcIiArIHR5cGUgKyBcIiwgbWVzc2FnZTogXCIgKyBtZXNzYWdlICsgXCIsIGRldGFpbDogXCIgKyBkZXRhaWwgKyBcIilcIjtcbiAgICB9O1xuICAgIFJlamVjdGlvbi5wcm90b3R5cGUudG9Qcm9taXNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY29tbW9uXzEuZXh0ZW5kKGNvbW1vbl8xLnNpbGVudFJlamVjdGlvbih0aGlzKSwgeyBfdHJhbnNpdGlvblJlamVjdGlvbjogdGhpcyB9KTtcbiAgICB9O1xuICAgIHJldHVybiBSZWplY3Rpb247XG59KCkpO1xuZXhwb3J0cy5SZWplY3Rpb24gPSBSZWplY3Rpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWplY3RGYWN0b3J5LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi90cmFuc2l0aW9uL3JlamVjdEZhY3RvcnkuanNcbi8vIG1vZHVsZSBpZCA9IDI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///24\n')},function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @coreapi\n * @module transition\n */\n/** for typedoc */\nvar interface_1 = __webpack_require__(16);\nvar common_1 = __webpack_require__(0);\nvar strings_1 = __webpack_require__(6);\nvar predicates_1 = __webpack_require__(1);\nvar hof_1 = __webpack_require__(2);\nvar trace_1 = __webpack_require__(8);\nvar coreservices_1 = __webpack_require__(3);\nvar rejectFactory_1 = __webpack_require__(24);\nvar targetState_1 = __webpack_require__(17);\nvar defaultOptions = {\n    current: common_1.noop,\n    transition: null,\n    traceData: {},\n    bind: null,\n};\n/** @hidden */\nvar TransitionHook = /** @class */ (function () {\n    function TransitionHook(transition, stateContext, registeredHook, options) {\n        var _this = this;\n        this.transition = transition;\n        this.stateContext = stateContext;\n        this.registeredHook = registeredHook;\n        this.options = options;\n        this.isSuperseded = function () {\n            return _this.type.hookPhase === interface_1.TransitionHookPhase.RUN && !_this.options.transition.isActive();\n        };\n        this.options = common_1.defaults(options, defaultOptions);\n        this.type = registeredHook.eventType;\n    }\n    /**\n     * Chains together an array of TransitionHooks.\n     *\n     * Given a list of [[TransitionHook]] objects, chains them together.\n     * Each hook is invoked after the previous one completes.\n     *\n     * #### Example:\n     * ```js\n     * var hooks: TransitionHook[] = getHooks();\n     * let promise: Promise<any> = TransitionHook.chain(hooks);\n     *\n     * promise.then(handleSuccess, handleError);\n     * ```\n     *\n     * @param hooks the list of hooks to chain together\n     * @param waitFor if provided, the chain is `.then()`'ed off this promise\n     * @returns a `Promise` for sequentially invoking the hooks (in order)\n     */\n    TransitionHook.chain = function (hooks, waitFor) {\n        // Chain the next hook off the previous\n        var createHookChainR = function (prev, nextHook) {\n            return prev.then(function () { return nextHook.invokeHook(); });\n        };\n        return hooks.reduce(createHookChainR, waitFor || coreservices_1.services.$q.when());\n    };\n    /**\n     * Invokes all the provided TransitionHooks, in order.\n     * Each hook's return value is checked.\n     * If any hook returns a promise, then the rest of the hooks are chained off that promise, and the promise is returned.\n     * If no hook returns a promise, then all hooks are processed synchronously.\n     *\n     * @param hooks the list of TransitionHooks to invoke\n     * @param doneCallback a callback that is invoked after all the hooks have successfully completed\n     *\n     * @returns a promise for the async result, or the result of the callback\n     */\n    TransitionHook.invokeHooks = function (hooks, doneCallback) {\n        for (var idx = 0; idx < hooks.length; idx++) {\n            var hookResult = hooks[idx].invokeHook();\n            if (predicates_1.isPromise(hookResult)) {\n                var remainingHooks = hooks.slice(idx + 1);\n                return TransitionHook.chain(remainingHooks, hookResult)\n                    .then(doneCallback);\n            }\n        }\n        return doneCallback();\n    };\n    /**\n     * Run all TransitionHooks, ignoring their return value.\n     */\n    TransitionHook.runAllHooks = function (hooks) {\n        hooks.forEach(function (hook) { return hook.invokeHook(); });\n    };\n    TransitionHook.prototype.logError = function (err) {\n        this.transition.router.stateService.defaultErrorHandler()(err);\n    };\n    TransitionHook.prototype.invokeHook = function () {\n        var _this = this;\n        var hook = this.registeredHook;\n        if (hook._deregistered)\n            return;\n        var notCurrent = this.getNotCurrentRejection();\n        if (notCurrent)\n            return notCurrent;\n        var options = this.options;\n        trace_1.trace.traceHookInvocation(this, this.transition, options);\n        var invokeCallback = function () {\n            return hook.callback.call(options.bind, _this.transition, _this.stateContext);\n        };\n        var normalizeErr = function (err) {\n            return rejectFactory_1.Rejection.normalize(err).toPromise();\n        };\n        var handleError = function (err) {\n            return hook.eventType.getErrorHandler(_this)(err);\n        };\n        var handleResult = function (result) {\n            return hook.eventType.getResultHandler(_this)(result);\n        };\n        try {\n            var result = invokeCallback();\n            if (!this.type.synchronous && predicates_1.isPromise(result)) {\n                return result.catch(normalizeErr)\n                    .then(handleResult, handleError);\n            }\n            else {\n                return handleResult(result);\n            }\n        }\n        catch (err) {\n            // If callback throws (synchronously)\n            return handleError(rejectFactory_1.Rejection.normalize(err));\n        }\n        finally {\n            if (hook.invokeLimit && ++hook.invokeCount >= hook.invokeLimit) {\n                hook.deregister();\n            }\n        }\n    };\n    /**\n     * This method handles the return value of a Transition Hook.\n     *\n     * A hook can return false (cancel), a TargetState (redirect),\n     * or a promise (which may later resolve to false or a redirect)\n     *\n     * This also handles \"transition superseded\" -- when a new transition\n     * was started while the hook was still running\n     */\n    TransitionHook.prototype.handleHookResult = function (result) {\n        var _this = this;\n        var notCurrent = this.getNotCurrentRejection();\n        if (notCurrent)\n            return notCurrent;\n        // Hook returned a promise\n        if (predicates_1.isPromise(result)) {\n            // Wait for the promise, then reprocess with the resulting value\n            return result.then(function (val) { return _this.handleHookResult(val); });\n        }\n        trace_1.trace.traceHookResult(result, this.transition, this.options);\n        // Hook returned false\n        if (result === false) {\n            // Abort this Transition\n            return rejectFactory_1.Rejection.aborted('Hook aborted transition').toPromise();\n        }\n        var isTargetState = hof_1.is(targetState_1.TargetState);\n        // hook returned a TargetState\n        if (isTargetState(result)) {\n            // Halt the current Transition and redirect (a new Transition) to the TargetState.\n            return rejectFactory_1.Rejection.redirected(result).toPromise();\n        }\n    };\n    /**\n     * Return a Rejection promise if the transition is no longer current due\n     * to a stopped router (disposed), or a new transition has started and superseded this one.\n     */\n    TransitionHook.prototype.getNotCurrentRejection = function () {\n        var router = this.transition.router;\n        // The router is stopped\n        if (router._disposed) {\n            return rejectFactory_1.Rejection.aborted(\"UIRouter instance #\" + router.$id + \" has been stopped (disposed)\").toPromise();\n        }\n        if (this.transition._aborted) {\n            return rejectFactory_1.Rejection.aborted().toPromise();\n        }\n        // This transition is no longer current.\n        // Another transition started while this hook was still running.\n        if (this.isSuperseded()) {\n            // Abort this transition\n            return rejectFactory_1.Rejection.superseded(this.options.current()).toPromise();\n        }\n    };\n    TransitionHook.prototype.toString = function () {\n        var _a = this, options = _a.options, registeredHook = _a.registeredHook;\n        var event = hof_1.parse('traceData.hookType')(options) || 'internal', context = hof_1.parse('traceData.context.state.name')(options) || hof_1.parse('traceData.context')(options) || 'unknown', name = strings_1.fnToString(registeredHook.callback);\n        return event + \" context: \" + context + \", \" + strings_1.maxLength(200, name);\n    };\n    /**\n     * These GetResultHandler(s) are used by [[invokeHook]] below\n     * Each HookType chooses a GetResultHandler (See: [[TransitionService._defineCoreEvents]])\n     */\n    TransitionHook.HANDLE_RESULT = function (hook) { return function (result) {\n        return hook.handleHookResult(result);\n    }; };\n    /**\n     * If the result is a promise rejection, log it.\n     * Otherwise, ignore the result.\n     */\n    TransitionHook.LOG_REJECTED_RESULT = function (hook) { return function (result) {\n        predicates_1.isPromise(result) && result.catch(function (err) {\n            return hook.logError(rejectFactory_1.Rejection.normalize(err));\n        });\n        return undefined;\n    }; };\n    /**\n     * These GetErrorHandler(s) are used by [[invokeHook]] below\n     * Each HookType chooses a GetErrorHandler (See: [[TransitionService._defineCoreEvents]])\n     */\n    TransitionHook.LOG_ERROR = function (hook) { return function (error) {\n        return hook.logError(error);\n    }; };\n    TransitionHook.REJECT_ERROR = function (hook) { return function (error) {\n        return common_1.silentRejection(error);\n    }; };\n    TransitionHook.THROW_ERROR = function (hook) { return function (error) {\n        throw error;\n    }; };\n    return TransitionHook;\n}());\nexports.TransitionHook = TransitionHook;\n//# sourceMappingURL=transitionHook.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3RyYW5zaXRpb24vdHJhbnNpdGlvbkhvb2suanM/NjczNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGNvcmVhcGlcbiAqIEBtb2R1bGUgdHJhbnNpdGlvblxuICovXG4vKiogZm9yIHR5cGVkb2MgKi9cbnZhciBpbnRlcmZhY2VfMSA9IHJlcXVpcmUoXCIuL2ludGVyZmFjZVwiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29tbW9uXCIpO1xudmFyIHN0cmluZ3NfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vc3RyaW5nc1wiKTtcbnZhciBwcmVkaWNhdGVzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3ByZWRpY2F0ZXNcIik7XG52YXIgaG9mXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2hvZlwiKTtcbnZhciB0cmFjZV8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi90cmFjZVwiKTtcbnZhciBjb3Jlc2VydmljZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29yZXNlcnZpY2VzXCIpO1xudmFyIHJlamVjdEZhY3RvcnlfMSA9IHJlcXVpcmUoXCIuL3JlamVjdEZhY3RvcnlcIik7XG52YXIgdGFyZ2V0U3RhdGVfMSA9IHJlcXVpcmUoXCIuLi9zdGF0ZS90YXJnZXRTdGF0ZVwiKTtcbnZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBjdXJyZW50OiBjb21tb25fMS5ub29wLFxuICAgIHRyYW5zaXRpb246IG51bGwsXG4gICAgdHJhY2VEYXRhOiB7fSxcbiAgICBiaW5kOiBudWxsLFxufTtcbi8qKiBAaGlkZGVuICovXG52YXIgVHJhbnNpdGlvbkhvb2sgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVHJhbnNpdGlvbkhvb2sodHJhbnNpdGlvbiwgc3RhdGVDb250ZXh0LCByZWdpc3RlcmVkSG9vaywgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uO1xuICAgICAgICB0aGlzLnN0YXRlQ29udGV4dCA9IHN0YXRlQ29udGV4dDtcbiAgICAgICAgdGhpcy5yZWdpc3RlcmVkSG9vayA9IHJlZ2lzdGVyZWRIb29rO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmlzU3VwZXJzZWRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy50eXBlLmhvb2tQaGFzZSA9PT0gaW50ZXJmYWNlXzEuVHJhbnNpdGlvbkhvb2tQaGFzZS5SVU4gJiYgIV90aGlzLm9wdGlvbnMudHJhbnNpdGlvbi5pc0FjdGl2ZSgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBjb21tb25fMS5kZWZhdWx0cyhvcHRpb25zLCBkZWZhdWx0T3B0aW9ucyk7XG4gICAgICAgIHRoaXMudHlwZSA9IHJlZ2lzdGVyZWRIb29rLmV2ZW50VHlwZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hhaW5zIHRvZ2V0aGVyIGFuIGFycmF5IG9mIFRyYW5zaXRpb25Ib29rcy5cbiAgICAgKlxuICAgICAqIEdpdmVuIGEgbGlzdCBvZiBbW1RyYW5zaXRpb25Ib29rXV0gb2JqZWN0cywgY2hhaW5zIHRoZW0gdG9nZXRoZXIuXG4gICAgICogRWFjaCBob29rIGlzIGludm9rZWQgYWZ0ZXIgdGhlIHByZXZpb3VzIG9uZSBjb21wbGV0ZXMuXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGU6XG4gICAgICogYGBganNcbiAgICAgKiB2YXIgaG9va3M6IFRyYW5zaXRpb25Ib29rW10gPSBnZXRIb29rcygpO1xuICAgICAqIGxldCBwcm9taXNlOiBQcm9taXNlPGFueT4gPSBUcmFuc2l0aW9uSG9vay5jaGFpbihob29rcyk7XG4gICAgICpcbiAgICAgKiBwcm9taXNlLnRoZW4oaGFuZGxlU3VjY2VzcywgaGFuZGxlRXJyb3IpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIGhvb2tzIHRoZSBsaXN0IG9mIGhvb2tzIHRvIGNoYWluIHRvZ2V0aGVyXG4gICAgICogQHBhcmFtIHdhaXRGb3IgaWYgcHJvdmlkZWQsIHRoZSBjaGFpbiBpcyBgLnRoZW4oKWAnZWQgb2ZmIHRoaXMgcHJvbWlzZVxuICAgICAqIEByZXR1cm5zIGEgYFByb21pc2VgIGZvciBzZXF1ZW50aWFsbHkgaW52b2tpbmcgdGhlIGhvb2tzIChpbiBvcmRlcilcbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uSG9vay5jaGFpbiA9IGZ1bmN0aW9uIChob29rcywgd2FpdEZvcikge1xuICAgICAgICAvLyBDaGFpbiB0aGUgbmV4dCBob29rIG9mZiB0aGUgcHJldmlvdXNcbiAgICAgICAgdmFyIGNyZWF0ZUhvb2tDaGFpblIgPSBmdW5jdGlvbiAocHJldiwgbmV4dEhvb2spIHtcbiAgICAgICAgICAgIHJldHVybiBwcmV2LnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV4dEhvb2suaW52b2tlSG9vaygpOyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGhvb2tzLnJlZHVjZShjcmVhdGVIb29rQ2hhaW5SLCB3YWl0Rm9yIHx8IGNvcmVzZXJ2aWNlc18xLnNlcnZpY2VzLiRxLndoZW4oKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbnZva2VzIGFsbCB0aGUgcHJvdmlkZWQgVHJhbnNpdGlvbkhvb2tzLCBpbiBvcmRlci5cbiAgICAgKiBFYWNoIGhvb2sncyByZXR1cm4gdmFsdWUgaXMgY2hlY2tlZC5cbiAgICAgKiBJZiBhbnkgaG9vayByZXR1cm5zIGEgcHJvbWlzZSwgdGhlbiB0aGUgcmVzdCBvZiB0aGUgaG9va3MgYXJlIGNoYWluZWQgb2ZmIHRoYXQgcHJvbWlzZSwgYW5kIHRoZSBwcm9taXNlIGlzIHJldHVybmVkLlxuICAgICAqIElmIG5vIGhvb2sgcmV0dXJucyBhIHByb21pc2UsIHRoZW4gYWxsIGhvb2tzIGFyZSBwcm9jZXNzZWQgc3luY2hyb25vdXNseS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBob29rcyB0aGUgbGlzdCBvZiBUcmFuc2l0aW9uSG9va3MgdG8gaW52b2tlXG4gICAgICogQHBhcmFtIGRvbmVDYWxsYmFjayBhIGNhbGxiYWNrIHRoYXQgaXMgaW52b2tlZCBhZnRlciBhbGwgdGhlIGhvb2tzIGhhdmUgc3VjY2Vzc2Z1bGx5IGNvbXBsZXRlZFxuICAgICAqXG4gICAgICogQHJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgYXN5bmMgcmVzdWx0LCBvciB0aGUgcmVzdWx0IG9mIHRoZSBjYWxsYmFja1xuICAgICAqL1xuICAgIFRyYW5zaXRpb25Ib29rLmludm9rZUhvb2tzID0gZnVuY3Rpb24gKGhvb2tzLCBkb25lQ2FsbGJhY2spIHtcbiAgICAgICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgaG9va3MubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgICAgdmFyIGhvb2tSZXN1bHQgPSBob29rc1tpZHhdLmludm9rZUhvb2soKTtcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGVzXzEuaXNQcm9taXNlKGhvb2tSZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlbWFpbmluZ0hvb2tzID0gaG9va3Muc2xpY2UoaWR4ICsgMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFRyYW5zaXRpb25Ib29rLmNoYWluKHJlbWFpbmluZ0hvb2tzLCBob29rUmVzdWx0KVxuICAgICAgICAgICAgICAgICAgICAudGhlbihkb25lQ2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkb25lQ2FsbGJhY2soKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJ1biBhbGwgVHJhbnNpdGlvbkhvb2tzLCBpZ25vcmluZyB0aGVpciByZXR1cm4gdmFsdWUuXG4gICAgICovXG4gICAgVHJhbnNpdGlvbkhvb2sucnVuQWxsSG9va3MgPSBmdW5jdGlvbiAoaG9va3MpIHtcbiAgICAgICAgaG9va3MuZm9yRWFjaChmdW5jdGlvbiAoaG9vaykgeyByZXR1cm4gaG9vay5pbnZva2VIb29rKCk7IH0pO1xuICAgIH07XG4gICAgVHJhbnNpdGlvbkhvb2sucHJvdG90eXBlLmxvZ0Vycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB0aGlzLnRyYW5zaXRpb24ucm91dGVyLnN0YXRlU2VydmljZS5kZWZhdWx0RXJyb3JIYW5kbGVyKCkoZXJyKTtcbiAgICB9O1xuICAgIFRyYW5zaXRpb25Ib29rLnByb3RvdHlwZS5pbnZva2VIb29rID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgaG9vayA9IHRoaXMucmVnaXN0ZXJlZEhvb2s7XG4gICAgICAgIGlmIChob29rLl9kZXJlZ2lzdGVyZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBub3RDdXJyZW50ID0gdGhpcy5nZXROb3RDdXJyZW50UmVqZWN0aW9uKCk7XG4gICAgICAgIGlmIChub3RDdXJyZW50KVxuICAgICAgICAgICAgcmV0dXJuIG5vdEN1cnJlbnQ7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICB0cmFjZV8xLnRyYWNlLnRyYWNlSG9va0ludm9jYXRpb24odGhpcywgdGhpcy50cmFuc2l0aW9uLCBvcHRpb25zKTtcbiAgICAgICAgdmFyIGludm9rZUNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGhvb2suY2FsbGJhY2suY2FsbChvcHRpb25zLmJpbmQsIF90aGlzLnRyYW5zaXRpb24sIF90aGlzLnN0YXRlQ29udGV4dCk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBub3JtYWxpemVFcnIgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0RmFjdG9yeV8xLlJlamVjdGlvbi5ub3JtYWxpemUoZXJyKS50b1Byb21pc2UoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGhhbmRsZUVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIGhvb2suZXZlbnRUeXBlLmdldEVycm9ySGFuZGxlcihfdGhpcykoZXJyKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGhhbmRsZVJlc3VsdCA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiBob29rLmV2ZW50VHlwZS5nZXRSZXN1bHRIYW5kbGVyKF90aGlzKShyZXN1bHQpO1xuICAgICAgICB9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGludm9rZUNhbGxiYWNrKCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMudHlwZS5zeW5jaHJvbm91cyAmJiBwcmVkaWNhdGVzXzEuaXNQcm9taXNlKHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LmNhdGNoKG5vcm1hbGl6ZUVycilcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oaGFuZGxlUmVzdWx0LCBoYW5kbGVFcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlUmVzdWx0KHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgLy8gSWYgY2FsbGJhY2sgdGhyb3dzIChzeW5jaHJvbm91c2x5KVxuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUVycm9yKHJlamVjdEZhY3RvcnlfMS5SZWplY3Rpb24ubm9ybWFsaXplKGVycikpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKGhvb2suaW52b2tlTGltaXQgJiYgKytob29rLmludm9rZUNvdW50ID49IGhvb2suaW52b2tlTGltaXQpIHtcbiAgICAgICAgICAgICAgICBob29rLmRlcmVnaXN0ZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaGFuZGxlcyB0aGUgcmV0dXJuIHZhbHVlIG9mIGEgVHJhbnNpdGlvbiBIb29rLlxuICAgICAqXG4gICAgICogQSBob29rIGNhbiByZXR1cm4gZmFsc2UgKGNhbmNlbCksIGEgVGFyZ2V0U3RhdGUgKHJlZGlyZWN0KSxcbiAgICAgKiBvciBhIHByb21pc2UgKHdoaWNoIG1heSBsYXRlciByZXNvbHZlIHRvIGZhbHNlIG9yIGEgcmVkaXJlY3QpXG4gICAgICpcbiAgICAgKiBUaGlzIGFsc28gaGFuZGxlcyBcInRyYW5zaXRpb24gc3VwZXJzZWRlZFwiIC0tIHdoZW4gYSBuZXcgdHJhbnNpdGlvblxuICAgICAqIHdhcyBzdGFydGVkIHdoaWxlIHRoZSBob29rIHdhcyBzdGlsbCBydW5uaW5nXG4gICAgICovXG4gICAgVHJhbnNpdGlvbkhvb2sucHJvdG90eXBlLmhhbmRsZUhvb2tSZXN1bHQgPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBub3RDdXJyZW50ID0gdGhpcy5nZXROb3RDdXJyZW50UmVqZWN0aW9uKCk7XG4gICAgICAgIGlmIChub3RDdXJyZW50KVxuICAgICAgICAgICAgcmV0dXJuIG5vdEN1cnJlbnQ7XG4gICAgICAgIC8vIEhvb2sgcmV0dXJuZWQgYSBwcm9taXNlXG4gICAgICAgIGlmIChwcmVkaWNhdGVzXzEuaXNQcm9taXNlKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIC8vIFdhaXQgZm9yIHRoZSBwcm9taXNlLCB0aGVuIHJlcHJvY2VzcyB3aXRoIHRoZSByZXN1bHRpbmcgdmFsdWVcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQudGhlbihmdW5jdGlvbiAodmFsKSB7IHJldHVybiBfdGhpcy5oYW5kbGVIb29rUmVzdWx0KHZhbCk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIHRyYWNlXzEudHJhY2UudHJhY2VIb29rUmVzdWx0KHJlc3VsdCwgdGhpcy50cmFuc2l0aW9uLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICAvLyBIb29rIHJldHVybmVkIGZhbHNlXG4gICAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAvLyBBYm9ydCB0aGlzIFRyYW5zaXRpb25cbiAgICAgICAgICAgIHJldHVybiByZWplY3RGYWN0b3J5XzEuUmVqZWN0aW9uLmFib3J0ZWQoJ0hvb2sgYWJvcnRlZCB0cmFuc2l0aW9uJykudG9Qcm9taXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlzVGFyZ2V0U3RhdGUgPSBob2ZfMS5pcyh0YXJnZXRTdGF0ZV8xLlRhcmdldFN0YXRlKTtcbiAgICAgICAgLy8gaG9vayByZXR1cm5lZCBhIFRhcmdldFN0YXRlXG4gICAgICAgIGlmIChpc1RhcmdldFN0YXRlKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIC8vIEhhbHQgdGhlIGN1cnJlbnQgVHJhbnNpdGlvbiBhbmQgcmVkaXJlY3QgKGEgbmV3IFRyYW5zaXRpb24pIHRvIHRoZSBUYXJnZXRTdGF0ZS5cbiAgICAgICAgICAgIHJldHVybiByZWplY3RGYWN0b3J5XzEuUmVqZWN0aW9uLnJlZGlyZWN0ZWQocmVzdWx0KS50b1Byb21pc2UoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgUmVqZWN0aW9uIHByb21pc2UgaWYgdGhlIHRyYW5zaXRpb24gaXMgbm8gbG9uZ2VyIGN1cnJlbnQgZHVlXG4gICAgICogdG8gYSBzdG9wcGVkIHJvdXRlciAoZGlzcG9zZWQpLCBvciBhIG5ldyB0cmFuc2l0aW9uIGhhcyBzdGFydGVkIGFuZCBzdXBlcnNlZGVkIHRoaXMgb25lLlxuICAgICAqL1xuICAgIFRyYW5zaXRpb25Ib29rLnByb3RvdHlwZS5nZXROb3RDdXJyZW50UmVqZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcm91dGVyID0gdGhpcy50cmFuc2l0aW9uLnJvdXRlcjtcbiAgICAgICAgLy8gVGhlIHJvdXRlciBpcyBzdG9wcGVkXG4gICAgICAgIGlmIChyb3V0ZXIuX2Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0RmFjdG9yeV8xLlJlamVjdGlvbi5hYm9ydGVkKFwiVUlSb3V0ZXIgaW5zdGFuY2UgI1wiICsgcm91dGVyLiRpZCArIFwiIGhhcyBiZWVuIHN0b3BwZWQgKGRpc3Bvc2VkKVwiKS50b1Byb21pc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50cmFuc2l0aW9uLl9hYm9ydGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVqZWN0RmFjdG9yeV8xLlJlamVjdGlvbi5hYm9ydGVkKCkudG9Qcm9taXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhpcyB0cmFuc2l0aW9uIGlzIG5vIGxvbmdlciBjdXJyZW50LlxuICAgICAgICAvLyBBbm90aGVyIHRyYW5zaXRpb24gc3RhcnRlZCB3aGlsZSB0aGlzIGhvb2sgd2FzIHN0aWxsIHJ1bm5pbmcuXG4gICAgICAgIGlmICh0aGlzLmlzU3VwZXJzZWRlZCgpKSB7XG4gICAgICAgICAgICAvLyBBYm9ydCB0aGlzIHRyYW5zaXRpb25cbiAgICAgICAgICAgIHJldHVybiByZWplY3RGYWN0b3J5XzEuUmVqZWN0aW9uLnN1cGVyc2VkZWQodGhpcy5vcHRpb25zLmN1cnJlbnQoKSkudG9Qcm9taXNlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRyYW5zaXRpb25Ib29rLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgb3B0aW9ucyA9IF9hLm9wdGlvbnMsIHJlZ2lzdGVyZWRIb29rID0gX2EucmVnaXN0ZXJlZEhvb2s7XG4gICAgICAgIHZhciBldmVudCA9IGhvZl8xLnBhcnNlKCd0cmFjZURhdGEuaG9va1R5cGUnKShvcHRpb25zKSB8fCAnaW50ZXJuYWwnLCBjb250ZXh0ID0gaG9mXzEucGFyc2UoJ3RyYWNlRGF0YS5jb250ZXh0LnN0YXRlLm5hbWUnKShvcHRpb25zKSB8fCBob2ZfMS5wYXJzZSgndHJhY2VEYXRhLmNvbnRleHQnKShvcHRpb25zKSB8fCAndW5rbm93bicsIG5hbWUgPSBzdHJpbmdzXzEuZm5Ub1N0cmluZyhyZWdpc3RlcmVkSG9vay5jYWxsYmFjayk7XG4gICAgICAgIHJldHVybiBldmVudCArIFwiIGNvbnRleHQ6IFwiICsgY29udGV4dCArIFwiLCBcIiArIHN0cmluZ3NfMS5tYXhMZW5ndGgoMjAwLCBuYW1lKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoZXNlIEdldFJlc3VsdEhhbmRsZXIocykgYXJlIHVzZWQgYnkgW1tpbnZva2VIb29rXV0gYmVsb3dcbiAgICAgKiBFYWNoIEhvb2tUeXBlIGNob29zZXMgYSBHZXRSZXN1bHRIYW5kbGVyIChTZWU6IFtbVHJhbnNpdGlvblNlcnZpY2UuX2RlZmluZUNvcmVFdmVudHNdXSlcbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uSG9vay5IQU5ETEVfUkVTVUxUID0gZnVuY3Rpb24gKGhvb2spIHsgcmV0dXJuIGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIGhvb2suaGFuZGxlSG9va1Jlc3VsdChyZXN1bHQpO1xuICAgIH07IH07XG4gICAgLyoqXG4gICAgICogSWYgdGhlIHJlc3VsdCBpcyBhIHByb21pc2UgcmVqZWN0aW9uLCBsb2cgaXQuXG4gICAgICogT3RoZXJ3aXNlLCBpZ25vcmUgdGhlIHJlc3VsdC5cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uSG9vay5MT0dfUkVKRUNURURfUkVTVUxUID0gZnVuY3Rpb24gKGhvb2spIHsgcmV0dXJuIGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgcHJlZGljYXRlc18xLmlzUHJvbWlzZShyZXN1bHQpICYmIHJlc3VsdC5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gaG9vay5sb2dFcnJvcihyZWplY3RGYWN0b3J5XzEuUmVqZWN0aW9uLm5vcm1hbGl6ZShlcnIpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTsgfTtcbiAgICAvKipcbiAgICAgKiBUaGVzZSBHZXRFcnJvckhhbmRsZXIocykgYXJlIHVzZWQgYnkgW1tpbnZva2VIb29rXV0gYmVsb3dcbiAgICAgKiBFYWNoIEhvb2tUeXBlIGNob29zZXMgYSBHZXRFcnJvckhhbmRsZXIgKFNlZTogW1tUcmFuc2l0aW9uU2VydmljZS5fZGVmaW5lQ29yZUV2ZW50c11dKVxuICAgICAqL1xuICAgIFRyYW5zaXRpb25Ib29rLkxPR19FUlJPUiA9IGZ1bmN0aW9uIChob29rKSB7IHJldHVybiBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGhvb2subG9nRXJyb3IoZXJyb3IpO1xuICAgIH07IH07XG4gICAgVHJhbnNpdGlvbkhvb2suUkVKRUNUX0VSUk9SID0gZnVuY3Rpb24gKGhvb2spIHsgcmV0dXJuIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICByZXR1cm4gY29tbW9uXzEuc2lsZW50UmVqZWN0aW9uKGVycm9yKTtcbiAgICB9OyB9O1xuICAgIFRyYW5zaXRpb25Ib29rLlRIUk9XX0VSUk9SID0gZnVuY3Rpb24gKGhvb2spIHsgcmV0dXJuIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9OyB9O1xuICAgIHJldHVybiBUcmFuc2l0aW9uSG9vaztcbn0oKSk7XG5leHBvcnRzLlRyYW5zaXRpb25Ib29rID0gVHJhbnNpdGlvbkhvb2s7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFuc2l0aW9uSG9vay5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvdHJhbnNpdGlvbi90cmFuc2l0aW9uSG9vay5qc1xuLy8gbW9kdWxlIGlkID0gMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///25\n")},function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @coreapi\n * @module resolve\n */ /** for typedoc */\nvar common_1 = __webpack_require__(0);\nvar coreservices_1 = __webpack_require__(3);\nvar trace_1 = __webpack_require__(8);\nvar strings_1 = __webpack_require__(6);\nvar predicates_1 = __webpack_require__(1);\nvar predicates_2 = __webpack_require__(1);\n// TODO: explicitly make this user configurable\nexports.defaultResolvePolicy = {\n    when: 'LAZY',\n    async: 'WAIT',\n};\n/**\n * The basic building block for the resolve system.\n *\n * Resolvables encapsulate a state's resolve's resolveFn, the resolveFn's declared dependencies, the wrapped (.promise),\n * and the unwrapped-when-complete (.data) result of the resolveFn.\n *\n * Resolvable.get() either retrieves the Resolvable's existing promise, or else invokes resolve() (which invokes the\n * resolveFn) and returns the resulting promise.\n *\n * Resolvable.get() and Resolvable.resolve() both execute within a context path, which is passed as the first\n * parameter to those fns.\n */\nvar Resolvable = /** @class */ (function () {\n    function Resolvable(arg1, resolveFn, deps, policy, data) {\n        this.resolved = false;\n        this.promise = undefined;\n        if (arg1 instanceof Resolvable) {\n            common_1.extend(this, arg1);\n        }\n        else if (predicates_1.isFunction(resolveFn)) {\n            if (predicates_2.isNullOrUndefined(arg1))\n                throw new Error('new Resolvable(): token argument is required');\n            if (!predicates_1.isFunction(resolveFn))\n                throw new Error('new Resolvable(): resolveFn argument must be a function');\n            this.token = arg1;\n            this.policy = policy;\n            this.resolveFn = resolveFn;\n            this.deps = deps || [];\n            this.data = data;\n            this.resolved = data !== undefined;\n            this.promise = this.resolved ? coreservices_1.services.$q.when(this.data) : undefined;\n        }\n        else if (predicates_1.isObject(arg1) && arg1.token && predicates_1.isFunction(arg1.resolveFn)) {\n            var literal = arg1;\n            return new Resolvable(literal.token, literal.resolveFn, literal.deps, literal.policy, literal.data);\n        }\n    }\n    Resolvable.prototype.getPolicy = function (state) {\n        var thisPolicy = this.policy || {};\n        var statePolicy = state && state.resolvePolicy || {};\n        return {\n            when: thisPolicy.when || statePolicy.when || exports.defaultResolvePolicy.when,\n            async: thisPolicy.async || statePolicy.async || exports.defaultResolvePolicy.async,\n        };\n    };\n    /**\n     * Asynchronously resolve this Resolvable's data\n     *\n     * Given a ResolveContext that this Resolvable is found in:\n     * Wait for this Resolvable's dependencies, then invoke this Resolvable's function\n     * and update the Resolvable's state\n     */\n    Resolvable.prototype.resolve = function (resolveContext, trans) {\n        var _this = this;\n        var $q = coreservices_1.services.$q;\n        // Gets all dependencies from ResolveContext and wait for them to be resolved\n        var getResolvableDependencies = function () {\n            return $q.all(resolveContext.getDependencies(_this).map(function (resolvable) {\n                return resolvable.get(resolveContext, trans);\n            }));\n        };\n        // Invokes the resolve function passing the resolved dependencies as arguments\n        var invokeResolveFn = function (resolvedDeps) {\n            return _this.resolveFn.apply(null, resolvedDeps);\n        };\n        /**\n         * For RXWAIT policy:\n         *\n         * Given an observable returned from a resolve function:\n         * - enables .cache() mode (this allows multicast subscribers)\n         * - then calls toPromise() (this triggers subscribe() and thus fetches)\n         * - Waits for the promise, then return the cached observable (not the first emitted value).\n         */\n        var waitForRx = function (observable$) {\n            var cached = observable$.cache(1);\n            return cached.take(1).toPromise().then(function () { return cached; });\n        };\n        // If the resolve policy is RXWAIT, wait for the observable to emit something. otherwise pass through.\n        var node = resolveContext.findNode(this);\n        var state = node && node.state;\n        var maybeWaitForRx = this.getPolicy(state).async === 'RXWAIT' ? waitForRx : common_1.identity;\n        // After the final value has been resolved, update the state of the Resolvable\n        var applyResolvedValue = function (resolvedValue) {\n            _this.data = resolvedValue;\n            _this.resolved = true;\n            trace_1.trace.traceResolvableResolved(_this, trans);\n            return _this.data;\n        };\n        // Sets the promise property first, then getsResolvableDependencies in the context of the promise chain. Always waits one tick.\n        return this.promise = $q.when()\n            .then(getResolvableDependencies)\n            .then(invokeResolveFn)\n            .then(maybeWaitForRx)\n            .then(applyResolvedValue);\n    };\n    /**\n     * Gets a promise for this Resolvable's data.\n     *\n     * Fetches the data and returns a promise.\n     * Returns the existing promise if it has already been fetched once.\n     */\n    Resolvable.prototype.get = function (resolveContext, trans) {\n        return this.promise || this.resolve(resolveContext, trans);\n    };\n    Resolvable.prototype.toString = function () {\n        return \"Resolvable(token: \" + strings_1.stringify(this.token) + \", requires: [\" + this.deps.map(strings_1.stringify) + \"])\";\n    };\n    Resolvable.prototype.clone = function () {\n        return new Resolvable(this);\n    };\n    Resolvable.fromData = function (token, data) {\n        return new Resolvable(token, function () { return data; }, null, null, data);\n    };\n    return Resolvable;\n}());\nexports.Resolvable = Resolvable;\n//# sourceMappingURL=resolvable.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3Jlc29sdmUvcmVzb2x2YWJsZS5qcz8xYzNhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAY29yZWFwaVxuICogQG1vZHVsZSByZXNvbHZlXG4gKi8gLyoqIGZvciB0eXBlZG9jICovXG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcbnZhciBjb3Jlc2VydmljZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29yZXNlcnZpY2VzXCIpO1xudmFyIHRyYWNlXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3RyYWNlXCIpO1xudmFyIHN0cmluZ3NfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vc3RyaW5nc1wiKTtcbnZhciBwcmVkaWNhdGVzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3ByZWRpY2F0ZXNcIik7XG52YXIgcHJlZGljYXRlc18yID0gcmVxdWlyZShcIi4uL2NvbW1vbi9wcmVkaWNhdGVzXCIpO1xuLy8gVE9ETzogZXhwbGljaXRseSBtYWtlIHRoaXMgdXNlciBjb25maWd1cmFibGVcbmV4cG9ydHMuZGVmYXVsdFJlc29sdmVQb2xpY3kgPSB7XG4gICAgd2hlbjogJ0xBWlknLFxuICAgIGFzeW5jOiAnV0FJVCcsXG59O1xuLyoqXG4gKiBUaGUgYmFzaWMgYnVpbGRpbmcgYmxvY2sgZm9yIHRoZSByZXNvbHZlIHN5c3RlbS5cbiAqXG4gKiBSZXNvbHZhYmxlcyBlbmNhcHN1bGF0ZSBhIHN0YXRlJ3MgcmVzb2x2ZSdzIHJlc29sdmVGbiwgdGhlIHJlc29sdmVGbidzIGRlY2xhcmVkIGRlcGVuZGVuY2llcywgdGhlIHdyYXBwZWQgKC5wcm9taXNlKSxcbiAqIGFuZCB0aGUgdW53cmFwcGVkLXdoZW4tY29tcGxldGUgKC5kYXRhKSByZXN1bHQgb2YgdGhlIHJlc29sdmVGbi5cbiAqXG4gKiBSZXNvbHZhYmxlLmdldCgpIGVpdGhlciByZXRyaWV2ZXMgdGhlIFJlc29sdmFibGUncyBleGlzdGluZyBwcm9taXNlLCBvciBlbHNlIGludm9rZXMgcmVzb2x2ZSgpICh3aGljaCBpbnZva2VzIHRoZVxuICogcmVzb2x2ZUZuKSBhbmQgcmV0dXJucyB0aGUgcmVzdWx0aW5nIHByb21pc2UuXG4gKlxuICogUmVzb2x2YWJsZS5nZXQoKSBhbmQgUmVzb2x2YWJsZS5yZXNvbHZlKCkgYm90aCBleGVjdXRlIHdpdGhpbiBhIGNvbnRleHQgcGF0aCwgd2hpY2ggaXMgcGFzc2VkIGFzIHRoZSBmaXJzdFxuICogcGFyYW1ldGVyIHRvIHRob3NlIGZucy5cbiAqL1xudmFyIFJlc29sdmFibGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVzb2x2YWJsZShhcmcxLCByZXNvbHZlRm4sIGRlcHMsIHBvbGljeSwgZGF0YSkge1xuICAgICAgICB0aGlzLnJlc29sdmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucHJvbWlzZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGFyZzEgaW5zdGFuY2VvZiBSZXNvbHZhYmxlKSB7XG4gICAgICAgICAgICBjb21tb25fMS5leHRlbmQodGhpcywgYXJnMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJlZGljYXRlc18xLmlzRnVuY3Rpb24ocmVzb2x2ZUZuKSkge1xuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZXNfMi5pc051bGxPclVuZGVmaW5lZChhcmcxKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25ldyBSZXNvbHZhYmxlKCk6IHRva2VuIGFyZ3VtZW50IGlzIHJlcXVpcmVkJyk7XG4gICAgICAgICAgICBpZiAoIXByZWRpY2F0ZXNfMS5pc0Z1bmN0aW9uKHJlc29sdmVGbikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCduZXcgUmVzb2x2YWJsZSgpOiByZXNvbHZlRm4gYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgICAgICB0aGlzLnRva2VuID0gYXJnMTtcbiAgICAgICAgICAgIHRoaXMucG9saWN5ID0gcG9saWN5O1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZlRm4gPSByZXNvbHZlRm47XG4gICAgICAgICAgICB0aGlzLmRlcHMgPSBkZXBzIHx8IFtdO1xuICAgICAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZWQgPSBkYXRhICE9PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLnByb21pc2UgPSB0aGlzLnJlc29sdmVkID8gY29yZXNlcnZpY2VzXzEuc2VydmljZXMuJHEud2hlbih0aGlzLmRhdGEpIDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByZWRpY2F0ZXNfMS5pc09iamVjdChhcmcxKSAmJiBhcmcxLnRva2VuICYmIHByZWRpY2F0ZXNfMS5pc0Z1bmN0aW9uKGFyZzEucmVzb2x2ZUZuKSkge1xuICAgICAgICAgICAgdmFyIGxpdGVyYWwgPSBhcmcxO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXNvbHZhYmxlKGxpdGVyYWwudG9rZW4sIGxpdGVyYWwucmVzb2x2ZUZuLCBsaXRlcmFsLmRlcHMsIGxpdGVyYWwucG9saWN5LCBsaXRlcmFsLmRhdGEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFJlc29sdmFibGUucHJvdG90eXBlLmdldFBvbGljeSA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICB2YXIgdGhpc1BvbGljeSA9IHRoaXMucG9saWN5IHx8IHt9O1xuICAgICAgICB2YXIgc3RhdGVQb2xpY3kgPSBzdGF0ZSAmJiBzdGF0ZS5yZXNvbHZlUG9saWN5IHx8IHt9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2hlbjogdGhpc1BvbGljeS53aGVuIHx8IHN0YXRlUG9saWN5LndoZW4gfHwgZXhwb3J0cy5kZWZhdWx0UmVzb2x2ZVBvbGljeS53aGVuLFxuICAgICAgICAgICAgYXN5bmM6IHRoaXNQb2xpY3kuYXN5bmMgfHwgc3RhdGVQb2xpY3kuYXN5bmMgfHwgZXhwb3J0cy5kZWZhdWx0UmVzb2x2ZVBvbGljeS5hc3luYyxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFzeW5jaHJvbm91c2x5IHJlc29sdmUgdGhpcyBSZXNvbHZhYmxlJ3MgZGF0YVxuICAgICAqXG4gICAgICogR2l2ZW4gYSBSZXNvbHZlQ29udGV4dCB0aGF0IHRoaXMgUmVzb2x2YWJsZSBpcyBmb3VuZCBpbjpcbiAgICAgKiBXYWl0IGZvciB0aGlzIFJlc29sdmFibGUncyBkZXBlbmRlbmNpZXMsIHRoZW4gaW52b2tlIHRoaXMgUmVzb2x2YWJsZSdzIGZ1bmN0aW9uXG4gICAgICogYW5kIHVwZGF0ZSB0aGUgUmVzb2x2YWJsZSdzIHN0YXRlXG4gICAgICovXG4gICAgUmVzb2x2YWJsZS5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uIChyZXNvbHZlQ29udGV4dCwgdHJhbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyICRxID0gY29yZXNlcnZpY2VzXzEuc2VydmljZXMuJHE7XG4gICAgICAgIC8vIEdldHMgYWxsIGRlcGVuZGVuY2llcyBmcm9tIFJlc29sdmVDb250ZXh0IGFuZCB3YWl0IGZvciB0aGVtIHRvIGJlIHJlc29sdmVkXG4gICAgICAgIHZhciBnZXRSZXNvbHZhYmxlRGVwZW5kZW5jaWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICRxLmFsbChyZXNvbHZlQ29udGV4dC5nZXREZXBlbmRlbmNpZXMoX3RoaXMpLm1hcChmdW5jdGlvbiAocmVzb2x2YWJsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZhYmxlLmdldChyZXNvbHZlQ29udGV4dCwgdHJhbnMpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBJbnZva2VzIHRoZSByZXNvbHZlIGZ1bmN0aW9uIHBhc3NpbmcgdGhlIHJlc29sdmVkIGRlcGVuZGVuY2llcyBhcyBhcmd1bWVudHNcbiAgICAgICAgdmFyIGludm9rZVJlc29sdmVGbiA9IGZ1bmN0aW9uIChyZXNvbHZlZERlcHMpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5yZXNvbHZlRm4uYXBwbHkobnVsbCwgcmVzb2x2ZWREZXBzKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZvciBSWFdBSVQgcG9saWN5OlxuICAgICAgICAgKlxuICAgICAgICAgKiBHaXZlbiBhbiBvYnNlcnZhYmxlIHJldHVybmVkIGZyb20gYSByZXNvbHZlIGZ1bmN0aW9uOlxuICAgICAgICAgKiAtIGVuYWJsZXMgLmNhY2hlKCkgbW9kZSAodGhpcyBhbGxvd3MgbXVsdGljYXN0IHN1YnNjcmliZXJzKVxuICAgICAgICAgKiAtIHRoZW4gY2FsbHMgdG9Qcm9taXNlKCkgKHRoaXMgdHJpZ2dlcnMgc3Vic2NyaWJlKCkgYW5kIHRodXMgZmV0Y2hlcylcbiAgICAgICAgICogLSBXYWl0cyBmb3IgdGhlIHByb21pc2UsIHRoZW4gcmV0dXJuIHRoZSBjYWNoZWQgb2JzZXJ2YWJsZSAobm90IHRoZSBmaXJzdCBlbWl0dGVkIHZhbHVlKS5cbiAgICAgICAgICovXG4gICAgICAgIHZhciB3YWl0Rm9yUnggPSBmdW5jdGlvbiAob2JzZXJ2YWJsZSQpIHtcbiAgICAgICAgICAgIHZhciBjYWNoZWQgPSBvYnNlcnZhYmxlJC5jYWNoZSgxKTtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWQudGFrZSgxKS50b1Byb21pc2UoKS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhY2hlZDsgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIElmIHRoZSByZXNvbHZlIHBvbGljeSBpcyBSWFdBSVQsIHdhaXQgZm9yIHRoZSBvYnNlcnZhYmxlIHRvIGVtaXQgc29tZXRoaW5nLiBvdGhlcndpc2UgcGFzcyB0aHJvdWdoLlxuICAgICAgICB2YXIgbm9kZSA9IHJlc29sdmVDb250ZXh0LmZpbmROb2RlKHRoaXMpO1xuICAgICAgICB2YXIgc3RhdGUgPSBub2RlICYmIG5vZGUuc3RhdGU7XG4gICAgICAgIHZhciBtYXliZVdhaXRGb3JSeCA9IHRoaXMuZ2V0UG9saWN5KHN0YXRlKS5hc3luYyA9PT0gJ1JYV0FJVCcgPyB3YWl0Rm9yUnggOiBjb21tb25fMS5pZGVudGl0eTtcbiAgICAgICAgLy8gQWZ0ZXIgdGhlIGZpbmFsIHZhbHVlIGhhcyBiZWVuIHJlc29sdmVkLCB1cGRhdGUgdGhlIHN0YXRlIG9mIHRoZSBSZXNvbHZhYmxlXG4gICAgICAgIHZhciBhcHBseVJlc29sdmVkVmFsdWUgPSBmdW5jdGlvbiAocmVzb2x2ZWRWYWx1ZSkge1xuICAgICAgICAgICAgX3RoaXMuZGF0YSA9IHJlc29sdmVkVmFsdWU7XG4gICAgICAgICAgICBfdGhpcy5yZXNvbHZlZCA9IHRydWU7XG4gICAgICAgICAgICB0cmFjZV8xLnRyYWNlLnRyYWNlUmVzb2x2YWJsZVJlc29sdmVkKF90aGlzLCB0cmFucyk7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuZGF0YTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gU2V0cyB0aGUgcHJvbWlzZSBwcm9wZXJ0eSBmaXJzdCwgdGhlbiBnZXRzUmVzb2x2YWJsZURlcGVuZGVuY2llcyBpbiB0aGUgY29udGV4dCBvZiB0aGUgcHJvbWlzZSBjaGFpbi4gQWx3YXlzIHdhaXRzIG9uZSB0aWNrLlxuICAgICAgICByZXR1cm4gdGhpcy5wcm9taXNlID0gJHEud2hlbigpXG4gICAgICAgICAgICAudGhlbihnZXRSZXNvbHZhYmxlRGVwZW5kZW5jaWVzKVxuICAgICAgICAgICAgLnRoZW4oaW52b2tlUmVzb2x2ZUZuKVxuICAgICAgICAgICAgLnRoZW4obWF5YmVXYWl0Rm9yUngpXG4gICAgICAgICAgICAudGhlbihhcHBseVJlc29sdmVkVmFsdWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyBhIHByb21pc2UgZm9yIHRoaXMgUmVzb2x2YWJsZSdzIGRhdGEuXG4gICAgICpcbiAgICAgKiBGZXRjaGVzIHRoZSBkYXRhIGFuZCByZXR1cm5zIGEgcHJvbWlzZS5cbiAgICAgKiBSZXR1cm5zIHRoZSBleGlzdGluZyBwcm9taXNlIGlmIGl0IGhhcyBhbHJlYWR5IGJlZW4gZmV0Y2hlZCBvbmNlLlxuICAgICAqL1xuICAgIFJlc29sdmFibGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChyZXNvbHZlQ29udGV4dCwgdHJhbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvbWlzZSB8fCB0aGlzLnJlc29sdmUocmVzb2x2ZUNvbnRleHQsIHRyYW5zKTtcbiAgICB9O1xuICAgIFJlc29sdmFibGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJSZXNvbHZhYmxlKHRva2VuOiBcIiArIHN0cmluZ3NfMS5zdHJpbmdpZnkodGhpcy50b2tlbikgKyBcIiwgcmVxdWlyZXM6IFtcIiArIHRoaXMuZGVwcy5tYXAoc3RyaW5nc18xLnN0cmluZ2lmeSkgKyBcIl0pXCI7XG4gICAgfTtcbiAgICBSZXNvbHZhYmxlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXNvbHZhYmxlKHRoaXMpO1xuICAgIH07XG4gICAgUmVzb2x2YWJsZS5mcm9tRGF0YSA9IGZ1bmN0aW9uICh0b2tlbiwgZGF0YSkge1xuICAgICAgICByZXR1cm4gbmV3IFJlc29sdmFibGUodG9rZW4sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRhdGE7IH0sIG51bGwsIG51bGwsIGRhdGEpO1xuICAgIH07XG4gICAgcmV0dXJuIFJlc29sdmFibGU7XG59KCkpO1xuZXhwb3J0cy5SZXNvbHZhYmxlID0gUmVzb2x2YWJsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc29sdmFibGUuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3Jlc29sdmUvcmVzb2x2YWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gMjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///26\n")},function(module,exports,__webpack_require__){"use strict";eval('\n\nexports.__esModule = true;\n\nvar _defineProperty = __webpack_require__(149);\n\nvar _defineProperty2 = _interopRequireDefault(_defineProperty);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if ("value" in descriptor) descriptor.writable = true;\n      (0, _defineProperty2.default)(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzLmpzP2MzMTAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9vYmplY3QvZGVmaW5lLXByb3BlcnR5XCIpO1xuXG52YXIgX2RlZmluZVByb3BlcnR5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlZmluZVByb3BlcnR5KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICgwLCBfZGVmaW5lUHJvcGVydHkyLmRlZmF1bHQpKHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH07XG59KCk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzLmpzXG4vLyBtb2R1bGUgaWQgPSAyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///27\n')},function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @coreapi\n * @module core\n */\n/**\n * Matches state names using glob-like pattern strings.\n *\n * Globs can be used in specific APIs including:\n *\n * - [[StateService.is]]\n * - [[StateService.includes]]\n * - The first argument to Hook Registration functions like [[TransitionService.onStart]]\n *    - [[HookMatchCriteria]] and [[HookMatchCriterion]]\n *\n * A `Glob` string is a pattern which matches state names.\n * Nested state names are split into segments (separated by a dot) when processing.\n * The state named `foo.bar.baz` is split into three segments ['foo', 'bar', 'baz']\n *\n * Globs work according to the following rules:\n *\n * ### Exact match:\n *\n * The glob `'A.B'` matches the state named exactly `'A.B'`.\n *\n * | Glob        |Matches states named|Does not match state named|\n * |:------------|:--------------------|:---------------------|\n * | `'A'`       | `'A'`               | `'B'` , `'A.C'`      |\n * | `'A.B'`     | `'A.B'`             | `'A'` , `'A.B.C'`    |\n * | `'foo'`     | `'foo'`             | `'FOO'` , `'foo.bar'`|\n *\n * ### Single star (`*`)\n *\n * A single star (`*`) is a wildcard that matches exactly one segment.\n *\n * | Glob        |Matches states named  |Does not match state named |\n * |:------------|:---------------------|:--------------------------|\n * | `'*'`       | `'A'` , `'Z'`        | `'A.B'` , `'Z.Y.X'`       |\n * | `'A.*'`     | `'A.B'` , `'A.C'`    | `'A'` , `'A.B.C'`         |\n * | `'A.*.*'`   | `'A.B.C'` , `'A.X.Y'`| `'A'`, `'A.B'` , `'Z.Y.X'`|\n *\n * ### Double star (`**`)\n *\n * A double star (`'**'`) is a wildcard that matches *zero or more segments*\n *\n * | Glob        |Matches states named                           |Does not match state named         |\n * |:------------|:----------------------------------------------|:----------------------------------|\n * | `'**'`      | `'A'` , `'A.B'`, `'Z.Y.X'`                    | (matches all states)              |\n * | `'A.**'`    | `'A'` , `'A.B'` , `'A.C.X'`                   | `'Z.Y.X'`                         |\n * | `'**.X'`    | `'X'` , `'A.X'` , `'Z.Y.X'`                   | `'A'` , `'A.login.Z'`             |\n * | `'A.**.X'`  | `'A.X'` , `'A.B.X'` , `'A.B.C.X'`             | `'A'` , `'A.B.C'`                 |\n *\n */\nvar Glob = /** @class */ (function () {\n    function Glob(text) {\n        this.text = text;\n        this.glob = text.split('.');\n        var regexpString = this.text.split('.')\n            .map(function (seg) {\n            if (seg === '**')\n                return '(?:|(?:\\\\.[^.]*)*)';\n            if (seg === '*')\n                return '\\\\.[^.]*';\n            return '\\\\.' + seg;\n        }).join('');\n        this.regexp = new RegExp('^' + regexpString + '$');\n    }\n    /** Returns true if the string has glob-like characters in it */\n    Glob.is = function (text) {\n        return !!/[!,*]+/.exec(text);\n    };\n    /** Returns a glob from the string, or null if the string isn't Glob-like */\n    Glob.fromString = function (text) {\n        return Glob.is(text) ? new Glob(text) : null;\n    };\n    Glob.prototype.matches = function (name) {\n        return this.regexp.test('.' + name);\n    };\n    return Glob;\n}());\nexports.Glob = Glob;\n//# sourceMappingURL=glob.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2NvbW1vbi9nbG9iLmpzP2I0ODkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEBjb3JlYXBpXG4gKiBAbW9kdWxlIGNvcmVcbiAqL1xuLyoqXG4gKiBNYXRjaGVzIHN0YXRlIG5hbWVzIHVzaW5nIGdsb2ItbGlrZSBwYXR0ZXJuIHN0cmluZ3MuXG4gKlxuICogR2xvYnMgY2FuIGJlIHVzZWQgaW4gc3BlY2lmaWMgQVBJcyBpbmNsdWRpbmc6XG4gKlxuICogLSBbW1N0YXRlU2VydmljZS5pc11dXG4gKiAtIFtbU3RhdGVTZXJ2aWNlLmluY2x1ZGVzXV1cbiAqIC0gVGhlIGZpcnN0IGFyZ3VtZW50IHRvIEhvb2sgUmVnaXN0cmF0aW9uIGZ1bmN0aW9ucyBsaWtlIFtbVHJhbnNpdGlvblNlcnZpY2Uub25TdGFydF1dXG4gKiAgICAtIFtbSG9va01hdGNoQ3JpdGVyaWFdXSBhbmQgW1tIb29rTWF0Y2hDcml0ZXJpb25dXVxuICpcbiAqIEEgYEdsb2JgIHN0cmluZyBpcyBhIHBhdHRlcm4gd2hpY2ggbWF0Y2hlcyBzdGF0ZSBuYW1lcy5cbiAqIE5lc3RlZCBzdGF0ZSBuYW1lcyBhcmUgc3BsaXQgaW50byBzZWdtZW50cyAoc2VwYXJhdGVkIGJ5IGEgZG90KSB3aGVuIHByb2Nlc3NpbmcuXG4gKiBUaGUgc3RhdGUgbmFtZWQgYGZvby5iYXIuYmF6YCBpcyBzcGxpdCBpbnRvIHRocmVlIHNlZ21lbnRzIFsnZm9vJywgJ2JhcicsICdiYXonXVxuICpcbiAqIEdsb2JzIHdvcmsgYWNjb3JkaW5nIHRvIHRoZSBmb2xsb3dpbmcgcnVsZXM6XG4gKlxuICogIyMjIEV4YWN0IG1hdGNoOlxuICpcbiAqIFRoZSBnbG9iIGAnQS5CJ2AgbWF0Y2hlcyB0aGUgc3RhdGUgbmFtZWQgZXhhY3RseSBgJ0EuQidgLlxuICpcbiAqIHwgR2xvYiAgICAgICAgfE1hdGNoZXMgc3RhdGVzIG5hbWVkfERvZXMgbm90IG1hdGNoIHN0YXRlIG5hbWVkfFxuICogfDotLS0tLS0tLS0tLS18Oi0tLS0tLS0tLS0tLS0tLS0tLS0tfDotLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gKiB8IGAnQSdgICAgICAgIHwgYCdBJ2AgICAgICAgICAgICAgICB8IGAnQidgICwgYCdBLkMnYCAgICAgIHxcbiAqIHwgYCdBLkInYCAgICAgfCBgJ0EuQidgICAgICAgICAgICAgIHwgYCdBJ2AgLCBgJ0EuQi5DJ2AgICAgfFxuICogfCBgJ2ZvbydgICAgICB8IGAnZm9vJ2AgICAgICAgICAgICAgfCBgJ0ZPTydgICwgYCdmb28uYmFyJ2B8XG4gKlxuICogIyMjIFNpbmdsZSBzdGFyIChgKmApXG4gKlxuICogQSBzaW5nbGUgc3RhciAoYCpgKSBpcyBhIHdpbGRjYXJkIHRoYXQgbWF0Y2hlcyBleGFjdGx5IG9uZSBzZWdtZW50LlxuICpcbiAqIHwgR2xvYiAgICAgICAgfE1hdGNoZXMgc3RhdGVzIG5hbWVkICB8RG9lcyBub3QgbWF0Y2ggc3RhdGUgbmFtZWQgfFxuICogfDotLS0tLS0tLS0tLS18Oi0tLS0tLS0tLS0tLS0tLS0tLS0tLXw6LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS18XG4gKiB8IGAnKidgICAgICAgIHwgYCdBJ2AgLCBgJ1onYCAgICAgICAgfCBgJ0EuQidgICwgYCdaLlkuWCdgICAgICAgIHxcbiAqIHwgYCdBLionYCAgICAgfCBgJ0EuQidgICwgYCdBLkMnYCAgICB8IGAnQSdgICwgYCdBLkIuQydgICAgICAgICAgfFxuICogfCBgJ0EuKi4qJ2AgICB8IGAnQS5CLkMnYCAsIGAnQS5YLlknYHwgYCdBJ2AsIGAnQS5CJ2AgLCBgJ1ouWS5YJ2B8XG4gKlxuICogIyMjIERvdWJsZSBzdGFyIChgKipgKVxuICpcbiAqIEEgZG91YmxlIHN0YXIgKGAnKionYCkgaXMgYSB3aWxkY2FyZCB0aGF0IG1hdGNoZXMgKnplcm8gb3IgbW9yZSBzZWdtZW50cypcbiAqXG4gKiB8IEdsb2IgICAgICAgIHxNYXRjaGVzIHN0YXRlcyBuYW1lZCAgICAgICAgICAgICAgICAgICAgICAgICAgIHxEb2VzIG5vdCBtYXRjaCBzdGF0ZSBuYW1lZCAgICAgICAgIHxcbiAqIHw6LS0tLS0tLS0tLS0tfDotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfDotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tfFxuICogfCBgJyoqJ2AgICAgICB8IGAnQSdgICwgYCdBLkInYCwgYCdaLlkuWCdgICAgICAgICAgICAgICAgICAgICB8IChtYXRjaGVzIGFsbCBzdGF0ZXMpICAgICAgICAgICAgICB8XG4gKiB8IGAnQS4qKidgICAgIHwgYCdBJ2AgLCBgJ0EuQidgICwgYCdBLkMuWCdgICAgICAgICAgICAgICAgICAgIHwgYCdaLlkuWCdgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwgYCcqKi5YJ2AgICAgfCBgJ1gnYCAsIGAnQS5YJ2AgLCBgJ1ouWS5YJ2AgICAgICAgICAgICAgICAgICAgfCBgJ0EnYCAsIGAnQS5sb2dpbi5aJ2AgICAgICAgICAgICAgfFxuICogfCBgJ0EuKiouWCdgICB8IGAnQS5YJ2AgLCBgJ0EuQi5YJ2AgLCBgJ0EuQi5DLlgnYCAgICAgICAgICAgICB8IGAnQSdgICwgYCdBLkIuQydgICAgICAgICAgICAgICAgICB8XG4gKlxuICovXG52YXIgR2xvYiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBHbG9iKHRleHQpIHtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICAgICAgdGhpcy5nbG9iID0gdGV4dC5zcGxpdCgnLicpO1xuICAgICAgICB2YXIgcmVnZXhwU3RyaW5nID0gdGhpcy50ZXh0LnNwbGl0KCcuJylcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHNlZykge1xuICAgICAgICAgICAgaWYgKHNlZyA9PT0gJyoqJylcbiAgICAgICAgICAgICAgICByZXR1cm4gJyg/OnwoPzpcXFxcLlteLl0qKSopJztcbiAgICAgICAgICAgIGlmIChzZWcgPT09ICcqJylcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1xcXFwuW14uXSonO1xuICAgICAgICAgICAgcmV0dXJuICdcXFxcLicgKyBzZWc7XG4gICAgICAgIH0pLmpvaW4oJycpO1xuICAgICAgICB0aGlzLnJlZ2V4cCA9IG5ldyBSZWdFeHAoJ14nICsgcmVnZXhwU3RyaW5nICsgJyQnKTtcbiAgICB9XG4gICAgLyoqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3RyaW5nIGhhcyBnbG9iLWxpa2UgY2hhcmFjdGVycyBpbiBpdCAqL1xuICAgIEdsb2IuaXMgPSBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICByZXR1cm4gISEvWyEsKl0rLy5leGVjKHRleHQpO1xuICAgIH07XG4gICAgLyoqIFJldHVybnMgYSBnbG9iIGZyb20gdGhlIHN0cmluZywgb3IgbnVsbCBpZiB0aGUgc3RyaW5nIGlzbid0IEdsb2ItbGlrZSAqL1xuICAgIEdsb2IuZnJvbVN0cmluZyA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICAgIHJldHVybiBHbG9iLmlzKHRleHQpID8gbmV3IEdsb2IodGV4dCkgOiBudWxsO1xuICAgIH07XG4gICAgR2xvYi5wcm90b3R5cGUubWF0Y2hlcyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZ2V4cC50ZXN0KCcuJyArIG5hbWUpO1xuICAgIH07XG4gICAgcmV0dXJuIEdsb2I7XG59KCkpO1xuZXhwb3J0cy5HbG9iID0gR2xvYjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdsb2IuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2NvbW1vbi9nbG9iLmpzXG4vLyBtb2R1bGUgaWQgPSAyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///28\n")},function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @coreapi\n * @module transition\n */\n/** for typedoc */\nvar trace_1 = __webpack_require__(8);\nvar coreservices_1 = __webpack_require__(3);\nvar strings_1 = __webpack_require__(6);\nvar common_1 = __webpack_require__(0);\nvar predicates_1 = __webpack_require__(1);\nvar hof_1 = __webpack_require__(2);\nvar interface_1 = __webpack_require__(16); // has or is using\nvar transitionHook_1 = __webpack_require__(25);\nvar hookRegistry_1 = __webpack_require__(44);\nvar hookBuilder_1 = __webpack_require__(70);\nvar pathUtils_1 = __webpack_require__(30);\nvar param_1 = __webpack_require__(18);\nvar resolvable_1 = __webpack_require__(26);\nvar resolveContext_1 = __webpack_require__(31);\n/** @hidden */\nvar stateSelf = hof_1.prop('self');\n/**\n * Represents a transition between two states.\n *\n * When navigating to a state, we are transitioning **from** the current state **to** the new state.\n *\n * This object contains all contextual information about the to/from states, parameters, resolves.\n * It has information about all states being entered and exited as a result of the transition.\n */\nvar Transition = /** @class */ (function () {\n    /**\n     * Creates a new Transition object.\n     *\n     * If the target state is not valid, an error is thrown.\n     *\n     * @internalapi\n     *\n     * @param fromPath The path of [[PathNode]]s from which the transition is leaving.  The last node in the `fromPath`\n     *        encapsulates the \"from state\".\n     * @param targetState The target state and parameters being transitioned to (also, the transition options)\n     * @param router The [[UIRouter]] instance\n     */\n    function Transition(fromPath, targetState, router) {\n        var _this = this;\n        /** @hidden */\n        this._deferred = coreservices_1.services.$q.defer();\n        /**\n         * This promise is resolved or rejected based on the outcome of the Transition.\n         *\n         * When the transition is successful, the promise is resolved\n         * When the transition is unsuccessful, the promise is rejected with the [[Rejection]] or javascript error\n         */\n        this.promise = this._deferred.promise;\n        /** @hidden Holds the hook registration functions such as those passed to Transition.onStart() */\n        this._registeredHooks = {};\n        /** @hidden */\n        this._hookBuilder = new hookBuilder_1.HookBuilder(this);\n        /** Checks if this transition is currently active/running. */\n        this.isActive = function () {\n            return _this.router.globals.transition === _this;\n        };\n        this.router = router;\n        this._targetState = targetState;\n        if (!targetState.valid()) {\n            throw new Error(targetState.error());\n        }\n        // current() is assumed to come from targetState.options, but provide a naive implementation otherwise.\n        this._options = common_1.extend({ current: hof_1.val(this) }, targetState.options());\n        this.$id = router.transitionService._transitionCount++;\n        var toPath = pathUtils_1.PathUtils.buildToPath(fromPath, targetState);\n        this._treeChanges = pathUtils_1.PathUtils.treeChanges(fromPath, toPath, this._options.reloadState);\n        this.createTransitionHookRegFns();\n        var onCreateHooks = this._hookBuilder.buildHooksForPhase(interface_1.TransitionHookPhase.CREATE);\n        transitionHook_1.TransitionHook.invokeHooks(onCreateHooks, function () { return null; });\n        this.applyViewConfigs(router);\n    }\n    /** @hidden */\n    Transition.prototype.onBefore = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    Transition.prototype.onStart = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    Transition.prototype.onExit = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    Transition.prototype.onRetain = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    Transition.prototype.onEnter = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    Transition.prototype.onFinish = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    Transition.prototype.onSuccess = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    Transition.prototype.onError = function (criteria, callback, options) { return; };\n    /** @hidden\n     * Creates the transition-level hook registration functions\n     * (which can then be used to register hooks)\n     */\n    Transition.prototype.createTransitionHookRegFns = function () {\n        var _this = this;\n        this.router.transitionService._pluginapi._getEvents()\n            .filter(function (type) { return type.hookPhase !== interface_1.TransitionHookPhase.CREATE; })\n            .forEach(function (type) { return hookRegistry_1.makeEvent(_this, _this.router.transitionService, type); });\n    };\n    /** @internalapi */\n    Transition.prototype.getHooks = function (hookName) {\n        return this._registeredHooks[hookName];\n    };\n    Transition.prototype.applyViewConfigs = function (router) {\n        var enteringStates = this._treeChanges.entering.map(function (node) { return node.state; });\n        pathUtils_1.PathUtils.applyViewConfigs(router.transitionService.$view, this._treeChanges.to, enteringStates);\n    };\n    /**\n     * @internalapi\n     *\n     * @returns the internal from [State] object\n     */\n    Transition.prototype.$from = function () {\n        return common_1.tail(this._treeChanges.from).state;\n    };\n    /**\n     * @internalapi\n     *\n     * @returns the internal to [State] object\n     */\n    Transition.prototype.$to = function () {\n        return common_1.tail(this._treeChanges.to).state;\n    };\n    /**\n     * Returns the \"from state\"\n     *\n     * Returns the state that the transition is coming *from*.\n     *\n     * @returns The state declaration object for the Transition's (\"from state\").\n     */\n    Transition.prototype.from = function () {\n        return this.$from().self;\n    };\n    /**\n     * Returns the \"to state\"\n     *\n     * Returns the state that the transition is going *to*.\n     *\n     * @returns The state declaration object for the Transition's target state (\"to state\").\n     */\n    Transition.prototype.to = function () {\n        return this.$to().self;\n    };\n    /**\n     * Gets the Target State\n     *\n     * A transition's [[TargetState]] encapsulates the [[to]] state, the [[params]], and the [[options]] as a single object.\n     *\n     * @returns the [[TargetState]] of this Transition\n     */\n    Transition.prototype.targetState = function () {\n        return this._targetState;\n    };\n    /**\n     * Determines whether two transitions are equivalent.\n     * @deprecated\n     */\n    Transition.prototype.is = function (compare) {\n        if (compare instanceof Transition) {\n            // TODO: Also compare parameters\n            return this.is({ to: compare.$to().name, from: compare.$from().name });\n        }\n        return !((compare.to && !hookRegistry_1.matchState(this.$to(), compare.to)) ||\n            (compare.from && !hookRegistry_1.matchState(this.$from(), compare.from)));\n    };\n    Transition.prototype.params = function (pathname) {\n        if (pathname === void 0) { pathname = 'to'; }\n        return Object.freeze(this._treeChanges[pathname].map(hof_1.prop('paramValues')).reduce(common_1.mergeR, {}));\n    };\n    /**\n     * Creates a [[UIInjector]] Dependency Injector\n     *\n     * Returns a Dependency Injector for the Transition's target state (to state).\n     * The injector provides resolve values which the target state has access to.\n     *\n     * The `UIInjector` can also provide values from the native root/global injector (ng1/ng2).\n     *\n     * #### Example:\n     * ```js\n     * .onEnter({ entering: 'myState' }, trans => {\n     *   var myResolveValue = trans.injector().get('myResolve');\n     *   // Inject a global service from the global/native injector (if it exists)\n     *   var MyService = trans.injector().get('MyService');\n     * })\n     * ```\n     *\n     * In some cases (such as `onBefore`), you may need access to some resolve data but it has not yet been fetched.\n     * You can use [[UIInjector.getAsync]] to get a promise for the data.\n     * #### Example:\n     * ```js\n     * .onBefore({}, trans => {\n     *   return trans.injector().getAsync('myResolve').then(myResolveValue =>\n     *     return myResolveValue !== 'ABORT';\n     *   });\n     * });\n     * ```\n     *\n     * If a `state` is provided, the injector that is returned will be limited to resolve values that the provided state has access to.\n     * This can be useful if both a parent state `foo` and a child state `foo.bar` have both defined a resolve such as `data`.\n     * #### Example:\n     * ```js\n     * .onEnter({ to: 'foo.bar' }, trans => {\n     *   // returns result of `foo` state's `myResolve` resolve\n     *   // even though `foo.bar` also has a `myResolve` resolve\n     *   var fooData = trans.injector('foo').get('myResolve');\n     * });\n     * ```\n     *\n     * If you need resolve data from the exiting states, pass `'from'` as `pathName`.\n     * The resolve data from the `from` path will be returned.\n     * #### Example:\n     * ```js\n     * .onExit({ exiting: 'foo.bar' }, trans => {\n     *   // Gets the resolve value of `myResolve` from the state being exited\n     *   var fooData = trans.injector(null, 'from').get('myResolve');\n     * });\n     * ```\n     *\n     *\n     * @param state Limits the resolves provided to only the resolves the provided state has access to.\n     * @param pathName Default: `'to'`: Chooses the path for which to create the injector. Use this to access resolves for `exiting` states.\n     *\n     * @returns a [[UIInjector]]\n     */\n    Transition.prototype.injector = function (state, pathName) {\n        if (pathName === void 0) { pathName = 'to'; }\n        var path = this._treeChanges[pathName];\n        if (state)\n            path = pathUtils_1.PathUtils.subPath(path, function (node) { return node.state === state || node.state.name === state; });\n        return new resolveContext_1.ResolveContext(path).injector();\n    };\n    /**\n     * Gets all available resolve tokens (keys)\n     *\n     * This method can be used in conjunction with [[injector]] to inspect the resolve values\n     * available to the Transition.\n     *\n     * This returns all the tokens defined on [[StateDeclaration.resolve]] blocks, for the states\n     * in the Transition's [[TreeChanges.to]] path.\n     *\n     * #### Example:\n     * This example logs all resolve values\n     * ```js\n     * let tokens = trans.getResolveTokens();\n     * tokens.forEach(token => console.log(token + \" = \" + trans.injector().get(token)));\n     * ```\n     *\n     * #### Example:\n     * This example creates promises for each resolve value.\n     * This triggers fetches of resolves (if any have not yet been fetched).\n     * When all promises have all settled, it logs the resolve values.\n     * ```js\n     * let tokens = trans.getResolveTokens();\n     * let promise = tokens.map(token => trans.injector().getAsync(token));\n     * Promise.all(promises).then(values => console.log(\"Resolved values: \" + values));\n     * ```\n     *\n     * Note: Angular 1 users whould use `$q.all()`\n     *\n     * @param pathname resolve context's path name (e.g., `to` or `from`)\n     *\n     * @returns an array of resolve tokens (keys)\n     */\n    Transition.prototype.getResolveTokens = function (pathname) {\n        if (pathname === void 0) { pathname = 'to'; }\n        return new resolveContext_1.ResolveContext(this._treeChanges[pathname]).getTokens();\n    };\n    /**\n     * Dynamically adds a new [[Resolvable]] (i.e., [[StateDeclaration.resolve]]) to this transition.\n     *\n     * Allows a transition hook to dynamically add a Resolvable to this Transition.\n     *\n     * Use the [[Transition.injector]] to retrieve the resolved data in subsequent hooks ([[UIInjector.get]]).\n     *\n     * If a `state` argument is provided, the Resolvable is processed when that state is being entered.\n     * If no `state` is provided then the root state is used.\n     * If the given `state` has already been entered, the Resolvable is processed when any child state is entered.\n     * If no child states will be entered, the Resolvable is processed during the `onFinish` phase of the Transition.\n     *\n     * The `state` argument also scopes the resolved data.\n     * The resolved data is available from the injector for that `state` and any children states.\n     *\n     * #### Example:\n     * ```js\n     * transitionService.onBefore({}, transition => {\n     *   transition.addResolvable({\n     *     token: 'myResolve',\n     *     deps: ['MyService'],\n     *     resolveFn: myService => myService.getData()\n     *   });\n     * });\n     * ```\n     *\n     * @param resolvable a [[ResolvableLiteral]] object (or a [[Resolvable]])\n     * @param state the state in the \"to path\" which should receive the new resolve (otherwise, the root state)\n     */\n    Transition.prototype.addResolvable = function (resolvable, state) {\n        if (state === void 0) { state = ''; }\n        resolvable = hof_1.is(resolvable_1.Resolvable)(resolvable) ? resolvable : new resolvable_1.Resolvable(resolvable);\n        var stateName = (typeof state === 'string') ? state : state.name;\n        var topath = this._treeChanges.to;\n        var targetNode = common_1.find(topath, function (node) { return node.state.name === stateName; });\n        var resolveContext = new resolveContext_1.ResolveContext(topath);\n        resolveContext.addResolvables([resolvable], targetNode.state);\n    };\n    /**\n     * Gets the transition from which this transition was redirected.\n     *\n     * If the current transition is a redirect, this method returns the transition that was redirected.\n     *\n     * #### Example:\n     * ```js\n     * let transitionA = $state.go('A').transition\n     * transitionA.onStart({}, () => $state.target('B'));\n     * $transitions.onSuccess({ to: 'B' }, (trans) => {\n     *   trans.to().name === 'B'; // true\n     *   trans.redirectedFrom() === transitionA; // true\n     * });\n     * ```\n     *\n     * @returns The previous Transition, or null if this Transition is not the result of a redirection\n     */\n    Transition.prototype.redirectedFrom = function () {\n        return this._options.redirectedFrom || null;\n    };\n    /**\n     * Gets the original transition in a redirect chain\n     *\n     * A transition might belong to a long chain of multiple redirects.\n     * This method walks the [[redirectedFrom]] chain back to the original (first) transition in the chain.\n     *\n     * #### Example:\n     * ```js\n     * // states\n     * registry.register({ name: 'A', redirectTo: 'B' });\n     * registry.register({ name: 'B', redirectTo: 'C' });\n     * registry.register({ name: 'C', redirectTo: 'D' });\n     * registry.register({ name: 'D' });\n     *\n     * let transitionA = $state.go('A').transition\n     *\n     * $transitions.onSuccess({ to: 'D' }, (trans) => {\n     *   trans.to().name === 'D'; // true\n     *   trans.redirectedFrom().to().name === 'C'; // true\n     *   trans.originalTransition() === transitionA; // true\n     *   trans.originalTransition().to().name === 'A'; // true\n     * });\n     * ```\n     *\n     * @returns The original Transition that started a redirect chain\n     */\n    Transition.prototype.originalTransition = function () {\n        var rf = this.redirectedFrom();\n        return (rf && rf.originalTransition()) || this;\n    };\n    /**\n     * Get the transition options\n     *\n     * @returns the options for this Transition.\n     */\n    Transition.prototype.options = function () {\n        return this._options;\n    };\n    /**\n     * Gets the states being entered.\n     *\n     * @returns an array of states that will be entered during this transition.\n     */\n    Transition.prototype.entering = function () {\n        return common_1.map(this._treeChanges.entering, hof_1.prop('state')).map(stateSelf);\n    };\n    /**\n     * Gets the states being exited.\n     *\n     * @returns an array of states that will be exited during this transition.\n     */\n    Transition.prototype.exiting = function () {\n        return common_1.map(this._treeChanges.exiting, hof_1.prop('state')).map(stateSelf).reverse();\n    };\n    /**\n     * Gets the states being retained.\n     *\n     * @returns an array of states that are already entered from a previous Transition, that will not be\n     *    exited during this Transition\n     */\n    Transition.prototype.retained = function () {\n        return common_1.map(this._treeChanges.retained, hof_1.prop('state')).map(stateSelf);\n    };\n    /**\n     * Get the [[ViewConfig]]s associated with this Transition\n     *\n     * Each state can define one or more views (template/controller), which are encapsulated as `ViewConfig` objects.\n     * This method fetches the `ViewConfigs` for a given path in the Transition (e.g., \"to\" or \"entering\").\n     *\n     * @param pathname the name of the path to fetch views for:\n     *   (`'to'`, `'from'`, `'entering'`, `'exiting'`, `'retained'`)\n     * @param state If provided, only returns the `ViewConfig`s for a single state in the path\n     *\n     * @returns a list of ViewConfig objects for the given path.\n     */\n    Transition.prototype.views = function (pathname, state) {\n        if (pathname === void 0) { pathname = 'entering'; }\n        var path = this._treeChanges[pathname];\n        path = !state ? path : path.filter(hof_1.propEq('state', state));\n        return path.map(hof_1.prop('views')).filter(common_1.identity).reduce(common_1.unnestR, []);\n    };\n    Transition.prototype.treeChanges = function (pathname) {\n        return pathname ? this._treeChanges[pathname] : this._treeChanges;\n    };\n    /**\n     * Creates a new transition that is a redirection of the current one.\n     *\n     * This transition can be returned from a [[TransitionService]] hook to\n     * redirect a transition to a new state and/or set of parameters.\n     *\n     * @internalapi\n     *\n     * @returns Returns a new [[Transition]] instance.\n     */\n    Transition.prototype.redirect = function (targetState) {\n        var redirects = 1, trans = this;\n        // tslint:disable-next-line:no-conditional-assignment\n        while ((trans = trans.redirectedFrom()) != null) {\n            if (++redirects > 20)\n                throw new Error(\"Too many consecutive Transition redirects (20+)\");\n        }\n        var redirectOpts = { redirectedFrom: this, source: 'redirect' };\n        // If the original transition was caused by URL sync, then use { location: 'replace' }\n        // on the new transition (unless the target state explicitly specifies location: false).\n        // This causes the original url to be replaced with the url for the redirect target\n        // so the original url disappears from the browser history.\n        if (this.options().source === 'url' && targetState.options().location !== false) {\n            redirectOpts.location = 'replace';\n        }\n        var newOptions = common_1.extend({}, this.options(), targetState.options(), redirectOpts);\n        targetState = targetState.withOptions(newOptions, true);\n        var newTransition = this.router.transitionService.create(this._treeChanges.from, targetState);\n        var originalEnteringNodes = this._treeChanges.entering;\n        var redirectEnteringNodes = newTransition._treeChanges.entering;\n        // --- Re-use resolve data from original transition ---\n        // When redirecting from a parent state to a child state where the parent parameter values haven't changed\n        // (because of the redirect), the resolves fetched by the original transition are still valid in the\n        // redirected transition.\n        //\n        // This allows you to define a redirect on a parent state which depends on an async resolve value.\n        // You can wait for the resolve, then redirect to a child state based on the result.\n        // The redirected transition does not have to re-fetch the resolve.\n        // ---------------------------------------------------------\n        var nodeIsReloading = function (reloadState) { return function (node) {\n            return reloadState && node.state.includes[reloadState.name];\n        }; };\n        // Find any \"entering\" nodes in the redirect path that match the original path and aren't being reloaded\n        var matchingEnteringNodes = pathUtils_1.PathUtils.matching(redirectEnteringNodes, originalEnteringNodes, pathUtils_1.PathUtils.nonDynamicParams)\n            .filter(hof_1.not(nodeIsReloading(targetState.options().reloadState)));\n        // Use the existing (possibly pre-resolved) resolvables for the matching entering nodes.\n        matchingEnteringNodes.forEach(function (node, idx) {\n            node.resolvables = originalEnteringNodes[idx].resolvables;\n        });\n        return newTransition;\n    };\n    /** @hidden If a transition doesn't exit/enter any states, returns any [[Param]] whose value changed */\n    Transition.prototype._changedParams = function () {\n        var tc = this._treeChanges;\n        /** Return undefined if it's not a \"dynamic\" transition, for the following reasons */\n        // If user explicitly wants a reload\n        if (this._options.reload)\n            return undefined;\n        // If any states are exiting or entering\n        if (tc.exiting.length || tc.entering.length)\n            return undefined;\n        // If to/from path lengths differ\n        if (tc.to.length !== tc.from.length)\n            return undefined;\n        // If the to/from paths are different\n        var pathsDiffer = common_1.arrayTuples(tc.to, tc.from)\n            .map(function (tuple) { return tuple[0].state !== tuple[1].state; })\n            .reduce(common_1.anyTrueR, false);\n        if (pathsDiffer)\n            return undefined;\n        // Find any parameter values that differ\n        var nodeSchemas = tc.to.map(function (node) { return node.paramSchema; });\n        var _a = [tc.to, tc.from].map(function (path) { return path.map(function (x) { return x.paramValues; }); }), toValues = _a[0], fromValues = _a[1];\n        var tuples = common_1.arrayTuples(nodeSchemas, toValues, fromValues);\n        return tuples.map(function (_a) {\n            var schema = _a[0], toVals = _a[1], fromVals = _a[2];\n            return param_1.Param.changed(schema, toVals, fromVals);\n        }).reduce(common_1.unnestR, []);\n    };\n    /**\n     * Returns true if the transition is dynamic.\n     *\n     * A transition is dynamic if no states are entered nor exited, but at least one dynamic parameter has changed.\n     *\n     * @returns true if the Transition is dynamic\n     */\n    Transition.prototype.dynamic = function () {\n        var changes = this._changedParams();\n        return !changes ? false : changes.map(function (x) { return x.dynamic; }).reduce(common_1.anyTrueR, false);\n    };\n    /**\n     * Returns true if the transition is ignored.\n     *\n     * A transition is ignored if no states are entered nor exited, and no parameter values have changed.\n     *\n     * @returns true if the Transition is ignored.\n     */\n    Transition.prototype.ignored = function () {\n        return !!this._ignoredReason();\n    };\n    /** @hidden */\n    Transition.prototype._ignoredReason = function () {\n        var pending = this.router.globals.transition;\n        var reloadState = this._options.reloadState;\n        var same = function (pathA, pathB) {\n            if (pathA.length !== pathB.length)\n                return false;\n            var matching = pathUtils_1.PathUtils.matching(pathA, pathB);\n            return pathA.length === matching.filter(function (node) { return !reloadState || !node.state.includes[reloadState.name]; }).length;\n        };\n        var newTC = this.treeChanges();\n        var pendTC = pending && pending.treeChanges();\n        if (pendTC && same(pendTC.to, newTC.to) && same(pendTC.exiting, newTC.exiting))\n            return 'SameAsPending';\n        if (newTC.exiting.length === 0 && newTC.entering.length === 0 && same(newTC.from, newTC.to))\n            return 'SameAsCurrent';\n    };\n    /**\n     * Runs the transition\n     *\n     * This method is generally called from the [[StateService.transitionTo]]\n     *\n     * @internalapi\n     *\n     * @returns a promise for a successful transition.\n     */\n    Transition.prototype.run = function () {\n        var _this = this;\n        var runAllHooks = transitionHook_1.TransitionHook.runAllHooks;\n        // Gets transition hooks array for the given phase\n        var getHooksFor = function (phase) {\n            return _this._hookBuilder.buildHooksForPhase(phase);\n        };\n        // When the chain is complete, then resolve or reject the deferred\n        var transitionSuccess = function () {\n            trace_1.trace.traceSuccess(_this.$to(), _this);\n            _this.success = true;\n            _this._deferred.resolve(_this.to());\n            runAllHooks(getHooksFor(interface_1.TransitionHookPhase.SUCCESS));\n        };\n        var transitionError = function (reason) {\n            trace_1.trace.traceError(reason, _this);\n            _this.success = false;\n            _this._deferred.reject(reason);\n            _this._error = reason;\n            runAllHooks(getHooksFor(interface_1.TransitionHookPhase.ERROR));\n        };\n        var runTransition = function () {\n            // Wait to build the RUN hook chain until the BEFORE hooks are done\n            // This allows a BEFORE hook to dynamically add additional RUN hooks via the Transition object.\n            var allRunHooks = getHooksFor(interface_1.TransitionHookPhase.RUN);\n            var done = function () { return coreservices_1.services.$q.when(undefined); };\n            return transitionHook_1.TransitionHook.invokeHooks(allRunHooks, done);\n        };\n        var startTransition = function () {\n            var globals = _this.router.globals;\n            globals.lastStartedTransitionId = _this.$id;\n            globals.transition = _this;\n            globals.transitionHistory.enqueue(_this);\n            trace_1.trace.traceTransitionStart(_this);\n            return coreservices_1.services.$q.when(undefined);\n        };\n        var allBeforeHooks = getHooksFor(interface_1.TransitionHookPhase.BEFORE);\n        transitionHook_1.TransitionHook.invokeHooks(allBeforeHooks, startTransition)\n            .then(runTransition)\n            .then(transitionSuccess, transitionError);\n        return this.promise;\n    };\n    /**\n     * Checks if the Transition is valid\n     *\n     * @returns true if the Transition is valid\n     */\n    Transition.prototype.valid = function () {\n        return !this.error() || this.success !== undefined;\n    };\n    /**\n     * Aborts this transition\n     *\n     * Imperative API to abort a Transition.\n     * This only applies to Transitions that are not yet complete.\n     */\n    Transition.prototype.abort = function () {\n        // Do not set flag if the transition is already complete\n        if (predicates_1.isUndefined(this.success)) {\n            this._aborted = true;\n        }\n    };\n    /**\n     * The Transition error reason.\n     *\n     * If the transition is invalid (and could not be run), returns the reason the transition is invalid.\n     * If the transition was valid and ran, but was not successful, returns the reason the transition failed.\n     *\n     * @returns an error message explaining why the transition is invalid, or the reason the transition failed.\n     */\n    Transition.prototype.error = function () {\n        var state = this.$to();\n        if (state.self.abstract)\n            return \"Cannot transition to abstract state '\" + state.name + \"'\";\n        var paramDefs = state.parameters(), values = this.params();\n        var invalidParams = paramDefs.filter(function (param) { return !param.validates(values[param.id]); });\n        if (invalidParams.length) {\n            return \"Param values not valid for state '\" + state.name + \"'. Invalid params: [ \" + invalidParams.map(function (param) { return param.id; }).join(', ') + \" ]\";\n        }\n        if (this.success === false)\n            return this._error;\n    };\n    /**\n     * A string representation of the Transition\n     *\n     * @returns A string representation of the Transition\n     */\n    Transition.prototype.toString = function () {\n        var fromStateOrName = this.from();\n        var toStateOrName = this.to();\n        var avoidEmptyHash = function (params) {\n            return (params['#'] !== null && params['#'] !== undefined) ? params : common_1.omit(params, ['#']);\n        };\n        // (X) means the to state is invalid.\n        var id = this.$id, from = predicates_1.isObject(fromStateOrName) ? fromStateOrName.name : fromStateOrName, fromParams = strings_1.stringify(avoidEmptyHash(this._treeChanges.from.map(hof_1.prop('paramValues')).reduce(common_1.mergeR, {}))), toValid = this.valid() ? '' : '(X) ', to = predicates_1.isObject(toStateOrName) ? toStateOrName.name : toStateOrName, toParams = strings_1.stringify(avoidEmptyHash(this.params()));\n        return \"Transition#\" + id + \"( '\" + from + \"'\" + fromParams + \" -> \" + toValid + \"'\" + to + \"'\" + toParams + \" )\";\n    };\n    /** @hidden */\n    Transition.diToken = Transition;\n    return Transition;\n}());\nexports.Transition = Transition;\n//# sourceMappingURL=transition.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3RyYW5zaXRpb24vdHJhbnNpdGlvbi5qcz82MTMzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAY29yZWFwaVxuICogQG1vZHVsZSB0cmFuc2l0aW9uXG4gKi9cbi8qKiBmb3IgdHlwZWRvYyAqL1xudmFyIHRyYWNlXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3RyYWNlXCIpO1xudmFyIGNvcmVzZXJ2aWNlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb3Jlc2VydmljZXNcIik7XG52YXIgc3RyaW5nc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9zdHJpbmdzXCIpO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb21tb25cIik7XG52YXIgcHJlZGljYXRlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9wcmVkaWNhdGVzXCIpO1xudmFyIGhvZl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9ob2ZcIik7XG52YXIgaW50ZXJmYWNlXzEgPSByZXF1aXJlKFwiLi9pbnRlcmZhY2VcIik7IC8vIGhhcyBvciBpcyB1c2luZ1xudmFyIHRyYW5zaXRpb25Ib29rXzEgPSByZXF1aXJlKFwiLi90cmFuc2l0aW9uSG9va1wiKTtcbnZhciBob29rUmVnaXN0cnlfMSA9IHJlcXVpcmUoXCIuL2hvb2tSZWdpc3RyeVwiKTtcbnZhciBob29rQnVpbGRlcl8xID0gcmVxdWlyZShcIi4vaG9va0J1aWxkZXJcIik7XG52YXIgcGF0aFV0aWxzXzEgPSByZXF1aXJlKFwiLi4vcGF0aC9wYXRoVXRpbHNcIik7XG52YXIgcGFyYW1fMSA9IHJlcXVpcmUoXCIuLi9wYXJhbXMvcGFyYW1cIik7XG52YXIgcmVzb2x2YWJsZV8xID0gcmVxdWlyZShcIi4uL3Jlc29sdmUvcmVzb2x2YWJsZVwiKTtcbnZhciByZXNvbHZlQ29udGV4dF8xID0gcmVxdWlyZShcIi4uL3Jlc29sdmUvcmVzb2x2ZUNvbnRleHRcIik7XG4vKiogQGhpZGRlbiAqL1xudmFyIHN0YXRlU2VsZiA9IGhvZl8xLnByb3AoJ3NlbGYnKTtcbi8qKlxuICogUmVwcmVzZW50cyBhIHRyYW5zaXRpb24gYmV0d2VlbiB0d28gc3RhdGVzLlxuICpcbiAqIFdoZW4gbmF2aWdhdGluZyB0byBhIHN0YXRlLCB3ZSBhcmUgdHJhbnNpdGlvbmluZyAqKmZyb20qKiB0aGUgY3VycmVudCBzdGF0ZSAqKnRvKiogdGhlIG5ldyBzdGF0ZS5cbiAqXG4gKiBUaGlzIG9iamVjdCBjb250YWlucyBhbGwgY29udGV4dHVhbCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgdG8vZnJvbSBzdGF0ZXMsIHBhcmFtZXRlcnMsIHJlc29sdmVzLlxuICogSXQgaGFzIGluZm9ybWF0aW9uIGFib3V0IGFsbCBzdGF0ZXMgYmVpbmcgZW50ZXJlZCBhbmQgZXhpdGVkIGFzIGEgcmVzdWx0IG9mIHRoZSB0cmFuc2l0aW9uLlxuICovXG52YXIgVHJhbnNpdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFRyYW5zaXRpb24gb2JqZWN0LlxuICAgICAqXG4gICAgICogSWYgdGhlIHRhcmdldCBzdGF0ZSBpcyBub3QgdmFsaWQsIGFuIGVycm9yIGlzIHRocm93bi5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbGFwaVxuICAgICAqXG4gICAgICogQHBhcmFtIGZyb21QYXRoIFRoZSBwYXRoIG9mIFtbUGF0aE5vZGVdXXMgZnJvbSB3aGljaCB0aGUgdHJhbnNpdGlvbiBpcyBsZWF2aW5nLiAgVGhlIGxhc3Qgbm9kZSBpbiB0aGUgYGZyb21QYXRoYFxuICAgICAqICAgICAgICBlbmNhcHN1bGF0ZXMgdGhlIFwiZnJvbSBzdGF0ZVwiLlxuICAgICAqIEBwYXJhbSB0YXJnZXRTdGF0ZSBUaGUgdGFyZ2V0IHN0YXRlIGFuZCBwYXJhbWV0ZXJzIGJlaW5nIHRyYW5zaXRpb25lZCB0byAoYWxzbywgdGhlIHRyYW5zaXRpb24gb3B0aW9ucylcbiAgICAgKiBAcGFyYW0gcm91dGVyIFRoZSBbW1VJUm91dGVyXV0gaW5zdGFuY2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBUcmFuc2l0aW9uKGZyb21QYXRoLCB0YXJnZXRTdGF0ZSwgcm91dGVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8qKiBAaGlkZGVuICovXG4gICAgICAgIHRoaXMuX2RlZmVycmVkID0gY29yZXNlcnZpY2VzXzEuc2VydmljZXMuJHEuZGVmZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgcHJvbWlzZSBpcyByZXNvbHZlZCBvciByZWplY3RlZCBiYXNlZCBvbiB0aGUgb3V0Y29tZSBvZiB0aGUgVHJhbnNpdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogV2hlbiB0aGUgdHJhbnNpdGlvbiBpcyBzdWNjZXNzZnVsLCB0aGUgcHJvbWlzZSBpcyByZXNvbHZlZFxuICAgICAgICAgKiBXaGVuIHRoZSB0cmFuc2l0aW9uIGlzIHVuc3VjY2Vzc2Z1bCwgdGhlIHByb21pc2UgaXMgcmVqZWN0ZWQgd2l0aCB0aGUgW1tSZWplY3Rpb25dXSBvciBqYXZhc2NyaXB0IGVycm9yXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnByb21pc2UgPSB0aGlzLl9kZWZlcnJlZC5wcm9taXNlO1xuICAgICAgICAvKiogQGhpZGRlbiBIb2xkcyB0aGUgaG9vayByZWdpc3RyYXRpb24gZnVuY3Rpb25zIHN1Y2ggYXMgdGhvc2UgcGFzc2VkIHRvIFRyYW5zaXRpb24ub25TdGFydCgpICovXG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyZWRIb29rcyA9IHt9O1xuICAgICAgICAvKiogQGhpZGRlbiAqL1xuICAgICAgICB0aGlzLl9ob29rQnVpbGRlciA9IG5ldyBob29rQnVpbGRlcl8xLkhvb2tCdWlsZGVyKHRoaXMpO1xuICAgICAgICAvKiogQ2hlY2tzIGlmIHRoaXMgdHJhbnNpdGlvbiBpcyBjdXJyZW50bHkgYWN0aXZlL3J1bm5pbmcuICovXG4gICAgICAgIHRoaXMuaXNBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMucm91dGVyLmdsb2JhbHMudHJhbnNpdGlvbiA9PT0gX3RoaXM7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucm91dGVyID0gcm91dGVyO1xuICAgICAgICB0aGlzLl90YXJnZXRTdGF0ZSA9IHRhcmdldFN0YXRlO1xuICAgICAgICBpZiAoIXRhcmdldFN0YXRlLnZhbGlkKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcih0YXJnZXRTdGF0ZS5lcnJvcigpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjdXJyZW50KCkgaXMgYXNzdW1lZCB0byBjb21lIGZyb20gdGFyZ2V0U3RhdGUub3B0aW9ucywgYnV0IHByb3ZpZGUgYSBuYWl2ZSBpbXBsZW1lbnRhdGlvbiBvdGhlcndpc2UuXG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSBjb21tb25fMS5leHRlbmQoeyBjdXJyZW50OiBob2ZfMS52YWwodGhpcykgfSwgdGFyZ2V0U3RhdGUub3B0aW9ucygpKTtcbiAgICAgICAgdGhpcy4kaWQgPSByb3V0ZXIudHJhbnNpdGlvblNlcnZpY2UuX3RyYW5zaXRpb25Db3VudCsrO1xuICAgICAgICB2YXIgdG9QYXRoID0gcGF0aFV0aWxzXzEuUGF0aFV0aWxzLmJ1aWxkVG9QYXRoKGZyb21QYXRoLCB0YXJnZXRTdGF0ZSk7XG4gICAgICAgIHRoaXMuX3RyZWVDaGFuZ2VzID0gcGF0aFV0aWxzXzEuUGF0aFV0aWxzLnRyZWVDaGFuZ2VzKGZyb21QYXRoLCB0b1BhdGgsIHRoaXMuX29wdGlvbnMucmVsb2FkU3RhdGUpO1xuICAgICAgICB0aGlzLmNyZWF0ZVRyYW5zaXRpb25Ib29rUmVnRm5zKCk7XG4gICAgICAgIHZhciBvbkNyZWF0ZUhvb2tzID0gdGhpcy5faG9va0J1aWxkZXIuYnVpbGRIb29rc0ZvclBoYXNlKGludGVyZmFjZV8xLlRyYW5zaXRpb25Ib29rUGhhc2UuQ1JFQVRFKTtcbiAgICAgICAgdHJhbnNpdGlvbkhvb2tfMS5UcmFuc2l0aW9uSG9vay5pbnZva2VIb29rcyhvbkNyZWF0ZUhvb2tzLCBmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9KTtcbiAgICAgICAgdGhpcy5hcHBseVZpZXdDb25maWdzKHJvdXRlcik7XG4gICAgfVxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgVHJhbnNpdGlvbi5wcm90b3R5cGUub25CZWZvcmUgPSBmdW5jdGlvbiAoY3JpdGVyaWEsIGNhbGxiYWNrLCBvcHRpb25zKSB7IHJldHVybjsgfTtcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5vblN0YXJ0ID0gZnVuY3Rpb24gKGNyaXRlcmlhLCBjYWxsYmFjaywgb3B0aW9ucykgeyByZXR1cm47IH07XG4gICAgLyoqIEBpbmhlcml0ZG9jICovXG4gICAgVHJhbnNpdGlvbi5wcm90b3R5cGUub25FeGl0ID0gZnVuY3Rpb24gKGNyaXRlcmlhLCBjYWxsYmFjaywgb3B0aW9ucykgeyByZXR1cm47IH07XG4gICAgLyoqIEBpbmhlcml0ZG9jICovXG4gICAgVHJhbnNpdGlvbi5wcm90b3R5cGUub25SZXRhaW4gPSBmdW5jdGlvbiAoY3JpdGVyaWEsIGNhbGxiYWNrLCBvcHRpb25zKSB7IHJldHVybjsgfTtcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5vbkVudGVyID0gZnVuY3Rpb24gKGNyaXRlcmlhLCBjYWxsYmFjaywgb3B0aW9ucykgeyByZXR1cm47IH07XG4gICAgLyoqIEBpbmhlcml0ZG9jICovXG4gICAgVHJhbnNpdGlvbi5wcm90b3R5cGUub25GaW5pc2ggPSBmdW5jdGlvbiAoY3JpdGVyaWEsIGNhbGxiYWNrLCBvcHRpb25zKSB7IHJldHVybjsgfTtcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5vblN1Y2Nlc3MgPSBmdW5jdGlvbiAoY3JpdGVyaWEsIGNhbGxiYWNrLCBvcHRpb25zKSB7IHJldHVybjsgfTtcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gKGNyaXRlcmlhLCBjYWxsYmFjaywgb3B0aW9ucykgeyByZXR1cm47IH07XG4gICAgLyoqIEBoaWRkZW5cbiAgICAgKiBDcmVhdGVzIHRoZSB0cmFuc2l0aW9uLWxldmVsIGhvb2sgcmVnaXN0cmF0aW9uIGZ1bmN0aW9uc1xuICAgICAqICh3aGljaCBjYW4gdGhlbiBiZSB1c2VkIHRvIHJlZ2lzdGVyIGhvb2tzKVxuICAgICAqL1xuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLmNyZWF0ZVRyYW5zaXRpb25Ib29rUmVnRm5zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnJvdXRlci50cmFuc2l0aW9uU2VydmljZS5fcGx1Z2luYXBpLl9nZXRFdmVudHMoKVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gdHlwZS5ob29rUGhhc2UgIT09IGludGVyZmFjZV8xLlRyYW5zaXRpb25Ib29rUGhhc2UuQ1JFQVRFOyB9KVxuICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHsgcmV0dXJuIGhvb2tSZWdpc3RyeV8xLm1ha2VFdmVudChfdGhpcywgX3RoaXMucm91dGVyLnRyYW5zaXRpb25TZXJ2aWNlLCB0eXBlKTsgfSk7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsYXBpICovXG4gICAgVHJhbnNpdGlvbi5wcm90b3R5cGUuZ2V0SG9va3MgPSBmdW5jdGlvbiAoaG9va05hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZ2lzdGVyZWRIb29rc1tob29rTmFtZV07XG4gICAgfTtcbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5hcHBseVZpZXdDb25maWdzID0gZnVuY3Rpb24gKHJvdXRlcikge1xuICAgICAgICB2YXIgZW50ZXJpbmdTdGF0ZXMgPSB0aGlzLl90cmVlQ2hhbmdlcy5lbnRlcmluZy5tYXAoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUuc3RhdGU7IH0pO1xuICAgICAgICBwYXRoVXRpbHNfMS5QYXRoVXRpbHMuYXBwbHlWaWV3Q29uZmlncyhyb3V0ZXIudHJhbnNpdGlvblNlcnZpY2UuJHZpZXcsIHRoaXMuX3RyZWVDaGFuZ2VzLnRvLCBlbnRlcmluZ1N0YXRlcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxhcGlcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHRoZSBpbnRlcm5hbCBmcm9tIFtTdGF0ZV0gb2JqZWN0XG4gICAgICovXG4gICAgVHJhbnNpdGlvbi5wcm90b3R5cGUuJGZyb20gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjb21tb25fMS50YWlsKHRoaXMuX3RyZWVDaGFuZ2VzLmZyb20pLnN0YXRlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGludGVybmFsYXBpXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB0aGUgaW50ZXJuYWwgdG8gW1N0YXRlXSBvYmplY3RcbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS4kdG8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjb21tb25fMS50YWlsKHRoaXMuX3RyZWVDaGFuZ2VzLnRvKS5zdGF0ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIFwiZnJvbSBzdGF0ZVwiXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIHRoZSBzdGF0ZSB0aGF0IHRoZSB0cmFuc2l0aW9uIGlzIGNvbWluZyAqZnJvbSouXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgc3RhdGUgZGVjbGFyYXRpb24gb2JqZWN0IGZvciB0aGUgVHJhbnNpdGlvbidzIChcImZyb20gc3RhdGVcIikuXG4gICAgICovXG4gICAgVHJhbnNpdGlvbi5wcm90b3R5cGUuZnJvbSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGZyb20oKS5zZWxmO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgXCJ0byBzdGF0ZVwiXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIHRoZSBzdGF0ZSB0aGF0IHRoZSB0cmFuc2l0aW9uIGlzIGdvaW5nICp0byouXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgc3RhdGUgZGVjbGFyYXRpb24gb2JqZWN0IGZvciB0aGUgVHJhbnNpdGlvbidzIHRhcmdldCBzdGF0ZSAoXCJ0byBzdGF0ZVwiKS5cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS50byA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHRvKCkuc2VsZjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIFRhcmdldCBTdGF0ZVxuICAgICAqXG4gICAgICogQSB0cmFuc2l0aW9uJ3MgW1tUYXJnZXRTdGF0ZV1dIGVuY2Fwc3VsYXRlcyB0aGUgW1t0b11dIHN0YXRlLCB0aGUgW1twYXJhbXNdXSwgYW5kIHRoZSBbW29wdGlvbnNdXSBhcyBhIHNpbmdsZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB0aGUgW1tUYXJnZXRTdGF0ZV1dIG9mIHRoaXMgVHJhbnNpdGlvblxuICAgICAqL1xuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLnRhcmdldFN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGFyZ2V0U3RhdGU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdHdvIHRyYW5zaXRpb25zIGFyZSBlcXVpdmFsZW50LlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gICAgVHJhbnNpdGlvbi5wcm90b3R5cGUuaXMgPSBmdW5jdGlvbiAoY29tcGFyZSkge1xuICAgICAgICBpZiAoY29tcGFyZSBpbnN0YW5jZW9mIFRyYW5zaXRpb24pIHtcbiAgICAgICAgICAgIC8vIFRPRE86IEFsc28gY29tcGFyZSBwYXJhbWV0ZXJzXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pcyh7IHRvOiBjb21wYXJlLiR0bygpLm5hbWUsIGZyb206IGNvbXBhcmUuJGZyb20oKS5uYW1lIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhKChjb21wYXJlLnRvICYmICFob29rUmVnaXN0cnlfMS5tYXRjaFN0YXRlKHRoaXMuJHRvKCksIGNvbXBhcmUudG8pKSB8fFxuICAgICAgICAgICAgKGNvbXBhcmUuZnJvbSAmJiAhaG9va1JlZ2lzdHJ5XzEubWF0Y2hTdGF0ZSh0aGlzLiRmcm9tKCksIGNvbXBhcmUuZnJvbSkpKTtcbiAgICB9O1xuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLnBhcmFtcyA9IGZ1bmN0aW9uIChwYXRobmFtZSkge1xuICAgICAgICBpZiAocGF0aG5hbWUgPT09IHZvaWQgMCkgeyBwYXRobmFtZSA9ICd0byc7IH1cbiAgICAgICAgcmV0dXJuIE9iamVjdC5mcmVlemUodGhpcy5fdHJlZUNoYW5nZXNbcGF0aG5hbWVdLm1hcChob2ZfMS5wcm9wKCdwYXJhbVZhbHVlcycpKS5yZWR1Y2UoY29tbW9uXzEubWVyZ2VSLCB7fSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFtbVUlJbmplY3Rvcl1dIERlcGVuZGVuY3kgSW5qZWN0b3JcbiAgICAgKlxuICAgICAqIFJldHVybnMgYSBEZXBlbmRlbmN5IEluamVjdG9yIGZvciB0aGUgVHJhbnNpdGlvbidzIHRhcmdldCBzdGF0ZSAodG8gc3RhdGUpLlxuICAgICAqIFRoZSBpbmplY3RvciBwcm92aWRlcyByZXNvbHZlIHZhbHVlcyB3aGljaCB0aGUgdGFyZ2V0IHN0YXRlIGhhcyBhY2Nlc3MgdG8uXG4gICAgICpcbiAgICAgKiBUaGUgYFVJSW5qZWN0b3JgIGNhbiBhbHNvIHByb3ZpZGUgdmFsdWVzIGZyb20gdGhlIG5hdGl2ZSByb290L2dsb2JhbCBpbmplY3RvciAobmcxL25nMikuXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGU6XG4gICAgICogYGBganNcbiAgICAgKiAub25FbnRlcih7IGVudGVyaW5nOiAnbXlTdGF0ZScgfSwgdHJhbnMgPT4ge1xuICAgICAqICAgdmFyIG15UmVzb2x2ZVZhbHVlID0gdHJhbnMuaW5qZWN0b3IoKS5nZXQoJ215UmVzb2x2ZScpO1xuICAgICAqICAgLy8gSW5qZWN0IGEgZ2xvYmFsIHNlcnZpY2UgZnJvbSB0aGUgZ2xvYmFsL25hdGl2ZSBpbmplY3RvciAoaWYgaXQgZXhpc3RzKVxuICAgICAqICAgdmFyIE15U2VydmljZSA9IHRyYW5zLmluamVjdG9yKCkuZ2V0KCdNeVNlcnZpY2UnKTtcbiAgICAgKiB9KVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogSW4gc29tZSBjYXNlcyAoc3VjaCBhcyBgb25CZWZvcmVgKSwgeW91IG1heSBuZWVkIGFjY2VzcyB0byBzb21lIHJlc29sdmUgZGF0YSBidXQgaXQgaGFzIG5vdCB5ZXQgYmVlbiBmZXRjaGVkLlxuICAgICAqIFlvdSBjYW4gdXNlIFtbVUlJbmplY3Rvci5nZXRBc3luY11dIHRvIGdldCBhIHByb21pc2UgZm9yIHRoZSBkYXRhLlxuICAgICAqICMjIyMgRXhhbXBsZTpcbiAgICAgKiBgYGBqc1xuICAgICAqIC5vbkJlZm9yZSh7fSwgdHJhbnMgPT4ge1xuICAgICAqICAgcmV0dXJuIHRyYW5zLmluamVjdG9yKCkuZ2V0QXN5bmMoJ215UmVzb2x2ZScpLnRoZW4obXlSZXNvbHZlVmFsdWUgPT5cbiAgICAgKiAgICAgcmV0dXJuIG15UmVzb2x2ZVZhbHVlICE9PSAnQUJPUlQnO1xuICAgICAqICAgfSk7XG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBJZiBhIGBzdGF0ZWAgaXMgcHJvdmlkZWQsIHRoZSBpbmplY3RvciB0aGF0IGlzIHJldHVybmVkIHdpbGwgYmUgbGltaXRlZCB0byByZXNvbHZlIHZhbHVlcyB0aGF0IHRoZSBwcm92aWRlZCBzdGF0ZSBoYXMgYWNjZXNzIHRvLlxuICAgICAqIFRoaXMgY2FuIGJlIHVzZWZ1bCBpZiBib3RoIGEgcGFyZW50IHN0YXRlIGBmb29gIGFuZCBhIGNoaWxkIHN0YXRlIGBmb28uYmFyYCBoYXZlIGJvdGggZGVmaW5lZCBhIHJlc29sdmUgc3VjaCBhcyBgZGF0YWAuXG4gICAgICogIyMjIyBFeGFtcGxlOlxuICAgICAqIGBgYGpzXG4gICAgICogLm9uRW50ZXIoeyB0bzogJ2Zvby5iYXInIH0sIHRyYW5zID0+IHtcbiAgICAgKiAgIC8vIHJldHVybnMgcmVzdWx0IG9mIGBmb29gIHN0YXRlJ3MgYG15UmVzb2x2ZWAgcmVzb2x2ZVxuICAgICAqICAgLy8gZXZlbiB0aG91Z2ggYGZvby5iYXJgIGFsc28gaGFzIGEgYG15UmVzb2x2ZWAgcmVzb2x2ZVxuICAgICAqICAgdmFyIGZvb0RhdGEgPSB0cmFucy5pbmplY3RvcignZm9vJykuZ2V0KCdteVJlc29sdmUnKTtcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIElmIHlvdSBuZWVkIHJlc29sdmUgZGF0YSBmcm9tIHRoZSBleGl0aW5nIHN0YXRlcywgcGFzcyBgJ2Zyb20nYCBhcyBgcGF0aE5hbWVgLlxuICAgICAqIFRoZSByZXNvbHZlIGRhdGEgZnJvbSB0aGUgYGZyb21gIHBhdGggd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKiAjIyMjIEV4YW1wbGU6XG4gICAgICogYGBganNcbiAgICAgKiAub25FeGl0KHsgZXhpdGluZzogJ2Zvby5iYXInIH0sIHRyYW5zID0+IHtcbiAgICAgKiAgIC8vIEdldHMgdGhlIHJlc29sdmUgdmFsdWUgb2YgYG15UmVzb2x2ZWAgZnJvbSB0aGUgc3RhdGUgYmVpbmcgZXhpdGVkXG4gICAgICogICB2YXIgZm9vRGF0YSA9IHRyYW5zLmluamVjdG9yKG51bGwsICdmcm9tJykuZ2V0KCdteVJlc29sdmUnKTtcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0YXRlIExpbWl0cyB0aGUgcmVzb2x2ZXMgcHJvdmlkZWQgdG8gb25seSB0aGUgcmVzb2x2ZXMgdGhlIHByb3ZpZGVkIHN0YXRlIGhhcyBhY2Nlc3MgdG8uXG4gICAgICogQHBhcmFtIHBhdGhOYW1lIERlZmF1bHQ6IGAndG8nYDogQ2hvb3NlcyB0aGUgcGF0aCBmb3Igd2hpY2ggdG8gY3JlYXRlIHRoZSBpbmplY3Rvci4gVXNlIHRoaXMgdG8gYWNjZXNzIHJlc29sdmVzIGZvciBgZXhpdGluZ2Agc3RhdGVzLlxuICAgICAqXG4gICAgICogQHJldHVybnMgYSBbW1VJSW5qZWN0b3JdXVxuICAgICAqL1xuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLmluamVjdG9yID0gZnVuY3Rpb24gKHN0YXRlLCBwYXRoTmFtZSkge1xuICAgICAgICBpZiAocGF0aE5hbWUgPT09IHZvaWQgMCkgeyBwYXRoTmFtZSA9ICd0byc7IH1cbiAgICAgICAgdmFyIHBhdGggPSB0aGlzLl90cmVlQ2hhbmdlc1twYXRoTmFtZV07XG4gICAgICAgIGlmIChzdGF0ZSlcbiAgICAgICAgICAgIHBhdGggPSBwYXRoVXRpbHNfMS5QYXRoVXRpbHMuc3ViUGF0aChwYXRoLCBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS5zdGF0ZSA9PT0gc3RhdGUgfHwgbm9kZS5zdGF0ZS5uYW1lID09PSBzdGF0ZTsgfSk7XG4gICAgICAgIHJldHVybiBuZXcgcmVzb2x2ZUNvbnRleHRfMS5SZXNvbHZlQ29udGV4dChwYXRoKS5pbmplY3RvcigpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyBhbGwgYXZhaWxhYmxlIHJlc29sdmUgdG9rZW5zIChrZXlzKVxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgY2FuIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBbW2luamVjdG9yXV0gdG8gaW5zcGVjdCB0aGUgcmVzb2x2ZSB2YWx1ZXNcbiAgICAgKiBhdmFpbGFibGUgdG8gdGhlIFRyYW5zaXRpb24uXG4gICAgICpcbiAgICAgKiBUaGlzIHJldHVybnMgYWxsIHRoZSB0b2tlbnMgZGVmaW5lZCBvbiBbW1N0YXRlRGVjbGFyYXRpb24ucmVzb2x2ZV1dIGJsb2NrcywgZm9yIHRoZSBzdGF0ZXNcbiAgICAgKiBpbiB0aGUgVHJhbnNpdGlvbidzIFtbVHJlZUNoYW5nZXMudG9dXSBwYXRoLlxuICAgICAqXG4gICAgICogIyMjIyBFeGFtcGxlOlxuICAgICAqIFRoaXMgZXhhbXBsZSBsb2dzIGFsbCByZXNvbHZlIHZhbHVlc1xuICAgICAqIGBgYGpzXG4gICAgICogbGV0IHRva2VucyA9IHRyYW5zLmdldFJlc29sdmVUb2tlbnMoKTtcbiAgICAgKiB0b2tlbnMuZm9yRWFjaCh0b2tlbiA9PiBjb25zb2xlLmxvZyh0b2tlbiArIFwiID0gXCIgKyB0cmFucy5pbmplY3RvcigpLmdldCh0b2tlbikpKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqICMjIyMgRXhhbXBsZTpcbiAgICAgKiBUaGlzIGV4YW1wbGUgY3JlYXRlcyBwcm9taXNlcyBmb3IgZWFjaCByZXNvbHZlIHZhbHVlLlxuICAgICAqIFRoaXMgdHJpZ2dlcnMgZmV0Y2hlcyBvZiByZXNvbHZlcyAoaWYgYW55IGhhdmUgbm90IHlldCBiZWVuIGZldGNoZWQpLlxuICAgICAqIFdoZW4gYWxsIHByb21pc2VzIGhhdmUgYWxsIHNldHRsZWQsIGl0IGxvZ3MgdGhlIHJlc29sdmUgdmFsdWVzLlxuICAgICAqIGBgYGpzXG4gICAgICogbGV0IHRva2VucyA9IHRyYW5zLmdldFJlc29sdmVUb2tlbnMoKTtcbiAgICAgKiBsZXQgcHJvbWlzZSA9IHRva2Vucy5tYXAodG9rZW4gPT4gdHJhbnMuaW5qZWN0b3IoKS5nZXRBc3luYyh0b2tlbikpO1xuICAgICAqIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKHZhbHVlcyA9PiBjb25zb2xlLmxvZyhcIlJlc29sdmVkIHZhbHVlczogXCIgKyB2YWx1ZXMpKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIE5vdGU6IEFuZ3VsYXIgMSB1c2VycyB3aG91bGQgdXNlIGAkcS5hbGwoKWBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXRobmFtZSByZXNvbHZlIGNvbnRleHQncyBwYXRoIG5hbWUgKGUuZy4sIGB0b2Agb3IgYGZyb21gKVxuICAgICAqXG4gICAgICogQHJldHVybnMgYW4gYXJyYXkgb2YgcmVzb2x2ZSB0b2tlbnMgKGtleXMpXG4gICAgICovXG4gICAgVHJhbnNpdGlvbi5wcm90b3R5cGUuZ2V0UmVzb2x2ZVRva2VucyA9IGZ1bmN0aW9uIChwYXRobmFtZSkge1xuICAgICAgICBpZiAocGF0aG5hbWUgPT09IHZvaWQgMCkgeyBwYXRobmFtZSA9ICd0byc7IH1cbiAgICAgICAgcmV0dXJuIG5ldyByZXNvbHZlQ29udGV4dF8xLlJlc29sdmVDb250ZXh0KHRoaXMuX3RyZWVDaGFuZ2VzW3BhdGhuYW1lXSkuZ2V0VG9rZW5zKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEeW5hbWljYWxseSBhZGRzIGEgbmV3IFtbUmVzb2x2YWJsZV1dIChpLmUuLCBbW1N0YXRlRGVjbGFyYXRpb24ucmVzb2x2ZV1dKSB0byB0aGlzIHRyYW5zaXRpb24uXG4gICAgICpcbiAgICAgKiBBbGxvd3MgYSB0cmFuc2l0aW9uIGhvb2sgdG8gZHluYW1pY2FsbHkgYWRkIGEgUmVzb2x2YWJsZSB0byB0aGlzIFRyYW5zaXRpb24uXG4gICAgICpcbiAgICAgKiBVc2UgdGhlIFtbVHJhbnNpdGlvbi5pbmplY3Rvcl1dIHRvIHJldHJpZXZlIHRoZSByZXNvbHZlZCBkYXRhIGluIHN1YnNlcXVlbnQgaG9va3MgKFtbVUlJbmplY3Rvci5nZXRdXSkuXG4gICAgICpcbiAgICAgKiBJZiBhIGBzdGF0ZWAgYXJndW1lbnQgaXMgcHJvdmlkZWQsIHRoZSBSZXNvbHZhYmxlIGlzIHByb2Nlc3NlZCB3aGVuIHRoYXQgc3RhdGUgaXMgYmVpbmcgZW50ZXJlZC5cbiAgICAgKiBJZiBubyBgc3RhdGVgIGlzIHByb3ZpZGVkIHRoZW4gdGhlIHJvb3Qgc3RhdGUgaXMgdXNlZC5cbiAgICAgKiBJZiB0aGUgZ2l2ZW4gYHN0YXRlYCBoYXMgYWxyZWFkeSBiZWVuIGVudGVyZWQsIHRoZSBSZXNvbHZhYmxlIGlzIHByb2Nlc3NlZCB3aGVuIGFueSBjaGlsZCBzdGF0ZSBpcyBlbnRlcmVkLlxuICAgICAqIElmIG5vIGNoaWxkIHN0YXRlcyB3aWxsIGJlIGVudGVyZWQsIHRoZSBSZXNvbHZhYmxlIGlzIHByb2Nlc3NlZCBkdXJpbmcgdGhlIGBvbkZpbmlzaGAgcGhhc2Ugb2YgdGhlIFRyYW5zaXRpb24uXG4gICAgICpcbiAgICAgKiBUaGUgYHN0YXRlYCBhcmd1bWVudCBhbHNvIHNjb3BlcyB0aGUgcmVzb2x2ZWQgZGF0YS5cbiAgICAgKiBUaGUgcmVzb2x2ZWQgZGF0YSBpcyBhdmFpbGFibGUgZnJvbSB0aGUgaW5qZWN0b3IgZm9yIHRoYXQgYHN0YXRlYCBhbmQgYW55IGNoaWxkcmVuIHN0YXRlcy5cbiAgICAgKlxuICAgICAqICMjIyMgRXhhbXBsZTpcbiAgICAgKiBgYGBqc1xuICAgICAqIHRyYW5zaXRpb25TZXJ2aWNlLm9uQmVmb3JlKHt9LCB0cmFuc2l0aW9uID0+IHtcbiAgICAgKiAgIHRyYW5zaXRpb24uYWRkUmVzb2x2YWJsZSh7XG4gICAgICogICAgIHRva2VuOiAnbXlSZXNvbHZlJyxcbiAgICAgKiAgICAgZGVwczogWydNeVNlcnZpY2UnXSxcbiAgICAgKiAgICAgcmVzb2x2ZUZuOiBteVNlcnZpY2UgPT4gbXlTZXJ2aWNlLmdldERhdGEoKVxuICAgICAqICAgfSk7XG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVzb2x2YWJsZSBhIFtbUmVzb2x2YWJsZUxpdGVyYWxdXSBvYmplY3QgKG9yIGEgW1tSZXNvbHZhYmxlXV0pXG4gICAgICogQHBhcmFtIHN0YXRlIHRoZSBzdGF0ZSBpbiB0aGUgXCJ0byBwYXRoXCIgd2hpY2ggc2hvdWxkIHJlY2VpdmUgdGhlIG5ldyByZXNvbHZlIChvdGhlcndpc2UsIHRoZSByb290IHN0YXRlKVxuICAgICAqL1xuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLmFkZFJlc29sdmFibGUgPSBmdW5jdGlvbiAocmVzb2x2YWJsZSwgc3RhdGUpIHtcbiAgICAgICAgaWYgKHN0YXRlID09PSB2b2lkIDApIHsgc3RhdGUgPSAnJzsgfVxuICAgICAgICByZXNvbHZhYmxlID0gaG9mXzEuaXMocmVzb2x2YWJsZV8xLlJlc29sdmFibGUpKHJlc29sdmFibGUpID8gcmVzb2x2YWJsZSA6IG5ldyByZXNvbHZhYmxlXzEuUmVzb2x2YWJsZShyZXNvbHZhYmxlKTtcbiAgICAgICAgdmFyIHN0YXRlTmFtZSA9ICh0eXBlb2Ygc3RhdGUgPT09ICdzdHJpbmcnKSA/IHN0YXRlIDogc3RhdGUubmFtZTtcbiAgICAgICAgdmFyIHRvcGF0aCA9IHRoaXMuX3RyZWVDaGFuZ2VzLnRvO1xuICAgICAgICB2YXIgdGFyZ2V0Tm9kZSA9IGNvbW1vbl8xLmZpbmQodG9wYXRoLCBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbm9kZS5zdGF0ZS5uYW1lID09PSBzdGF0ZU5hbWU7IH0pO1xuICAgICAgICB2YXIgcmVzb2x2ZUNvbnRleHQgPSBuZXcgcmVzb2x2ZUNvbnRleHRfMS5SZXNvbHZlQ29udGV4dCh0b3BhdGgpO1xuICAgICAgICByZXNvbHZlQ29udGV4dC5hZGRSZXNvbHZhYmxlcyhbcmVzb2x2YWJsZV0sIHRhcmdldE5vZGUuc3RhdGUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgdHJhbnNpdGlvbiBmcm9tIHdoaWNoIHRoaXMgdHJhbnNpdGlvbiB3YXMgcmVkaXJlY3RlZC5cbiAgICAgKlxuICAgICAqIElmIHRoZSBjdXJyZW50IHRyYW5zaXRpb24gaXMgYSByZWRpcmVjdCwgdGhpcyBtZXRob2QgcmV0dXJucyB0aGUgdHJhbnNpdGlvbiB0aGF0IHdhcyByZWRpcmVjdGVkLlxuICAgICAqXG4gICAgICogIyMjIyBFeGFtcGxlOlxuICAgICAqIGBgYGpzXG4gICAgICogbGV0IHRyYW5zaXRpb25BID0gJHN0YXRlLmdvKCdBJykudHJhbnNpdGlvblxuICAgICAqIHRyYW5zaXRpb25BLm9uU3RhcnQoe30sICgpID0+ICRzdGF0ZS50YXJnZXQoJ0InKSk7XG4gICAgICogJHRyYW5zaXRpb25zLm9uU3VjY2Vzcyh7IHRvOiAnQicgfSwgKHRyYW5zKSA9PiB7XG4gICAgICogICB0cmFucy50bygpLm5hbWUgPT09ICdCJzsgLy8gdHJ1ZVxuICAgICAqICAgdHJhbnMucmVkaXJlY3RlZEZyb20oKSA9PT0gdHJhbnNpdGlvbkE7IC8vIHRydWVcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBwcmV2aW91cyBUcmFuc2l0aW9uLCBvciBudWxsIGlmIHRoaXMgVHJhbnNpdGlvbiBpcyBub3QgdGhlIHJlc3VsdCBvZiBhIHJlZGlyZWN0aW9uXG4gICAgICovXG4gICAgVHJhbnNpdGlvbi5wcm90b3R5cGUucmVkaXJlY3RlZEZyb20gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcHRpb25zLnJlZGlyZWN0ZWRGcm9tIHx8IG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBvcmlnaW5hbCB0cmFuc2l0aW9uIGluIGEgcmVkaXJlY3QgY2hhaW5cbiAgICAgKlxuICAgICAqIEEgdHJhbnNpdGlvbiBtaWdodCBiZWxvbmcgdG8gYSBsb25nIGNoYWluIG9mIG11bHRpcGxlIHJlZGlyZWN0cy5cbiAgICAgKiBUaGlzIG1ldGhvZCB3YWxrcyB0aGUgW1tyZWRpcmVjdGVkRnJvbV1dIGNoYWluIGJhY2sgdG8gdGhlIG9yaWdpbmFsIChmaXJzdCkgdHJhbnNpdGlvbiBpbiB0aGUgY2hhaW4uXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGU6XG4gICAgICogYGBganNcbiAgICAgKiAvLyBzdGF0ZXNcbiAgICAgKiByZWdpc3RyeS5yZWdpc3Rlcih7IG5hbWU6ICdBJywgcmVkaXJlY3RUbzogJ0InIH0pO1xuICAgICAqIHJlZ2lzdHJ5LnJlZ2lzdGVyKHsgbmFtZTogJ0InLCByZWRpcmVjdFRvOiAnQycgfSk7XG4gICAgICogcmVnaXN0cnkucmVnaXN0ZXIoeyBuYW1lOiAnQycsIHJlZGlyZWN0VG86ICdEJyB9KTtcbiAgICAgKiByZWdpc3RyeS5yZWdpc3Rlcih7IG5hbWU6ICdEJyB9KTtcbiAgICAgKlxuICAgICAqIGxldCB0cmFuc2l0aW9uQSA9ICRzdGF0ZS5nbygnQScpLnRyYW5zaXRpb25cbiAgICAgKlxuICAgICAqICR0cmFuc2l0aW9ucy5vblN1Y2Nlc3MoeyB0bzogJ0QnIH0sICh0cmFucykgPT4ge1xuICAgICAqICAgdHJhbnMudG8oKS5uYW1lID09PSAnRCc7IC8vIHRydWVcbiAgICAgKiAgIHRyYW5zLnJlZGlyZWN0ZWRGcm9tKCkudG8oKS5uYW1lID09PSAnQyc7IC8vIHRydWVcbiAgICAgKiAgIHRyYW5zLm9yaWdpbmFsVHJhbnNpdGlvbigpID09PSB0cmFuc2l0aW9uQTsgLy8gdHJ1ZVxuICAgICAqICAgdHJhbnMub3JpZ2luYWxUcmFuc2l0aW9uKCkudG8oKS5uYW1lID09PSAnQSc7IC8vIHRydWVcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSBvcmlnaW5hbCBUcmFuc2l0aW9uIHRoYXQgc3RhcnRlZCBhIHJlZGlyZWN0IGNoYWluXG4gICAgICovXG4gICAgVHJhbnNpdGlvbi5wcm90b3R5cGUub3JpZ2luYWxUcmFuc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmYgPSB0aGlzLnJlZGlyZWN0ZWRGcm9tKCk7XG4gICAgICAgIHJldHVybiAocmYgJiYgcmYub3JpZ2luYWxUcmFuc2l0aW9uKCkpIHx8IHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIHRyYW5zaXRpb24gb3B0aW9uc1xuICAgICAqXG4gICAgICogQHJldHVybnMgdGhlIG9wdGlvbnMgZm9yIHRoaXMgVHJhbnNpdGlvbi5cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5vcHRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb3B0aW9ucztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHN0YXRlcyBiZWluZyBlbnRlcmVkLlxuICAgICAqXG4gICAgICogQHJldHVybnMgYW4gYXJyYXkgb2Ygc3RhdGVzIHRoYXQgd2lsbCBiZSBlbnRlcmVkIGR1cmluZyB0aGlzIHRyYW5zaXRpb24uXG4gICAgICovXG4gICAgVHJhbnNpdGlvbi5wcm90b3R5cGUuZW50ZXJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjb21tb25fMS5tYXAodGhpcy5fdHJlZUNoYW5nZXMuZW50ZXJpbmcsIGhvZl8xLnByb3AoJ3N0YXRlJykpLm1hcChzdGF0ZVNlbGYpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgc3RhdGVzIGJlaW5nIGV4aXRlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGFuIGFycmF5IG9mIHN0YXRlcyB0aGF0IHdpbGwgYmUgZXhpdGVkIGR1cmluZyB0aGlzIHRyYW5zaXRpb24uXG4gICAgICovXG4gICAgVHJhbnNpdGlvbi5wcm90b3R5cGUuZXhpdGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNvbW1vbl8xLm1hcCh0aGlzLl90cmVlQ2hhbmdlcy5leGl0aW5nLCBob2ZfMS5wcm9wKCdzdGF0ZScpKS5tYXAoc3RhdGVTZWxmKS5yZXZlcnNlKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzdGF0ZXMgYmVpbmcgcmV0YWluZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBhbiBhcnJheSBvZiBzdGF0ZXMgdGhhdCBhcmUgYWxyZWFkeSBlbnRlcmVkIGZyb20gYSBwcmV2aW91cyBUcmFuc2l0aW9uLCB0aGF0IHdpbGwgbm90IGJlXG4gICAgICogICAgZXhpdGVkIGR1cmluZyB0aGlzIFRyYW5zaXRpb25cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5yZXRhaW5lZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNvbW1vbl8xLm1hcCh0aGlzLl90cmVlQ2hhbmdlcy5yZXRhaW5lZCwgaG9mXzEucHJvcCgnc3RhdGUnKSkubWFwKHN0YXRlU2VsZik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIFtbVmlld0NvbmZpZ11dcyBhc3NvY2lhdGVkIHdpdGggdGhpcyBUcmFuc2l0aW9uXG4gICAgICpcbiAgICAgKiBFYWNoIHN0YXRlIGNhbiBkZWZpbmUgb25lIG9yIG1vcmUgdmlld3MgKHRlbXBsYXRlL2NvbnRyb2xsZXIpLCB3aGljaCBhcmUgZW5jYXBzdWxhdGVkIGFzIGBWaWV3Q29uZmlnYCBvYmplY3RzLlxuICAgICAqIFRoaXMgbWV0aG9kIGZldGNoZXMgdGhlIGBWaWV3Q29uZmlnc2AgZm9yIGEgZ2l2ZW4gcGF0aCBpbiB0aGUgVHJhbnNpdGlvbiAoZS5nLiwgXCJ0b1wiIG9yIFwiZW50ZXJpbmdcIikuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGF0aG5hbWUgdGhlIG5hbWUgb2YgdGhlIHBhdGggdG8gZmV0Y2ggdmlld3MgZm9yOlxuICAgICAqICAgKGAndG8nYCwgYCdmcm9tJ2AsIGAnZW50ZXJpbmcnYCwgYCdleGl0aW5nJ2AsIGAncmV0YWluZWQnYClcbiAgICAgKiBAcGFyYW0gc3RhdGUgSWYgcHJvdmlkZWQsIG9ubHkgcmV0dXJucyB0aGUgYFZpZXdDb25maWdgcyBmb3IgYSBzaW5nbGUgc3RhdGUgaW4gdGhlIHBhdGhcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGEgbGlzdCBvZiBWaWV3Q29uZmlnIG9iamVjdHMgZm9yIHRoZSBnaXZlbiBwYXRoLlxuICAgICAqL1xuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLnZpZXdzID0gZnVuY3Rpb24gKHBhdGhuYW1lLCBzdGF0ZSkge1xuICAgICAgICBpZiAocGF0aG5hbWUgPT09IHZvaWQgMCkgeyBwYXRobmFtZSA9ICdlbnRlcmluZyc7IH1cbiAgICAgICAgdmFyIHBhdGggPSB0aGlzLl90cmVlQ2hhbmdlc1twYXRobmFtZV07XG4gICAgICAgIHBhdGggPSAhc3RhdGUgPyBwYXRoIDogcGF0aC5maWx0ZXIoaG9mXzEucHJvcEVxKCdzdGF0ZScsIHN0YXRlKSk7XG4gICAgICAgIHJldHVybiBwYXRoLm1hcChob2ZfMS5wcm9wKCd2aWV3cycpKS5maWx0ZXIoY29tbW9uXzEuaWRlbnRpdHkpLnJlZHVjZShjb21tb25fMS51bm5lc3RSLCBbXSk7XG4gICAgfTtcbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS50cmVlQ2hhbmdlcyA9IGZ1bmN0aW9uIChwYXRobmFtZSkge1xuICAgICAgICByZXR1cm4gcGF0aG5hbWUgPyB0aGlzLl90cmVlQ2hhbmdlc1twYXRobmFtZV0gOiB0aGlzLl90cmVlQ2hhbmdlcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgdHJhbnNpdGlvbiB0aGF0IGlzIGEgcmVkaXJlY3Rpb24gb2YgdGhlIGN1cnJlbnQgb25lLlxuICAgICAqXG4gICAgICogVGhpcyB0cmFuc2l0aW9uIGNhbiBiZSByZXR1cm5lZCBmcm9tIGEgW1tUcmFuc2l0aW9uU2VydmljZV1dIGhvb2sgdG9cbiAgICAgKiByZWRpcmVjdCBhIHRyYW5zaXRpb24gdG8gYSBuZXcgc3RhdGUgYW5kL29yIHNldCBvZiBwYXJhbWV0ZXJzLlxuICAgICAqXG4gICAgICogQGludGVybmFsYXBpXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBSZXR1cm5zIGEgbmV3IFtbVHJhbnNpdGlvbl1dIGluc3RhbmNlLlxuICAgICAqL1xuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLnJlZGlyZWN0ID0gZnVuY3Rpb24gKHRhcmdldFN0YXRlKSB7XG4gICAgICAgIHZhciByZWRpcmVjdHMgPSAxLCB0cmFucyA9IHRoaXM7XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1jb25kaXRpb25hbC1hc3NpZ25tZW50XG4gICAgICAgIHdoaWxlICgodHJhbnMgPSB0cmFucy5yZWRpcmVjdGVkRnJvbSgpKSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoKytyZWRpcmVjdHMgPiAyMClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUb28gbWFueSBjb25zZWN1dGl2ZSBUcmFuc2l0aW9uIHJlZGlyZWN0cyAoMjArKVwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVkaXJlY3RPcHRzID0geyByZWRpcmVjdGVkRnJvbTogdGhpcywgc291cmNlOiAncmVkaXJlY3QnIH07XG4gICAgICAgIC8vIElmIHRoZSBvcmlnaW5hbCB0cmFuc2l0aW9uIHdhcyBjYXVzZWQgYnkgVVJMIHN5bmMsIHRoZW4gdXNlIHsgbG9jYXRpb246ICdyZXBsYWNlJyB9XG4gICAgICAgIC8vIG9uIHRoZSBuZXcgdHJhbnNpdGlvbiAodW5sZXNzIHRoZSB0YXJnZXQgc3RhdGUgZXhwbGljaXRseSBzcGVjaWZpZXMgbG9jYXRpb246IGZhbHNlKS5cbiAgICAgICAgLy8gVGhpcyBjYXVzZXMgdGhlIG9yaWdpbmFsIHVybCB0byBiZSByZXBsYWNlZCB3aXRoIHRoZSB1cmwgZm9yIHRoZSByZWRpcmVjdCB0YXJnZXRcbiAgICAgICAgLy8gc28gdGhlIG9yaWdpbmFsIHVybCBkaXNhcHBlYXJzIGZyb20gdGhlIGJyb3dzZXIgaGlzdG9yeS5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucygpLnNvdXJjZSA9PT0gJ3VybCcgJiYgdGFyZ2V0U3RhdGUub3B0aW9ucygpLmxvY2F0aW9uICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgcmVkaXJlY3RPcHRzLmxvY2F0aW9uID0gJ3JlcGxhY2UnO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZXdPcHRpb25zID0gY29tbW9uXzEuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMoKSwgdGFyZ2V0U3RhdGUub3B0aW9ucygpLCByZWRpcmVjdE9wdHMpO1xuICAgICAgICB0YXJnZXRTdGF0ZSA9IHRhcmdldFN0YXRlLndpdGhPcHRpb25zKG5ld09wdGlvbnMsIHRydWUpO1xuICAgICAgICB2YXIgbmV3VHJhbnNpdGlvbiA9IHRoaXMucm91dGVyLnRyYW5zaXRpb25TZXJ2aWNlLmNyZWF0ZSh0aGlzLl90cmVlQ2hhbmdlcy5mcm9tLCB0YXJnZXRTdGF0ZSk7XG4gICAgICAgIHZhciBvcmlnaW5hbEVudGVyaW5nTm9kZXMgPSB0aGlzLl90cmVlQ2hhbmdlcy5lbnRlcmluZztcbiAgICAgICAgdmFyIHJlZGlyZWN0RW50ZXJpbmdOb2RlcyA9IG5ld1RyYW5zaXRpb24uX3RyZWVDaGFuZ2VzLmVudGVyaW5nO1xuICAgICAgICAvLyAtLS0gUmUtdXNlIHJlc29sdmUgZGF0YSBmcm9tIG9yaWdpbmFsIHRyYW5zaXRpb24gLS0tXG4gICAgICAgIC8vIFdoZW4gcmVkaXJlY3RpbmcgZnJvbSBhIHBhcmVudCBzdGF0ZSB0byBhIGNoaWxkIHN0YXRlIHdoZXJlIHRoZSBwYXJlbnQgcGFyYW1ldGVyIHZhbHVlcyBoYXZlbid0IGNoYW5nZWRcbiAgICAgICAgLy8gKGJlY2F1c2Ugb2YgdGhlIHJlZGlyZWN0KSwgdGhlIHJlc29sdmVzIGZldGNoZWQgYnkgdGhlIG9yaWdpbmFsIHRyYW5zaXRpb24gYXJlIHN0aWxsIHZhbGlkIGluIHRoZVxuICAgICAgICAvLyByZWRpcmVjdGVkIHRyYW5zaXRpb24uXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRoaXMgYWxsb3dzIHlvdSB0byBkZWZpbmUgYSByZWRpcmVjdCBvbiBhIHBhcmVudCBzdGF0ZSB3aGljaCBkZXBlbmRzIG9uIGFuIGFzeW5jIHJlc29sdmUgdmFsdWUuXG4gICAgICAgIC8vIFlvdSBjYW4gd2FpdCBmb3IgdGhlIHJlc29sdmUsIHRoZW4gcmVkaXJlY3QgdG8gYSBjaGlsZCBzdGF0ZSBiYXNlZCBvbiB0aGUgcmVzdWx0LlxuICAgICAgICAvLyBUaGUgcmVkaXJlY3RlZCB0cmFuc2l0aW9uIGRvZXMgbm90IGhhdmUgdG8gcmUtZmV0Y2ggdGhlIHJlc29sdmUuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICB2YXIgbm9kZUlzUmVsb2FkaW5nID0gZnVuY3Rpb24gKHJlbG9hZFN0YXRlKSB7IHJldHVybiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlbG9hZFN0YXRlICYmIG5vZGUuc3RhdGUuaW5jbHVkZXNbcmVsb2FkU3RhdGUubmFtZV07XG4gICAgICAgIH07IH07XG4gICAgICAgIC8vIEZpbmQgYW55IFwiZW50ZXJpbmdcIiBub2RlcyBpbiB0aGUgcmVkaXJlY3QgcGF0aCB0aGF0IG1hdGNoIHRoZSBvcmlnaW5hbCBwYXRoIGFuZCBhcmVuJ3QgYmVpbmcgcmVsb2FkZWRcbiAgICAgICAgdmFyIG1hdGNoaW5nRW50ZXJpbmdOb2RlcyA9IHBhdGhVdGlsc18xLlBhdGhVdGlscy5tYXRjaGluZyhyZWRpcmVjdEVudGVyaW5nTm9kZXMsIG9yaWdpbmFsRW50ZXJpbmdOb2RlcywgcGF0aFV0aWxzXzEuUGF0aFV0aWxzLm5vbkR5bmFtaWNQYXJhbXMpXG4gICAgICAgICAgICAuZmlsdGVyKGhvZl8xLm5vdChub2RlSXNSZWxvYWRpbmcodGFyZ2V0U3RhdGUub3B0aW9ucygpLnJlbG9hZFN0YXRlKSkpO1xuICAgICAgICAvLyBVc2UgdGhlIGV4aXN0aW5nIChwb3NzaWJseSBwcmUtcmVzb2x2ZWQpIHJlc29sdmFibGVzIGZvciB0aGUgbWF0Y2hpbmcgZW50ZXJpbmcgbm9kZXMuXG4gICAgICAgIG1hdGNoaW5nRW50ZXJpbmdOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlLCBpZHgpIHtcbiAgICAgICAgICAgIG5vZGUucmVzb2x2YWJsZXMgPSBvcmlnaW5hbEVudGVyaW5nTm9kZXNbaWR4XS5yZXNvbHZhYmxlcztcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXdUcmFuc2l0aW9uO1xuICAgIH07XG4gICAgLyoqIEBoaWRkZW4gSWYgYSB0cmFuc2l0aW9uIGRvZXNuJ3QgZXhpdC9lbnRlciBhbnkgc3RhdGVzLCByZXR1cm5zIGFueSBbW1BhcmFtXV0gd2hvc2UgdmFsdWUgY2hhbmdlZCAqL1xuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLl9jaGFuZ2VkUGFyYW1zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGMgPSB0aGlzLl90cmVlQ2hhbmdlcztcbiAgICAgICAgLyoqIFJldHVybiB1bmRlZmluZWQgaWYgaXQncyBub3QgYSBcImR5bmFtaWNcIiB0cmFuc2l0aW9uLCBmb3IgdGhlIGZvbGxvd2luZyByZWFzb25zICovXG4gICAgICAgIC8vIElmIHVzZXIgZXhwbGljaXRseSB3YW50cyBhIHJlbG9hZFxuICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5yZWxvYWQpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAvLyBJZiBhbnkgc3RhdGVzIGFyZSBleGl0aW5nIG9yIGVudGVyaW5nXG4gICAgICAgIGlmICh0Yy5leGl0aW5nLmxlbmd0aCB8fCB0Yy5lbnRlcmluZy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAvLyBJZiB0by9mcm9tIHBhdGggbGVuZ3RocyBkaWZmZXJcbiAgICAgICAgaWYgKHRjLnRvLmxlbmd0aCAhPT0gdGMuZnJvbS5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAvLyBJZiB0aGUgdG8vZnJvbSBwYXRocyBhcmUgZGlmZmVyZW50XG4gICAgICAgIHZhciBwYXRoc0RpZmZlciA9IGNvbW1vbl8xLmFycmF5VHVwbGVzKHRjLnRvLCB0Yy5mcm9tKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAodHVwbGUpIHsgcmV0dXJuIHR1cGxlWzBdLnN0YXRlICE9PSB0dXBsZVsxXS5zdGF0ZTsgfSlcbiAgICAgICAgICAgIC5yZWR1Y2UoY29tbW9uXzEuYW55VHJ1ZVIsIGZhbHNlKTtcbiAgICAgICAgaWYgKHBhdGhzRGlmZmVyKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgLy8gRmluZCBhbnkgcGFyYW1ldGVyIHZhbHVlcyB0aGF0IGRpZmZlclxuICAgICAgICB2YXIgbm9kZVNjaGVtYXMgPSB0Yy50by5tYXAoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUucGFyYW1TY2hlbWE7IH0pO1xuICAgICAgICB2YXIgX2EgPSBbdGMudG8sIHRjLmZyb21dLm1hcChmdW5jdGlvbiAocGF0aCkgeyByZXR1cm4gcGF0aC5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHgucGFyYW1WYWx1ZXM7IH0pOyB9KSwgdG9WYWx1ZXMgPSBfYVswXSwgZnJvbVZhbHVlcyA9IF9hWzFdO1xuICAgICAgICB2YXIgdHVwbGVzID0gY29tbW9uXzEuYXJyYXlUdXBsZXMobm9kZVNjaGVtYXMsIHRvVmFsdWVzLCBmcm9tVmFsdWVzKTtcbiAgICAgICAgcmV0dXJuIHR1cGxlcy5tYXAoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgc2NoZW1hID0gX2FbMF0sIHRvVmFscyA9IF9hWzFdLCBmcm9tVmFscyA9IF9hWzJdO1xuICAgICAgICAgICAgcmV0dXJuIHBhcmFtXzEuUGFyYW0uY2hhbmdlZChzY2hlbWEsIHRvVmFscywgZnJvbVZhbHMpO1xuICAgICAgICB9KS5yZWR1Y2UoY29tbW9uXzEudW5uZXN0UiwgW10pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSB0cmFuc2l0aW9uIGlzIGR5bmFtaWMuXG4gICAgICpcbiAgICAgKiBBIHRyYW5zaXRpb24gaXMgZHluYW1pYyBpZiBubyBzdGF0ZXMgYXJlIGVudGVyZWQgbm9yIGV4aXRlZCwgYnV0IGF0IGxlYXN0IG9uZSBkeW5hbWljIHBhcmFtZXRlciBoYXMgY2hhbmdlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIFRyYW5zaXRpb24gaXMgZHluYW1pY1xuICAgICAqL1xuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLmR5bmFtaWMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjaGFuZ2VzID0gdGhpcy5fY2hhbmdlZFBhcmFtcygpO1xuICAgICAgICByZXR1cm4gIWNoYW5nZXMgPyBmYWxzZSA6IGNoYW5nZXMubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LmR5bmFtaWM7IH0pLnJlZHVjZShjb21tb25fMS5hbnlUcnVlUiwgZmFsc2UpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSB0cmFuc2l0aW9uIGlzIGlnbm9yZWQuXG4gICAgICpcbiAgICAgKiBBIHRyYW5zaXRpb24gaXMgaWdub3JlZCBpZiBubyBzdGF0ZXMgYXJlIGVudGVyZWQgbm9yIGV4aXRlZCwgYW5kIG5vIHBhcmFtZXRlciB2YWx1ZXMgaGF2ZSBjaGFuZ2VkLlxuICAgICAqXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgVHJhbnNpdGlvbiBpcyBpZ25vcmVkLlxuICAgICAqL1xuICAgIFRyYW5zaXRpb24ucHJvdG90eXBlLmlnbm9yZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2lnbm9yZWRSZWFzb24oKTtcbiAgICB9O1xuICAgIC8qKiBAaGlkZGVuICovXG4gICAgVHJhbnNpdGlvbi5wcm90b3R5cGUuX2lnbm9yZWRSZWFzb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwZW5kaW5nID0gdGhpcy5yb3V0ZXIuZ2xvYmFscy50cmFuc2l0aW9uO1xuICAgICAgICB2YXIgcmVsb2FkU3RhdGUgPSB0aGlzLl9vcHRpb25zLnJlbG9hZFN0YXRlO1xuICAgICAgICB2YXIgc2FtZSA9IGZ1bmN0aW9uIChwYXRoQSwgcGF0aEIpIHtcbiAgICAgICAgICAgIGlmIChwYXRoQS5sZW5ndGggIT09IHBhdGhCLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB2YXIgbWF0Y2hpbmcgPSBwYXRoVXRpbHNfMS5QYXRoVXRpbHMubWF0Y2hpbmcocGF0aEEsIHBhdGhCKTtcbiAgICAgICAgICAgIHJldHVybiBwYXRoQS5sZW5ndGggPT09IG1hdGNoaW5nLmZpbHRlcihmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gIXJlbG9hZFN0YXRlIHx8ICFub2RlLnN0YXRlLmluY2x1ZGVzW3JlbG9hZFN0YXRlLm5hbWVdOyB9KS5sZW5ndGg7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBuZXdUQyA9IHRoaXMudHJlZUNoYW5nZXMoKTtcbiAgICAgICAgdmFyIHBlbmRUQyA9IHBlbmRpbmcgJiYgcGVuZGluZy50cmVlQ2hhbmdlcygpO1xuICAgICAgICBpZiAocGVuZFRDICYmIHNhbWUocGVuZFRDLnRvLCBuZXdUQy50bykgJiYgc2FtZShwZW5kVEMuZXhpdGluZywgbmV3VEMuZXhpdGluZykpXG4gICAgICAgICAgICByZXR1cm4gJ1NhbWVBc1BlbmRpbmcnO1xuICAgICAgICBpZiAobmV3VEMuZXhpdGluZy5sZW5ndGggPT09IDAgJiYgbmV3VEMuZW50ZXJpbmcubGVuZ3RoID09PSAwICYmIHNhbWUobmV3VEMuZnJvbSwgbmV3VEMudG8pKVxuICAgICAgICAgICAgcmV0dXJuICdTYW1lQXNDdXJyZW50JztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJ1bnMgdGhlIHRyYW5zaXRpb25cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGdlbmVyYWxseSBjYWxsZWQgZnJvbSB0aGUgW1tTdGF0ZVNlcnZpY2UudHJhbnNpdGlvblRvXV1cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbGFwaVxuICAgICAqXG4gICAgICogQHJldHVybnMgYSBwcm9taXNlIGZvciBhIHN1Y2Nlc3NmdWwgdHJhbnNpdGlvbi5cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBydW5BbGxIb29rcyA9IHRyYW5zaXRpb25Ib29rXzEuVHJhbnNpdGlvbkhvb2sucnVuQWxsSG9va3M7XG4gICAgICAgIC8vIEdldHMgdHJhbnNpdGlvbiBob29rcyBhcnJheSBmb3IgdGhlIGdpdmVuIHBoYXNlXG4gICAgICAgIHZhciBnZXRIb29rc0ZvciA9IGZ1bmN0aW9uIChwaGFzZSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9ob29rQnVpbGRlci5idWlsZEhvb2tzRm9yUGhhc2UocGhhc2UpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBXaGVuIHRoZSBjaGFpbiBpcyBjb21wbGV0ZSwgdGhlbiByZXNvbHZlIG9yIHJlamVjdCB0aGUgZGVmZXJyZWRcbiAgICAgICAgdmFyIHRyYW5zaXRpb25TdWNjZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdHJhY2VfMS50cmFjZS50cmFjZVN1Y2Nlc3MoX3RoaXMuJHRvKCksIF90aGlzKTtcbiAgICAgICAgICAgIF90aGlzLnN1Y2Nlc3MgPSB0cnVlO1xuICAgICAgICAgICAgX3RoaXMuX2RlZmVycmVkLnJlc29sdmUoX3RoaXMudG8oKSk7XG4gICAgICAgICAgICBydW5BbGxIb29rcyhnZXRIb29rc0ZvcihpbnRlcmZhY2VfMS5UcmFuc2l0aW9uSG9va1BoYXNlLlNVQ0NFU1MpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHRyYW5zaXRpb25FcnJvciA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgICAgIHRyYWNlXzEudHJhY2UudHJhY2VFcnJvcihyZWFzb24sIF90aGlzKTtcbiAgICAgICAgICAgIF90aGlzLnN1Y2Nlc3MgPSBmYWxzZTtcbiAgICAgICAgICAgIF90aGlzLl9kZWZlcnJlZC5yZWplY3QocmVhc29uKTtcbiAgICAgICAgICAgIF90aGlzLl9lcnJvciA9IHJlYXNvbjtcbiAgICAgICAgICAgIHJ1bkFsbEhvb2tzKGdldEhvb2tzRm9yKGludGVyZmFjZV8xLlRyYW5zaXRpb25Ib29rUGhhc2UuRVJST1IpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHJ1blRyYW5zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBXYWl0IHRvIGJ1aWxkIHRoZSBSVU4gaG9vayBjaGFpbiB1bnRpbCB0aGUgQkVGT1JFIGhvb2tzIGFyZSBkb25lXG4gICAgICAgICAgICAvLyBUaGlzIGFsbG93cyBhIEJFRk9SRSBob29rIHRvIGR5bmFtaWNhbGx5IGFkZCBhZGRpdGlvbmFsIFJVTiBob29rcyB2aWEgdGhlIFRyYW5zaXRpb24gb2JqZWN0LlxuICAgICAgICAgICAgdmFyIGFsbFJ1bkhvb2tzID0gZ2V0SG9va3NGb3IoaW50ZXJmYWNlXzEuVHJhbnNpdGlvbkhvb2tQaGFzZS5SVU4pO1xuICAgICAgICAgICAgdmFyIGRvbmUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjb3Jlc2VydmljZXNfMS5zZXJ2aWNlcy4kcS53aGVuKHVuZGVmaW5lZCk7IH07XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNpdGlvbkhvb2tfMS5UcmFuc2l0aW9uSG9vay5pbnZva2VIb29rcyhhbGxSdW5Ib29rcywgZG9uZSk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBzdGFydFRyYW5zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZ2xvYmFscyA9IF90aGlzLnJvdXRlci5nbG9iYWxzO1xuICAgICAgICAgICAgZ2xvYmFscy5sYXN0U3RhcnRlZFRyYW5zaXRpb25JZCA9IF90aGlzLiRpZDtcbiAgICAgICAgICAgIGdsb2JhbHMudHJhbnNpdGlvbiA9IF90aGlzO1xuICAgICAgICAgICAgZ2xvYmFscy50cmFuc2l0aW9uSGlzdG9yeS5lbnF1ZXVlKF90aGlzKTtcbiAgICAgICAgICAgIHRyYWNlXzEudHJhY2UudHJhY2VUcmFuc2l0aW9uU3RhcnQoX3RoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIGNvcmVzZXJ2aWNlc18xLnNlcnZpY2VzLiRxLndoZW4odW5kZWZpbmVkKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGFsbEJlZm9yZUhvb2tzID0gZ2V0SG9va3NGb3IoaW50ZXJmYWNlXzEuVHJhbnNpdGlvbkhvb2tQaGFzZS5CRUZPUkUpO1xuICAgICAgICB0cmFuc2l0aW9uSG9va18xLlRyYW5zaXRpb25Ib29rLmludm9rZUhvb2tzKGFsbEJlZm9yZUhvb2tzLCBzdGFydFRyYW5zaXRpb24pXG4gICAgICAgICAgICAudGhlbihydW5UcmFuc2l0aW9uKVxuICAgICAgICAgICAgLnRoZW4odHJhbnNpdGlvblN1Y2Nlc3MsIHRyYW5zaXRpb25FcnJvcik7XG4gICAgICAgIHJldHVybiB0aGlzLnByb21pc2U7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIFRyYW5zaXRpb24gaXMgdmFsaWRcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIFRyYW5zaXRpb24gaXMgdmFsaWRcbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS52YWxpZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmVycm9yKCkgfHwgdGhpcy5zdWNjZXNzICE9PSB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBYm9ydHMgdGhpcyB0cmFuc2l0aW9uXG4gICAgICpcbiAgICAgKiBJbXBlcmF0aXZlIEFQSSB0byBhYm9ydCBhIFRyYW5zaXRpb24uXG4gICAgICogVGhpcyBvbmx5IGFwcGxpZXMgdG8gVHJhbnNpdGlvbnMgdGhhdCBhcmUgbm90IHlldCBjb21wbGV0ZS5cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gRG8gbm90IHNldCBmbGFnIGlmIHRoZSB0cmFuc2l0aW9uIGlzIGFscmVhZHkgY29tcGxldGVcbiAgICAgICAgaWYgKHByZWRpY2F0ZXNfMS5pc1VuZGVmaW5lZCh0aGlzLnN1Y2Nlc3MpKSB7XG4gICAgICAgICAgICB0aGlzLl9hYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogVGhlIFRyYW5zaXRpb24gZXJyb3IgcmVhc29uLlxuICAgICAqXG4gICAgICogSWYgdGhlIHRyYW5zaXRpb24gaXMgaW52YWxpZCAoYW5kIGNvdWxkIG5vdCBiZSBydW4pLCByZXR1cm5zIHRoZSByZWFzb24gdGhlIHRyYW5zaXRpb24gaXMgaW52YWxpZC5cbiAgICAgKiBJZiB0aGUgdHJhbnNpdGlvbiB3YXMgdmFsaWQgYW5kIHJhbiwgYnV0IHdhcyBub3Qgc3VjY2Vzc2Z1bCwgcmV0dXJucyB0aGUgcmVhc29uIHRoZSB0cmFuc2l0aW9uIGZhaWxlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGFuIGVycm9yIG1lc3NhZ2UgZXhwbGFpbmluZyB3aHkgdGhlIHRyYW5zaXRpb24gaXMgaW52YWxpZCwgb3IgdGhlIHJlYXNvbiB0aGUgdHJhbnNpdGlvbiBmYWlsZWQuXG4gICAgICovXG4gICAgVHJhbnNpdGlvbi5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuJHRvKCk7XG4gICAgICAgIGlmIChzdGF0ZS5zZWxmLmFic3RyYWN0KVxuICAgICAgICAgICAgcmV0dXJuIFwiQ2Fubm90IHRyYW5zaXRpb24gdG8gYWJzdHJhY3Qgc3RhdGUgJ1wiICsgc3RhdGUubmFtZSArIFwiJ1wiO1xuICAgICAgICB2YXIgcGFyYW1EZWZzID0gc3RhdGUucGFyYW1ldGVycygpLCB2YWx1ZXMgPSB0aGlzLnBhcmFtcygpO1xuICAgICAgICB2YXIgaW52YWxpZFBhcmFtcyA9IHBhcmFtRGVmcy5maWx0ZXIoZnVuY3Rpb24gKHBhcmFtKSB7IHJldHVybiAhcGFyYW0udmFsaWRhdGVzKHZhbHVlc1twYXJhbS5pZF0pOyB9KTtcbiAgICAgICAgaWYgKGludmFsaWRQYXJhbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJQYXJhbSB2YWx1ZXMgbm90IHZhbGlkIGZvciBzdGF0ZSAnXCIgKyBzdGF0ZS5uYW1lICsgXCInLiBJbnZhbGlkIHBhcmFtczogWyBcIiArIGludmFsaWRQYXJhbXMubWFwKGZ1bmN0aW9uIChwYXJhbSkgeyByZXR1cm4gcGFyYW0uaWQ7IH0pLmpvaW4oJywgJykgKyBcIiBdXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3VjY2VzcyA9PT0gZmFsc2UpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZXJyb3I7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgVHJhbnNpdGlvblxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIFRyYW5zaXRpb25cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGZyb21TdGF0ZU9yTmFtZSA9IHRoaXMuZnJvbSgpO1xuICAgICAgICB2YXIgdG9TdGF0ZU9yTmFtZSA9IHRoaXMudG8oKTtcbiAgICAgICAgdmFyIGF2b2lkRW1wdHlIYXNoID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICAgICAgcmV0dXJuIChwYXJhbXNbJyMnXSAhPT0gbnVsbCAmJiBwYXJhbXNbJyMnXSAhPT0gdW5kZWZpbmVkKSA/IHBhcmFtcyA6IGNvbW1vbl8xLm9taXQocGFyYW1zLCBbJyMnXSk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIChYKSBtZWFucyB0aGUgdG8gc3RhdGUgaXMgaW52YWxpZC5cbiAgICAgICAgdmFyIGlkID0gdGhpcy4kaWQsIGZyb20gPSBwcmVkaWNhdGVzXzEuaXNPYmplY3QoZnJvbVN0YXRlT3JOYW1lKSA/IGZyb21TdGF0ZU9yTmFtZS5uYW1lIDogZnJvbVN0YXRlT3JOYW1lLCBmcm9tUGFyYW1zID0gc3RyaW5nc18xLnN0cmluZ2lmeShhdm9pZEVtcHR5SGFzaCh0aGlzLl90cmVlQ2hhbmdlcy5mcm9tLm1hcChob2ZfMS5wcm9wKCdwYXJhbVZhbHVlcycpKS5yZWR1Y2UoY29tbW9uXzEubWVyZ2VSLCB7fSkpKSwgdG9WYWxpZCA9IHRoaXMudmFsaWQoKSA/ICcnIDogJyhYKSAnLCB0byA9IHByZWRpY2F0ZXNfMS5pc09iamVjdCh0b1N0YXRlT3JOYW1lKSA/IHRvU3RhdGVPck5hbWUubmFtZSA6IHRvU3RhdGVPck5hbWUsIHRvUGFyYW1zID0gc3RyaW5nc18xLnN0cmluZ2lmeShhdm9pZEVtcHR5SGFzaCh0aGlzLnBhcmFtcygpKSk7XG4gICAgICAgIHJldHVybiBcIlRyYW5zaXRpb24jXCIgKyBpZCArIFwiKCAnXCIgKyBmcm9tICsgXCInXCIgKyBmcm9tUGFyYW1zICsgXCIgLT4gXCIgKyB0b1ZhbGlkICsgXCInXCIgKyB0byArIFwiJ1wiICsgdG9QYXJhbXMgKyBcIiApXCI7XG4gICAgfTtcbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIFRyYW5zaXRpb24uZGlUb2tlbiA9IFRyYW5zaXRpb247XG4gICAgcmV0dXJuIFRyYW5zaXRpb247XG59KCkpO1xuZXhwb3J0cy5UcmFuc2l0aW9uID0gVHJhbnNpdGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYW5zaXRpb24uanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3RyYW5zaXRpb24vdHJhbnNpdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gMjlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///29\n")},function(module,exports,__webpack_require__){"use strict";eval("\n/** @module path */ /** for typedoc */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar common_1 = __webpack_require__(0);\nvar hof_1 = __webpack_require__(2);\nvar targetState_1 = __webpack_require__(17);\nvar pathNode_1 = __webpack_require__(45);\n/**\n * This class contains functions which convert TargetStates, Nodes and paths from one type to another.\n */\nvar PathUtils = /** @class */ (function () {\n    function PathUtils() {\n    }\n    /** Given a PathNode[], create an TargetState */\n    PathUtils.makeTargetState = function (registry, path) {\n        var state = common_1.tail(path).state;\n        return new targetState_1.TargetState(registry, state, path.map(hof_1.prop('paramValues')).reduce(common_1.mergeR, {}), {});\n    };\n    PathUtils.buildPath = function (targetState) {\n        var toParams = targetState.params();\n        return targetState.$state().path.map(function (state) { return new pathNode_1.PathNode(state).applyRawParams(toParams); });\n    };\n    /** Given a fromPath: PathNode[] and a TargetState, builds a toPath: PathNode[] */\n    PathUtils.buildToPath = function (fromPath, targetState) {\n        var toPath = PathUtils.buildPath(targetState);\n        if (targetState.options().inherit) {\n            return PathUtils.inheritParams(fromPath, toPath, Object.keys(targetState.params()));\n        }\n        return toPath;\n    };\n    /**\n     * Creates ViewConfig objects and adds to nodes.\n     *\n     * On each [[PathNode]], creates ViewConfig objects from the views: property of the node's state\n     */\n    PathUtils.applyViewConfigs = function ($view, path, states) {\n        // Only apply the viewConfigs to the nodes for the given states\n        path.filter(function (node) { return common_1.inArray(states, node.state); }).forEach(function (node) {\n            var viewDecls = common_1.values(node.state.views || {});\n            var subPath = PathUtils.subPath(path, function (n) { return n === node; });\n            var viewConfigs = viewDecls.map(function (view) { return $view.createViewConfig(subPath, view); });\n            node.views = viewConfigs.reduce(common_1.unnestR, []);\n        });\n    };\n    /**\n     * Given a fromPath and a toPath, returns a new to path which inherits parameters from the fromPath\n     *\n     * For a parameter in a node to be inherited from the from path:\n     * - The toPath's node must have a matching node in the fromPath (by state).\n     * - The parameter name must not be found in the toKeys parameter array.\n     *\n     * Note: the keys provided in toKeys are intended to be those param keys explicitly specified by some\n     * caller, for instance, $state.transitionTo(..., toParams).  If a key was found in toParams,\n     * it is not inherited from the fromPath.\n     */\n    PathUtils.inheritParams = function (fromPath, toPath, toKeys) {\n        if (toKeys === void 0) { toKeys = []; }\n        function nodeParamVals(path, state) {\n            var node = common_1.find(path, hof_1.propEq('state', state));\n            return common_1.extend({}, node && node.paramValues);\n        }\n        var noInherit = fromPath.map(function (node) { return node.paramSchema; })\n            .reduce(common_1.unnestR, [])\n            .filter(function (param) { return !param.inherit; })\n            .map(hof_1.prop('id'));\n        /**\n         * Given an [[PathNode]] \"toNode\", return a new [[PathNode]] with param values inherited from the\n         * matching node in fromPath.  Only inherit keys that aren't found in \"toKeys\" from the node in \"fromPath\"\"\n         */\n        function makeInheritedParamsNode(toNode) {\n            // All param values for the node (may include default key/vals, when key was not found in toParams)\n            var toParamVals = common_1.extend({}, toNode && toNode.paramValues);\n            // limited to only those keys found in toParams\n            var incomingParamVals = common_1.pick(toParamVals, toKeys);\n            toParamVals = common_1.omit(toParamVals, toKeys);\n            var fromParamVals = common_1.omit(nodeParamVals(fromPath, toNode.state) || {}, noInherit);\n            // extend toParamVals with any fromParamVals, then override any of those those with incomingParamVals\n            var ownParamVals = common_1.extend(toParamVals, fromParamVals, incomingParamVals);\n            return new pathNode_1.PathNode(toNode.state).applyRawParams(ownParamVals);\n        }\n        // The param keys specified by the incoming toParams\n        return toPath.map(makeInheritedParamsNode);\n    };\n    /**\n     * Computes the tree changes (entering, exiting) between a fromPath and toPath.\n     */\n    PathUtils.treeChanges = function (fromPath, toPath, reloadState) {\n        var max = Math.min(fromPath.length, toPath.length);\n        var keep = 0;\n        var nodesMatch = function (node1, node2) {\n            return node1.equals(node2, PathUtils.nonDynamicParams);\n        };\n        while (keep < max && fromPath[keep].state !== reloadState && nodesMatch(fromPath[keep], toPath[keep])) {\n            keep++;\n        }\n        /** Given a retained node, return a new node which uses the to node's param values */\n        function applyToParams(retainedNode, idx) {\n            var cloned = pathNode_1.PathNode.clone(retainedNode);\n            cloned.paramValues = toPath[idx].paramValues;\n            return cloned;\n        }\n        var from, retained, exiting, entering, to;\n        from = fromPath;\n        retained = from.slice(0, keep).map(applyToParams); // applyToParams to update dynamic params\n        exiting = from.slice(keep);\n        entering = toPath.slice(keep);\n        to = (retained).concat(entering);\n        return { from: from, to: to, retained: retained, exiting: exiting, entering: entering };\n    };\n    /**\n     * Returns a new path which is: the subpath of the first path which matches the second path.\n     *\n     * The new path starts from root and contains any nodes that match the nodes in the second path.\n     * It stops before the first non-matching node.\n     *\n     * Nodes are compared using their state property and their parameter values.\n     * If a `paramsFn` is provided, only the [[Param]] returned by the function will be considered when comparing nodes.\n     *\n     * @param pathA the first path\n     * @param pathB the second path\n     * @param paramsFn a function which returns the parameters to consider when comparing\n     *\n     * @returns an array of PathNodes from the first path which match the nodes in the second path\n     */\n    PathUtils.matching = function (pathA, pathB, paramsFn) {\n        var done = false;\n        var tuples = common_1.arrayTuples(pathA, pathB);\n        return tuples.reduce(function (matching, _a) {\n            var nodeA = _a[0], nodeB = _a[1];\n            done = done || !nodeA.equals(nodeB, paramsFn);\n            return done ? matching : matching.concat(nodeA);\n        }, []);\n    };\n    /**\n     * Returns true if two paths are identical.\n     *\n     * @param pathA\n     * @param pathB\n     * @param paramsFn a function which returns the parameters to consider when comparing\n     * @returns true if the the states and parameter values for both paths are identical\n     */\n    PathUtils.equals = function (pathA, pathB, paramsFn) {\n        return pathA.length === pathB.length &&\n            PathUtils.matching(pathA, pathB, paramsFn).length === pathA.length;\n    };\n    /**\n     * Return a subpath of a path, which stops at the first matching node\n     *\n     * Given an array of nodes, returns a subset of the array starting from the first node,\n     * stopping when the first node matches the predicate.\n     *\n     * @param path a path of [[PathNode]]s\n     * @param predicate a [[Predicate]] fn that matches [[PathNode]]s\n     * @returns a subpath up to the matching node, or undefined if no match is found\n     */\n    PathUtils.subPath = function (path, predicate) {\n        var node = common_1.find(path, predicate);\n        var elementIdx = path.indexOf(node);\n        return elementIdx === -1 ? undefined : path.slice(0, elementIdx + 1);\n    };\n    PathUtils.nonDynamicParams = function (node) {\n        return node.state.parameters({ inherit: false })\n            .filter(function (param) { return !param.dynamic; });\n    };\n    /** Gets the raw parameter values from a path */\n    PathUtils.paramValues = function (path) {\n        return path.reduce(function (acc, node) { return common_1.extend(acc, node.paramValues); }, {});\n    };\n    return PathUtils;\n}());\nexports.PathUtils = PathUtils;\n//# sourceMappingURL=pathUtils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3BhdGgvcGF0aFV0aWxzLmpzPzczYmYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKiogQG1vZHVsZSBwYXRoICovIC8qKiBmb3IgdHlwZWRvYyAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb21tb25cIik7XG52YXIgaG9mXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2hvZlwiKTtcbnZhciB0YXJnZXRTdGF0ZV8xID0gcmVxdWlyZShcIi4uL3N0YXRlL3RhcmdldFN0YXRlXCIpO1xudmFyIHBhdGhOb2RlXzEgPSByZXF1aXJlKFwiLi9wYXRoTm9kZVwiKTtcbi8qKlxuICogVGhpcyBjbGFzcyBjb250YWlucyBmdW5jdGlvbnMgd2hpY2ggY29udmVydCBUYXJnZXRTdGF0ZXMsIE5vZGVzIGFuZCBwYXRocyBmcm9tIG9uZSB0eXBlIHRvIGFub3RoZXIuXG4gKi9cbnZhciBQYXRoVXRpbHMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGF0aFV0aWxzKCkge1xuICAgIH1cbiAgICAvKiogR2l2ZW4gYSBQYXRoTm9kZVtdLCBjcmVhdGUgYW4gVGFyZ2V0U3RhdGUgKi9cbiAgICBQYXRoVXRpbHMubWFrZVRhcmdldFN0YXRlID0gZnVuY3Rpb24gKHJlZ2lzdHJ5LCBwYXRoKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IGNvbW1vbl8xLnRhaWwocGF0aCkuc3RhdGU7XG4gICAgICAgIHJldHVybiBuZXcgdGFyZ2V0U3RhdGVfMS5UYXJnZXRTdGF0ZShyZWdpc3RyeSwgc3RhdGUsIHBhdGgubWFwKGhvZl8xLnByb3AoJ3BhcmFtVmFsdWVzJykpLnJlZHVjZShjb21tb25fMS5tZXJnZVIsIHt9KSwge30pO1xuICAgIH07XG4gICAgUGF0aFV0aWxzLmJ1aWxkUGF0aCA9IGZ1bmN0aW9uICh0YXJnZXRTdGF0ZSkge1xuICAgICAgICB2YXIgdG9QYXJhbXMgPSB0YXJnZXRTdGF0ZS5wYXJhbXMoKTtcbiAgICAgICAgcmV0dXJuIHRhcmdldFN0YXRlLiRzdGF0ZSgpLnBhdGgubWFwKGZ1bmN0aW9uIChzdGF0ZSkgeyByZXR1cm4gbmV3IHBhdGhOb2RlXzEuUGF0aE5vZGUoc3RhdGUpLmFwcGx5UmF3UGFyYW1zKHRvUGFyYW1zKTsgfSk7XG4gICAgfTtcbiAgICAvKiogR2l2ZW4gYSBmcm9tUGF0aDogUGF0aE5vZGVbXSBhbmQgYSBUYXJnZXRTdGF0ZSwgYnVpbGRzIGEgdG9QYXRoOiBQYXRoTm9kZVtdICovXG4gICAgUGF0aFV0aWxzLmJ1aWxkVG9QYXRoID0gZnVuY3Rpb24gKGZyb21QYXRoLCB0YXJnZXRTdGF0ZSkge1xuICAgICAgICB2YXIgdG9QYXRoID0gUGF0aFV0aWxzLmJ1aWxkUGF0aCh0YXJnZXRTdGF0ZSk7XG4gICAgICAgIGlmICh0YXJnZXRTdGF0ZS5vcHRpb25zKCkuaW5oZXJpdCkge1xuICAgICAgICAgICAgcmV0dXJuIFBhdGhVdGlscy5pbmhlcml0UGFyYW1zKGZyb21QYXRoLCB0b1BhdGgsIE9iamVjdC5rZXlzKHRhcmdldFN0YXRlLnBhcmFtcygpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvUGF0aDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgVmlld0NvbmZpZyBvYmplY3RzIGFuZCBhZGRzIHRvIG5vZGVzLlxuICAgICAqXG4gICAgICogT24gZWFjaCBbW1BhdGhOb2RlXV0sIGNyZWF0ZXMgVmlld0NvbmZpZyBvYmplY3RzIGZyb20gdGhlIHZpZXdzOiBwcm9wZXJ0eSBvZiB0aGUgbm9kZSdzIHN0YXRlXG4gICAgICovXG4gICAgUGF0aFV0aWxzLmFwcGx5Vmlld0NvbmZpZ3MgPSBmdW5jdGlvbiAoJHZpZXcsIHBhdGgsIHN0YXRlcykge1xuICAgICAgICAvLyBPbmx5IGFwcGx5IHRoZSB2aWV3Q29uZmlncyB0byB0aGUgbm9kZXMgZm9yIHRoZSBnaXZlbiBzdGF0ZXNcbiAgICAgICAgcGF0aC5maWx0ZXIoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIGNvbW1vbl8xLmluQXJyYXkoc3RhdGVzLCBub2RlLnN0YXRlKTsgfSkuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgdmFyIHZpZXdEZWNscyA9IGNvbW1vbl8xLnZhbHVlcyhub2RlLnN0YXRlLnZpZXdzIHx8IHt9KTtcbiAgICAgICAgICAgIHZhciBzdWJQYXRoID0gUGF0aFV0aWxzLnN1YlBhdGgocGF0aCwgZnVuY3Rpb24gKG4pIHsgcmV0dXJuIG4gPT09IG5vZGU7IH0pO1xuICAgICAgICAgICAgdmFyIHZpZXdDb25maWdzID0gdmlld0RlY2xzLm1hcChmdW5jdGlvbiAodmlldykgeyByZXR1cm4gJHZpZXcuY3JlYXRlVmlld0NvbmZpZyhzdWJQYXRoLCB2aWV3KTsgfSk7XG4gICAgICAgICAgICBub2RlLnZpZXdzID0gdmlld0NvbmZpZ3MucmVkdWNlKGNvbW1vbl8xLnVubmVzdFIsIFtdKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIGZyb21QYXRoIGFuZCBhIHRvUGF0aCwgcmV0dXJucyBhIG5ldyB0byBwYXRoIHdoaWNoIGluaGVyaXRzIHBhcmFtZXRlcnMgZnJvbSB0aGUgZnJvbVBhdGhcbiAgICAgKlxuICAgICAqIEZvciBhIHBhcmFtZXRlciBpbiBhIG5vZGUgdG8gYmUgaW5oZXJpdGVkIGZyb20gdGhlIGZyb20gcGF0aDpcbiAgICAgKiAtIFRoZSB0b1BhdGgncyBub2RlIG11c3QgaGF2ZSBhIG1hdGNoaW5nIG5vZGUgaW4gdGhlIGZyb21QYXRoIChieSBzdGF0ZSkuXG4gICAgICogLSBUaGUgcGFyYW1ldGVyIG5hbWUgbXVzdCBub3QgYmUgZm91bmQgaW4gdGhlIHRvS2V5cyBwYXJhbWV0ZXIgYXJyYXkuXG4gICAgICpcbiAgICAgKiBOb3RlOiB0aGUga2V5cyBwcm92aWRlZCBpbiB0b0tleXMgYXJlIGludGVuZGVkIHRvIGJlIHRob3NlIHBhcmFtIGtleXMgZXhwbGljaXRseSBzcGVjaWZpZWQgYnkgc29tZVxuICAgICAqIGNhbGxlciwgZm9yIGluc3RhbmNlLCAkc3RhdGUudHJhbnNpdGlvblRvKC4uLiwgdG9QYXJhbXMpLiAgSWYgYSBrZXkgd2FzIGZvdW5kIGluIHRvUGFyYW1zLFxuICAgICAqIGl0IGlzIG5vdCBpbmhlcml0ZWQgZnJvbSB0aGUgZnJvbVBhdGguXG4gICAgICovXG4gICAgUGF0aFV0aWxzLmluaGVyaXRQYXJhbXMgPSBmdW5jdGlvbiAoZnJvbVBhdGgsIHRvUGF0aCwgdG9LZXlzKSB7XG4gICAgICAgIGlmICh0b0tleXMgPT09IHZvaWQgMCkgeyB0b0tleXMgPSBbXTsgfVxuICAgICAgICBmdW5jdGlvbiBub2RlUGFyYW1WYWxzKHBhdGgsIHN0YXRlKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IGNvbW1vbl8xLmZpbmQocGF0aCwgaG9mXzEucHJvcEVxKCdzdGF0ZScsIHN0YXRlKSk7XG4gICAgICAgICAgICByZXR1cm4gY29tbW9uXzEuZXh0ZW5kKHt9LCBub2RlICYmIG5vZGUucGFyYW1WYWx1ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBub0luaGVyaXQgPSBmcm9tUGF0aC5tYXAoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUucGFyYW1TY2hlbWE7IH0pXG4gICAgICAgICAgICAucmVkdWNlKGNvbW1vbl8xLnVubmVzdFIsIFtdKVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAocGFyYW0pIHsgcmV0dXJuICFwYXJhbS5pbmhlcml0OyB9KVxuICAgICAgICAgICAgLm1hcChob2ZfMS5wcm9wKCdpZCcpKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdpdmVuIGFuIFtbUGF0aE5vZGVdXSBcInRvTm9kZVwiLCByZXR1cm4gYSBuZXcgW1tQYXRoTm9kZV1dIHdpdGggcGFyYW0gdmFsdWVzIGluaGVyaXRlZCBmcm9tIHRoZVxuICAgICAgICAgKiBtYXRjaGluZyBub2RlIGluIGZyb21QYXRoLiAgT25seSBpbmhlcml0IGtleXMgdGhhdCBhcmVuJ3QgZm91bmQgaW4gXCJ0b0tleXNcIiBmcm9tIHRoZSBub2RlIGluIFwiZnJvbVBhdGhcIlwiXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBtYWtlSW5oZXJpdGVkUGFyYW1zTm9kZSh0b05vZGUpIHtcbiAgICAgICAgICAgIC8vIEFsbCBwYXJhbSB2YWx1ZXMgZm9yIHRoZSBub2RlIChtYXkgaW5jbHVkZSBkZWZhdWx0IGtleS92YWxzLCB3aGVuIGtleSB3YXMgbm90IGZvdW5kIGluIHRvUGFyYW1zKVxuICAgICAgICAgICAgdmFyIHRvUGFyYW1WYWxzID0gY29tbW9uXzEuZXh0ZW5kKHt9LCB0b05vZGUgJiYgdG9Ob2RlLnBhcmFtVmFsdWVzKTtcbiAgICAgICAgICAgIC8vIGxpbWl0ZWQgdG8gb25seSB0aG9zZSBrZXlzIGZvdW5kIGluIHRvUGFyYW1zXG4gICAgICAgICAgICB2YXIgaW5jb21pbmdQYXJhbVZhbHMgPSBjb21tb25fMS5waWNrKHRvUGFyYW1WYWxzLCB0b0tleXMpO1xuICAgICAgICAgICAgdG9QYXJhbVZhbHMgPSBjb21tb25fMS5vbWl0KHRvUGFyYW1WYWxzLCB0b0tleXMpO1xuICAgICAgICAgICAgdmFyIGZyb21QYXJhbVZhbHMgPSBjb21tb25fMS5vbWl0KG5vZGVQYXJhbVZhbHMoZnJvbVBhdGgsIHRvTm9kZS5zdGF0ZSkgfHwge30sIG5vSW5oZXJpdCk7XG4gICAgICAgICAgICAvLyBleHRlbmQgdG9QYXJhbVZhbHMgd2l0aCBhbnkgZnJvbVBhcmFtVmFscywgdGhlbiBvdmVycmlkZSBhbnkgb2YgdGhvc2UgdGhvc2Ugd2l0aCBpbmNvbWluZ1BhcmFtVmFsc1xuICAgICAgICAgICAgdmFyIG93blBhcmFtVmFscyA9IGNvbW1vbl8xLmV4dGVuZCh0b1BhcmFtVmFscywgZnJvbVBhcmFtVmFscywgaW5jb21pbmdQYXJhbVZhbHMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBwYXRoTm9kZV8xLlBhdGhOb2RlKHRvTm9kZS5zdGF0ZSkuYXBwbHlSYXdQYXJhbXMob3duUGFyYW1WYWxzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgcGFyYW0ga2V5cyBzcGVjaWZpZWQgYnkgdGhlIGluY29taW5nIHRvUGFyYW1zXG4gICAgICAgIHJldHVybiB0b1BhdGgubWFwKG1ha2VJbmhlcml0ZWRQYXJhbXNOb2RlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSB0cmVlIGNoYW5nZXMgKGVudGVyaW5nLCBleGl0aW5nKSBiZXR3ZWVuIGEgZnJvbVBhdGggYW5kIHRvUGF0aC5cbiAgICAgKi9cbiAgICBQYXRoVXRpbHMudHJlZUNoYW5nZXMgPSBmdW5jdGlvbiAoZnJvbVBhdGgsIHRvUGF0aCwgcmVsb2FkU3RhdGUpIHtcbiAgICAgICAgdmFyIG1heCA9IE1hdGgubWluKGZyb21QYXRoLmxlbmd0aCwgdG9QYXRoLmxlbmd0aCk7XG4gICAgICAgIHZhciBrZWVwID0gMDtcbiAgICAgICAgdmFyIG5vZGVzTWF0Y2ggPSBmdW5jdGlvbiAobm9kZTEsIG5vZGUyKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTEuZXF1YWxzKG5vZGUyLCBQYXRoVXRpbHMubm9uRHluYW1pY1BhcmFtcyk7XG4gICAgICAgIH07XG4gICAgICAgIHdoaWxlIChrZWVwIDwgbWF4ICYmIGZyb21QYXRoW2tlZXBdLnN0YXRlICE9PSByZWxvYWRTdGF0ZSAmJiBub2Rlc01hdGNoKGZyb21QYXRoW2tlZXBdLCB0b1BhdGhba2VlcF0pKSB7XG4gICAgICAgICAgICBrZWVwKys7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIEdpdmVuIGEgcmV0YWluZWQgbm9kZSwgcmV0dXJuIGEgbmV3IG5vZGUgd2hpY2ggdXNlcyB0aGUgdG8gbm9kZSdzIHBhcmFtIHZhbHVlcyAqL1xuICAgICAgICBmdW5jdGlvbiBhcHBseVRvUGFyYW1zKHJldGFpbmVkTm9kZSwgaWR4KSB7XG4gICAgICAgICAgICB2YXIgY2xvbmVkID0gcGF0aE5vZGVfMS5QYXRoTm9kZS5jbG9uZShyZXRhaW5lZE5vZGUpO1xuICAgICAgICAgICAgY2xvbmVkLnBhcmFtVmFsdWVzID0gdG9QYXRoW2lkeF0ucGFyYW1WYWx1ZXM7XG4gICAgICAgICAgICByZXR1cm4gY2xvbmVkO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmcm9tLCByZXRhaW5lZCwgZXhpdGluZywgZW50ZXJpbmcsIHRvO1xuICAgICAgICBmcm9tID0gZnJvbVBhdGg7XG4gICAgICAgIHJldGFpbmVkID0gZnJvbS5zbGljZSgwLCBrZWVwKS5tYXAoYXBwbHlUb1BhcmFtcyk7IC8vIGFwcGx5VG9QYXJhbXMgdG8gdXBkYXRlIGR5bmFtaWMgcGFyYW1zXG4gICAgICAgIGV4aXRpbmcgPSBmcm9tLnNsaWNlKGtlZXApO1xuICAgICAgICBlbnRlcmluZyA9IHRvUGF0aC5zbGljZShrZWVwKTtcbiAgICAgICAgdG8gPSAocmV0YWluZWQpLmNvbmNhdChlbnRlcmluZyk7XG4gICAgICAgIHJldHVybiB7IGZyb206IGZyb20sIHRvOiB0bywgcmV0YWluZWQ6IHJldGFpbmVkLCBleGl0aW5nOiBleGl0aW5nLCBlbnRlcmluZzogZW50ZXJpbmcgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgcGF0aCB3aGljaCBpczogdGhlIHN1YnBhdGggb2YgdGhlIGZpcnN0IHBhdGggd2hpY2ggbWF0Y2hlcyB0aGUgc2Vjb25kIHBhdGguXG4gICAgICpcbiAgICAgKiBUaGUgbmV3IHBhdGggc3RhcnRzIGZyb20gcm9vdCBhbmQgY29udGFpbnMgYW55IG5vZGVzIHRoYXQgbWF0Y2ggdGhlIG5vZGVzIGluIHRoZSBzZWNvbmQgcGF0aC5cbiAgICAgKiBJdCBzdG9wcyBiZWZvcmUgdGhlIGZpcnN0IG5vbi1tYXRjaGluZyBub2RlLlxuICAgICAqXG4gICAgICogTm9kZXMgYXJlIGNvbXBhcmVkIHVzaW5nIHRoZWlyIHN0YXRlIHByb3BlcnR5IGFuZCB0aGVpciBwYXJhbWV0ZXIgdmFsdWVzLlxuICAgICAqIElmIGEgYHBhcmFtc0ZuYCBpcyBwcm92aWRlZCwgb25seSB0aGUgW1tQYXJhbV1dIHJldHVybmVkIGJ5IHRoZSBmdW5jdGlvbiB3aWxsIGJlIGNvbnNpZGVyZWQgd2hlbiBjb21wYXJpbmcgbm9kZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGF0aEEgdGhlIGZpcnN0IHBhdGhcbiAgICAgKiBAcGFyYW0gcGF0aEIgdGhlIHNlY29uZCBwYXRoXG4gICAgICogQHBhcmFtIHBhcmFtc0ZuIGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyB0aGUgcGFyYW1ldGVycyB0byBjb25zaWRlciB3aGVuIGNvbXBhcmluZ1xuICAgICAqXG4gICAgICogQHJldHVybnMgYW4gYXJyYXkgb2YgUGF0aE5vZGVzIGZyb20gdGhlIGZpcnN0IHBhdGggd2hpY2ggbWF0Y2ggdGhlIG5vZGVzIGluIHRoZSBzZWNvbmQgcGF0aFxuICAgICAqL1xuICAgIFBhdGhVdGlscy5tYXRjaGluZyA9IGZ1bmN0aW9uIChwYXRoQSwgcGF0aEIsIHBhcmFtc0ZuKSB7XG4gICAgICAgIHZhciBkb25lID0gZmFsc2U7XG4gICAgICAgIHZhciB0dXBsZXMgPSBjb21tb25fMS5hcnJheVR1cGxlcyhwYXRoQSwgcGF0aEIpO1xuICAgICAgICByZXR1cm4gdHVwbGVzLnJlZHVjZShmdW5jdGlvbiAobWF0Y2hpbmcsIF9hKSB7XG4gICAgICAgICAgICB2YXIgbm9kZUEgPSBfYVswXSwgbm9kZUIgPSBfYVsxXTtcbiAgICAgICAgICAgIGRvbmUgPSBkb25lIHx8ICFub2RlQS5lcXVhbHMobm9kZUIsIHBhcmFtc0ZuKTtcbiAgICAgICAgICAgIHJldHVybiBkb25lID8gbWF0Y2hpbmcgOiBtYXRjaGluZy5jb25jYXQobm9kZUEpO1xuICAgICAgICB9LCBbXSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdHdvIHBhdGhzIGFyZSBpZGVudGljYWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGF0aEFcbiAgICAgKiBAcGFyYW0gcGF0aEJcbiAgICAgKiBAcGFyYW0gcGFyYW1zRm4gYSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIHRoZSBwYXJhbWV0ZXJzIHRvIGNvbnNpZGVyIHdoZW4gY29tcGFyaW5nXG4gICAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgdGhlIHN0YXRlcyBhbmQgcGFyYW1ldGVyIHZhbHVlcyBmb3IgYm90aCBwYXRocyBhcmUgaWRlbnRpY2FsXG4gICAgICovXG4gICAgUGF0aFV0aWxzLmVxdWFscyA9IGZ1bmN0aW9uIChwYXRoQSwgcGF0aEIsIHBhcmFtc0ZuKSB7XG4gICAgICAgIHJldHVybiBwYXRoQS5sZW5ndGggPT09IHBhdGhCLmxlbmd0aCAmJlxuICAgICAgICAgICAgUGF0aFV0aWxzLm1hdGNoaW5nKHBhdGhBLCBwYXRoQiwgcGFyYW1zRm4pLmxlbmd0aCA9PT0gcGF0aEEubGVuZ3RoO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgc3VicGF0aCBvZiBhIHBhdGgsIHdoaWNoIHN0b3BzIGF0IHRoZSBmaXJzdCBtYXRjaGluZyBub2RlXG4gICAgICpcbiAgICAgKiBHaXZlbiBhbiBhcnJheSBvZiBub2RlcywgcmV0dXJucyBhIHN1YnNldCBvZiB0aGUgYXJyYXkgc3RhcnRpbmcgZnJvbSB0aGUgZmlyc3Qgbm9kZSxcbiAgICAgKiBzdG9wcGluZyB3aGVuIHRoZSBmaXJzdCBub2RlIG1hdGNoZXMgdGhlIHByZWRpY2F0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXRoIGEgcGF0aCBvZiBbW1BhdGhOb2RlXV1zXG4gICAgICogQHBhcmFtIHByZWRpY2F0ZSBhIFtbUHJlZGljYXRlXV0gZm4gdGhhdCBtYXRjaGVzIFtbUGF0aE5vZGVdXXNcbiAgICAgKiBAcmV0dXJucyBhIHN1YnBhdGggdXAgdG8gdGhlIG1hdGNoaW5nIG5vZGUsIG9yIHVuZGVmaW5lZCBpZiBubyBtYXRjaCBpcyBmb3VuZFxuICAgICAqL1xuICAgIFBhdGhVdGlscy5zdWJQYXRoID0gZnVuY3Rpb24gKHBhdGgsIHByZWRpY2F0ZSkge1xuICAgICAgICB2YXIgbm9kZSA9IGNvbW1vbl8xLmZpbmQocGF0aCwgcHJlZGljYXRlKTtcbiAgICAgICAgdmFyIGVsZW1lbnRJZHggPSBwYXRoLmluZGV4T2Yobm9kZSk7XG4gICAgICAgIHJldHVybiBlbGVtZW50SWR4ID09PSAtMSA/IHVuZGVmaW5lZCA6IHBhdGguc2xpY2UoMCwgZWxlbWVudElkeCArIDEpO1xuICAgIH07XG4gICAgUGF0aFV0aWxzLm5vbkR5bmFtaWNQYXJhbXMgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZS5zdGF0ZS5wYXJhbWV0ZXJzKHsgaW5oZXJpdDogZmFsc2UgfSlcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHBhcmFtKSB7IHJldHVybiAhcGFyYW0uZHluYW1pYzsgfSk7XG4gICAgfTtcbiAgICAvKiogR2V0cyB0aGUgcmF3IHBhcmFtZXRlciB2YWx1ZXMgZnJvbSBhIHBhdGggKi9cbiAgICBQYXRoVXRpbHMucGFyYW1WYWx1ZXMgPSBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICByZXR1cm4gcGF0aC5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgbm9kZSkgeyByZXR1cm4gY29tbW9uXzEuZXh0ZW5kKGFjYywgbm9kZS5wYXJhbVZhbHVlcyk7IH0sIHt9KTtcbiAgICB9O1xuICAgIHJldHVybiBQYXRoVXRpbHM7XG59KCkpO1xuZXhwb3J0cy5QYXRoVXRpbHMgPSBQYXRoVXRpbHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXRoVXRpbHMuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3BhdGgvcGF0aFV0aWxzLmpzXG4vLyBtb2R1bGUgaWQgPSAzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///30\n")},function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @module resolve */\n/** for typedoc */\nvar common_1 = __webpack_require__(0);\nvar hof_1 = __webpack_require__(2);\nvar trace_1 = __webpack_require__(8);\nvar coreservices_1 = __webpack_require__(3);\nvar interface_1 = __webpack_require__(71);\nvar resolvable_1 = __webpack_require__(26);\nvar pathUtils_1 = __webpack_require__(30);\nvar strings_1 = __webpack_require__(6);\nvar common_2 = __webpack_require__(5);\nvar whens = interface_1.resolvePolicies.when;\nvar ALL_WHENS = [whens.EAGER, whens.LAZY];\nvar EAGER_WHENS = [whens.EAGER];\n// tslint:disable-next-line:no-inferrable-types\nexports.NATIVE_INJECTOR_TOKEN = 'Native Injector';\n/**\n * Encapsulates Dependency Injection for a path of nodes\n *\n * UI-Router states are organized as a tree.\n * A nested state has a path of ancestors to the root of the tree.\n * When a state is being activated, each element in the path is wrapped as a [[PathNode]].\n * A `PathNode` is a stateful object that holds things like parameters and resolvables for the state being activated.\n *\n * The ResolveContext closes over the [[PathNode]]s, and provides DI for the last node in the path.\n */\nvar ResolveContext = /** @class */ (function () {\n    function ResolveContext(_path) {\n        this._path = _path;\n    }\n    /** Gets all the tokens found in the resolve context, de-duplicated */\n    ResolveContext.prototype.getTokens = function () {\n        return this._path.reduce(function (acc, node) { return acc.concat(node.resolvables.map(function (r) { return r.token; })); }, []).reduce(common_1.uniqR, []);\n    };\n    /**\n     * Gets the Resolvable that matches the token\n     *\n     * Gets the last Resolvable that matches the token in this context, or undefined.\n     * Throws an error if it doesn't exist in the ResolveContext\n     */\n    ResolveContext.prototype.getResolvable = function (token) {\n        var matching = this._path.map(function (node) { return node.resolvables; })\n            .reduce(common_1.unnestR, [])\n            .filter(function (r) { return r.token === token; });\n        return common_1.tail(matching);\n    };\n    /** Returns the [[ResolvePolicy]] for the given [[Resolvable]] */\n    ResolveContext.prototype.getPolicy = function (resolvable) {\n        var node = this.findNode(resolvable);\n        return resolvable.getPolicy(node.state);\n    };\n    /**\n     * Returns a ResolveContext that includes a portion of this one\n     *\n     * Given a state, this method creates a new ResolveContext from this one.\n     * The new context starts at the first node (root) and stops at the node for the `state` parameter.\n     *\n     * #### Why\n     *\n     * When a transition is created, the nodes in the \"To Path\" are injected from a ResolveContext.\n     * A ResolveContext closes over a path of [[PathNode]]s and processes the resolvables.\n     * The \"To State\" can inject values from its own resolvables, as well as those from all its ancestor state's (node's).\n     * This method is used to create a narrower context when injecting ancestor nodes.\n     *\n     * @example\n     * `let ABCD = new ResolveContext([A, B, C, D]);`\n     *\n     * Given a path `[A, B, C, D]`, where `A`, `B`, `C` and `D` are nodes for states `a`, `b`, `c`, `d`:\n     * When injecting `D`, `D` should have access to all resolvables from `A`, `B`, `C`, `D`.\n     * However, `B` should only be able to access resolvables from `A`, `B`.\n     *\n     * When resolving for the `B` node, first take the full \"To Path\" Context `[A,B,C,D]` and limit to the subpath `[A,B]`.\n     * `let AB = ABCD.subcontext(a)`\n     */\n    ResolveContext.prototype.subContext = function (state) {\n        return new ResolveContext(pathUtils_1.PathUtils.subPath(this._path, function (node) { return node.state === state; }));\n    };\n    /**\n     * Adds Resolvables to the node that matches the state\n     *\n     * This adds a [[Resolvable]] (generally one created on the fly; not declared on a [[StateDeclaration.resolve]] block).\n     * The resolvable is added to the node matching the `state` parameter.\n     *\n     * These new resolvables are not automatically fetched.\n     * The calling code should either fetch them, fetch something that depends on them,\n     * or rely on [[resolvePath]] being called when some state is being entered.\n     *\n     * Note: each resolvable's [[ResolvePolicy]] is merged with the state's policy, and the global default.\n     *\n     * @param newResolvables the new Resolvables\n     * @param state Used to find the node to put the resolvable on\n     */\n    ResolveContext.prototype.addResolvables = function (newResolvables, state) {\n        var node = common_1.find(this._path, hof_1.propEq('state', state));\n        var keys = newResolvables.map(function (r) { return r.token; });\n        node.resolvables = node.resolvables.filter(function (r) { return keys.indexOf(r.token) === -1; }).concat(newResolvables);\n    };\n    /**\n     * Returns a promise for an array of resolved path Element promises\n     *\n     * @param when\n     * @param trans\n     * @returns {Promise<any>|any}\n     */\n    ResolveContext.prototype.resolvePath = function (when, trans) {\n        var _this = this;\n        if (when === void 0) { when = 'LAZY'; }\n        // This option determines which 'when' policy Resolvables we are about to fetch.\n        var whenOption = common_1.inArray(ALL_WHENS, when) ? when : 'LAZY';\n        // If the caller specified EAGER, only the EAGER Resolvables are fetched.\n        // if the caller specified LAZY, both EAGER and LAZY Resolvables are fetched.`\n        var matchedWhens = whenOption === interface_1.resolvePolicies.when.EAGER ? EAGER_WHENS : ALL_WHENS;\n        // get the subpath to the state argument, if provided\n        trace_1.trace.traceResolvePath(this._path, when, trans);\n        var matchesPolicy = function (acceptedVals, whenOrAsync) {\n            return function (resolvable) {\n                return common_1.inArray(acceptedVals, _this.getPolicy(resolvable)[whenOrAsync]);\n            };\n        };\n        // Trigger all the (matching) Resolvables in the path\n        // Reduce all the \"WAIT\" Resolvables into an array\n        var promises = this._path.reduce(function (acc, node) {\n            var nodeResolvables = node.resolvables.filter(matchesPolicy(matchedWhens, 'when'));\n            var nowait = nodeResolvables.filter(matchesPolicy(['NOWAIT'], 'async'));\n            var wait = nodeResolvables.filter(hof_1.not(matchesPolicy(['NOWAIT'], 'async')));\n            // For the matching Resolvables, start their async fetch process.\n            var subContext = _this.subContext(node.state);\n            var getResult = function (r) { return r.get(subContext, trans)\n                .then(function (value) { return ({ token: r.token, value: value }); }); };\n            nowait.forEach(getResult);\n            return acc.concat(wait.map(getResult));\n        }, []);\n        // Wait for all the \"WAIT\" resolvables\n        return coreservices_1.services.$q.all(promises);\n    };\n    ResolveContext.prototype.injector = function () {\n        return this._injector || (this._injector = new UIInjectorImpl(this));\n    };\n    ResolveContext.prototype.findNode = function (resolvable) {\n        return common_1.find(this._path, function (node) { return common_1.inArray(node.resolvables, resolvable); });\n    };\n    /**\n     * Gets the async dependencies of a Resolvable\n     *\n     * Given a Resolvable, returns its dependencies as a Resolvable[]\n     */\n    ResolveContext.prototype.getDependencies = function (resolvable) {\n        var _this = this;\n        var node = this.findNode(resolvable);\n        // Find which other resolvables are \"visible\" to the `resolvable` argument\n        // subpath stopping at resolvable's node, or the whole path (if the resolvable isn't in the path)\n        var subPath = pathUtils_1.PathUtils.subPath(this._path, function (x) { return x === node; }) || this._path;\n        var availableResolvables = subPath\n            .reduce(function (acc, _node) { return acc.concat(_node.resolvables); }, []) // all of subpath's resolvables\n            .filter(function (res) { return res !== resolvable; }); // filter out the `resolvable` argument\n        var getDependency = function (token) {\n            var matching = availableResolvables.filter(function (r) { return r.token === token; });\n            if (matching.length)\n                return common_1.tail(matching);\n            var fromInjector = _this.injector().getNative(token);\n            if (common_2.isUndefined(fromInjector)) {\n                throw new Error('Could not find Dependency Injection token: ' + strings_1.stringify(token));\n            }\n            return new resolvable_1.Resolvable(token, function () { return fromInjector; }, [], fromInjector);\n        };\n        return resolvable.deps.map(getDependency);\n    };\n    return ResolveContext;\n}());\nexports.ResolveContext = ResolveContext;\nvar UIInjectorImpl = /** @class */ (function () {\n    function UIInjectorImpl(context) {\n        this.context = context;\n        this.native = this.get(exports.NATIVE_INJECTOR_TOKEN) || coreservices_1.services.$injector;\n    }\n    UIInjectorImpl.prototype.get = function (token) {\n        var resolvable = this.context.getResolvable(token);\n        if (resolvable) {\n            if (this.context.getPolicy(resolvable).async === 'NOWAIT') {\n                return resolvable.get(this.context);\n            }\n            if (!resolvable.resolved) {\n                throw new Error('Resolvable async .get() not complete:' + strings_1.stringify(resolvable.token));\n            }\n            return resolvable.data;\n        }\n        return this.getNative(token);\n    };\n    UIInjectorImpl.prototype.getAsync = function (token) {\n        var resolvable = this.context.getResolvable(token);\n        if (resolvable)\n            return resolvable.get(this.context);\n        return coreservices_1.services.$q.when(this.native.get(token));\n    };\n    UIInjectorImpl.prototype.getNative = function (token) {\n        return this.native && this.native.get(token);\n    };\n    return UIInjectorImpl;\n}());\n//# sourceMappingURL=resolveContext.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3Jlc29sdmUvcmVzb2x2ZUNvbnRleHQuanM/MmNkNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKiBAbW9kdWxlIHJlc29sdmUgKi9cbi8qKiBmb3IgdHlwZWRvYyAqL1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb21tb25cIik7XG52YXIgaG9mXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2hvZlwiKTtcbnZhciB0cmFjZV8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi90cmFjZVwiKTtcbnZhciBjb3Jlc2VydmljZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29yZXNlcnZpY2VzXCIpO1xudmFyIGludGVyZmFjZV8xID0gcmVxdWlyZShcIi4vaW50ZXJmYWNlXCIpO1xudmFyIHJlc29sdmFibGVfMSA9IHJlcXVpcmUoXCIuL3Jlc29sdmFibGVcIik7XG52YXIgcGF0aFV0aWxzXzEgPSByZXF1aXJlKFwiLi4vcGF0aC9wYXRoVXRpbHNcIik7XG52YXIgc3RyaW5nc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9zdHJpbmdzXCIpO1xudmFyIGNvbW1vbl8yID0gcmVxdWlyZShcIi4uL2NvbW1vblwiKTtcbnZhciB3aGVucyA9IGludGVyZmFjZV8xLnJlc29sdmVQb2xpY2llcy53aGVuO1xudmFyIEFMTF9XSEVOUyA9IFt3aGVucy5FQUdFUiwgd2hlbnMuTEFaWV07XG52YXIgRUFHRVJfV0hFTlMgPSBbd2hlbnMuRUFHRVJdO1xuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWluZmVycmFibGUtdHlwZXNcbmV4cG9ydHMuTkFUSVZFX0lOSkVDVE9SX1RPS0VOID0gJ05hdGl2ZSBJbmplY3Rvcic7XG4vKipcbiAqIEVuY2Fwc3VsYXRlcyBEZXBlbmRlbmN5IEluamVjdGlvbiBmb3IgYSBwYXRoIG9mIG5vZGVzXG4gKlxuICogVUktUm91dGVyIHN0YXRlcyBhcmUgb3JnYW5pemVkIGFzIGEgdHJlZS5cbiAqIEEgbmVzdGVkIHN0YXRlIGhhcyBhIHBhdGggb2YgYW5jZXN0b3JzIHRvIHRoZSByb290IG9mIHRoZSB0cmVlLlxuICogV2hlbiBhIHN0YXRlIGlzIGJlaW5nIGFjdGl2YXRlZCwgZWFjaCBlbGVtZW50IGluIHRoZSBwYXRoIGlzIHdyYXBwZWQgYXMgYSBbW1BhdGhOb2RlXV0uXG4gKiBBIGBQYXRoTm9kZWAgaXMgYSBzdGF0ZWZ1bCBvYmplY3QgdGhhdCBob2xkcyB0aGluZ3MgbGlrZSBwYXJhbWV0ZXJzIGFuZCByZXNvbHZhYmxlcyBmb3IgdGhlIHN0YXRlIGJlaW5nIGFjdGl2YXRlZC5cbiAqXG4gKiBUaGUgUmVzb2x2ZUNvbnRleHQgY2xvc2VzIG92ZXIgdGhlIFtbUGF0aE5vZGVdXXMsIGFuZCBwcm92aWRlcyBESSBmb3IgdGhlIGxhc3Qgbm9kZSBpbiB0aGUgcGF0aC5cbiAqL1xudmFyIFJlc29sdmVDb250ZXh0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlc29sdmVDb250ZXh0KF9wYXRoKSB7XG4gICAgICAgIHRoaXMuX3BhdGggPSBfcGF0aDtcbiAgICB9XG4gICAgLyoqIEdldHMgYWxsIHRoZSB0b2tlbnMgZm91bmQgaW4gdGhlIHJlc29sdmUgY29udGV4dCwgZGUtZHVwbGljYXRlZCAqL1xuICAgIFJlc29sdmVDb250ZXh0LnByb3RvdHlwZS5nZXRUb2tlbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXRoLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBub2RlKSB7IHJldHVybiBhY2MuY29uY2F0KG5vZGUucmVzb2x2YWJsZXMubWFwKGZ1bmN0aW9uIChyKSB7IHJldHVybiByLnRva2VuOyB9KSk7IH0sIFtdKS5yZWR1Y2UoY29tbW9uXzEudW5pcVIsIFtdKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIFJlc29sdmFibGUgdGhhdCBtYXRjaGVzIHRoZSB0b2tlblxuICAgICAqXG4gICAgICogR2V0cyB0aGUgbGFzdCBSZXNvbHZhYmxlIHRoYXQgbWF0Y2hlcyB0aGUgdG9rZW4gaW4gdGhpcyBjb250ZXh0LCBvciB1bmRlZmluZWQuXG4gICAgICogVGhyb3dzIGFuIGVycm9yIGlmIGl0IGRvZXNuJ3QgZXhpc3QgaW4gdGhlIFJlc29sdmVDb250ZXh0XG4gICAgICovXG4gICAgUmVzb2x2ZUNvbnRleHQucHJvdG90eXBlLmdldFJlc29sdmFibGUgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgdmFyIG1hdGNoaW5nID0gdGhpcy5fcGF0aC5tYXAoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUucmVzb2x2YWJsZXM7IH0pXG4gICAgICAgICAgICAucmVkdWNlKGNvbW1vbl8xLnVubmVzdFIsIFtdKVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAocikgeyByZXR1cm4gci50b2tlbiA9PT0gdG9rZW47IH0pO1xuICAgICAgICByZXR1cm4gY29tbW9uXzEudGFpbChtYXRjaGluZyk7XG4gICAgfTtcbiAgICAvKiogUmV0dXJucyB0aGUgW1tSZXNvbHZlUG9saWN5XV0gZm9yIHRoZSBnaXZlbiBbW1Jlc29sdmFibGVdXSAqL1xuICAgIFJlc29sdmVDb250ZXh0LnByb3RvdHlwZS5nZXRQb2xpY3kgPSBmdW5jdGlvbiAocmVzb2x2YWJsZSkge1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuZmluZE5vZGUocmVzb2x2YWJsZSk7XG4gICAgICAgIHJldHVybiByZXNvbHZhYmxlLmdldFBvbGljeShub2RlLnN0YXRlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBSZXNvbHZlQ29udGV4dCB0aGF0IGluY2x1ZGVzIGEgcG9ydGlvbiBvZiB0aGlzIG9uZVxuICAgICAqXG4gICAgICogR2l2ZW4gYSBzdGF0ZSwgdGhpcyBtZXRob2QgY3JlYXRlcyBhIG5ldyBSZXNvbHZlQ29udGV4dCBmcm9tIHRoaXMgb25lLlxuICAgICAqIFRoZSBuZXcgY29udGV4dCBzdGFydHMgYXQgdGhlIGZpcnN0IG5vZGUgKHJvb3QpIGFuZCBzdG9wcyBhdCB0aGUgbm9kZSBmb3IgdGhlIGBzdGF0ZWAgcGFyYW1ldGVyLlxuICAgICAqXG4gICAgICogIyMjIyBXaHlcbiAgICAgKlxuICAgICAqIFdoZW4gYSB0cmFuc2l0aW9uIGlzIGNyZWF0ZWQsIHRoZSBub2RlcyBpbiB0aGUgXCJUbyBQYXRoXCIgYXJlIGluamVjdGVkIGZyb20gYSBSZXNvbHZlQ29udGV4dC5cbiAgICAgKiBBIFJlc29sdmVDb250ZXh0IGNsb3NlcyBvdmVyIGEgcGF0aCBvZiBbW1BhdGhOb2RlXV1zIGFuZCBwcm9jZXNzZXMgdGhlIHJlc29sdmFibGVzLlxuICAgICAqIFRoZSBcIlRvIFN0YXRlXCIgY2FuIGluamVjdCB2YWx1ZXMgZnJvbSBpdHMgb3duIHJlc29sdmFibGVzLCBhcyB3ZWxsIGFzIHRob3NlIGZyb20gYWxsIGl0cyBhbmNlc3RvciBzdGF0ZSdzIChub2RlJ3MpLlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgdG8gY3JlYXRlIGEgbmFycm93ZXIgY29udGV4dCB3aGVuIGluamVjdGluZyBhbmNlc3RvciBub2Rlcy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGxldCBBQkNEID0gbmV3IFJlc29sdmVDb250ZXh0KFtBLCBCLCBDLCBEXSk7YFxuICAgICAqXG4gICAgICogR2l2ZW4gYSBwYXRoIGBbQSwgQiwgQywgRF1gLCB3aGVyZSBgQWAsIGBCYCwgYENgIGFuZCBgRGAgYXJlIG5vZGVzIGZvciBzdGF0ZXMgYGFgLCBgYmAsIGBjYCwgYGRgOlxuICAgICAqIFdoZW4gaW5qZWN0aW5nIGBEYCwgYERgIHNob3VsZCBoYXZlIGFjY2VzcyB0byBhbGwgcmVzb2x2YWJsZXMgZnJvbSBgQWAsIGBCYCwgYENgLCBgRGAuXG4gICAgICogSG93ZXZlciwgYEJgIHNob3VsZCBvbmx5IGJlIGFibGUgdG8gYWNjZXNzIHJlc29sdmFibGVzIGZyb20gYEFgLCBgQmAuXG4gICAgICpcbiAgICAgKiBXaGVuIHJlc29sdmluZyBmb3IgdGhlIGBCYCBub2RlLCBmaXJzdCB0YWtlIHRoZSBmdWxsIFwiVG8gUGF0aFwiIENvbnRleHQgYFtBLEIsQyxEXWAgYW5kIGxpbWl0IHRvIHRoZSBzdWJwYXRoIGBbQSxCXWAuXG4gICAgICogYGxldCBBQiA9IEFCQ0Quc3ViY29udGV4dChhKWBcbiAgICAgKi9cbiAgICBSZXNvbHZlQ29udGV4dC5wcm90b3R5cGUuc3ViQ29udGV4dCA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFJlc29sdmVDb250ZXh0KHBhdGhVdGlsc18xLlBhdGhVdGlscy5zdWJQYXRoKHRoaXMuX3BhdGgsIGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBub2RlLnN0YXRlID09PSBzdGF0ZTsgfSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkcyBSZXNvbHZhYmxlcyB0byB0aGUgbm9kZSB0aGF0IG1hdGNoZXMgdGhlIHN0YXRlXG4gICAgICpcbiAgICAgKiBUaGlzIGFkZHMgYSBbW1Jlc29sdmFibGVdXSAoZ2VuZXJhbGx5IG9uZSBjcmVhdGVkIG9uIHRoZSBmbHk7IG5vdCBkZWNsYXJlZCBvbiBhIFtbU3RhdGVEZWNsYXJhdGlvbi5yZXNvbHZlXV0gYmxvY2spLlxuICAgICAqIFRoZSByZXNvbHZhYmxlIGlzIGFkZGVkIHRvIHRoZSBub2RlIG1hdGNoaW5nIHRoZSBgc3RhdGVgIHBhcmFtZXRlci5cbiAgICAgKlxuICAgICAqIFRoZXNlIG5ldyByZXNvbHZhYmxlcyBhcmUgbm90IGF1dG9tYXRpY2FsbHkgZmV0Y2hlZC5cbiAgICAgKiBUaGUgY2FsbGluZyBjb2RlIHNob3VsZCBlaXRoZXIgZmV0Y2ggdGhlbSwgZmV0Y2ggc29tZXRoaW5nIHRoYXQgZGVwZW5kcyBvbiB0aGVtLFxuICAgICAqIG9yIHJlbHkgb24gW1tyZXNvbHZlUGF0aF1dIGJlaW5nIGNhbGxlZCB3aGVuIHNvbWUgc3RhdGUgaXMgYmVpbmcgZW50ZXJlZC5cbiAgICAgKlxuICAgICAqIE5vdGU6IGVhY2ggcmVzb2x2YWJsZSdzIFtbUmVzb2x2ZVBvbGljeV1dIGlzIG1lcmdlZCB3aXRoIHRoZSBzdGF0ZSdzIHBvbGljeSwgYW5kIHRoZSBnbG9iYWwgZGVmYXVsdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuZXdSZXNvbHZhYmxlcyB0aGUgbmV3IFJlc29sdmFibGVzXG4gICAgICogQHBhcmFtIHN0YXRlIFVzZWQgdG8gZmluZCB0aGUgbm9kZSB0byBwdXQgdGhlIHJlc29sdmFibGUgb25cbiAgICAgKi9cbiAgICBSZXNvbHZlQ29udGV4dC5wcm90b3R5cGUuYWRkUmVzb2x2YWJsZXMgPSBmdW5jdGlvbiAobmV3UmVzb2x2YWJsZXMsIHN0YXRlKSB7XG4gICAgICAgIHZhciBub2RlID0gY29tbW9uXzEuZmluZCh0aGlzLl9wYXRoLCBob2ZfMS5wcm9wRXEoJ3N0YXRlJywgc3RhdGUpKTtcbiAgICAgICAgdmFyIGtleXMgPSBuZXdSZXNvbHZhYmxlcy5tYXAoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIHIudG9rZW47IH0pO1xuICAgICAgICBub2RlLnJlc29sdmFibGVzID0gbm9kZS5yZXNvbHZhYmxlcy5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuIGtleXMuaW5kZXhPZihyLnRva2VuKSA9PT0gLTE7IH0pLmNvbmNhdChuZXdSZXNvbHZhYmxlcyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgcHJvbWlzZSBmb3IgYW4gYXJyYXkgb2YgcmVzb2x2ZWQgcGF0aCBFbGVtZW50IHByb21pc2VzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gd2hlblxuICAgICAqIEBwYXJhbSB0cmFuc1xuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT58YW55fVxuICAgICAqL1xuICAgIFJlc29sdmVDb250ZXh0LnByb3RvdHlwZS5yZXNvbHZlUGF0aCA9IGZ1bmN0aW9uICh3aGVuLCB0cmFucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAod2hlbiA9PT0gdm9pZCAwKSB7IHdoZW4gPSAnTEFaWSc7IH1cbiAgICAgICAgLy8gVGhpcyBvcHRpb24gZGV0ZXJtaW5lcyB3aGljaCAnd2hlbicgcG9saWN5IFJlc29sdmFibGVzIHdlIGFyZSBhYm91dCB0byBmZXRjaC5cbiAgICAgICAgdmFyIHdoZW5PcHRpb24gPSBjb21tb25fMS5pbkFycmF5KEFMTF9XSEVOUywgd2hlbikgPyB3aGVuIDogJ0xBWlknO1xuICAgICAgICAvLyBJZiB0aGUgY2FsbGVyIHNwZWNpZmllZCBFQUdFUiwgb25seSB0aGUgRUFHRVIgUmVzb2x2YWJsZXMgYXJlIGZldGNoZWQuXG4gICAgICAgIC8vIGlmIHRoZSBjYWxsZXIgc3BlY2lmaWVkIExBWlksIGJvdGggRUFHRVIgYW5kIExBWlkgUmVzb2x2YWJsZXMgYXJlIGZldGNoZWQuYFxuICAgICAgICB2YXIgbWF0Y2hlZFdoZW5zID0gd2hlbk9wdGlvbiA9PT0gaW50ZXJmYWNlXzEucmVzb2x2ZVBvbGljaWVzLndoZW4uRUFHRVIgPyBFQUdFUl9XSEVOUyA6IEFMTF9XSEVOUztcbiAgICAgICAgLy8gZ2V0IHRoZSBzdWJwYXRoIHRvIHRoZSBzdGF0ZSBhcmd1bWVudCwgaWYgcHJvdmlkZWRcbiAgICAgICAgdHJhY2VfMS50cmFjZS50cmFjZVJlc29sdmVQYXRoKHRoaXMuX3BhdGgsIHdoZW4sIHRyYW5zKTtcbiAgICAgICAgdmFyIG1hdGNoZXNQb2xpY3kgPSBmdW5jdGlvbiAoYWNjZXB0ZWRWYWxzLCB3aGVuT3JBc3luYykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChyZXNvbHZhYmxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1vbl8xLmluQXJyYXkoYWNjZXB0ZWRWYWxzLCBfdGhpcy5nZXRQb2xpY3kocmVzb2x2YWJsZSlbd2hlbk9yQXN5bmNdKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8vIFRyaWdnZXIgYWxsIHRoZSAobWF0Y2hpbmcpIFJlc29sdmFibGVzIGluIHRoZSBwYXRoXG4gICAgICAgIC8vIFJlZHVjZSBhbGwgdGhlIFwiV0FJVFwiIFJlc29sdmFibGVzIGludG8gYW4gYXJyYXlcbiAgICAgICAgdmFyIHByb21pc2VzID0gdGhpcy5fcGF0aC5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgbm9kZSkge1xuICAgICAgICAgICAgdmFyIG5vZGVSZXNvbHZhYmxlcyA9IG5vZGUucmVzb2x2YWJsZXMuZmlsdGVyKG1hdGNoZXNQb2xpY3kobWF0Y2hlZFdoZW5zLCAnd2hlbicpKTtcbiAgICAgICAgICAgIHZhciBub3dhaXQgPSBub2RlUmVzb2x2YWJsZXMuZmlsdGVyKG1hdGNoZXNQb2xpY3koWydOT1dBSVQnXSwgJ2FzeW5jJykpO1xuICAgICAgICAgICAgdmFyIHdhaXQgPSBub2RlUmVzb2x2YWJsZXMuZmlsdGVyKGhvZl8xLm5vdChtYXRjaGVzUG9saWN5KFsnTk9XQUlUJ10sICdhc3luYycpKSk7XG4gICAgICAgICAgICAvLyBGb3IgdGhlIG1hdGNoaW5nIFJlc29sdmFibGVzLCBzdGFydCB0aGVpciBhc3luYyBmZXRjaCBwcm9jZXNzLlxuICAgICAgICAgICAgdmFyIHN1YkNvbnRleHQgPSBfdGhpcy5zdWJDb250ZXh0KG5vZGUuc3RhdGUpO1xuICAgICAgICAgICAgdmFyIGdldFJlc3VsdCA9IGZ1bmN0aW9uIChyKSB7IHJldHVybiByLmdldChzdWJDb250ZXh0LCB0cmFucylcbiAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuICh7IHRva2VuOiByLnRva2VuLCB2YWx1ZTogdmFsdWUgfSk7IH0pOyB9O1xuICAgICAgICAgICAgbm93YWl0LmZvckVhY2goZ2V0UmVzdWx0KTtcbiAgICAgICAgICAgIHJldHVybiBhY2MuY29uY2F0KHdhaXQubWFwKGdldFJlc3VsdCkpO1xuICAgICAgICB9LCBbXSk7XG4gICAgICAgIC8vIFdhaXQgZm9yIGFsbCB0aGUgXCJXQUlUXCIgcmVzb2x2YWJsZXNcbiAgICAgICAgcmV0dXJuIGNvcmVzZXJ2aWNlc18xLnNlcnZpY2VzLiRxLmFsbChwcm9taXNlcyk7XG4gICAgfTtcbiAgICBSZXNvbHZlQ29udGV4dC5wcm90b3R5cGUuaW5qZWN0b3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbmplY3RvciB8fCAodGhpcy5faW5qZWN0b3IgPSBuZXcgVUlJbmplY3RvckltcGwodGhpcykpO1xuICAgIH07XG4gICAgUmVzb2x2ZUNvbnRleHQucHJvdG90eXBlLmZpbmROb2RlID0gZnVuY3Rpb24gKHJlc29sdmFibGUpIHtcbiAgICAgICAgcmV0dXJuIGNvbW1vbl8xLmZpbmQodGhpcy5fcGF0aCwgZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIGNvbW1vbl8xLmluQXJyYXkobm9kZS5yZXNvbHZhYmxlcywgcmVzb2x2YWJsZSk7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYXN5bmMgZGVwZW5kZW5jaWVzIG9mIGEgUmVzb2x2YWJsZVxuICAgICAqXG4gICAgICogR2l2ZW4gYSBSZXNvbHZhYmxlLCByZXR1cm5zIGl0cyBkZXBlbmRlbmNpZXMgYXMgYSBSZXNvbHZhYmxlW11cbiAgICAgKi9cbiAgICBSZXNvbHZlQ29udGV4dC5wcm90b3R5cGUuZ2V0RGVwZW5kZW5jaWVzID0gZnVuY3Rpb24gKHJlc29sdmFibGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmZpbmROb2RlKHJlc29sdmFibGUpO1xuICAgICAgICAvLyBGaW5kIHdoaWNoIG90aGVyIHJlc29sdmFibGVzIGFyZSBcInZpc2libGVcIiB0byB0aGUgYHJlc29sdmFibGVgIGFyZ3VtZW50XG4gICAgICAgIC8vIHN1YnBhdGggc3RvcHBpbmcgYXQgcmVzb2x2YWJsZSdzIG5vZGUsIG9yIHRoZSB3aG9sZSBwYXRoIChpZiB0aGUgcmVzb2x2YWJsZSBpc24ndCBpbiB0aGUgcGF0aClcbiAgICAgICAgdmFyIHN1YlBhdGggPSBwYXRoVXRpbHNfMS5QYXRoVXRpbHMuc3ViUGF0aCh0aGlzLl9wYXRoLCBmdW5jdGlvbiAoeCkgeyByZXR1cm4geCA9PT0gbm9kZTsgfSkgfHwgdGhpcy5fcGF0aDtcbiAgICAgICAgdmFyIGF2YWlsYWJsZVJlc29sdmFibGVzID0gc3ViUGF0aFxuICAgICAgICAgICAgLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBfbm9kZSkgeyByZXR1cm4gYWNjLmNvbmNhdChfbm9kZS5yZXNvbHZhYmxlcyk7IH0sIFtdKSAvLyBhbGwgb2Ygc3VicGF0aCdzIHJlc29sdmFibGVzXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChyZXMpIHsgcmV0dXJuIHJlcyAhPT0gcmVzb2x2YWJsZTsgfSk7IC8vIGZpbHRlciBvdXQgdGhlIGByZXNvbHZhYmxlYCBhcmd1bWVudFxuICAgICAgICB2YXIgZ2V0RGVwZW5kZW5jeSA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICAgICAgdmFyIG1hdGNoaW5nID0gYXZhaWxhYmxlUmVzb2x2YWJsZXMuZmlsdGVyKGZ1bmN0aW9uIChyKSB7IHJldHVybiByLnRva2VuID09PSB0b2tlbjsgfSk7XG4gICAgICAgICAgICBpZiAobWF0Y2hpbmcubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiBjb21tb25fMS50YWlsKG1hdGNoaW5nKTtcbiAgICAgICAgICAgIHZhciBmcm9tSW5qZWN0b3IgPSBfdGhpcy5pbmplY3RvcigpLmdldE5hdGl2ZSh0b2tlbik7XG4gICAgICAgICAgICBpZiAoY29tbW9uXzIuaXNVbmRlZmluZWQoZnJvbUluamVjdG9yKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGZpbmQgRGVwZW5kZW5jeSBJbmplY3Rpb24gdG9rZW46ICcgKyBzdHJpbmdzXzEuc3RyaW5naWZ5KHRva2VuKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IHJlc29sdmFibGVfMS5SZXNvbHZhYmxlKHRva2VuLCBmdW5jdGlvbiAoKSB7IHJldHVybiBmcm9tSW5qZWN0b3I7IH0sIFtdLCBmcm9tSW5qZWN0b3IpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcmVzb2x2YWJsZS5kZXBzLm1hcChnZXREZXBlbmRlbmN5KTtcbiAgICB9O1xuICAgIHJldHVybiBSZXNvbHZlQ29udGV4dDtcbn0oKSk7XG5leHBvcnRzLlJlc29sdmVDb250ZXh0ID0gUmVzb2x2ZUNvbnRleHQ7XG52YXIgVUlJbmplY3RvckltcGwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVUlJbmplY3RvckltcGwoY29udGV4dCkge1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLm5hdGl2ZSA9IHRoaXMuZ2V0KGV4cG9ydHMuTkFUSVZFX0lOSkVDVE9SX1RPS0VOKSB8fCBjb3Jlc2VydmljZXNfMS5zZXJ2aWNlcy4kaW5qZWN0b3I7XG4gICAgfVxuICAgIFVJSW5qZWN0b3JJbXBsLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgdmFyIHJlc29sdmFibGUgPSB0aGlzLmNvbnRleHQuZ2V0UmVzb2x2YWJsZSh0b2tlbik7XG4gICAgICAgIGlmIChyZXNvbHZhYmxlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb250ZXh0LmdldFBvbGljeShyZXNvbHZhYmxlKS5hc3luYyA9PT0gJ05PV0FJVCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2YWJsZS5nZXQodGhpcy5jb250ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcmVzb2x2YWJsZS5yZXNvbHZlZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVzb2x2YWJsZSBhc3luYyAuZ2V0KCkgbm90IGNvbXBsZXRlOicgKyBzdHJpbmdzXzEuc3RyaW5naWZ5KHJlc29sdmFibGUudG9rZW4pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXNvbHZhYmxlLmRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TmF0aXZlKHRva2VuKTtcbiAgICB9O1xuICAgIFVJSW5qZWN0b3JJbXBsLnByb3RvdHlwZS5nZXRBc3luYyA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICB2YXIgcmVzb2x2YWJsZSA9IHRoaXMuY29udGV4dC5nZXRSZXNvbHZhYmxlKHRva2VuKTtcbiAgICAgICAgaWYgKHJlc29sdmFibGUpXG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2YWJsZS5nZXQodGhpcy5jb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIGNvcmVzZXJ2aWNlc18xLnNlcnZpY2VzLiRxLndoZW4odGhpcy5uYXRpdmUuZ2V0KHRva2VuKSk7XG4gICAgfTtcbiAgICBVSUluamVjdG9ySW1wbC5wcm90b3R5cGUuZ2V0TmF0aXZlID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hdGl2ZSAmJiB0aGlzLm5hdGl2ZS5nZXQodG9rZW4pO1xuICAgIH07XG4gICAgcmV0dXJuIFVJSW5qZWN0b3JJbXBsO1xufSgpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc29sdmVDb250ZXh0LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9yZXNvbHZlL3Jlc29sdmVDb250ZXh0LmpzXG4vLyBtb2R1bGUgaWQgPSAzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///31\n")},function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @coreapi\n * @module url\n */\n/** for typedoc */\nvar common_1 = __webpack_require__(0);\nvar hof_1 = __webpack_require__(2);\nvar predicates_1 = __webpack_require__(1);\nvar param_1 = __webpack_require__(18);\nvar strings_1 = __webpack_require__(6);\n/** @hidden */\nfunction quoteRegExp(str, param) {\n    var surroundPattern = ['', ''], result = str.replace(/[\\\\\\[\\]\\^$*+?.()|{}]/g, '\\\\$&');\n    if (!param)\n        return result;\n    switch (param.squash) {\n        case false:\n            surroundPattern = ['(', ')' + (param.isOptional ? '?' : '')];\n            break;\n        case true:\n            result = result.replace(/\\/$/, '');\n            surroundPattern = ['(?:\\/(', ')|\\/)?'];\n            break;\n        default:\n            surroundPattern = [\"(\" + param.squash + \"|\", ')?'];\n            break;\n    }\n    return result + surroundPattern[0] + param.type.pattern.source + surroundPattern[1];\n}\n/** @hidden */\nvar memoizeTo = function (obj, _prop, fn) {\n    return obj[_prop] = obj[_prop] || fn();\n};\n/** @hidden */\nvar splitOnSlash = strings_1.splitOnDelim('/');\n/**\n * Matches URLs against patterns.\n *\n * Matches URLs against patterns and extracts named parameters from the path or the search\n * part of the URL.\n *\n * A URL pattern consists of a path pattern, optionally followed by '?' and a list of search (query)\n * parameters. Multiple search parameter names are separated by '&'. Search parameters\n * do not influence whether or not a URL is matched, but their values are passed through into\n * the matched parameters returned by [[UrlMatcher.exec]].\n *\n * - *Path parameters* are defined using curly brace placeholders (`/somepath/{param}`)\n * or colon placeholders (`/somePath/:param`).\n *\n * - *A parameter RegExp* may be defined for a param after a colon\n * (`/somePath/{param:[a-zA-Z0-9]+}`) in a curly brace placeholder.\n * The regexp must match for the url to be matched.\n * Should the regexp itself contain curly braces, they must be in matched pairs or escaped with a backslash.\n *\n * Note: a RegExp parameter will encode its value using either [[ParamTypes.path]] or [[ParamTypes.query]].\n *\n * - *Custom parameter types* may also be specified after a colon (`/somePath/{param:int}`) in curly brace parameters.\n *   See [[UrlMatcherFactory.type]] for more information.\n *\n * - *Catch-all parameters* are defined using an asterisk placeholder (`/somepath/*catchallparam`).\n *   A catch-all * parameter value will contain the remainder of the URL.\n *\n * ---\n *\n * Parameter names may contain only word characters (latin letters, digits, and underscore) and\n * must be unique within the pattern (across both path and search parameters).\n * A path parameter matches any number of characters other than '/'. For catch-all\n * placeholders the path parameter matches any number of characters.\n *\n * Examples:\n *\n * * `'/hello/'` - Matches only if the path is exactly '/hello/'. There is no special treatment for\n *   trailing slashes, and patterns have to match the entire path, not just a prefix.\n * * `'/user/:id'` - Matches '/user/bob' or '/user/1234!!!' or even '/user/' but not '/user' or\n *   '/user/bob/details'. The second path segment will be captured as the parameter 'id'.\n * * `'/user/{id}'` - Same as the previous example, but using curly brace syntax.\n * * `'/user/{id:[^/]*}'` - Same as the previous example.\n * * `'/user/{id:[0-9a-fA-F]{1,8}}'` - Similar to the previous example, but only matches if the id\n *   parameter consists of 1 to 8 hex digits.\n * * `'/files/{path:.*}'` - Matches any URL starting with '/files/' and captures the rest of the\n *   path into the parameter 'path'.\n * * `'/files/*path'` - ditto.\n * * `'/calendar/{start:date}'` - Matches \"/calendar/2014-11-12\" (because the pattern defined\n *   in the built-in  `date` ParamType matches `2014-11-12`) and provides a Date object in $stateParams.start\n *\n */\nvar UrlMatcher = /** @class */ (function () {\n    /**\n     * @param pattern The pattern to compile into a matcher.\n     * @param paramTypes The [[ParamTypes]] registry\n     * @param config  A configuration object\n     * - `caseInsensitive` - `true` if URL matching should be case insensitive, otherwise `false`, the default value (for backward compatibility) is `false`.\n     * - `strict` - `false` if matching against a URL with a trailing slash should be treated as equivalent to a URL without a trailing slash, the default value is `true`.\n     */\n    function UrlMatcher(pattern, paramTypes, paramFactory, config) {\n        var _this = this;\n        this.config = config;\n        /** @hidden */\n        this._cache = { path: [this] };\n        /** @hidden */\n        this._children = [];\n        /** @hidden */\n        this._params = [];\n        /** @hidden */\n        this._segments = [];\n        /** @hidden */\n        this._compiled = [];\n        this.pattern = pattern;\n        this.config = common_1.defaults(this.config, {\n            params: {},\n            strict: true,\n            caseInsensitive: false,\n            paramMap: common_1.identity,\n        });\n        // Find all placeholders and create a compiled pattern, using either classic or curly syntax:\n        //   '*' name\n        //   ':' name\n        //   '{' name '}'\n        //   '{' name ':' regexp '}'\n        // The regular expression is somewhat complicated due to the need to allow curly braces\n        // inside the regular expression. The placeholder regexp breaks down as follows:\n        //    ([:*])([\\w\\[\\]]+)              - classic placeholder ($1 / $2) (search version has - for snake-case)\n        //    \\{([\\w\\[\\]]+)(?:\\:\\s*( ... ))?\\}  - curly brace placeholder ($3) with optional regexp/type ... ($4) (search version has - for snake-case\n        //    (?: ... | ... | ... )+         - the regexp consists of any number of atoms, an atom being either\n        //    [^{}\\\\]+                       - anything other than curly braces or backslash\n        //    \\\\.                            - a backslash escape\n        //    \\{(?:[^{}\\\\]+|\\\\.)*\\}          - a matched set of curly braces containing other atoms\n        var placeholder = /([:*])([\\w\\[\\]]+)|\\{([\\w\\[\\]]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g;\n        var searchPlaceholder = /([:]?)([\\w\\[\\].-]+)|\\{([\\w\\[\\].-]+)(?:\\:\\s*((?:[^{}\\\\]+|\\\\.|\\{(?:[^{}\\\\]+|\\\\.)*\\})+))?\\}/g;\n        var patterns = [];\n        var last = 0, matchArray;\n        var checkParamErrors = function (id) {\n            if (!UrlMatcher.nameValidator.test(id))\n                throw new Error(\"Invalid parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n            if (common_1.find(_this._params, hof_1.propEq('id', id)))\n                throw new Error(\"Duplicate parameter name '\" + id + \"' in pattern '\" + pattern + \"'\");\n        };\n        // Split into static segments separated by path parameter placeholders.\n        // The number of segments is always 1 more than the number of parameters.\n        var matchDetails = function (m, isSearch) {\n            // IE[78] returns '' for unmatched groups instead of null\n            var id = m[2] || m[3];\n            var regexp = isSearch ? m[4] : m[4] || (m[1] === '*' ? '[\\\\s\\\\S]*' : null);\n            var makeRegexpType = function (str) { return common_1.inherit(paramTypes.type(isSearch ? 'query' : 'path'), {\n                pattern: new RegExp(str, _this.config.caseInsensitive ? 'i' : undefined),\n            }); };\n            return {\n                id: id,\n                regexp: regexp,\n                cfg: _this.config.params[id],\n                segment: pattern.substring(last, m.index),\n                type: !regexp ? null : paramTypes.type(regexp) || makeRegexpType(regexp),\n            };\n        };\n        var p, segment;\n        // tslint:disable-next-line:no-conditional-assignment\n        while ((matchArray = placeholder.exec(pattern))) {\n            p = matchDetails(matchArray, false);\n            if (p.segment.indexOf('?') >= 0)\n                break; // we're into the search part\n            checkParamErrors(p.id);\n            this._params.push(paramFactory.fromPath(p.id, p.type, this.config.paramMap(p.cfg, false)));\n            this._segments.push(p.segment);\n            patterns.push([p.segment, common_1.tail(this._params)]);\n            last = placeholder.lastIndex;\n        }\n        segment = pattern.substring(last);\n        // Find any search parameter names and remove them from the last segment\n        var i = segment.indexOf('?');\n        if (i >= 0) {\n            var search = segment.substring(i);\n            segment = segment.substring(0, i);\n            if (search.length > 0) {\n                last = 0;\n                // tslint:disable-next-line:no-conditional-assignment\n                while ((matchArray = searchPlaceholder.exec(search))) {\n                    p = matchDetails(matchArray, true);\n                    checkParamErrors(p.id);\n                    this._params.push(paramFactory.fromSearch(p.id, p.type, this.config.paramMap(p.cfg, true)));\n                    last = placeholder.lastIndex;\n                    // check if ?&\n                }\n            }\n        }\n        this._segments.push(segment);\n        this._compiled = patterns.map(function (_pattern) { return quoteRegExp.apply(null, _pattern); }).concat(quoteRegExp(segment));\n    }\n    /** @hidden */\n    UrlMatcher.encodeDashes = function (str) {\n        return encodeURIComponent(str).replace(/-/g, function (c) { return \"%5C%\" + c.charCodeAt(0).toString(16).toUpperCase(); });\n    };\n    /** @hidden Given a matcher, return an array with the matcher's path segments and path params, in order */\n    UrlMatcher.pathSegmentsAndParams = function (matcher) {\n        var staticSegments = matcher._segments;\n        var pathParams = matcher._params.filter(function (p) { return p.location === param_1.DefType.PATH; });\n        return common_1.arrayTuples(staticSegments, pathParams.concat(undefined))\n            .reduce(common_1.unnestR, [])\n            .filter(function (x) { return x !== '' && predicates_1.isDefined(x); });\n    };\n    /** @hidden Given a matcher, return an array with the matcher's query params */\n    UrlMatcher.queryParams = function (matcher) {\n        return matcher._params.filter(function (p) { return p.location === param_1.DefType.SEARCH; });\n    };\n    /**\n     * Compare two UrlMatchers\n     *\n     * This comparison function converts a UrlMatcher into static and dynamic path segments.\n     * Each static path segment is a static string between a path separator (slash character).\n     * Each dynamic segment is a path parameter.\n     *\n     * The comparison function sorts static segments before dynamic ones.\n     */\n    UrlMatcher.compare = function (a, b) {\n        /**\n         * Turn a UrlMatcher and all its parent matchers into an array\n         * of slash literals '/', string literals, and Param objects\n         *\n         * This example matcher matches strings like \"/foo/:param/tail\":\n         * var matcher = $umf.compile(\"/foo\").append($umf.compile(\"/:param\")).append($umf.compile(\"/\")).append($umf.compile(\"tail\"));\n         * var result = segments(matcher); // [ '/', 'foo', '/', Param, '/', 'tail' ]\n         *\n         * Caches the result as `matcher._cache.segments`\n         */\n        var segments = function (matcher) {\n            return matcher._cache.segments = matcher._cache.segments ||\n                matcher._cache.path.map(UrlMatcher.pathSegmentsAndParams)\n                    .reduce(common_1.unnestR, [])\n                    .reduce(strings_1.joinNeighborsR, [])\n                    .map(function (x) { return predicates_1.isString(x) ? splitOnSlash(x) : x; })\n                    .reduce(common_1.unnestR, []);\n        };\n        /**\n         * Gets the sort weight for each segment of a UrlMatcher\n         *\n         * Caches the result as `matcher._cache.weights`\n         */\n        var weights = function (matcher) {\n            return matcher._cache.weights = matcher._cache.weights ||\n                segments(matcher).map(function (segment) {\n                    // Sort slashes first, then static strings, the Params\n                    if (segment === '/')\n                        return 1;\n                    if (predicates_1.isString(segment))\n                        return 2;\n                    if (segment instanceof param_1.Param)\n                        return 3;\n                });\n        };\n        /**\n         * Pads shorter array in-place (mutates)\n         */\n        var padArrays = function (l, r, padVal) {\n            var len = Math.max(l.length, r.length);\n            while (l.length < len)\n                l.push(padVal);\n            while (r.length < len)\n                r.push(padVal);\n        };\n        var weightsA = weights(a), weightsB = weights(b);\n        padArrays(weightsA, weightsB, 0);\n        var _pairs = common_1.arrayTuples(weightsA, weightsB);\n        var cmp, i;\n        for (i = 0; i < _pairs.length; i++) {\n            cmp = _pairs[i][0] - _pairs[i][1];\n            if (cmp !== 0)\n                return cmp;\n        }\n        return 0;\n    };\n    /**\n     * Creates a new concatenated UrlMatcher\n     *\n     * Builds a new UrlMatcher by appending another UrlMatcher to this one.\n     *\n     * @param url A `UrlMatcher` instance to append as a child of the current `UrlMatcher`.\n     */\n    UrlMatcher.prototype.append = function (url) {\n        this._children.push(url);\n        url._cache = {\n            path: this._cache.path.concat(url),\n            parent: this,\n            pattern: null,\n        };\n        return url;\n    };\n    /** @hidden */\n    UrlMatcher.prototype.isRoot = function () {\n        return this._cache.path[0] === this;\n    };\n    /** Returns the input pattern string */\n    UrlMatcher.prototype.toString = function () {\n        return this.pattern;\n    };\n    /**\n     * Tests the specified url/path against this matcher.\n     *\n     * Tests if the given url matches this matcher's pattern, and returns an object containing the captured\n     * parameter values.  Returns null if the path does not match.\n     *\n     * The returned object contains the values\n     * of any search parameters that are mentioned in the pattern, but their value may be null if\n     * they are not present in `search`. This means that search parameters are always treated\n     * as optional.\n     *\n     * #### Example:\n     * ```js\n     * new UrlMatcher('/user/{id}?q&r').exec('/user/bob', {\n     *   x: '1', q: 'hello'\n     * });\n     * // returns { id: 'bob', q: 'hello', r: null }\n     * ```\n     *\n     * @param path    The URL path to match, e.g. `$location.path()`.\n     * @param search  URL search parameters, e.g. `$location.search()`.\n     * @param hash    URL hash e.g. `$location.hash()`.\n     * @param options\n     *\n     * @returns The captured parameter values.\n     */\n    UrlMatcher.prototype.exec = function (path, search, hash, options) {\n        var _this = this;\n        if (search === void 0) { search = {}; }\n        if (options === void 0) { options = {}; }\n        var match = memoizeTo(this._cache, 'pattern', function () {\n            return new RegExp([\n                '^',\n                common_1.unnest(_this._cache.path.map(hof_1.prop('_compiled'))).join(''),\n                _this.config.strict === false ? '\\/?' : '',\n                '$',\n            ].join(''), _this.config.caseInsensitive ? 'i' : undefined);\n        }).exec(path);\n        if (!match)\n            return null;\n        // options = defaults(options, { isolate: false });\n        var allParams = this.parameters(), pathParams = allParams.filter(function (param) { return !param.isSearch(); }), searchParams = allParams.filter(function (param) { return param.isSearch(); }), nPathSegments = this._cache.path.map(function (urlm) { return urlm._segments.length - 1; }).reduce(function (a, x) { return a + x; }), values = {};\n        if (nPathSegments !== match.length - 1)\n            throw new Error(\"Unbalanced capture group in route '\" + this.pattern + \"'\");\n        function decodePathArray(paramVal) {\n            var reverseString = function (str) { return str.split('').reverse().join(''); };\n            var unquoteDashes = function (str) { return str.replace(/\\\\-/g, '-'); };\n            var split = reverseString(paramVal).split(/-(?!\\\\)/);\n            var allReversed = common_1.map(split, reverseString);\n            return common_1.map(allReversed, unquoteDashes).reverse();\n        }\n        for (var i = 0; i < nPathSegments; i++) {\n            var param = pathParams[i];\n            var value = match[i + 1];\n            // if the param value matches a pre-replace pair, replace the value before decoding.\n            for (var j = 0; j < param.replace.length; j++) {\n                if (param.replace[j].from === value)\n                    value = param.replace[j].to;\n            }\n            if (value && param.array === true)\n                value = decodePathArray(value);\n            if (predicates_1.isDefined(value))\n                value = param.type.decode(value);\n            values[param.id] = param.value(value);\n        }\n        searchParams.forEach(function (param) {\n            var value = search[param.id];\n            for (var j = 0; j < param.replace.length; j++) {\n                if (param.replace[j].from === value)\n                    value = param.replace[j].to;\n            }\n            if (predicates_1.isDefined(value))\n                value = param.type.decode(value);\n            values[param.id] = param.value(value);\n        });\n        if (hash)\n            values['#'] = hash;\n        return values;\n    };\n    /**\n     * @hidden\n     * Returns all the [[Param]] objects of all path and search parameters of this pattern in order of appearance.\n     *\n     * @returns {Array.<Param>}  An array of [[Param]] objects. Must be treated as read-only. If the\n     *    pattern has no parameters, an empty array is returned.\n     */\n    UrlMatcher.prototype.parameters = function (opts) {\n        if (opts === void 0) { opts = {}; }\n        if (opts.inherit === false)\n            return this._params;\n        return common_1.unnest(this._cache.path.map(function (matcher) { return matcher._params; }));\n    };\n    /**\n     * @hidden\n     * Returns a single parameter from this UrlMatcher by id\n     *\n     * @param id\n     * @param opts\n     * @returns {T|Param|any|boolean|UrlMatcher|null}\n     */\n    UrlMatcher.prototype.parameter = function (id, opts) {\n        var _this = this;\n        if (opts === void 0) { opts = {}; }\n        var findParam = function () {\n            for (var _i = 0, _a = _this._params; _i < _a.length; _i++) {\n                var param = _a[_i];\n                if (param.id === id)\n                    return param;\n            }\n        };\n        var parent = this._cache.parent;\n        return findParam() || (opts.inherit !== false && parent && parent.parameter(id, opts)) || null;\n    };\n    /**\n     * Validates the input parameter values against this UrlMatcher\n     *\n     * Checks an object hash of parameters to validate their correctness according to the parameter\n     * types of this `UrlMatcher`.\n     *\n     * @param params The object hash of parameters to validate.\n     * @returns Returns `true` if `params` validates, otherwise `false`.\n     */\n    UrlMatcher.prototype.validates = function (params) {\n        var validParamVal = function (param, val) {\n            return !param || param.validates(val);\n        };\n        params = params || {};\n        // I'm not sure why this checks only the param keys passed in, and not all the params known to the matcher\n        var paramSchema = this.parameters().filter(function (paramDef) { return params.hasOwnProperty(paramDef.id); });\n        return paramSchema.map(function (paramDef) { return validParamVal(paramDef, params[paramDef.id]); }).reduce(common_1.allTrueR, true);\n    };\n    /**\n     * Given a set of parameter values, creates a URL from this UrlMatcher.\n     *\n     * Creates a URL that matches this pattern by substituting the specified values\n     * for the path and search parameters.\n     *\n     * #### Example:\n     * ```js\n     * new UrlMatcher('/user/{id}?q').format({ id:'bob', q:'yes' });\n     * // returns '/user/bob?q=yes'\n     * ```\n     *\n     * @param values  the values to substitute for the parameters in this pattern.\n     * @returns the formatted URL (path and optionally search part).\n     */\n    UrlMatcher.prototype.format = function (values) {\n        if (values === void 0) { values = {}; }\n        // Build the full path of UrlMatchers (including all parent UrlMatchers)\n        var urlMatchers = this._cache.path;\n        // Extract all the static segments and Params (processed as ParamDetails)\n        // into an ordered array\n        var pathSegmentsAndParams = urlMatchers.map(UrlMatcher.pathSegmentsAndParams)\n            .reduce(common_1.unnestR, [])\n            .map(function (x) { return predicates_1.isString(x) ? x : getDetails(x); });\n        // Extract the query params into a separate array\n        var queryParams = urlMatchers.map(UrlMatcher.queryParams)\n            .reduce(common_1.unnestR, [])\n            .map(getDetails);\n        var isInvalid = function (param) { return param.isValid === false; };\n        if (pathSegmentsAndParams.concat(queryParams).filter(isInvalid).length) {\n            return null;\n        }\n        /**\n         * Given a Param, applies the parameter value, then returns detailed information about it\n         */\n        function getDetails(param) {\n            // Normalize to typed value\n            var value = param.value(values[param.id]);\n            var isValid = param.validates(value);\n            var isDefaultValue = param.isDefaultValue(value);\n            // Check if we're in squash mode for the parameter\n            var squash = isDefaultValue ? param.squash : false;\n            // Allow the Parameter's Type to encode the value\n            var encoded = param.type.encode(value);\n            return { param: param, value: value, isValid: isValid, isDefaultValue: isDefaultValue, squash: squash, encoded: encoded };\n        }\n        // Build up the path-portion from the list of static segments and parameters\n        var pathString = pathSegmentsAndParams.reduce(function (acc, x) {\n            // The element is a static segment (a raw string); just append it\n            if (predicates_1.isString(x))\n                return acc + x;\n            // Otherwise, it's a ParamDetails.\n            var squash = x.squash, encoded = x.encoded, param = x.param;\n            // If squash is === true, try to remove a slash from the path\n            if (squash === true)\n                return (acc.match(/\\/$/)) ? acc.slice(0, -1) : acc;\n            // If squash is a string, use the string for the param value\n            if (predicates_1.isString(squash))\n                return acc + squash;\n            if (squash !== false)\n                return acc; // ?\n            if (encoded == null)\n                return acc;\n            // If this parameter value is an array, encode the value using encodeDashes\n            if (predicates_1.isArray(encoded))\n                return acc + common_1.map(encoded, UrlMatcher.encodeDashes).join('-');\n            // If the parameter type is \"raw\", then do not encodeURIComponent\n            if (param.raw)\n                return acc + encoded;\n            // Encode the value\n            return acc + encodeURIComponent(encoded);\n        }, '');\n        // Build the query string by applying parameter values (array or regular)\n        // then mapping to key=value, then flattening and joining using \"&\"\n        var queryString = queryParams.map(function (paramDetails) {\n            var param = paramDetails.param, squash = paramDetails.squash, encoded = paramDetails.encoded, isDefaultValue = paramDetails.isDefaultValue;\n            if (encoded == null || (isDefaultValue && squash !== false))\n                return;\n            if (!predicates_1.isArray(encoded))\n                encoded = [encoded];\n            if (encoded.length === 0)\n                return;\n            if (!param.raw)\n                encoded = common_1.map(encoded, encodeURIComponent);\n            return encoded.map(function (val) { return param.id + \"=\" + val; });\n        }).filter(common_1.identity).reduce(common_1.unnestR, []).join('&');\n        // Concat the pathstring with the queryString (if exists) and the hashString (if exists)\n        return pathString + (queryString ? \"?\" + queryString : '') + (values['#'] ? '#' + values['#'] : '');\n    };\n    /** @hidden */\n    UrlMatcher.nameValidator = /^\\w+([-.]+\\w+)*(?:\\[\\])?$/;\n    return UrlMatcher;\n}());\nexports.UrlMatcher = UrlMatcher;\n//# sourceMappingURL=urlMatcher.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3VybC91cmxNYXRjaGVyLmpzPzRkY2YiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEBjb3JlYXBpXG4gKiBAbW9kdWxlIHVybFxuICovXG4vKiogZm9yIHR5cGVkb2MgKi9cbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29tbW9uXCIpO1xudmFyIGhvZl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9ob2ZcIik7XG52YXIgcHJlZGljYXRlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9wcmVkaWNhdGVzXCIpO1xudmFyIHBhcmFtXzEgPSByZXF1aXJlKFwiLi4vcGFyYW1zL3BhcmFtXCIpO1xudmFyIHN0cmluZ3NfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vc3RyaW5nc1wiKTtcbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiBxdW90ZVJlZ0V4cChzdHIsIHBhcmFtKSB7XG4gICAgdmFyIHN1cnJvdW5kUGF0dGVybiA9IFsnJywgJyddLCByZXN1bHQgPSBzdHIucmVwbGFjZSgvW1xcXFxcXFtcXF1cXF4kKis/LigpfHt9XS9nLCAnXFxcXCQmJyk7XG4gICAgaWYgKCFwYXJhbSlcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICBzd2l0Y2ggKHBhcmFtLnNxdWFzaCkge1xuICAgICAgICBjYXNlIGZhbHNlOlxuICAgICAgICAgICAgc3Vycm91bmRQYXR0ZXJuID0gWycoJywgJyknICsgKHBhcmFtLmlzT3B0aW9uYWwgPyAnPycgOiAnJyldO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgdHJ1ZTpcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5yZXBsYWNlKC9cXC8kLywgJycpO1xuICAgICAgICAgICAgc3Vycm91bmRQYXR0ZXJuID0gWycoPzpcXC8oJywgJyl8XFwvKT8nXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgc3Vycm91bmRQYXR0ZXJuID0gW1wiKFwiICsgcGFyYW0uc3F1YXNoICsgXCJ8XCIsICcpPyddO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQgKyBzdXJyb3VuZFBhdHRlcm5bMF0gKyBwYXJhbS50eXBlLnBhdHRlcm4uc291cmNlICsgc3Vycm91bmRQYXR0ZXJuWzFdO1xufVxuLyoqIEBoaWRkZW4gKi9cbnZhciBtZW1vaXplVG8gPSBmdW5jdGlvbiAob2JqLCBfcHJvcCwgZm4pIHtcbiAgICByZXR1cm4gb2JqW19wcm9wXSA9IG9ialtfcHJvcF0gfHwgZm4oKTtcbn07XG4vKiogQGhpZGRlbiAqL1xudmFyIHNwbGl0T25TbGFzaCA9IHN0cmluZ3NfMS5zcGxpdE9uRGVsaW0oJy8nKTtcbi8qKlxuICogTWF0Y2hlcyBVUkxzIGFnYWluc3QgcGF0dGVybnMuXG4gKlxuICogTWF0Y2hlcyBVUkxzIGFnYWluc3QgcGF0dGVybnMgYW5kIGV4dHJhY3RzIG5hbWVkIHBhcmFtZXRlcnMgZnJvbSB0aGUgcGF0aCBvciB0aGUgc2VhcmNoXG4gKiBwYXJ0IG9mIHRoZSBVUkwuXG4gKlxuICogQSBVUkwgcGF0dGVybiBjb25zaXN0cyBvZiBhIHBhdGggcGF0dGVybiwgb3B0aW9uYWxseSBmb2xsb3dlZCBieSAnPycgYW5kIGEgbGlzdCBvZiBzZWFyY2ggKHF1ZXJ5KVxuICogcGFyYW1ldGVycy4gTXVsdGlwbGUgc2VhcmNoIHBhcmFtZXRlciBuYW1lcyBhcmUgc2VwYXJhdGVkIGJ5ICcmJy4gU2VhcmNoIHBhcmFtZXRlcnNcbiAqIGRvIG5vdCBpbmZsdWVuY2Ugd2hldGhlciBvciBub3QgYSBVUkwgaXMgbWF0Y2hlZCwgYnV0IHRoZWlyIHZhbHVlcyBhcmUgcGFzc2VkIHRocm91Z2ggaW50b1xuICogdGhlIG1hdGNoZWQgcGFyYW1ldGVycyByZXR1cm5lZCBieSBbW1VybE1hdGNoZXIuZXhlY11dLlxuICpcbiAqIC0gKlBhdGggcGFyYW1ldGVycyogYXJlIGRlZmluZWQgdXNpbmcgY3VybHkgYnJhY2UgcGxhY2Vob2xkZXJzIChgL3NvbWVwYXRoL3twYXJhbX1gKVxuICogb3IgY29sb24gcGxhY2Vob2xkZXJzIChgL3NvbWVQYXRoLzpwYXJhbWApLlxuICpcbiAqIC0gKkEgcGFyYW1ldGVyIFJlZ0V4cCogbWF5IGJlIGRlZmluZWQgZm9yIGEgcGFyYW0gYWZ0ZXIgYSBjb2xvblxuICogKGAvc29tZVBhdGgve3BhcmFtOlthLXpBLVowLTldK31gKSBpbiBhIGN1cmx5IGJyYWNlIHBsYWNlaG9sZGVyLlxuICogVGhlIHJlZ2V4cCBtdXN0IG1hdGNoIGZvciB0aGUgdXJsIHRvIGJlIG1hdGNoZWQuXG4gKiBTaG91bGQgdGhlIHJlZ2V4cCBpdHNlbGYgY29udGFpbiBjdXJseSBicmFjZXMsIHRoZXkgbXVzdCBiZSBpbiBtYXRjaGVkIHBhaXJzIG9yIGVzY2FwZWQgd2l0aCBhIGJhY2tzbGFzaC5cbiAqXG4gKiBOb3RlOiBhIFJlZ0V4cCBwYXJhbWV0ZXIgd2lsbCBlbmNvZGUgaXRzIHZhbHVlIHVzaW5nIGVpdGhlciBbW1BhcmFtVHlwZXMucGF0aF1dIG9yIFtbUGFyYW1UeXBlcy5xdWVyeV1dLlxuICpcbiAqIC0gKkN1c3RvbSBwYXJhbWV0ZXIgdHlwZXMqIG1heSBhbHNvIGJlIHNwZWNpZmllZCBhZnRlciBhIGNvbG9uIChgL3NvbWVQYXRoL3twYXJhbTppbnR9YCkgaW4gY3VybHkgYnJhY2UgcGFyYW1ldGVycy5cbiAqICAgU2VlIFtbVXJsTWF0Y2hlckZhY3RvcnkudHlwZV1dIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIC0gKkNhdGNoLWFsbCBwYXJhbWV0ZXJzKiBhcmUgZGVmaW5lZCB1c2luZyBhbiBhc3RlcmlzayBwbGFjZWhvbGRlciAoYC9zb21lcGF0aC8qY2F0Y2hhbGxwYXJhbWApLlxuICogICBBIGNhdGNoLWFsbCAqIHBhcmFtZXRlciB2YWx1ZSB3aWxsIGNvbnRhaW4gdGhlIHJlbWFpbmRlciBvZiB0aGUgVVJMLlxuICpcbiAqIC0tLVxuICpcbiAqIFBhcmFtZXRlciBuYW1lcyBtYXkgY29udGFpbiBvbmx5IHdvcmQgY2hhcmFjdGVycyAobGF0aW4gbGV0dGVycywgZGlnaXRzLCBhbmQgdW5kZXJzY29yZSkgYW5kXG4gKiBtdXN0IGJlIHVuaXF1ZSB3aXRoaW4gdGhlIHBhdHRlcm4gKGFjcm9zcyBib3RoIHBhdGggYW5kIHNlYXJjaCBwYXJhbWV0ZXJzKS5cbiAqIEEgcGF0aCBwYXJhbWV0ZXIgbWF0Y2hlcyBhbnkgbnVtYmVyIG9mIGNoYXJhY3RlcnMgb3RoZXIgdGhhbiAnLycuIEZvciBjYXRjaC1hbGxcbiAqIHBsYWNlaG9sZGVycyB0aGUgcGF0aCBwYXJhbWV0ZXIgbWF0Y2hlcyBhbnkgbnVtYmVyIG9mIGNoYXJhY3RlcnMuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogKiBgJy9oZWxsby8nYCAtIE1hdGNoZXMgb25seSBpZiB0aGUgcGF0aCBpcyBleGFjdGx5ICcvaGVsbG8vJy4gVGhlcmUgaXMgbm8gc3BlY2lhbCB0cmVhdG1lbnQgZm9yXG4gKiAgIHRyYWlsaW5nIHNsYXNoZXMsIGFuZCBwYXR0ZXJucyBoYXZlIHRvIG1hdGNoIHRoZSBlbnRpcmUgcGF0aCwgbm90IGp1c3QgYSBwcmVmaXguXG4gKiAqIGAnL3VzZXIvOmlkJ2AgLSBNYXRjaGVzICcvdXNlci9ib2InIG9yICcvdXNlci8xMjM0ISEhJyBvciBldmVuICcvdXNlci8nIGJ1dCBub3QgJy91c2VyJyBvclxuICogICAnL3VzZXIvYm9iL2RldGFpbHMnLiBUaGUgc2Vjb25kIHBhdGggc2VnbWVudCB3aWxsIGJlIGNhcHR1cmVkIGFzIHRoZSBwYXJhbWV0ZXIgJ2lkJy5cbiAqICogYCcvdXNlci97aWR9J2AgLSBTYW1lIGFzIHRoZSBwcmV2aW91cyBleGFtcGxlLCBidXQgdXNpbmcgY3VybHkgYnJhY2Ugc3ludGF4LlxuICogKiBgJy91c2VyL3tpZDpbXi9dKn0nYCAtIFNhbWUgYXMgdGhlIHByZXZpb3VzIGV4YW1wbGUuXG4gKiAqIGAnL3VzZXIve2lkOlswLTlhLWZBLUZdezEsOH19J2AgLSBTaW1pbGFyIHRvIHRoZSBwcmV2aW91cyBleGFtcGxlLCBidXQgb25seSBtYXRjaGVzIGlmIHRoZSBpZFxuICogICBwYXJhbWV0ZXIgY29uc2lzdHMgb2YgMSB0byA4IGhleCBkaWdpdHMuXG4gKiAqIGAnL2ZpbGVzL3twYXRoOi4qfSdgIC0gTWF0Y2hlcyBhbnkgVVJMIHN0YXJ0aW5nIHdpdGggJy9maWxlcy8nIGFuZCBjYXB0dXJlcyB0aGUgcmVzdCBvZiB0aGVcbiAqICAgcGF0aCBpbnRvIHRoZSBwYXJhbWV0ZXIgJ3BhdGgnLlxuICogKiBgJy9maWxlcy8qcGF0aCdgIC0gZGl0dG8uXG4gKiAqIGAnL2NhbGVuZGFyL3tzdGFydDpkYXRlfSdgIC0gTWF0Y2hlcyBcIi9jYWxlbmRhci8yMDE0LTExLTEyXCIgKGJlY2F1c2UgdGhlIHBhdHRlcm4gZGVmaW5lZFxuICogICBpbiB0aGUgYnVpbHQtaW4gIGBkYXRlYCBQYXJhbVR5cGUgbWF0Y2hlcyBgMjAxNC0xMS0xMmApIGFuZCBwcm92aWRlcyBhIERhdGUgb2JqZWN0IGluICRzdGF0ZVBhcmFtcy5zdGFydFxuICpcbiAqL1xudmFyIFVybE1hdGNoZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHBhdHRlcm4gVGhlIHBhdHRlcm4gdG8gY29tcGlsZSBpbnRvIGEgbWF0Y2hlci5cbiAgICAgKiBAcGFyYW0gcGFyYW1UeXBlcyBUaGUgW1tQYXJhbVR5cGVzXV0gcmVnaXN0cnlcbiAgICAgKiBAcGFyYW0gY29uZmlnICBBIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAgICogLSBgY2FzZUluc2Vuc2l0aXZlYCAtIGB0cnVlYCBpZiBVUkwgbWF0Y2hpbmcgc2hvdWxkIGJlIGNhc2UgaW5zZW5zaXRpdmUsIG90aGVyd2lzZSBgZmFsc2VgLCB0aGUgZGVmYXVsdCB2YWx1ZSAoZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkpIGlzIGBmYWxzZWAuXG4gICAgICogLSBgc3RyaWN0YCAtIGBmYWxzZWAgaWYgbWF0Y2hpbmcgYWdhaW5zdCBhIFVSTCB3aXRoIGEgdHJhaWxpbmcgc2xhc2ggc2hvdWxkIGJlIHRyZWF0ZWQgYXMgZXF1aXZhbGVudCB0byBhIFVSTCB3aXRob3V0IGEgdHJhaWxpbmcgc2xhc2gsIHRoZSBkZWZhdWx0IHZhbHVlIGlzIGB0cnVlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBVcmxNYXRjaGVyKHBhdHRlcm4sIHBhcmFtVHlwZXMsIHBhcmFtRmFjdG9yeSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICAvKiogQGhpZGRlbiAqL1xuICAgICAgICB0aGlzLl9jYWNoZSA9IHsgcGF0aDogW3RoaXNdIH07XG4gICAgICAgIC8qKiBAaGlkZGVuICovXG4gICAgICAgIHRoaXMuX2NoaWxkcmVuID0gW107XG4gICAgICAgIC8qKiBAaGlkZGVuICovXG4gICAgICAgIHRoaXMuX3BhcmFtcyA9IFtdO1xuICAgICAgICAvKiogQGhpZGRlbiAqL1xuICAgICAgICB0aGlzLl9zZWdtZW50cyA9IFtdO1xuICAgICAgICAvKiogQGhpZGRlbiAqL1xuICAgICAgICB0aGlzLl9jb21waWxlZCA9IFtdO1xuICAgICAgICB0aGlzLnBhdHRlcm4gPSBwYXR0ZXJuO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbW1vbl8xLmRlZmF1bHRzKHRoaXMuY29uZmlnLCB7XG4gICAgICAgICAgICBwYXJhbXM6IHt9LFxuICAgICAgICAgICAgc3RyaWN0OiB0cnVlLFxuICAgICAgICAgICAgY2FzZUluc2Vuc2l0aXZlOiBmYWxzZSxcbiAgICAgICAgICAgIHBhcmFtTWFwOiBjb21tb25fMS5pZGVudGl0eSxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEZpbmQgYWxsIHBsYWNlaG9sZGVycyBhbmQgY3JlYXRlIGEgY29tcGlsZWQgcGF0dGVybiwgdXNpbmcgZWl0aGVyIGNsYXNzaWMgb3IgY3VybHkgc3ludGF4OlxuICAgICAgICAvLyAgICcqJyBuYW1lXG4gICAgICAgIC8vICAgJzonIG5hbWVcbiAgICAgICAgLy8gICAneycgbmFtZSAnfSdcbiAgICAgICAgLy8gICAneycgbmFtZSAnOicgcmVnZXhwICd9J1xuICAgICAgICAvLyBUaGUgcmVndWxhciBleHByZXNzaW9uIGlzIHNvbWV3aGF0IGNvbXBsaWNhdGVkIGR1ZSB0byB0aGUgbmVlZCB0byBhbGxvdyBjdXJseSBicmFjZXNcbiAgICAgICAgLy8gaW5zaWRlIHRoZSByZWd1bGFyIGV4cHJlc3Npb24uIFRoZSBwbGFjZWhvbGRlciByZWdleHAgYnJlYWtzIGRvd24gYXMgZm9sbG93czpcbiAgICAgICAgLy8gICAgKFs6Kl0pKFtcXHdcXFtcXF1dKykgICAgICAgICAgICAgIC0gY2xhc3NpYyBwbGFjZWhvbGRlciAoJDEgLyAkMikgKHNlYXJjaCB2ZXJzaW9uIGhhcyAtIGZvciBzbmFrZS1jYXNlKVxuICAgICAgICAvLyAgICBcXHsoW1xcd1xcW1xcXV0rKSg/OlxcOlxccyooIC4uLiApKT9cXH0gIC0gY3VybHkgYnJhY2UgcGxhY2Vob2xkZXIgKCQzKSB3aXRoIG9wdGlvbmFsIHJlZ2V4cC90eXBlIC4uLiAoJDQpIChzZWFyY2ggdmVyc2lvbiBoYXMgLSBmb3Igc25ha2UtY2FzZVxuICAgICAgICAvLyAgICAoPzogLi4uIHwgLi4uIHwgLi4uICkrICAgICAgICAgLSB0aGUgcmVnZXhwIGNvbnNpc3RzIG9mIGFueSBudW1iZXIgb2YgYXRvbXMsIGFuIGF0b20gYmVpbmcgZWl0aGVyXG4gICAgICAgIC8vICAgIFtee31cXFxcXSsgICAgICAgICAgICAgICAgICAgICAgIC0gYW55dGhpbmcgb3RoZXIgdGhhbiBjdXJseSBicmFjZXMgb3IgYmFja3NsYXNoXG4gICAgICAgIC8vICAgIFxcXFwuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gYSBiYWNrc2xhc2ggZXNjYXBlXG4gICAgICAgIC8vICAgIFxceyg/Oltee31cXFxcXSt8XFxcXC4pKlxcfSAgICAgICAgICAtIGEgbWF0Y2hlZCBzZXQgb2YgY3VybHkgYnJhY2VzIGNvbnRhaW5pbmcgb3RoZXIgYXRvbXNcbiAgICAgICAgdmFyIHBsYWNlaG9sZGVyID0gLyhbOipdKShbXFx3XFxbXFxdXSspfFxceyhbXFx3XFxbXFxdXSspKD86XFw6XFxzKigoPzpbXnt9XFxcXF0rfFxcXFwufFxceyg/Oltee31cXFxcXSt8XFxcXC4pKlxcfSkrKSk/XFx9L2c7XG4gICAgICAgIHZhciBzZWFyY2hQbGFjZWhvbGRlciA9IC8oWzpdPykoW1xcd1xcW1xcXS4tXSspfFxceyhbXFx3XFxbXFxdLi1dKykoPzpcXDpcXHMqKCg/Oltee31cXFxcXSt8XFxcXC58XFx7KD86W157fVxcXFxdK3xcXFxcLikqXFx9KSspKT9cXH0vZztcbiAgICAgICAgdmFyIHBhdHRlcm5zID0gW107XG4gICAgICAgIHZhciBsYXN0ID0gMCwgbWF0Y2hBcnJheTtcbiAgICAgICAgdmFyIGNoZWNrUGFyYW1FcnJvcnMgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgIGlmICghVXJsTWF0Y2hlci5uYW1lVmFsaWRhdG9yLnRlc3QoaWQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcGFyYW1ldGVyIG5hbWUgJ1wiICsgaWQgKyBcIicgaW4gcGF0dGVybiAnXCIgKyBwYXR0ZXJuICsgXCInXCIpO1xuICAgICAgICAgICAgaWYgKGNvbW1vbl8xLmZpbmQoX3RoaXMuX3BhcmFtcywgaG9mXzEucHJvcEVxKCdpZCcsIGlkKSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRHVwbGljYXRlIHBhcmFtZXRlciBuYW1lICdcIiArIGlkICsgXCInIGluIHBhdHRlcm4gJ1wiICsgcGF0dGVybiArIFwiJ1wiKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gU3BsaXQgaW50byBzdGF0aWMgc2VnbWVudHMgc2VwYXJhdGVkIGJ5IHBhdGggcGFyYW1ldGVyIHBsYWNlaG9sZGVycy5cbiAgICAgICAgLy8gVGhlIG51bWJlciBvZiBzZWdtZW50cyBpcyBhbHdheXMgMSBtb3JlIHRoYW4gdGhlIG51bWJlciBvZiBwYXJhbWV0ZXJzLlxuICAgICAgICB2YXIgbWF0Y2hEZXRhaWxzID0gZnVuY3Rpb24gKG0sIGlzU2VhcmNoKSB7XG4gICAgICAgICAgICAvLyBJRVs3OF0gcmV0dXJucyAnJyBmb3IgdW5tYXRjaGVkIGdyb3VwcyBpbnN0ZWFkIG9mIG51bGxcbiAgICAgICAgICAgIHZhciBpZCA9IG1bMl0gfHwgbVszXTtcbiAgICAgICAgICAgIHZhciByZWdleHAgPSBpc1NlYXJjaCA/IG1bNF0gOiBtWzRdIHx8IChtWzFdID09PSAnKicgPyAnW1xcXFxzXFxcXFNdKicgOiBudWxsKTtcbiAgICAgICAgICAgIHZhciBtYWtlUmVnZXhwVHlwZSA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIGNvbW1vbl8xLmluaGVyaXQocGFyYW1UeXBlcy50eXBlKGlzU2VhcmNoID8gJ3F1ZXJ5JyA6ICdwYXRoJyksIHtcbiAgICAgICAgICAgICAgICBwYXR0ZXJuOiBuZXcgUmVnRXhwKHN0ciwgX3RoaXMuY29uZmlnLmNhc2VJbnNlbnNpdGl2ZSA/ICdpJyA6IHVuZGVmaW5lZCksXG4gICAgICAgICAgICB9KTsgfTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgIHJlZ2V4cDogcmVnZXhwLFxuICAgICAgICAgICAgICAgIGNmZzogX3RoaXMuY29uZmlnLnBhcmFtc1tpZF0sXG4gICAgICAgICAgICAgICAgc2VnbWVudDogcGF0dGVybi5zdWJzdHJpbmcobGFzdCwgbS5pbmRleCksXG4gICAgICAgICAgICAgICAgdHlwZTogIXJlZ2V4cCA/IG51bGwgOiBwYXJhbVR5cGVzLnR5cGUocmVnZXhwKSB8fCBtYWtlUmVnZXhwVHlwZShyZWdleHApLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHAsIHNlZ21lbnQ7XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1jb25kaXRpb25hbC1hc3NpZ25tZW50XG4gICAgICAgIHdoaWxlICgobWF0Y2hBcnJheSA9IHBsYWNlaG9sZGVyLmV4ZWMocGF0dGVybikpKSB7XG4gICAgICAgICAgICBwID0gbWF0Y2hEZXRhaWxzKG1hdGNoQXJyYXksIGZhbHNlKTtcbiAgICAgICAgICAgIGlmIChwLnNlZ21lbnQuaW5kZXhPZignPycpID49IDApXG4gICAgICAgICAgICAgICAgYnJlYWs7IC8vIHdlJ3JlIGludG8gdGhlIHNlYXJjaCBwYXJ0XG4gICAgICAgICAgICBjaGVja1BhcmFtRXJyb3JzKHAuaWQpO1xuICAgICAgICAgICAgdGhpcy5fcGFyYW1zLnB1c2gocGFyYW1GYWN0b3J5LmZyb21QYXRoKHAuaWQsIHAudHlwZSwgdGhpcy5jb25maWcucGFyYW1NYXAocC5jZmcsIGZhbHNlKSkpO1xuICAgICAgICAgICAgdGhpcy5fc2VnbWVudHMucHVzaChwLnNlZ21lbnQpO1xuICAgICAgICAgICAgcGF0dGVybnMucHVzaChbcC5zZWdtZW50LCBjb21tb25fMS50YWlsKHRoaXMuX3BhcmFtcyldKTtcbiAgICAgICAgICAgIGxhc3QgPSBwbGFjZWhvbGRlci5sYXN0SW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgc2VnbWVudCA9IHBhdHRlcm4uc3Vic3RyaW5nKGxhc3QpO1xuICAgICAgICAvLyBGaW5kIGFueSBzZWFyY2ggcGFyYW1ldGVyIG5hbWVzIGFuZCByZW1vdmUgdGhlbSBmcm9tIHRoZSBsYXN0IHNlZ21lbnRcbiAgICAgICAgdmFyIGkgPSBzZWdtZW50LmluZGV4T2YoJz8nKTtcbiAgICAgICAgaWYgKGkgPj0gMCkge1xuICAgICAgICAgICAgdmFyIHNlYXJjaCA9IHNlZ21lbnQuc3Vic3RyaW5nKGkpO1xuICAgICAgICAgICAgc2VnbWVudCA9IHNlZ21lbnQuc3Vic3RyaW5nKDAsIGkpO1xuICAgICAgICAgICAgaWYgKHNlYXJjaC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbGFzdCA9IDA7XG4gICAgICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWNvbmRpdGlvbmFsLWFzc2lnbm1lbnRcbiAgICAgICAgICAgICAgICB3aGlsZSAoKG1hdGNoQXJyYXkgPSBzZWFyY2hQbGFjZWhvbGRlci5leGVjKHNlYXJjaCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBtYXRjaERldGFpbHMobWF0Y2hBcnJheSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrUGFyYW1FcnJvcnMocC5pZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcmFtcy5wdXNoKHBhcmFtRmFjdG9yeS5mcm9tU2VhcmNoKHAuaWQsIHAudHlwZSwgdGhpcy5jb25maWcucGFyYW1NYXAocC5jZmcsIHRydWUpKSk7XG4gICAgICAgICAgICAgICAgICAgIGxhc3QgPSBwbGFjZWhvbGRlci5sYXN0SW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmID8mXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NlZ21lbnRzLnB1c2goc2VnbWVudCk7XG4gICAgICAgIHRoaXMuX2NvbXBpbGVkID0gcGF0dGVybnMubWFwKGZ1bmN0aW9uIChfcGF0dGVybikgeyByZXR1cm4gcXVvdGVSZWdFeHAuYXBwbHkobnVsbCwgX3BhdHRlcm4pOyB9KS5jb25jYXQocXVvdGVSZWdFeHAoc2VnbWVudCkpO1xuICAgIH1cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIFVybE1hdGNoZXIuZW5jb2RlRGFzaGVzID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cikucmVwbGFjZSgvLS9nLCBmdW5jdGlvbiAoYykgeyByZXR1cm4gXCIlNUMlXCIgKyBjLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7IH0pO1xuICAgIH07XG4gICAgLyoqIEBoaWRkZW4gR2l2ZW4gYSBtYXRjaGVyLCByZXR1cm4gYW4gYXJyYXkgd2l0aCB0aGUgbWF0Y2hlcidzIHBhdGggc2VnbWVudHMgYW5kIHBhdGggcGFyYW1zLCBpbiBvcmRlciAqL1xuICAgIFVybE1hdGNoZXIucGF0aFNlZ21lbnRzQW5kUGFyYW1zID0gZnVuY3Rpb24gKG1hdGNoZXIpIHtcbiAgICAgICAgdmFyIHN0YXRpY1NlZ21lbnRzID0gbWF0Y2hlci5fc2VnbWVudHM7XG4gICAgICAgIHZhciBwYXRoUGFyYW1zID0gbWF0Y2hlci5fcGFyYW1zLmZpbHRlcihmdW5jdGlvbiAocCkgeyByZXR1cm4gcC5sb2NhdGlvbiA9PT0gcGFyYW1fMS5EZWZUeXBlLlBBVEg7IH0pO1xuICAgICAgICByZXR1cm4gY29tbW9uXzEuYXJyYXlUdXBsZXMoc3RhdGljU2VnbWVudHMsIHBhdGhQYXJhbXMuY29uY2F0KHVuZGVmaW5lZCkpXG4gICAgICAgICAgICAucmVkdWNlKGNvbW1vbl8xLnVubmVzdFIsIFtdKVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoeCkgeyByZXR1cm4geCAhPT0gJycgJiYgcHJlZGljYXRlc18xLmlzRGVmaW5lZCh4KTsgfSk7XG4gICAgfTtcbiAgICAvKiogQGhpZGRlbiBHaXZlbiBhIG1hdGNoZXIsIHJldHVybiBhbiBhcnJheSB3aXRoIHRoZSBtYXRjaGVyJ3MgcXVlcnkgcGFyYW1zICovXG4gICAgVXJsTWF0Y2hlci5xdWVyeVBhcmFtcyA9IGZ1bmN0aW9uIChtYXRjaGVyKSB7XG4gICAgICAgIHJldHVybiBtYXRjaGVyLl9wYXJhbXMuZmlsdGVyKGZ1bmN0aW9uIChwKSB7IHJldHVybiBwLmxvY2F0aW9uID09PSBwYXJhbV8xLkRlZlR5cGUuU0VBUkNIOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbXBhcmUgdHdvIFVybE1hdGNoZXJzXG4gICAgICpcbiAgICAgKiBUaGlzIGNvbXBhcmlzb24gZnVuY3Rpb24gY29udmVydHMgYSBVcmxNYXRjaGVyIGludG8gc3RhdGljIGFuZCBkeW5hbWljIHBhdGggc2VnbWVudHMuXG4gICAgICogRWFjaCBzdGF0aWMgcGF0aCBzZWdtZW50IGlzIGEgc3RhdGljIHN0cmluZyBiZXR3ZWVuIGEgcGF0aCBzZXBhcmF0b3IgKHNsYXNoIGNoYXJhY3RlcikuXG4gICAgICogRWFjaCBkeW5hbWljIHNlZ21lbnQgaXMgYSBwYXRoIHBhcmFtZXRlci5cbiAgICAgKlxuICAgICAqIFRoZSBjb21wYXJpc29uIGZ1bmN0aW9uIHNvcnRzIHN0YXRpYyBzZWdtZW50cyBiZWZvcmUgZHluYW1pYyBvbmVzLlxuICAgICAqL1xuICAgIFVybE1hdGNoZXIuY29tcGFyZSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUdXJuIGEgVXJsTWF0Y2hlciBhbmQgYWxsIGl0cyBwYXJlbnQgbWF0Y2hlcnMgaW50byBhbiBhcnJheVxuICAgICAgICAgKiBvZiBzbGFzaCBsaXRlcmFscyAnLycsIHN0cmluZyBsaXRlcmFscywgYW5kIFBhcmFtIG9iamVjdHNcbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBleGFtcGxlIG1hdGNoZXIgbWF0Y2hlcyBzdHJpbmdzIGxpa2UgXCIvZm9vLzpwYXJhbS90YWlsXCI6XG4gICAgICAgICAqIHZhciBtYXRjaGVyID0gJHVtZi5jb21waWxlKFwiL2Zvb1wiKS5hcHBlbmQoJHVtZi5jb21waWxlKFwiLzpwYXJhbVwiKSkuYXBwZW5kKCR1bWYuY29tcGlsZShcIi9cIikpLmFwcGVuZCgkdW1mLmNvbXBpbGUoXCJ0YWlsXCIpKTtcbiAgICAgICAgICogdmFyIHJlc3VsdCA9IHNlZ21lbnRzKG1hdGNoZXIpOyAvLyBbICcvJywgJ2ZvbycsICcvJywgUGFyYW0sICcvJywgJ3RhaWwnIF1cbiAgICAgICAgICpcbiAgICAgICAgICogQ2FjaGVzIHRoZSByZXN1bHQgYXMgYG1hdGNoZXIuX2NhY2hlLnNlZ21lbnRzYFxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIHNlZ21lbnRzID0gZnVuY3Rpb24gKG1hdGNoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaGVyLl9jYWNoZS5zZWdtZW50cyA9IG1hdGNoZXIuX2NhY2hlLnNlZ21lbnRzIHx8XG4gICAgICAgICAgICAgICAgbWF0Y2hlci5fY2FjaGUucGF0aC5tYXAoVXJsTWF0Y2hlci5wYXRoU2VnbWVudHNBbmRQYXJhbXMpXG4gICAgICAgICAgICAgICAgICAgIC5yZWR1Y2UoY29tbW9uXzEudW5uZXN0UiwgW10pXG4gICAgICAgICAgICAgICAgICAgIC5yZWR1Y2Uoc3RyaW5nc18xLmpvaW5OZWlnaGJvcnNSLCBbXSlcbiAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4gcHJlZGljYXRlc18xLmlzU3RyaW5nKHgpID8gc3BsaXRPblNsYXNoKHgpIDogeDsgfSlcbiAgICAgICAgICAgICAgICAgICAgLnJlZHVjZShjb21tb25fMS51bm5lc3RSLCBbXSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXRzIHRoZSBzb3J0IHdlaWdodCBmb3IgZWFjaCBzZWdtZW50IG9mIGEgVXJsTWF0Y2hlclxuICAgICAgICAgKlxuICAgICAgICAgKiBDYWNoZXMgdGhlIHJlc3VsdCBhcyBgbWF0Y2hlci5fY2FjaGUud2VpZ2h0c2BcbiAgICAgICAgICovXG4gICAgICAgIHZhciB3ZWlnaHRzID0gZnVuY3Rpb24gKG1hdGNoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaGVyLl9jYWNoZS53ZWlnaHRzID0gbWF0Y2hlci5fY2FjaGUud2VpZ2h0cyB8fFxuICAgICAgICAgICAgICAgIHNlZ21lbnRzKG1hdGNoZXIpLm1hcChmdW5jdGlvbiAoc2VnbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTb3J0IHNsYXNoZXMgZmlyc3QsIHRoZW4gc3RhdGljIHN0cmluZ3MsIHRoZSBQYXJhbXNcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlZ21lbnQgPT09ICcvJylcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJlZGljYXRlc18xLmlzU3RyaW5nKHNlZ21lbnQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWdtZW50IGluc3RhbmNlb2YgcGFyYW1fMS5QYXJhbSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAzO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUGFkcyBzaG9ydGVyIGFycmF5IGluLXBsYWNlIChtdXRhdGVzKVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIHBhZEFycmF5cyA9IGZ1bmN0aW9uIChsLCByLCBwYWRWYWwpIHtcbiAgICAgICAgICAgIHZhciBsZW4gPSBNYXRoLm1heChsLmxlbmd0aCwgci5sZW5ndGgpO1xuICAgICAgICAgICAgd2hpbGUgKGwubGVuZ3RoIDwgbGVuKVxuICAgICAgICAgICAgICAgIGwucHVzaChwYWRWYWwpO1xuICAgICAgICAgICAgd2hpbGUgKHIubGVuZ3RoIDwgbGVuKVxuICAgICAgICAgICAgICAgIHIucHVzaChwYWRWYWwpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgd2VpZ2h0c0EgPSB3ZWlnaHRzKGEpLCB3ZWlnaHRzQiA9IHdlaWdodHMoYik7XG4gICAgICAgIHBhZEFycmF5cyh3ZWlnaHRzQSwgd2VpZ2h0c0IsIDApO1xuICAgICAgICB2YXIgX3BhaXJzID0gY29tbW9uXzEuYXJyYXlUdXBsZXMod2VpZ2h0c0EsIHdlaWdodHNCKTtcbiAgICAgICAgdmFyIGNtcCwgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IF9wYWlycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY21wID0gX3BhaXJzW2ldWzBdIC0gX3BhaXJzW2ldWzFdO1xuICAgICAgICAgICAgaWYgKGNtcCAhPT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gY21wO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBjb25jYXRlbmF0ZWQgVXJsTWF0Y2hlclxuICAgICAqXG4gICAgICogQnVpbGRzIGEgbmV3IFVybE1hdGNoZXIgYnkgYXBwZW5kaW5nIGFub3RoZXIgVXJsTWF0Y2hlciB0byB0aGlzIG9uZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1cmwgQSBgVXJsTWF0Y2hlcmAgaW5zdGFuY2UgdG8gYXBwZW5kIGFzIGEgY2hpbGQgb2YgdGhlIGN1cnJlbnQgYFVybE1hdGNoZXJgLlxuICAgICAqL1xuICAgIFVybE1hdGNoZXIucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgdGhpcy5fY2hpbGRyZW4ucHVzaCh1cmwpO1xuICAgICAgICB1cmwuX2NhY2hlID0ge1xuICAgICAgICAgICAgcGF0aDogdGhpcy5fY2FjaGUucGF0aC5jb25jYXQodXJsKSxcbiAgICAgICAgICAgIHBhcmVudDogdGhpcyxcbiAgICAgICAgICAgIHBhdHRlcm46IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfTtcbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIFVybE1hdGNoZXIucHJvdG90eXBlLmlzUm9vdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlLnBhdGhbMF0gPT09IHRoaXM7XG4gICAgfTtcbiAgICAvKiogUmV0dXJucyB0aGUgaW5wdXQgcGF0dGVybiBzdHJpbmcgKi9cbiAgICBVcmxNYXRjaGVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGF0dGVybjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRlc3RzIHRoZSBzcGVjaWZpZWQgdXJsL3BhdGggYWdhaW5zdCB0aGlzIG1hdGNoZXIuXG4gICAgICpcbiAgICAgKiBUZXN0cyBpZiB0aGUgZ2l2ZW4gdXJsIG1hdGNoZXMgdGhpcyBtYXRjaGVyJ3MgcGF0dGVybiwgYW5kIHJldHVybnMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGNhcHR1cmVkXG4gICAgICogcGFyYW1ldGVyIHZhbHVlcy4gIFJldHVybnMgbnVsbCBpZiB0aGUgcGF0aCBkb2VzIG5vdCBtYXRjaC5cbiAgICAgKlxuICAgICAqIFRoZSByZXR1cm5lZCBvYmplY3QgY29udGFpbnMgdGhlIHZhbHVlc1xuICAgICAqIG9mIGFueSBzZWFyY2ggcGFyYW1ldGVycyB0aGF0IGFyZSBtZW50aW9uZWQgaW4gdGhlIHBhdHRlcm4sIGJ1dCB0aGVpciB2YWx1ZSBtYXkgYmUgbnVsbCBpZlxuICAgICAqIHRoZXkgYXJlIG5vdCBwcmVzZW50IGluIGBzZWFyY2hgLiBUaGlzIG1lYW5zIHRoYXQgc2VhcmNoIHBhcmFtZXRlcnMgYXJlIGFsd2F5cyB0cmVhdGVkXG4gICAgICogYXMgb3B0aW9uYWwuXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGU6XG4gICAgICogYGBganNcbiAgICAgKiBuZXcgVXJsTWF0Y2hlcignL3VzZXIve2lkfT9xJnInKS5leGVjKCcvdXNlci9ib2InLCB7XG4gICAgICogICB4OiAnMScsIHE6ICdoZWxsbydcbiAgICAgKiB9KTtcbiAgICAgKiAvLyByZXR1cm5zIHsgaWQ6ICdib2InLCBxOiAnaGVsbG8nLCByOiBudWxsIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXRoICAgIFRoZSBVUkwgcGF0aCB0byBtYXRjaCwgZS5nLiBgJGxvY2F0aW9uLnBhdGgoKWAuXG4gICAgICogQHBhcmFtIHNlYXJjaCAgVVJMIHNlYXJjaCBwYXJhbWV0ZXJzLCBlLmcuIGAkbG9jYXRpb24uc2VhcmNoKClgLlxuICAgICAqIEBwYXJhbSBoYXNoICAgIFVSTCBoYXNoIGUuZy4gYCRsb2NhdGlvbi5oYXNoKClgLlxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgY2FwdHVyZWQgcGFyYW1ldGVyIHZhbHVlcy5cbiAgICAgKi9cbiAgICBVcmxNYXRjaGVyLnByb3RvdHlwZS5leGVjID0gZnVuY3Rpb24gKHBhdGgsIHNlYXJjaCwgaGFzaCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoc2VhcmNoID09PSB2b2lkIDApIHsgc2VhcmNoID0ge307IH1cbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgdmFyIG1hdGNoID0gbWVtb2l6ZVRvKHRoaXMuX2NhY2hlLCAncGF0dGVybicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKFtcbiAgICAgICAgICAgICAgICAnXicsXG4gICAgICAgICAgICAgICAgY29tbW9uXzEudW5uZXN0KF90aGlzLl9jYWNoZS5wYXRoLm1hcChob2ZfMS5wcm9wKCdfY29tcGlsZWQnKSkpLmpvaW4oJycpLFxuICAgICAgICAgICAgICAgIF90aGlzLmNvbmZpZy5zdHJpY3QgPT09IGZhbHNlID8gJ1xcLz8nIDogJycsXG4gICAgICAgICAgICAgICAgJyQnLFxuICAgICAgICAgICAgXS5qb2luKCcnKSwgX3RoaXMuY29uZmlnLmNhc2VJbnNlbnNpdGl2ZSA/ICdpJyA6IHVuZGVmaW5lZCk7XG4gICAgICAgIH0pLmV4ZWMocGF0aCk7XG4gICAgICAgIGlmICghbWF0Y2gpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgLy8gb3B0aW9ucyA9IGRlZmF1bHRzKG9wdGlvbnMsIHsgaXNvbGF0ZTogZmFsc2UgfSk7XG4gICAgICAgIHZhciBhbGxQYXJhbXMgPSB0aGlzLnBhcmFtZXRlcnMoKSwgcGF0aFBhcmFtcyA9IGFsbFBhcmFtcy5maWx0ZXIoZnVuY3Rpb24gKHBhcmFtKSB7IHJldHVybiAhcGFyYW0uaXNTZWFyY2goKTsgfSksIHNlYXJjaFBhcmFtcyA9IGFsbFBhcmFtcy5maWx0ZXIoZnVuY3Rpb24gKHBhcmFtKSB7IHJldHVybiBwYXJhbS5pc1NlYXJjaCgpOyB9KSwgblBhdGhTZWdtZW50cyA9IHRoaXMuX2NhY2hlLnBhdGgubWFwKGZ1bmN0aW9uICh1cmxtKSB7IHJldHVybiB1cmxtLl9zZWdtZW50cy5sZW5ndGggLSAxOyB9KS5yZWR1Y2UoZnVuY3Rpb24gKGEsIHgpIHsgcmV0dXJuIGEgKyB4OyB9KSwgdmFsdWVzID0ge307XG4gICAgICAgIGlmIChuUGF0aFNlZ21lbnRzICE9PSBtYXRjaC5sZW5ndGggLSAxKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5iYWxhbmNlZCBjYXB0dXJlIGdyb3VwIGluIHJvdXRlICdcIiArIHRoaXMucGF0dGVybiArIFwiJ1wiKTtcbiAgICAgICAgZnVuY3Rpb24gZGVjb2RlUGF0aEFycmF5KHBhcmFtVmFsKSB7XG4gICAgICAgICAgICB2YXIgcmV2ZXJzZVN0cmluZyA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIHN0ci5zcGxpdCgnJykucmV2ZXJzZSgpLmpvaW4oJycpOyB9O1xuICAgICAgICAgICAgdmFyIHVucXVvdGVEYXNoZXMgPSBmdW5jdGlvbiAoc3RyKSB7IHJldHVybiBzdHIucmVwbGFjZSgvXFxcXC0vZywgJy0nKTsgfTtcbiAgICAgICAgICAgIHZhciBzcGxpdCA9IHJldmVyc2VTdHJpbmcocGFyYW1WYWwpLnNwbGl0KC8tKD8hXFxcXCkvKTtcbiAgICAgICAgICAgIHZhciBhbGxSZXZlcnNlZCA9IGNvbW1vbl8xLm1hcChzcGxpdCwgcmV2ZXJzZVN0cmluZyk7XG4gICAgICAgICAgICByZXR1cm4gY29tbW9uXzEubWFwKGFsbFJldmVyc2VkLCB1bnF1b3RlRGFzaGVzKS5yZXZlcnNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuUGF0aFNlZ21lbnRzOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwYXJhbSA9IHBhdGhQYXJhbXNbaV07XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBtYXRjaFtpICsgMV07XG4gICAgICAgICAgICAvLyBpZiB0aGUgcGFyYW0gdmFsdWUgbWF0Y2hlcyBhIHByZS1yZXBsYWNlIHBhaXIsIHJlcGxhY2UgdGhlIHZhbHVlIGJlZm9yZSBkZWNvZGluZy5cbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcGFyYW0ucmVwbGFjZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGlmIChwYXJhbS5yZXBsYWNlW2pdLmZyb20gPT09IHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcmFtLnJlcGxhY2Vbal0udG87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUgJiYgcGFyYW0uYXJyYXkgPT09IHRydWUpXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBkZWNvZGVQYXRoQXJyYXkodmFsdWUpO1xuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZXNfMS5pc0RlZmluZWQodmFsdWUpKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyYW0udHlwZS5kZWNvZGUodmFsdWUpO1xuICAgICAgICAgICAgdmFsdWVzW3BhcmFtLmlkXSA9IHBhcmFtLnZhbHVlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBzZWFyY2hQYXJhbXMuZm9yRWFjaChmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHNlYXJjaFtwYXJhbS5pZF07XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBhcmFtLnJlcGxhY2UubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyYW0ucmVwbGFjZVtqXS5mcm9tID09PSB2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJhbS5yZXBsYWNlW2pdLnRvO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZXNfMS5pc0RlZmluZWQodmFsdWUpKVxuICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyYW0udHlwZS5kZWNvZGUodmFsdWUpO1xuICAgICAgICAgICAgdmFsdWVzW3BhcmFtLmlkXSA9IHBhcmFtLnZhbHVlKHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChoYXNoKVxuICAgICAgICAgICAgdmFsdWVzWycjJ10gPSBoYXNoO1xuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIFJldHVybnMgYWxsIHRoZSBbW1BhcmFtXV0gb2JqZWN0cyBvZiBhbGwgcGF0aCBhbmQgc2VhcmNoIHBhcmFtZXRlcnMgb2YgdGhpcyBwYXR0ZXJuIGluIG9yZGVyIG9mIGFwcGVhcmFuY2UuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7QXJyYXkuPFBhcmFtPn0gIEFuIGFycmF5IG9mIFtbUGFyYW1dXSBvYmplY3RzLiBNdXN0IGJlIHRyZWF0ZWQgYXMgcmVhZC1vbmx5LiBJZiB0aGVcbiAgICAgKiAgICBwYXR0ZXJuIGhhcyBubyBwYXJhbWV0ZXJzLCBhbiBlbXB0eSBhcnJheSBpcyByZXR1cm5lZC5cbiAgICAgKi9cbiAgICBVcmxNYXRjaGVyLnByb3RvdHlwZS5wYXJhbWV0ZXJzID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgICAgICAgaWYgKG9wdHMgPT09IHZvaWQgMCkgeyBvcHRzID0ge307IH1cbiAgICAgICAgaWYgKG9wdHMuaW5oZXJpdCA9PT0gZmFsc2UpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFyYW1zO1xuICAgICAgICByZXR1cm4gY29tbW9uXzEudW5uZXN0KHRoaXMuX2NhY2hlLnBhdGgubWFwKGZ1bmN0aW9uIChtYXRjaGVyKSB7IHJldHVybiBtYXRjaGVyLl9wYXJhbXM7IH0pKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBSZXR1cm5zIGEgc2luZ2xlIHBhcmFtZXRlciBmcm9tIHRoaXMgVXJsTWF0Y2hlciBieSBpZFxuICAgICAqXG4gICAgICogQHBhcmFtIGlkXG4gICAgICogQHBhcmFtIG9wdHNcbiAgICAgKiBAcmV0dXJucyB7VHxQYXJhbXxhbnl8Ym9vbGVhbnxVcmxNYXRjaGVyfG51bGx9XG4gICAgICovXG4gICAgVXJsTWF0Y2hlci5wcm90b3R5cGUucGFyYW1ldGVyID0gZnVuY3Rpb24gKGlkLCBvcHRzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChvcHRzID09PSB2b2lkIDApIHsgb3B0cyA9IHt9OyB9XG4gICAgICAgIHZhciBmaW5kUGFyYW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gX3RoaXMuX3BhcmFtczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyYW0gPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtLmlkID09PSBpZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcmFtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5fY2FjaGUucGFyZW50O1xuICAgICAgICByZXR1cm4gZmluZFBhcmFtKCkgfHwgKG9wdHMuaW5oZXJpdCAhPT0gZmFsc2UgJiYgcGFyZW50ICYmIHBhcmVudC5wYXJhbWV0ZXIoaWQsIG9wdHMpKSB8fCBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVmFsaWRhdGVzIHRoZSBpbnB1dCBwYXJhbWV0ZXIgdmFsdWVzIGFnYWluc3QgdGhpcyBVcmxNYXRjaGVyXG4gICAgICpcbiAgICAgKiBDaGVja3MgYW4gb2JqZWN0IGhhc2ggb2YgcGFyYW1ldGVycyB0byB2YWxpZGF0ZSB0aGVpciBjb3JyZWN0bmVzcyBhY2NvcmRpbmcgdG8gdGhlIHBhcmFtZXRlclxuICAgICAqIHR5cGVzIG9mIHRoaXMgYFVybE1hdGNoZXJgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyBUaGUgb2JqZWN0IGhhc2ggb2YgcGFyYW1ldGVycyB0byB2YWxpZGF0ZS5cbiAgICAgKiBAcmV0dXJucyBSZXR1cm5zIGB0cnVlYCBpZiBgcGFyYW1zYCB2YWxpZGF0ZXMsIG90aGVyd2lzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIFVybE1hdGNoZXIucHJvdG90eXBlLnZhbGlkYXRlcyA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgdmFyIHZhbGlkUGFyYW1WYWwgPSBmdW5jdGlvbiAocGFyYW0sIHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuICFwYXJhbSB8fCBwYXJhbS52YWxpZGF0ZXModmFsKTtcbiAgICAgICAgfTtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICAgICAgICAvLyBJJ20gbm90IHN1cmUgd2h5IHRoaXMgY2hlY2tzIG9ubHkgdGhlIHBhcmFtIGtleXMgcGFzc2VkIGluLCBhbmQgbm90IGFsbCB0aGUgcGFyYW1zIGtub3duIHRvIHRoZSBtYXRjaGVyXG4gICAgICAgIHZhciBwYXJhbVNjaGVtYSA9IHRoaXMucGFyYW1ldGVycygpLmZpbHRlcihmdW5jdGlvbiAocGFyYW1EZWYpIHsgcmV0dXJuIHBhcmFtcy5oYXNPd25Qcm9wZXJ0eShwYXJhbURlZi5pZCk7IH0pO1xuICAgICAgICByZXR1cm4gcGFyYW1TY2hlbWEubWFwKGZ1bmN0aW9uIChwYXJhbURlZikgeyByZXR1cm4gdmFsaWRQYXJhbVZhbChwYXJhbURlZiwgcGFyYW1zW3BhcmFtRGVmLmlkXSk7IH0pLnJlZHVjZShjb21tb25fMS5hbGxUcnVlUiwgdHJ1ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIHNldCBvZiBwYXJhbWV0ZXIgdmFsdWVzLCBjcmVhdGVzIGEgVVJMIGZyb20gdGhpcyBVcmxNYXRjaGVyLlxuICAgICAqXG4gICAgICogQ3JlYXRlcyBhIFVSTCB0aGF0IG1hdGNoZXMgdGhpcyBwYXR0ZXJuIGJ5IHN1YnN0aXR1dGluZyB0aGUgc3BlY2lmaWVkIHZhbHVlc1xuICAgICAqIGZvciB0aGUgcGF0aCBhbmQgc2VhcmNoIHBhcmFtZXRlcnMuXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGU6XG4gICAgICogYGBganNcbiAgICAgKiBuZXcgVXJsTWF0Y2hlcignL3VzZXIve2lkfT9xJykuZm9ybWF0KHsgaWQ6J2JvYicsIHE6J3llcycgfSk7XG4gICAgICogLy8gcmV0dXJucyAnL3VzZXIvYm9iP3E9eWVzJ1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlcyAgdGhlIHZhbHVlcyB0byBzdWJzdGl0dXRlIGZvciB0aGUgcGFyYW1ldGVycyBpbiB0aGlzIHBhdHRlcm4uXG4gICAgICogQHJldHVybnMgdGhlIGZvcm1hdHRlZCBVUkwgKHBhdGggYW5kIG9wdGlvbmFsbHkgc2VhcmNoIHBhcnQpLlxuICAgICAqL1xuICAgIFVybE1hdGNoZXIucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHZhbHVlcyA9PT0gdm9pZCAwKSB7IHZhbHVlcyA9IHt9OyB9XG4gICAgICAgIC8vIEJ1aWxkIHRoZSBmdWxsIHBhdGggb2YgVXJsTWF0Y2hlcnMgKGluY2x1ZGluZyBhbGwgcGFyZW50IFVybE1hdGNoZXJzKVxuICAgICAgICB2YXIgdXJsTWF0Y2hlcnMgPSB0aGlzLl9jYWNoZS5wYXRoO1xuICAgICAgICAvLyBFeHRyYWN0IGFsbCB0aGUgc3RhdGljIHNlZ21lbnRzIGFuZCBQYXJhbXMgKHByb2Nlc3NlZCBhcyBQYXJhbURldGFpbHMpXG4gICAgICAgIC8vIGludG8gYW4gb3JkZXJlZCBhcnJheVxuICAgICAgICB2YXIgcGF0aFNlZ21lbnRzQW5kUGFyYW1zID0gdXJsTWF0Y2hlcnMubWFwKFVybE1hdGNoZXIucGF0aFNlZ21lbnRzQW5kUGFyYW1zKVxuICAgICAgICAgICAgLnJlZHVjZShjb21tb25fMS51bm5lc3RSLCBbXSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHByZWRpY2F0ZXNfMS5pc1N0cmluZyh4KSA/IHggOiBnZXREZXRhaWxzKHgpOyB9KTtcbiAgICAgICAgLy8gRXh0cmFjdCB0aGUgcXVlcnkgcGFyYW1zIGludG8gYSBzZXBhcmF0ZSBhcnJheVxuICAgICAgICB2YXIgcXVlcnlQYXJhbXMgPSB1cmxNYXRjaGVycy5tYXAoVXJsTWF0Y2hlci5xdWVyeVBhcmFtcylcbiAgICAgICAgICAgIC5yZWR1Y2UoY29tbW9uXzEudW5uZXN0UiwgW10pXG4gICAgICAgICAgICAubWFwKGdldERldGFpbHMpO1xuICAgICAgICB2YXIgaXNJbnZhbGlkID0gZnVuY3Rpb24gKHBhcmFtKSB7IHJldHVybiBwYXJhbS5pc1ZhbGlkID09PSBmYWxzZTsgfTtcbiAgICAgICAgaWYgKHBhdGhTZWdtZW50c0FuZFBhcmFtcy5jb25jYXQocXVlcnlQYXJhbXMpLmZpbHRlcihpc0ludmFsaWQpLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdpdmVuIGEgUGFyYW0sIGFwcGxpZXMgdGhlIHBhcmFtZXRlciB2YWx1ZSwgdGhlbiByZXR1cm5zIGRldGFpbGVkIGluZm9ybWF0aW9uIGFib3V0IGl0XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBnZXREZXRhaWxzKHBhcmFtKSB7XG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgdG8gdHlwZWQgdmFsdWVcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHBhcmFtLnZhbHVlKHZhbHVlc1twYXJhbS5pZF0pO1xuICAgICAgICAgICAgdmFyIGlzVmFsaWQgPSBwYXJhbS52YWxpZGF0ZXModmFsdWUpO1xuICAgICAgICAgICAgdmFyIGlzRGVmYXVsdFZhbHVlID0gcGFyYW0uaXNEZWZhdWx0VmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgd2UncmUgaW4gc3F1YXNoIG1vZGUgZm9yIHRoZSBwYXJhbWV0ZXJcbiAgICAgICAgICAgIHZhciBzcXVhc2ggPSBpc0RlZmF1bHRWYWx1ZSA/IHBhcmFtLnNxdWFzaCA6IGZhbHNlO1xuICAgICAgICAgICAgLy8gQWxsb3cgdGhlIFBhcmFtZXRlcidzIFR5cGUgdG8gZW5jb2RlIHRoZSB2YWx1ZVxuICAgICAgICAgICAgdmFyIGVuY29kZWQgPSBwYXJhbS50eXBlLmVuY29kZSh2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4geyBwYXJhbTogcGFyYW0sIHZhbHVlOiB2YWx1ZSwgaXNWYWxpZDogaXNWYWxpZCwgaXNEZWZhdWx0VmFsdWU6IGlzRGVmYXVsdFZhbHVlLCBzcXVhc2g6IHNxdWFzaCwgZW5jb2RlZDogZW5jb2RlZCB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIEJ1aWxkIHVwIHRoZSBwYXRoLXBvcnRpb24gZnJvbSB0aGUgbGlzdCBvZiBzdGF0aWMgc2VnbWVudHMgYW5kIHBhcmFtZXRlcnNcbiAgICAgICAgdmFyIHBhdGhTdHJpbmcgPSBwYXRoU2VnbWVudHNBbmRQYXJhbXMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHgpIHtcbiAgICAgICAgICAgIC8vIFRoZSBlbGVtZW50IGlzIGEgc3RhdGljIHNlZ21lbnQgKGEgcmF3IHN0cmluZyk7IGp1c3QgYXBwZW5kIGl0XG4gICAgICAgICAgICBpZiAocHJlZGljYXRlc18xLmlzU3RyaW5nKHgpKVxuICAgICAgICAgICAgICAgIHJldHVybiBhY2MgKyB4O1xuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBpdCdzIGEgUGFyYW1EZXRhaWxzLlxuICAgICAgICAgICAgdmFyIHNxdWFzaCA9IHguc3F1YXNoLCBlbmNvZGVkID0geC5lbmNvZGVkLCBwYXJhbSA9IHgucGFyYW07XG4gICAgICAgICAgICAvLyBJZiBzcXVhc2ggaXMgPT09IHRydWUsIHRyeSB0byByZW1vdmUgYSBzbGFzaCBmcm9tIHRoZSBwYXRoXG4gICAgICAgICAgICBpZiAoc3F1YXNoID09PSB0cnVlKVxuICAgICAgICAgICAgICAgIHJldHVybiAoYWNjLm1hdGNoKC9cXC8kLykpID8gYWNjLnNsaWNlKDAsIC0xKSA6IGFjYztcbiAgICAgICAgICAgIC8vIElmIHNxdWFzaCBpcyBhIHN0cmluZywgdXNlIHRoZSBzdHJpbmcgZm9yIHRoZSBwYXJhbSB2YWx1ZVxuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZXNfMS5pc1N0cmluZyhzcXVhc2gpKVxuICAgICAgICAgICAgICAgIHJldHVybiBhY2MgKyBzcXVhc2g7XG4gICAgICAgICAgICBpZiAoc3F1YXNoICE9PSBmYWxzZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjOyAvLyA/XG4gICAgICAgICAgICBpZiAoZW5jb2RlZCA9PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIHBhcmFtZXRlciB2YWx1ZSBpcyBhbiBhcnJheSwgZW5jb2RlIHRoZSB2YWx1ZSB1c2luZyBlbmNvZGVEYXNoZXNcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGVzXzEuaXNBcnJheShlbmNvZGVkKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjICsgY29tbW9uXzEubWFwKGVuY29kZWQsIFVybE1hdGNoZXIuZW5jb2RlRGFzaGVzKS5qb2luKCctJyk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgcGFyYW1ldGVyIHR5cGUgaXMgXCJyYXdcIiwgdGhlbiBkbyBub3QgZW5jb2RlVVJJQ29tcG9uZW50XG4gICAgICAgICAgICBpZiAocGFyYW0ucmF3KVxuICAgICAgICAgICAgICAgIHJldHVybiBhY2MgKyBlbmNvZGVkO1xuICAgICAgICAgICAgLy8gRW5jb2RlIHRoZSB2YWx1ZVxuICAgICAgICAgICAgcmV0dXJuIGFjYyArIGVuY29kZVVSSUNvbXBvbmVudChlbmNvZGVkKTtcbiAgICAgICAgfSwgJycpO1xuICAgICAgICAvLyBCdWlsZCB0aGUgcXVlcnkgc3RyaW5nIGJ5IGFwcGx5aW5nIHBhcmFtZXRlciB2YWx1ZXMgKGFycmF5IG9yIHJlZ3VsYXIpXG4gICAgICAgIC8vIHRoZW4gbWFwcGluZyB0byBrZXk9dmFsdWUsIHRoZW4gZmxhdHRlbmluZyBhbmQgam9pbmluZyB1c2luZyBcIiZcIlxuICAgICAgICB2YXIgcXVlcnlTdHJpbmcgPSBxdWVyeVBhcmFtcy5tYXAoZnVuY3Rpb24gKHBhcmFtRGV0YWlscykge1xuICAgICAgICAgICAgdmFyIHBhcmFtID0gcGFyYW1EZXRhaWxzLnBhcmFtLCBzcXVhc2ggPSBwYXJhbURldGFpbHMuc3F1YXNoLCBlbmNvZGVkID0gcGFyYW1EZXRhaWxzLmVuY29kZWQsIGlzRGVmYXVsdFZhbHVlID0gcGFyYW1EZXRhaWxzLmlzRGVmYXVsdFZhbHVlO1xuICAgICAgICAgICAgaWYgKGVuY29kZWQgPT0gbnVsbCB8fCAoaXNEZWZhdWx0VmFsdWUgJiYgc3F1YXNoICE9PSBmYWxzZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKCFwcmVkaWNhdGVzXzEuaXNBcnJheShlbmNvZGVkKSlcbiAgICAgICAgICAgICAgICBlbmNvZGVkID0gW2VuY29kZWRdO1xuICAgICAgICAgICAgaWYgKGVuY29kZWQubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmICghcGFyYW0ucmF3KVxuICAgICAgICAgICAgICAgIGVuY29kZWQgPSBjb21tb25fMS5tYXAoZW5jb2RlZCwgZW5jb2RlVVJJQ29tcG9uZW50KTtcbiAgICAgICAgICAgIHJldHVybiBlbmNvZGVkLm1hcChmdW5jdGlvbiAodmFsKSB7IHJldHVybiBwYXJhbS5pZCArIFwiPVwiICsgdmFsOyB9KTtcbiAgICAgICAgfSkuZmlsdGVyKGNvbW1vbl8xLmlkZW50aXR5KS5yZWR1Y2UoY29tbW9uXzEudW5uZXN0UiwgW10pLmpvaW4oJyYnKTtcbiAgICAgICAgLy8gQ29uY2F0IHRoZSBwYXRoc3RyaW5nIHdpdGggdGhlIHF1ZXJ5U3RyaW5nIChpZiBleGlzdHMpIGFuZCB0aGUgaGFzaFN0cmluZyAoaWYgZXhpc3RzKVxuICAgICAgICByZXR1cm4gcGF0aFN0cmluZyArIChxdWVyeVN0cmluZyA/IFwiP1wiICsgcXVlcnlTdHJpbmcgOiAnJykgKyAodmFsdWVzWycjJ10gPyAnIycgKyB2YWx1ZXNbJyMnXSA6ICcnKTtcbiAgICB9O1xuICAgIC8qKiBAaGlkZGVuICovXG4gICAgVXJsTWF0Y2hlci5uYW1lVmFsaWRhdG9yID0gL15cXHcrKFstLl0rXFx3KykqKD86XFxbXFxdKT8kLztcbiAgICByZXR1cm4gVXJsTWF0Y2hlcjtcbn0oKSk7XG5leHBvcnRzLlVybE1hdGNoZXIgPSBVcmxNYXRjaGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXJsTWF0Y2hlci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvdXJsL3VybE1hdGNoZXIuanNcbi8vIG1vZHVsZSBpZCA9IDMyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///32\n")},function(module,exports,__webpack_require__){"use strict";eval('\n/**\n * @internalapi\n * @module vanilla\n */ /** */\nObject.defineProperty(exports, "__esModule", { value: true });\nvar common_1 = __webpack_require__(5);\nvar utils_1 = __webpack_require__(48);\n/** A base `LocationServices` */\nvar BaseLocationServices = /** @class */ (function () {\n    function BaseLocationServices(router, fireAfterUpdate) {\n        var _this = this;\n        this.fireAfterUpdate = fireAfterUpdate;\n        this._listeners = [];\n        this._listener = function (evt) { return _this._listeners.forEach(function (cb) { return cb(evt); }); };\n        this.hash = function () { return utils_1.parseUrl(_this._get()).hash; };\n        this.path = function () { return utils_1.parseUrl(_this._get()).path; };\n        this.search = function () { return utils_1.getParams(utils_1.parseUrl(_this._get()).search); };\n        this._location = common_1.root.location;\n        this._history = common_1.root.history;\n    }\n    BaseLocationServices.prototype.url = function (url, replace) {\n        if (replace === void 0) { replace = true; }\n        if (common_1.isDefined(url) && url !== this._get()) {\n            this._set(null, null, url, replace);\n            if (this.fireAfterUpdate) {\n                this._listeners.forEach(function (cb) { return cb({ url: url }); });\n            }\n        }\n        return utils_1.buildUrl(this);\n    };\n    BaseLocationServices.prototype.onChange = function (cb) {\n        var _this = this;\n        this._listeners.push(cb);\n        return function () { return common_1.removeFrom(_this._listeners, cb); };\n    };\n    BaseLocationServices.prototype.dispose = function (router) {\n        common_1.deregAll(this._listeners);\n    };\n    return BaseLocationServices;\n}());\nexports.BaseLocationServices = BaseLocationServices;\n//# sourceMappingURL=baseLocationService.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3ZhbmlsbGEvYmFzZUxvY2F0aW9uU2VydmljZS5qcz8wODc5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAaW50ZXJuYWxhcGlcbiAqIEBtb2R1bGUgdmFuaWxsYVxuICovIC8qKiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vblwiKTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG4vKiogQSBiYXNlIGBMb2NhdGlvblNlcnZpY2VzYCAqL1xudmFyIEJhc2VMb2NhdGlvblNlcnZpY2VzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJhc2VMb2NhdGlvblNlcnZpY2VzKHJvdXRlciwgZmlyZUFmdGVyVXBkYXRlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuZmlyZUFmdGVyVXBkYXRlID0gZmlyZUFmdGVyVXBkYXRlO1xuICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgdGhpcy5fbGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZ0KSB7IHJldHVybiBfdGhpcy5fbGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGNiKSB7IHJldHVybiBjYihldnQpOyB9KTsgfTtcbiAgICAgICAgdGhpcy5oYXNoID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdXRpbHNfMS5wYXJzZVVybChfdGhpcy5fZ2V0KCkpLmhhc2g7IH07XG4gICAgICAgIHRoaXMucGF0aCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxzXzEucGFyc2VVcmwoX3RoaXMuX2dldCgpKS5wYXRoOyB9O1xuICAgICAgICB0aGlzLnNlYXJjaCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWxzXzEuZ2V0UGFyYW1zKHV0aWxzXzEucGFyc2VVcmwoX3RoaXMuX2dldCgpKS5zZWFyY2gpOyB9O1xuICAgICAgICB0aGlzLl9sb2NhdGlvbiA9IGNvbW1vbl8xLnJvb3QubG9jYXRpb247XG4gICAgICAgIHRoaXMuX2hpc3RvcnkgPSBjb21tb25fMS5yb290Lmhpc3Rvcnk7XG4gICAgfVxuICAgIEJhc2VMb2NhdGlvblNlcnZpY2VzLnByb3RvdHlwZS51cmwgPSBmdW5jdGlvbiAodXJsLCByZXBsYWNlKSB7XG4gICAgICAgIGlmIChyZXBsYWNlID09PSB2b2lkIDApIHsgcmVwbGFjZSA9IHRydWU7IH1cbiAgICAgICAgaWYgKGNvbW1vbl8xLmlzRGVmaW5lZCh1cmwpICYmIHVybCAhPT0gdGhpcy5fZ2V0KCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldChudWxsLCBudWxsLCB1cmwsIHJlcGxhY2UpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZmlyZUFmdGVyVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGNiKSB7IHJldHVybiBjYih7IHVybDogdXJsIH0pOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXRpbHNfMS5idWlsZFVybCh0aGlzKTtcbiAgICB9O1xuICAgIEJhc2VMb2NhdGlvblNlcnZpY2VzLnByb3RvdHlwZS5vbkNoYW5nZSA9IGZ1bmN0aW9uIChjYikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl9saXN0ZW5lcnMucHVzaChjYik7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb21tb25fMS5yZW1vdmVGcm9tKF90aGlzLl9saXN0ZW5lcnMsIGNiKTsgfTtcbiAgICB9O1xuICAgIEJhc2VMb2NhdGlvblNlcnZpY2VzLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKHJvdXRlcikge1xuICAgICAgICBjb21tb25fMS5kZXJlZ0FsbCh0aGlzLl9saXN0ZW5lcnMpO1xuICAgIH07XG4gICAgcmV0dXJuIEJhc2VMb2NhdGlvblNlcnZpY2VzO1xufSgpKTtcbmV4cG9ydHMuQmFzZUxvY2F0aW9uU2VydmljZXMgPSBCYXNlTG9jYXRpb25TZXJ2aWNlcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhc2VMb2NhdGlvblNlcnZpY2UuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3ZhbmlsbGEvYmFzZUxvY2F0aW9uU2VydmljZS5qc1xuLy8gbW9kdWxlIGlkID0gMzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///33\n')},function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\nexports.OctavoComponentController = undefined;\n\nvar _assign = __webpack_require__(141);\n\nvar _assign2 = _interopRequireDefault(_assign);\n\nvar _classCallCheck2 = __webpack_require__(19);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __webpack_require__(27);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar OctavoComponentController = exports.OctavoComponentController = function () {\n    OctavoComponentController.$inject = ["$http", "$stateParams", "$state"];\n\n    /* @ngInject */\n    function OctavoComponentController($http, $stateParams, $state) {\n        (0, _classCallCheck3.default)(this, OctavoComponentController);\n\n        this.$http = $http;\n        this.$stateParams = $stateParams;\n        this.$state = $state;\n        this.queryRunning = false;\n        (0, _assign2.default)(this, $stateParams);\n        this.endpointChanged();\n    }\n\n    (0, _createClass3.default)(OctavoComponentController, [{\n        key: "uiOnParamsChanged",\n        value: function uiOnParamsChanged(params) {\n            if (params.endpoint && this.endpoint !== params.endpoint) {\n                this.endpoint = params.endpoint;\n                this.endpointChanged();\n            } else this.doRunQuery();\n        }\n        // tslint:disable-next-line: no-empty\n\n    }, {\n        key: "endpointUpdated",\n        value: function endpointUpdated(indexInfo) {}\n    }, {\n        key: "endpointChanged",\n        value: function endpointChanged() {\n            var _this = this;\n\n            this.$http.get(this.endpoint + "indexInfo").then(function (response) {\n                _this.isEndpointValid = true;\n                _this.$state.go(_this.$state.current, _this);\n                _this.endpointUpdated(response.data);\n            }, function () {\n                _this.isEndpointValid = false;\n            });\n        }\n    }, {\n        key: "runQuery",\n        value: function runQuery() {\n            this.$state.go(this.$state.current, this);\n        }\n    }, {\n        key: "doRunQuery",\n        value: function doRunQuery() {\n            this.error = undefined;\n            this.queryRunning = true;\n        }\n    }]);\n    return OctavoComponentController;\n}();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vYXBwL2NvbXBvbmVudHMvb2N0YXZvLWNvbXBvbmVudC1jb250cm9sbGVyLnRzPzhhNTYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnQgY2xhc3MgT2N0YXZvQ29tcG9uZW50Q29udHJvbGxlciB7XG4gICAgLyogQG5nSW5qZWN0ICovXG4gICAgY29uc3RydWN0b3IoJGh0dHAsICRzdGF0ZVBhcmFtcywgJHN0YXRlKSB7XG4gICAgICAgIHRoaXMuJGh0dHAgPSAkaHR0cDtcbiAgICAgICAgdGhpcy4kc3RhdGVQYXJhbXMgPSAkc3RhdGVQYXJhbXM7XG4gICAgICAgIHRoaXMuJHN0YXRlID0gJHN0YXRlO1xuICAgICAgICB0aGlzLnF1ZXJ5UnVubmluZyA9IGZhbHNlO1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsICRzdGF0ZVBhcmFtcyk7XG4gICAgICAgIHRoaXMuZW5kcG9pbnRDaGFuZ2VkKCk7XG4gICAgfVxuICAgIHVpT25QYXJhbXNDaGFuZ2VkKHBhcmFtcykge1xuICAgICAgICBpZiAocGFyYW1zLmVuZHBvaW50ICYmIHRoaXMuZW5kcG9pbnQgIT09IHBhcmFtcy5lbmRwb2ludCkge1xuICAgICAgICAgICAgdGhpcy5lbmRwb2ludCA9IHBhcmFtcy5lbmRwb2ludDtcbiAgICAgICAgICAgIHRoaXMuZW5kcG9pbnRDaGFuZ2VkKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5kb1J1blF1ZXJ5KCk7XG4gICAgfVxuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogbm8tZW1wdHlcbiAgICBlbmRwb2ludFVwZGF0ZWQoaW5kZXhJbmZvKSB7IH1cbiAgICBlbmRwb2ludENoYW5nZWQoKSB7XG4gICAgICAgIHRoaXMuJGh0dHAuZ2V0KHRoaXMuZW5kcG9pbnQgKyBcImluZGV4SW5mb1wiKS50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5pc0VuZHBvaW50VmFsaWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy4kc3RhdGUuZ28odGhpcy4kc3RhdGUuY3VycmVudCwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLmVuZHBvaW50VXBkYXRlZChyZXNwb25zZS5kYXRhKTtcbiAgICAgICAgfSwgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5pc0VuZHBvaW50VmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJ1blF1ZXJ5KCkge1xuICAgICAgICB0aGlzLiRzdGF0ZS5nbyh0aGlzLiRzdGF0ZS5jdXJyZW50LCB0aGlzKTtcbiAgICB9XG4gICAgZG9SdW5RdWVyeSgpIHtcbiAgICAgICAgdGhpcy5lcnJvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5xdWVyeVJ1bm5pbmcgPSB0cnVlO1xuICAgIH1cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBhcHAvY29tcG9uZW50cy9vY3Rhdm8tY29tcG9uZW50LWNvbnRyb2xsZXIudHMiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7OztBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTs7O0FBQUE7OztBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///34\n')},function(module,exports){eval("module.exports = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3Byb3BlcnR5LWRlc2MuanM/NWZjMCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChiaXRtYXAsIHZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZTogIShiaXRtYXAgJiAxKSxcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG4gICAgd3JpdGFibGU6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWU6IHZhbHVlXG4gIH07XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3Byb3BlcnR5LWRlc2MuanNcbi8vIG1vZHVsZSBpZCA9IDM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///35\n")},function(module,exports,__webpack_require__){eval("// 19.1.2.14 / 15.2.3.14 Object.keys(O)\nvar $keys = __webpack_require__(98);\nvar enumBugKeys = __webpack_require__(55);\n\nmodule.exports = Object.keys || function keys(O) {\n  return $keys(O, enumBugKeys);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1rZXlzLmpzPzk2NGIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gMTkuMS4yLjE0IC8gMTUuMi4zLjE0IE9iamVjdC5rZXlzKE8pXG52YXIgJGtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cy1pbnRlcm5hbCcpO1xudmFyIGVudW1CdWdLZXlzID0gcmVxdWlyZSgnLi9fZW51bS1idWcta2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTykge1xuICByZXR1cm4gJGtleXMoTywgZW51bUJ1Z0tleXMpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qta2V5cy5qc1xuLy8gbW9kdWxlIGlkID0gMzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///36\n")},function(module,exports){eval("var id = 0;\nvar px = Math.random();\nmodule.exports = function (key) {\n  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3VpZC5qcz9kYzRhIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBpZCA9IDA7XG52YXIgcHggPSBNYXRoLnJhbmRvbSgpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiAnU3ltYm9sKCcuY29uY2F0KGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXksICcpXycsICgrK2lkICsgcHgpLnRvU3RyaW5nKDM2KSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3VpZC5qc1xuLy8gbW9kdWxlIGlkID0gMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///37\n")},function(module,exports){eval("exports.f = {}.propertyIsEnumerable;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1waWUuanM/MzY5MiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzLmYgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtcGllLmpzXG4vLyBtb2R1bGUgaWQgPSAzOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///38\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar pug_has_own_property = Object.prototype.hasOwnProperty;\n\n/**\n * Merge two attribute objects giving precedence\n * to values in object `b`. Classes are special-cased\n * allowing for arrays and merging/joining appropriately\n * resulting in a string.\n *\n * @param {Object} a\n * @param {Object} b\n * @return {Object} a\n * @api private\n */\n\nexports.merge = pug_merge;\nfunction pug_merge(a, b) {\n  if (arguments.length === 1) {\n    var attrs = a[0];\n    for (var i = 1; i < a.length; i++) {\n      attrs = pug_merge(attrs, a[i]);\n    }\n    return attrs;\n  }\n\n  for (var key in b) {\n    if (key === 'class') {\n      var valA = a[key] || [];\n      a[key] = (Array.isArray(valA) ? valA : [valA]).concat(b[key] || []);\n    } else if (key === 'style') {\n      var valA = pug_style(a[key]);\n      var valB = pug_style(b[key]);\n      a[key] = valA + valB;\n    } else {\n      a[key] = b[key];\n    }\n  }\n\n  return a;\n};\n\n/**\n * Process array, object, or string as a string of classes delimited by a space.\n *\n * If `val` is an array, all members of it and its subarrays are counted as\n * classes. If `escaping` is an array, then whether or not the item in `val` is\n * escaped depends on the corresponding item in `escaping`. If `escaping` is\n * not an array, no escaping is done.\n *\n * If `val` is an object, all the keys whose value is truthy are counted as\n * classes. No escaping is done.\n *\n * If `val` is a string, it is counted as a class. No escaping is done.\n *\n * @param {(Array.<string>|Object.<string, boolean>|string)} val\n * @param {?Array.<string>} escaping\n * @return {String}\n */\nexports.classes = pug_classes;\nfunction pug_classes_array(val, escaping) {\n  var classString = '', className, padding = '', escapeEnabled = Array.isArray(escaping);\n  for (var i = 0; i < val.length; i++) {\n    className = pug_classes(val[i]);\n    if (!className) continue;\n    escapeEnabled && escaping[i] && (className = pug_escape(className));\n    classString = classString + padding + className;\n    padding = ' ';\n  }\n  return classString;\n}\nfunction pug_classes_object(val) {\n  var classString = '', padding = '';\n  for (var key in val) {\n    if (key && val[key] && pug_has_own_property.call(val, key)) {\n      classString = classString + padding + key;\n      padding = ' ';\n    }\n  }\n  return classString;\n}\nfunction pug_classes(val, escaping) {\n  if (Array.isArray(val)) {\n    return pug_classes_array(val, escaping);\n  } else if (val && typeof val === 'object') {\n    return pug_classes_object(val);\n  } else {\n    return val || '';\n  }\n}\n\n/**\n * Convert object or string to a string of CSS styles delimited by a semicolon.\n *\n * @param {(Object.<string, string>|string)} val\n * @return {String}\n */\n\nexports.style = pug_style;\nfunction pug_style(val) {\n  if (!val) return '';\n  if (typeof val === 'object') {\n    var out = '';\n    for (var style in val) {\n      /* istanbul ignore else */\n      if (pug_has_own_property.call(val, style)) {\n        out = out + style + ':' + val[style] + ';';\n      }\n    }\n    return out;\n  } else {\n    val += '';\n    if (val[val.length - 1] !== ';') \n      return val + ';';\n    return val;\n  }\n};\n\n/**\n * Render the given attribute.\n *\n * @param {String} key\n * @param {String} val\n * @param {Boolean} escaped\n * @param {Boolean} terse\n * @return {String}\n */\nexports.attr = pug_attr;\nfunction pug_attr(key, val, escaped, terse) {\n  if (val === false || val == null || !val && (key === 'class' || key === 'style')) {\n    return '';\n  }\n  if (val === true) {\n    return ' ' + (terse ? key : key + '=\"' + key + '\"');\n  }\n  if (typeof val.toJSON === 'function') {\n    val = val.toJSON();\n  }\n  if (typeof val !== 'string') {\n    val = JSON.stringify(val);\n    if (!escaped && val.indexOf('\"') !== -1) {\n      return ' ' + key + '=\\'' + val.replace(/'/g, '&#39;') + '\\'';\n    }\n  }\n  if (escaped) val = pug_escape(val);\n  return ' ' + key + '=\"' + val + '\"';\n};\n\n/**\n * Render the given attributes object.\n *\n * @param {Object} obj\n * @param {Object} terse whether to use HTML5 terse boolean attributes\n * @return {String}\n */\nexports.attrs = pug_attrs;\nfunction pug_attrs(obj, terse){\n  var attrs = '';\n\n  for (var key in obj) {\n    if (pug_has_own_property.call(obj, key)) {\n      var val = obj[key];\n\n      if ('class' === key) {\n        val = pug_classes(val);\n        attrs = pug_attr(key, val, false, terse) + attrs;\n        continue;\n      }\n      if ('style' === key) {\n        val = pug_style(val);\n      }\n      attrs += pug_attr(key, val, false, terse);\n    }\n  }\n\n  return attrs;\n};\n\n/**\n * Escape the given string of `html`.\n *\n * @param {String} html\n * @return {String}\n * @api private\n */\n\nvar pug_match_html = /[\"&<>]/;\nexports.escape = pug_escape;\nfunction pug_escape(_html){\n  var html = '' + _html;\n  var regexResult = pug_match_html.exec(html);\n  if (!regexResult) return _html;\n\n  var result = '';\n  var i, lastIndex, escape;\n  for (i = regexResult.index, lastIndex = 0; i < html.length; i++) {\n    switch (html.charCodeAt(i)) {\n      case 34: escape = '&quot;'; break;\n      case 38: escape = '&amp;'; break;\n      case 60: escape = '&lt;'; break;\n      case 62: escape = '&gt;'; break;\n      default: continue;\n    }\n    if (lastIndex !== i) result += html.substring(lastIndex, i);\n    lastIndex = i + 1;\n    result += escape;\n  }\n  if (lastIndex !== i) return result + html.substring(lastIndex, i);\n  else return result;\n};\n\n/**\n * Re-throw the given `err` in context to the\n * the pug in `filename` at the given `lineno`.\n *\n * @param {Error} err\n * @param {String} filename\n * @param {String} lineno\n * @param {String} str original source\n * @api private\n */\n\nexports.rethrow = pug_rethrow;\nfunction pug_rethrow(err, filename, lineno, str){\n  if (!(err instanceof Error)) throw err;\n  if ((typeof window != 'undefined' || !filename) && !str) {\n    err.message += ' on line ' + lineno;\n    throw err;\n  }\n  try {\n    str = str || __webpack_require__(153).readFileSync(filename, 'utf8')\n  } catch (ex) {\n    pug_rethrow(err, null, lineno)\n  }\n  var context = 3\n    , lines = str.split('\\n')\n    , start = Math.max(lineno - context, 0)\n    , end = Math.min(lines.length, lineno + context);\n\n  // Error context\n  var context = lines.slice(start, end).map(function(line, i){\n    var curr = i + start + 1;\n    return (curr == lineno ? '  > ' : '    ')\n      + curr\n      + '| '\n      + line;\n  }).join('\\n');\n\n  // Alter exception message\n  err.path = filename;\n  err.message = (filename || 'Pug') + ':' + lineno\n    + '\\n' + context + '\\n\\n' + err.message;\n  throw err;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHVnLXJ1bnRpbWUvaW5kZXguanM/NzI4MCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBwdWdfaGFzX293bl9wcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogTWVyZ2UgdHdvIGF0dHJpYnV0ZSBvYmplY3RzIGdpdmluZyBwcmVjZWRlbmNlXG4gKiB0byB2YWx1ZXMgaW4gb2JqZWN0IGBiYC4gQ2xhc3NlcyBhcmUgc3BlY2lhbC1jYXNlZFxuICogYWxsb3dpbmcgZm9yIGFycmF5cyBhbmQgbWVyZ2luZy9qb2luaW5nIGFwcHJvcHJpYXRlbHlcbiAqIHJlc3VsdGluZyBpbiBhIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYVxuICogQHBhcmFtIHtPYmplY3R9IGJcbiAqIEByZXR1cm4ge09iamVjdH0gYVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5tZXJnZSA9IHB1Z19tZXJnZTtcbmZ1bmN0aW9uIHB1Z19tZXJnZShhLCBiKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIGF0dHJzID0gYVswXTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGF0dHJzID0gcHVnX21lcmdlKGF0dHJzLCBhW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGF0dHJzO1xuICB9XG5cbiAgZm9yICh2YXIga2V5IGluIGIpIHtcbiAgICBpZiAoa2V5ID09PSAnY2xhc3MnKSB7XG4gICAgICB2YXIgdmFsQSA9IGFba2V5XSB8fCBbXTtcbiAgICAgIGFba2V5XSA9IChBcnJheS5pc0FycmF5KHZhbEEpID8gdmFsQSA6IFt2YWxBXSkuY29uY2F0KGJba2V5XSB8fCBbXSk7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09ICdzdHlsZScpIHtcbiAgICAgIHZhciB2YWxBID0gcHVnX3N0eWxlKGFba2V5XSk7XG4gICAgICB2YXIgdmFsQiA9IHB1Z19zdHlsZShiW2tleV0pO1xuICAgICAgYVtrZXldID0gdmFsQSArIHZhbEI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFba2V5XSA9IGJba2V5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYTtcbn07XG5cbi8qKlxuICogUHJvY2VzcyBhcnJheSwgb2JqZWN0LCBvciBzdHJpbmcgYXMgYSBzdHJpbmcgb2YgY2xhc3NlcyBkZWxpbWl0ZWQgYnkgYSBzcGFjZS5cbiAqXG4gKiBJZiBgdmFsYCBpcyBhbiBhcnJheSwgYWxsIG1lbWJlcnMgb2YgaXQgYW5kIGl0cyBzdWJhcnJheXMgYXJlIGNvdW50ZWQgYXNcbiAqIGNsYXNzZXMuIElmIGBlc2NhcGluZ2AgaXMgYW4gYXJyYXksIHRoZW4gd2hldGhlciBvciBub3QgdGhlIGl0ZW0gaW4gYHZhbGAgaXNcbiAqIGVzY2FwZWQgZGVwZW5kcyBvbiB0aGUgY29ycmVzcG9uZGluZyBpdGVtIGluIGBlc2NhcGluZ2AuIElmIGBlc2NhcGluZ2AgaXNcbiAqIG5vdCBhbiBhcnJheSwgbm8gZXNjYXBpbmcgaXMgZG9uZS5cbiAqXG4gKiBJZiBgdmFsYCBpcyBhbiBvYmplY3QsIGFsbCB0aGUga2V5cyB3aG9zZSB2YWx1ZSBpcyB0cnV0aHkgYXJlIGNvdW50ZWQgYXNcbiAqIGNsYXNzZXMuIE5vIGVzY2FwaW5nIGlzIGRvbmUuXG4gKlxuICogSWYgYHZhbGAgaXMgYSBzdHJpbmcsIGl0IGlzIGNvdW50ZWQgYXMgYSBjbGFzcy4gTm8gZXNjYXBpbmcgaXMgZG9uZS5cbiAqXG4gKiBAcGFyYW0geyhBcnJheS48c3RyaW5nPnxPYmplY3QuPHN0cmluZywgYm9vbGVhbj58c3RyaW5nKX0gdmFsXG4gKiBAcGFyYW0gez9BcnJheS48c3RyaW5nPn0gZXNjYXBpbmdcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZXhwb3J0cy5jbGFzc2VzID0gcHVnX2NsYXNzZXM7XG5mdW5jdGlvbiBwdWdfY2xhc3Nlc19hcnJheSh2YWwsIGVzY2FwaW5nKSB7XG4gIHZhciBjbGFzc1N0cmluZyA9ICcnLCBjbGFzc05hbWUsIHBhZGRpbmcgPSAnJywgZXNjYXBlRW5hYmxlZCA9IEFycmF5LmlzQXJyYXkoZXNjYXBpbmcpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbC5sZW5ndGg7IGkrKykge1xuICAgIGNsYXNzTmFtZSA9IHB1Z19jbGFzc2VzKHZhbFtpXSk7XG4gICAgaWYgKCFjbGFzc05hbWUpIGNvbnRpbnVlO1xuICAgIGVzY2FwZUVuYWJsZWQgJiYgZXNjYXBpbmdbaV0gJiYgKGNsYXNzTmFtZSA9IHB1Z19lc2NhcGUoY2xhc3NOYW1lKSk7XG4gICAgY2xhc3NTdHJpbmcgPSBjbGFzc1N0cmluZyArIHBhZGRpbmcgKyBjbGFzc05hbWU7XG4gICAgcGFkZGluZyA9ICcgJztcbiAgfVxuICByZXR1cm4gY2xhc3NTdHJpbmc7XG59XG5mdW5jdGlvbiBwdWdfY2xhc3Nlc19vYmplY3QodmFsKSB7XG4gIHZhciBjbGFzc1N0cmluZyA9ICcnLCBwYWRkaW5nID0gJyc7XG4gIGZvciAodmFyIGtleSBpbiB2YWwpIHtcbiAgICBpZiAoa2V5ICYmIHZhbFtrZXldICYmIHB1Z19oYXNfb3duX3Byb3BlcnR5LmNhbGwodmFsLCBrZXkpKSB7XG4gICAgICBjbGFzc1N0cmluZyA9IGNsYXNzU3RyaW5nICsgcGFkZGluZyArIGtleTtcbiAgICAgIHBhZGRpbmcgPSAnICc7XG4gICAgfVxuICB9XG4gIHJldHVybiBjbGFzc1N0cmluZztcbn1cbmZ1bmN0aW9uIHB1Z19jbGFzc2VzKHZhbCwgZXNjYXBpbmcpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgIHJldHVybiBwdWdfY2xhc3Nlc19hcnJheSh2YWwsIGVzY2FwaW5nKTtcbiAgfSBlbHNlIGlmICh2YWwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gcHVnX2NsYXNzZXNfb2JqZWN0KHZhbCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZhbCB8fCAnJztcbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnQgb2JqZWN0IG9yIHN0cmluZyB0byBhIHN0cmluZyBvZiBDU1Mgc3R5bGVzIGRlbGltaXRlZCBieSBhIHNlbWljb2xvbi5cbiAqXG4gKiBAcGFyYW0geyhPYmplY3QuPHN0cmluZywgc3RyaW5nPnxzdHJpbmcpfSB2YWxcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuXG5leHBvcnRzLnN0eWxlID0gcHVnX3N0eWxlO1xuZnVuY3Rpb24gcHVnX3N0eWxlKHZhbCkge1xuICBpZiAoIXZhbCkgcmV0dXJuICcnO1xuICBpZiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgb3V0ID0gJyc7XG4gICAgZm9yICh2YXIgc3R5bGUgaW4gdmFsKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKHB1Z19oYXNfb3duX3Byb3BlcnR5LmNhbGwodmFsLCBzdHlsZSkpIHtcbiAgICAgICAgb3V0ID0gb3V0ICsgc3R5bGUgKyAnOicgKyB2YWxbc3R5bGVdICsgJzsnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9IGVsc2Uge1xuICAgIHZhbCArPSAnJztcbiAgICBpZiAodmFsW3ZhbC5sZW5ndGggLSAxXSAhPT0gJzsnKSBcbiAgICAgIHJldHVybiB2YWwgKyAnOyc7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxufTtcblxuLyoqXG4gKiBSZW5kZXIgdGhlIGdpdmVuIGF0dHJpYnV0ZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGVzY2FwZWRcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gdGVyc2VcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZXhwb3J0cy5hdHRyID0gcHVnX2F0dHI7XG5mdW5jdGlvbiBwdWdfYXR0cihrZXksIHZhbCwgZXNjYXBlZCwgdGVyc2UpIHtcbiAgaWYgKHZhbCA9PT0gZmFsc2UgfHwgdmFsID09IG51bGwgfHwgIXZhbCAmJiAoa2V5ID09PSAnY2xhc3MnIHx8IGtleSA9PT0gJ3N0eWxlJykpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgaWYgKHZhbCA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiAnICcgKyAodGVyc2UgPyBrZXkgOiBrZXkgKyAnPVwiJyArIGtleSArICdcIicpO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhbCA9IHZhbC50b0pTT04oKTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbCAhPT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBKU09OLnN0cmluZ2lmeSh2YWwpO1xuICAgIGlmICghZXNjYXBlZCAmJiB2YWwuaW5kZXhPZignXCInKSAhPT0gLTEpIHtcbiAgICAgIHJldHVybiAnICcgKyBrZXkgKyAnPVxcJycgKyB2YWwucmVwbGFjZSgvJy9nLCAnJiMzOTsnKSArICdcXCcnO1xuICAgIH1cbiAgfVxuICBpZiAoZXNjYXBlZCkgdmFsID0gcHVnX2VzY2FwZSh2YWwpO1xuICByZXR1cm4gJyAnICsga2V5ICsgJz1cIicgKyB2YWwgKyAnXCInO1xufTtcblxuLyoqXG4gKiBSZW5kZXIgdGhlIGdpdmVuIGF0dHJpYnV0ZXMgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0ZXJzZSB3aGV0aGVyIHRvIHVzZSBIVE1MNSB0ZXJzZSBib29sZWFuIGF0dHJpYnV0ZXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuZXhwb3J0cy5hdHRycyA9IHB1Z19hdHRycztcbmZ1bmN0aW9uIHB1Z19hdHRycyhvYmosIHRlcnNlKXtcbiAgdmFyIGF0dHJzID0gJyc7XG5cbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChwdWdfaGFzX293bl9wcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgdmFyIHZhbCA9IG9ialtrZXldO1xuXG4gICAgICBpZiAoJ2NsYXNzJyA9PT0ga2V5KSB7XG4gICAgICAgIHZhbCA9IHB1Z19jbGFzc2VzKHZhbCk7XG4gICAgICAgIGF0dHJzID0gcHVnX2F0dHIoa2V5LCB2YWwsIGZhbHNlLCB0ZXJzZSkgKyBhdHRycztcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoJ3N0eWxlJyA9PT0ga2V5KSB7XG4gICAgICAgIHZhbCA9IHB1Z19zdHlsZSh2YWwpO1xuICAgICAgfVxuICAgICAgYXR0cnMgKz0gcHVnX2F0dHIoa2V5LCB2YWwsIGZhbHNlLCB0ZXJzZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGF0dHJzO1xufTtcblxuLyoqXG4gKiBFc2NhcGUgdGhlIGdpdmVuIHN0cmluZyBvZiBgaHRtbGAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGh0bWxcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbnZhciBwdWdfbWF0Y2hfaHRtbCA9IC9bXCImPD5dLztcbmV4cG9ydHMuZXNjYXBlID0gcHVnX2VzY2FwZTtcbmZ1bmN0aW9uIHB1Z19lc2NhcGUoX2h0bWwpe1xuICB2YXIgaHRtbCA9ICcnICsgX2h0bWw7XG4gIHZhciByZWdleFJlc3VsdCA9IHB1Z19tYXRjaF9odG1sLmV4ZWMoaHRtbCk7XG4gIGlmICghcmVnZXhSZXN1bHQpIHJldHVybiBfaHRtbDtcblxuICB2YXIgcmVzdWx0ID0gJyc7XG4gIHZhciBpLCBsYXN0SW5kZXgsIGVzY2FwZTtcbiAgZm9yIChpID0gcmVnZXhSZXN1bHQuaW5kZXgsIGxhc3RJbmRleCA9IDA7IGkgPCBodG1sLmxlbmd0aDsgaSsrKSB7XG4gICAgc3dpdGNoIChodG1sLmNoYXJDb2RlQXQoaSkpIHtcbiAgICAgIGNhc2UgMzQ6IGVzY2FwZSA9ICcmcXVvdDsnOyBicmVhaztcbiAgICAgIGNhc2UgMzg6IGVzY2FwZSA9ICcmYW1wOyc7IGJyZWFrO1xuICAgICAgY2FzZSA2MDogZXNjYXBlID0gJyZsdDsnOyBicmVhaztcbiAgICAgIGNhc2UgNjI6IGVzY2FwZSA9ICcmZ3Q7JzsgYnJlYWs7XG4gICAgICBkZWZhdWx0OiBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGxhc3RJbmRleCAhPT0gaSkgcmVzdWx0ICs9IGh0bWwuc3Vic3RyaW5nKGxhc3RJbmRleCwgaSk7XG4gICAgbGFzdEluZGV4ID0gaSArIDE7XG4gICAgcmVzdWx0ICs9IGVzY2FwZTtcbiAgfVxuICBpZiAobGFzdEluZGV4ICE9PSBpKSByZXR1cm4gcmVzdWx0ICsgaHRtbC5zdWJzdHJpbmcobGFzdEluZGV4LCBpKTtcbiAgZWxzZSByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBSZS10aHJvdyB0aGUgZ2l2ZW4gYGVycmAgaW4gY29udGV4dCB0byB0aGVcbiAqIHRoZSBwdWcgaW4gYGZpbGVuYW1lYCBhdCB0aGUgZ2l2ZW4gYGxpbmVub2AuXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyXG4gKiBAcGFyYW0ge1N0cmluZ30gZmlsZW5hbWVcbiAqIEBwYXJhbSB7U3RyaW5nfSBsaW5lbm9cbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgb3JpZ2luYWwgc291cmNlXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLnJldGhyb3cgPSBwdWdfcmV0aHJvdztcbmZ1bmN0aW9uIHB1Z19yZXRocm93KGVyciwgZmlsZW5hbWUsIGxpbmVubywgc3RyKXtcbiAgaWYgKCEoZXJyIGluc3RhbmNlb2YgRXJyb3IpKSB0aHJvdyBlcnI7XG4gIGlmICgodHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyB8fCAhZmlsZW5hbWUpICYmICFzdHIpIHtcbiAgICBlcnIubWVzc2FnZSArPSAnIG9uIGxpbmUgJyArIGxpbmVubztcbiAgICB0aHJvdyBlcnI7XG4gIH1cbiAgdHJ5IHtcbiAgICBzdHIgPSBzdHIgfHwgcmVxdWlyZSgnZnMnKS5yZWFkRmlsZVN5bmMoZmlsZW5hbWUsICd1dGY4JylcbiAgfSBjYXRjaCAoZXgpIHtcbiAgICBwdWdfcmV0aHJvdyhlcnIsIG51bGwsIGxpbmVubylcbiAgfVxuICB2YXIgY29udGV4dCA9IDNcbiAgICAsIGxpbmVzID0gc3RyLnNwbGl0KCdcXG4nKVxuICAgICwgc3RhcnQgPSBNYXRoLm1heChsaW5lbm8gLSBjb250ZXh0LCAwKVxuICAgICwgZW5kID0gTWF0aC5taW4obGluZXMubGVuZ3RoLCBsaW5lbm8gKyBjb250ZXh0KTtcblxuICAvLyBFcnJvciBjb250ZXh0XG4gIHZhciBjb250ZXh0ID0gbGluZXMuc2xpY2Uoc3RhcnQsIGVuZCkubWFwKGZ1bmN0aW9uKGxpbmUsIGkpe1xuICAgIHZhciBjdXJyID0gaSArIHN0YXJ0ICsgMTtcbiAgICByZXR1cm4gKGN1cnIgPT0gbGluZW5vID8gJyAgPiAnIDogJyAgICAnKVxuICAgICAgKyBjdXJyXG4gICAgICArICd8ICdcbiAgICAgICsgbGluZTtcbiAgfSkuam9pbignXFxuJyk7XG5cbiAgLy8gQWx0ZXIgZXhjZXB0aW9uIG1lc3NhZ2VcbiAgZXJyLnBhdGggPSBmaWxlbmFtZTtcbiAgZXJyLm1lc3NhZ2UgPSAoZmlsZW5hbWUgfHwgJ1B1ZycpICsgJzonICsgbGluZW5vXG4gICAgKyAnXFxuJyArIGNvbnRleHQgKyAnXFxuXFxuJyArIGVyci5tZXNzYWdlO1xuICB0aHJvdyBlcnI7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcHVnLXJ1bnRpbWUvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDM5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///39\n")},function(module,exports){eval("module.exports = {};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXJhdG9ycy5qcz9mZGI0Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0ge307XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlcmF0b3JzLmpzXG4vLyBtb2R1bGUgaWQgPSA0MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///40\n")},function(module,exports,__webpack_require__){eval('module.exports = { "default": __webpack_require__(167), __esModule: true };//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9nZXQtcHJvdG90eXBlLW9mLmpzPzY3MWUiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9nZXQtcHJvdG90eXBlLW9mXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL29iamVjdC9nZXQtcHJvdG90eXBlLW9mLmpzXG4vLyBtb2R1bGUgaWQgPSA0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///41\n')},function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar common_1 = __webpack_require__(0);\nvar hof_1 = __webpack_require__(2);\nvar glob_1 = __webpack_require__(28);\nvar predicates_1 = __webpack_require__(1);\n/**\n * Internal representation of a UI-Router state.\n *\n * Instances of this class are created when a [[StateDeclaration]] is registered with the [[StateRegistry]].\n *\n * A registered [[StateDeclaration]] is augmented with a getter ([[StateDeclaration.$$state]]) which returns the corresponding [[StateObject]] object.\n *\n * This class prototypally inherits from the corresponding [[StateDeclaration]].\n * Each of its own properties (i.e., `hasOwnProperty`) are built using builders from the [[StateBuilder]].\n */\nvar StateObject = /** @class */ (function () {\n    /** @deprecated use State.create() */\n    function StateObject(config) {\n        return StateObject.create(config || {});\n    }\n    /**\n     * Create a state object to put the private/internal implementation details onto.\n     * The object's prototype chain looks like:\n     * (Internal State Object) -> (Copy of State.prototype) -> (State Declaration object) -> (State Declaration's prototype...)\n     *\n     * @param stateDecl the user-supplied State Declaration\n     * @returns {StateObject} an internal State object\n     */\n    StateObject.create = function (stateDecl) {\n        stateDecl = StateObject.isStateClass(stateDecl) ? new stateDecl() : stateDecl;\n        var state = common_1.inherit(common_1.inherit(stateDecl, StateObject.prototype));\n        stateDecl.$$state = function () { return state; };\n        state.self = stateDecl;\n        state.__stateObjectCache = {\n            nameGlob: glob_1.Glob.fromString(state.name),\n        };\n        return state;\n    };\n    /**\n     * Returns true if the provided parameter is the same state.\n     *\n     * Compares the identity of the state against the passed value, which is either an object\n     * reference to the actual `State` instance, the original definition object passed to\n     * `$stateProvider.state()`, or the fully-qualified name.\n     *\n     * @param ref Can be one of (a) a `State` instance, (b) an object that was passed\n     *        into `$stateProvider.state()`, (c) the fully-qualified name of a state as a string.\n     * @returns Returns `true` if `ref` matches the current `State` instance.\n     */\n    StateObject.prototype.is = function (ref) {\n        return this === ref || this.self === ref || this.fqn() === ref;\n    };\n    /**\n     * @deprecated this does not properly handle dot notation\n     * @returns Returns a dot-separated name of the state.\n     */\n    StateObject.prototype.fqn = function () {\n        if (!this.parent || !(this.parent instanceof this.constructor))\n            return this.name;\n        var name = this.parent.fqn();\n        return name ? name + '.' + this.name : this.name;\n    };\n    /**\n     * Returns the root node of this state's tree.\n     *\n     * @returns The root of this state's tree.\n     */\n    StateObject.prototype.root = function () {\n        return this.parent && this.parent.root() || this;\n    };\n    /**\n     * Gets the state's `Param` objects\n     *\n     * Gets the list of [[Param]] objects owned by the state.\n     * If `opts.inherit` is true, it also includes the ancestor states' [[Param]] objects.\n     * If `opts.matchingKeys` exists, returns only `Param`s whose `id` is a key on the `matchingKeys` object\n     *\n     * @param opts options\n     */\n    StateObject.prototype.parameters = function (opts) {\n        opts = common_1.defaults(opts, { inherit: true, matchingKeys: null });\n        var inherited = opts.inherit && this.parent && this.parent.parameters() || [];\n        return inherited.concat(common_1.values(this.params))\n            .filter(function (param) { return !opts.matchingKeys || opts.matchingKeys.hasOwnProperty(param.id); });\n    };\n    /**\n     * Returns a single [[Param]] that is owned by the state\n     *\n     * If `opts.inherit` is true, it also searches the ancestor states` [[Param]]s.\n     * @param id the name of the [[Param]] to return\n     * @param opts options\n     */\n    StateObject.prototype.parameter = function (id, opts) {\n        if (opts === void 0) { opts = {}; }\n        return (this.url && this.url.parameter(id, opts) ||\n            common_1.find(common_1.values(this.params), hof_1.propEq('id', id)) ||\n            opts.inherit && this.parent && this.parent.parameter(id));\n    };\n    StateObject.prototype.toString = function () {\n        return this.fqn();\n    };\n    /** Predicate which returns true if the object is an class with @State() decorator */\n    StateObject.isStateClass = function (stateDecl) {\n        return predicates_1.isFunction(stateDecl) && stateDecl['__uiRouterState'] === true;\n    };\n    /** Predicate which returns true if the object is an internal [[StateObject]] object */\n    StateObject.isState = function (obj) {\n        return predicates_1.isObject(obj['__stateObjectCache']);\n    };\n    return StateObject;\n}());\nexports.StateObject = StateObject;\n//# sourceMappingURL=stateObject.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3N0YXRlL3N0YXRlT2JqZWN0LmpzP2U4YzciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcbnZhciBob2ZfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vaG9mXCIpO1xudmFyIGdsb2JfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vZ2xvYlwiKTtcbnZhciBwcmVkaWNhdGVzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3ByZWRpY2F0ZXNcIik7XG4vKipcbiAqIEludGVybmFsIHJlcHJlc2VudGF0aW9uIG9mIGEgVUktUm91dGVyIHN0YXRlLlxuICpcbiAqIEluc3RhbmNlcyBvZiB0aGlzIGNsYXNzIGFyZSBjcmVhdGVkIHdoZW4gYSBbW1N0YXRlRGVjbGFyYXRpb25dXSBpcyByZWdpc3RlcmVkIHdpdGggdGhlIFtbU3RhdGVSZWdpc3RyeV1dLlxuICpcbiAqIEEgcmVnaXN0ZXJlZCBbW1N0YXRlRGVjbGFyYXRpb25dXSBpcyBhdWdtZW50ZWQgd2l0aCBhIGdldHRlciAoW1tTdGF0ZURlY2xhcmF0aW9uLiQkc3RhdGVdXSkgd2hpY2ggcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBbW1N0YXRlT2JqZWN0XV0gb2JqZWN0LlxuICpcbiAqIFRoaXMgY2xhc3MgcHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gdGhlIGNvcnJlc3BvbmRpbmcgW1tTdGF0ZURlY2xhcmF0aW9uXV0uXG4gKiBFYWNoIG9mIGl0cyBvd24gcHJvcGVydGllcyAoaS5lLiwgYGhhc093blByb3BlcnR5YCkgYXJlIGJ1aWx0IHVzaW5nIGJ1aWxkZXJzIGZyb20gdGhlIFtbU3RhdGVCdWlsZGVyXV0uXG4gKi9cbnZhciBTdGF0ZU9iamVjdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKiogQGRlcHJlY2F0ZWQgdXNlIFN0YXRlLmNyZWF0ZSgpICovXG4gICAgZnVuY3Rpb24gU3RhdGVPYmplY3QoY29uZmlnKSB7XG4gICAgICAgIHJldHVybiBTdGF0ZU9iamVjdC5jcmVhdGUoY29uZmlnIHx8IHt9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgc3RhdGUgb2JqZWN0IHRvIHB1dCB0aGUgcHJpdmF0ZS9pbnRlcm5hbCBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzIG9udG8uXG4gICAgICogVGhlIG9iamVjdCdzIHByb3RvdHlwZSBjaGFpbiBsb29rcyBsaWtlOlxuICAgICAqIChJbnRlcm5hbCBTdGF0ZSBPYmplY3QpIC0+IChDb3B5IG9mIFN0YXRlLnByb3RvdHlwZSkgLT4gKFN0YXRlIERlY2xhcmF0aW9uIG9iamVjdCkgLT4gKFN0YXRlIERlY2xhcmF0aW9uJ3MgcHJvdG90eXBlLi4uKVxuICAgICAqXG4gICAgICogQHBhcmFtIHN0YXRlRGVjbCB0aGUgdXNlci1zdXBwbGllZCBTdGF0ZSBEZWNsYXJhdGlvblxuICAgICAqIEByZXR1cm5zIHtTdGF0ZU9iamVjdH0gYW4gaW50ZXJuYWwgU3RhdGUgb2JqZWN0XG4gICAgICovXG4gICAgU3RhdGVPYmplY3QuY3JlYXRlID0gZnVuY3Rpb24gKHN0YXRlRGVjbCkge1xuICAgICAgICBzdGF0ZURlY2wgPSBTdGF0ZU9iamVjdC5pc1N0YXRlQ2xhc3Moc3RhdGVEZWNsKSA/IG5ldyBzdGF0ZURlY2woKSA6IHN0YXRlRGVjbDtcbiAgICAgICAgdmFyIHN0YXRlID0gY29tbW9uXzEuaW5oZXJpdChjb21tb25fMS5pbmhlcml0KHN0YXRlRGVjbCwgU3RhdGVPYmplY3QucHJvdG90eXBlKSk7XG4gICAgICAgIHN0YXRlRGVjbC4kJHN0YXRlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RhdGU7IH07XG4gICAgICAgIHN0YXRlLnNlbGYgPSBzdGF0ZURlY2w7XG4gICAgICAgIHN0YXRlLl9fc3RhdGVPYmplY3RDYWNoZSA9IHtcbiAgICAgICAgICAgIG5hbWVHbG9iOiBnbG9iXzEuR2xvYi5mcm9tU3RyaW5nKHN0YXRlLm5hbWUpLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHByb3ZpZGVkIHBhcmFtZXRlciBpcyB0aGUgc2FtZSBzdGF0ZS5cbiAgICAgKlxuICAgICAqIENvbXBhcmVzIHRoZSBpZGVudGl0eSBvZiB0aGUgc3RhdGUgYWdhaW5zdCB0aGUgcGFzc2VkIHZhbHVlLCB3aGljaCBpcyBlaXRoZXIgYW4gb2JqZWN0XG4gICAgICogcmVmZXJlbmNlIHRvIHRoZSBhY3R1YWwgYFN0YXRlYCBpbnN0YW5jZSwgdGhlIG9yaWdpbmFsIGRlZmluaXRpb24gb2JqZWN0IHBhc3NlZCB0b1xuICAgICAqIGAkc3RhdGVQcm92aWRlci5zdGF0ZSgpYCwgb3IgdGhlIGZ1bGx5LXF1YWxpZmllZCBuYW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHJlZiBDYW4gYmUgb25lIG9mIChhKSBhIGBTdGF0ZWAgaW5zdGFuY2UsIChiKSBhbiBvYmplY3QgdGhhdCB3YXMgcGFzc2VkXG4gICAgICogICAgICAgIGludG8gYCRzdGF0ZVByb3ZpZGVyLnN0YXRlKClgLCAoYykgdGhlIGZ1bGx5LXF1YWxpZmllZCBuYW1lIG9mIGEgc3RhdGUgYXMgYSBzdHJpbmcuXG4gICAgICogQHJldHVybnMgUmV0dXJucyBgdHJ1ZWAgaWYgYHJlZmAgbWF0Y2hlcyB0aGUgY3VycmVudCBgU3RhdGVgIGluc3RhbmNlLlxuICAgICAqL1xuICAgIFN0YXRlT2JqZWN0LnByb3RvdHlwZS5pcyA9IGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMgPT09IHJlZiB8fCB0aGlzLnNlbGYgPT09IHJlZiB8fCB0aGlzLmZxbigpID09PSByZWY7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCB0aGlzIGRvZXMgbm90IHByb3Blcmx5IGhhbmRsZSBkb3Qgbm90YXRpb25cbiAgICAgKiBAcmV0dXJucyBSZXR1cm5zIGEgZG90LXNlcGFyYXRlZCBuYW1lIG9mIHRoZSBzdGF0ZS5cbiAgICAgKi9cbiAgICBTdGF0ZU9iamVjdC5wcm90b3R5cGUuZnFuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMucGFyZW50IHx8ICEodGhpcy5wYXJlbnQgaW5zdGFuY2VvZiB0aGlzLmNvbnN0cnVjdG9yKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5hbWU7XG4gICAgICAgIHZhciBuYW1lID0gdGhpcy5wYXJlbnQuZnFuKCk7XG4gICAgICAgIHJldHVybiBuYW1lID8gbmFtZSArICcuJyArIHRoaXMubmFtZSA6IHRoaXMubmFtZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHJvb3Qgbm9kZSBvZiB0aGlzIHN0YXRlJ3MgdHJlZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFRoZSByb290IG9mIHRoaXMgc3RhdGUncyB0cmVlLlxuICAgICAqL1xuICAgIFN0YXRlT2JqZWN0LnByb3RvdHlwZS5yb290ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQucm9vdCgpIHx8IHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzdGF0ZSdzIGBQYXJhbWAgb2JqZWN0c1xuICAgICAqXG4gICAgICogR2V0cyB0aGUgbGlzdCBvZiBbW1BhcmFtXV0gb2JqZWN0cyBvd25lZCBieSB0aGUgc3RhdGUuXG4gICAgICogSWYgYG9wdHMuaW5oZXJpdGAgaXMgdHJ1ZSwgaXQgYWxzbyBpbmNsdWRlcyB0aGUgYW5jZXN0b3Igc3RhdGVzJyBbW1BhcmFtXV0gb2JqZWN0cy5cbiAgICAgKiBJZiBgb3B0cy5tYXRjaGluZ0tleXNgIGV4aXN0cywgcmV0dXJucyBvbmx5IGBQYXJhbWBzIHdob3NlIGBpZGAgaXMgYSBrZXkgb24gdGhlIGBtYXRjaGluZ0tleXNgIG9iamVjdFxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdHMgb3B0aW9uc1xuICAgICAqL1xuICAgIFN0YXRlT2JqZWN0LnByb3RvdHlwZS5wYXJhbWV0ZXJzID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgICAgICAgb3B0cyA9IGNvbW1vbl8xLmRlZmF1bHRzKG9wdHMsIHsgaW5oZXJpdDogdHJ1ZSwgbWF0Y2hpbmdLZXlzOiBudWxsIH0pO1xuICAgICAgICB2YXIgaW5oZXJpdGVkID0gb3B0cy5pbmhlcml0ICYmIHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LnBhcmFtZXRlcnMoKSB8fCBbXTtcbiAgICAgICAgcmV0dXJuIGluaGVyaXRlZC5jb25jYXQoY29tbW9uXzEudmFsdWVzKHRoaXMucGFyYW1zKSlcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHBhcmFtKSB7IHJldHVybiAhb3B0cy5tYXRjaGluZ0tleXMgfHwgb3B0cy5tYXRjaGluZ0tleXMuaGFzT3duUHJvcGVydHkocGFyYW0uaWQpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzaW5nbGUgW1tQYXJhbV1dIHRoYXQgaXMgb3duZWQgYnkgdGhlIHN0YXRlXG4gICAgICpcbiAgICAgKiBJZiBgb3B0cy5pbmhlcml0YCBpcyB0cnVlLCBpdCBhbHNvIHNlYXJjaGVzIHRoZSBhbmNlc3RvciBzdGF0ZXNgIFtbUGFyYW1dXXMuXG4gICAgICogQHBhcmFtIGlkIHRoZSBuYW1lIG9mIHRoZSBbW1BhcmFtXV0gdG8gcmV0dXJuXG4gICAgICogQHBhcmFtIG9wdHMgb3B0aW9uc1xuICAgICAqL1xuICAgIFN0YXRlT2JqZWN0LnByb3RvdHlwZS5wYXJhbWV0ZXIgPSBmdW5jdGlvbiAoaWQsIG9wdHMpIHtcbiAgICAgICAgaWYgKG9wdHMgPT09IHZvaWQgMCkgeyBvcHRzID0ge307IH1cbiAgICAgICAgcmV0dXJuICh0aGlzLnVybCAmJiB0aGlzLnVybC5wYXJhbWV0ZXIoaWQsIG9wdHMpIHx8XG4gICAgICAgICAgICBjb21tb25fMS5maW5kKGNvbW1vbl8xLnZhbHVlcyh0aGlzLnBhcmFtcyksIGhvZl8xLnByb3BFcSgnaWQnLCBpZCkpIHx8XG4gICAgICAgICAgICBvcHRzLmluaGVyaXQgJiYgdGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQucGFyYW1ldGVyKGlkKSk7XG4gICAgfTtcbiAgICBTdGF0ZU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZxbigpO1xuICAgIH07XG4gICAgLyoqIFByZWRpY2F0ZSB3aGljaCByZXR1cm5zIHRydWUgaWYgdGhlIG9iamVjdCBpcyBhbiBjbGFzcyB3aXRoIEBTdGF0ZSgpIGRlY29yYXRvciAqL1xuICAgIFN0YXRlT2JqZWN0LmlzU3RhdGVDbGFzcyA9IGZ1bmN0aW9uIChzdGF0ZURlY2wpIHtcbiAgICAgICAgcmV0dXJuIHByZWRpY2F0ZXNfMS5pc0Z1bmN0aW9uKHN0YXRlRGVjbCkgJiYgc3RhdGVEZWNsWydfX3VpUm91dGVyU3RhdGUnXSA9PT0gdHJ1ZTtcbiAgICB9O1xuICAgIC8qKiBQcmVkaWNhdGUgd2hpY2ggcmV0dXJucyB0cnVlIGlmIHRoZSBvYmplY3QgaXMgYW4gaW50ZXJuYWwgW1tTdGF0ZU9iamVjdF1dIG9iamVjdCAqL1xuICAgIFN0YXRlT2JqZWN0LmlzU3RhdGUgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiBwcmVkaWNhdGVzXzEuaXNPYmplY3Qob2JqWydfX3N0YXRlT2JqZWN0Q2FjaGUnXSk7XG4gICAgfTtcbiAgICByZXR1cm4gU3RhdGVPYmplY3Q7XG59KCkpO1xuZXhwb3J0cy5TdGF0ZU9iamVjdCA9IFN0YXRlT2JqZWN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RhdGVPYmplY3QuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3N0YXRlL3N0YXRlT2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSA0MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///42\n")},function(module,exports,__webpack_require__){"use strict";eval('\n/**\n * @module common\n */ /** for typedoc */\nObject.defineProperty(exports, "__esModule", { value: true });\nvar Queue = /** @class */ (function () {\n    function Queue(_items, _limit) {\n        if (_items === void 0) { _items = []; }\n        if (_limit === void 0) { _limit = null; }\n        this._items = _items;\n        this._limit = _limit;\n    }\n    Queue.prototype.enqueue = function (item) {\n        var items = this._items;\n        items.push(item);\n        if (this._limit && items.length > this._limit)\n            items.shift();\n        return item;\n    };\n    Queue.prototype.dequeue = function () {\n        if (this.size())\n            return this._items.splice(0, 1)[0];\n    };\n    Queue.prototype.clear = function () {\n        var current = this._items;\n        this._items = [];\n        return current;\n    };\n    Queue.prototype.size = function () {\n        return this._items.length;\n    };\n    Queue.prototype.remove = function (item) {\n        var idx = this._items.indexOf(item);\n        return idx > -1 && this._items.splice(idx, 1)[0];\n    };\n    Queue.prototype.peekTail = function () {\n        return this._items[this._items.length - 1];\n    };\n    Queue.prototype.peekHead = function () {\n        if (this.size())\n            return this._items[0];\n    };\n    return Queue;\n}());\nexports.Queue = Queue;\n//# sourceMappingURL=queue.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2NvbW1vbi9xdWV1ZS5qcz9iNTY0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAbW9kdWxlIGNvbW1vblxuICovIC8qKiBmb3IgdHlwZWRvYyAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFF1ZXVlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFF1ZXVlKF9pdGVtcywgX2xpbWl0KSB7XG4gICAgICAgIGlmIChfaXRlbXMgPT09IHZvaWQgMCkgeyBfaXRlbXMgPSBbXTsgfVxuICAgICAgICBpZiAoX2xpbWl0ID09PSB2b2lkIDApIHsgX2xpbWl0ID0gbnVsbDsgfVxuICAgICAgICB0aGlzLl9pdGVtcyA9IF9pdGVtcztcbiAgICAgICAgdGhpcy5fbGltaXQgPSBfbGltaXQ7XG4gICAgfVxuICAgIFF1ZXVlLnByb3RvdHlwZS5lbnF1ZXVlID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgdmFyIGl0ZW1zID0gdGhpcy5faXRlbXM7XG4gICAgICAgIGl0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgIGlmICh0aGlzLl9saW1pdCAmJiBpdGVtcy5sZW5ndGggPiB0aGlzLl9saW1pdClcbiAgICAgICAgICAgIGl0ZW1zLnNoaWZ0KCk7XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH07XG4gICAgUXVldWUucHJvdG90eXBlLmRlcXVldWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnNpemUoKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pdGVtcy5zcGxpY2UoMCwgMSlbMF07XG4gICAgfTtcbiAgICBRdWV1ZS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5faXRlbXM7XG4gICAgICAgIHRoaXMuX2l0ZW1zID0gW107XG4gICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgIH07XG4gICAgUXVldWUucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pdGVtcy5sZW5ndGg7XG4gICAgfTtcbiAgICBRdWV1ZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgdmFyIGlkeCA9IHRoaXMuX2l0ZW1zLmluZGV4T2YoaXRlbSk7XG4gICAgICAgIHJldHVybiBpZHggPiAtMSAmJiB0aGlzLl9pdGVtcy5zcGxpY2UoaWR4LCAxKVswXTtcbiAgICB9O1xuICAgIFF1ZXVlLnByb3RvdHlwZS5wZWVrVGFpbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2l0ZW1zW3RoaXMuX2l0ZW1zLmxlbmd0aCAtIDFdO1xuICAgIH07XG4gICAgUXVldWUucHJvdG90eXBlLnBlZWtIZWFkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zaXplKCkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faXRlbXNbMF07XG4gICAgfTtcbiAgICByZXR1cm4gUXVldWU7XG59KCkpO1xuZXhwb3J0cy5RdWV1ZSA9IFF1ZXVlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cXVldWUuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2NvbW1vbi9xdWV1ZS5qc1xuLy8gbW9kdWxlIGlkID0gNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///43\n')},function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\n/**\n * @coreapi\n * @module transition\n */ /** for typedoc */\nvar common_1 = __webpack_require__(0);\nvar predicates_1 = __webpack_require__(1);\nvar interface_1 = __webpack_require__(16); // has or is using\nvar glob_1 = __webpack_require__(28);\n/**\n * Determines if the given state matches the matchCriteria\n *\n * @hidden\n *\n * @param state a State Object to test against\n * @param criterion\n * - If a string, matchState uses the string as a glob-matcher against the state name\n * - If an array (of strings), matchState uses each string in the array as a glob-matchers against the state name\n *   and returns a positive match if any of the globs match.\n * - If a function, matchState calls the function with the state and returns true if the function\'s result is truthy.\n * @returns {boolean}\n */\nfunction matchState(state, criterion) {\n    var toMatch = predicates_1.isString(criterion) ? [criterion] : criterion;\n    function matchGlobs(_state) {\n        var globStrings = toMatch;\n        for (var i = 0; i < globStrings.length; i++) {\n            var glob = new glob_1.Glob(globStrings[i]);\n            if ((glob && glob.matches(_state.name)) || (!glob && globStrings[i] === _state.name)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    var matchFn = (predicates_1.isFunction(toMatch) ? toMatch : matchGlobs);\n    return !!matchFn(state);\n}\nexports.matchState = matchState;\n/**\n * @internalapi\n * The registration data for a registered transition hook\n */\nvar RegisteredHook = /** @class */ (function () {\n    function RegisteredHook(tranSvc, eventType, callback, matchCriteria, removeHookFromRegistry, options) {\n        if (options === void 0) { options = {}; }\n        this.tranSvc = tranSvc;\n        this.eventType = eventType;\n        this.callback = callback;\n        this.matchCriteria = matchCriteria;\n        this.removeHookFromRegistry = removeHookFromRegistry;\n        this.invokeCount = 0;\n        this._deregistered = false;\n        this.priority = options.priority || 0;\n        this.bind = options.bind || null;\n        this.invokeLimit = options.invokeLimit;\n    }\n    /**\n     * Gets the matching [[PathNode]]s\n     *\n     * Given an array of [[PathNode]]s, and a [[HookMatchCriterion]], returns an array containing\n     * the [[PathNode]]s that the criteria matches, or `null` if there were no matching nodes.\n     *\n     * Returning `null` is significant to distinguish between the default\n     * "match-all criterion value" of `true` compared to a `() => true` function,\n     * when the nodes is an empty array.\n     *\n     * This is useful to allow a transition match criteria of `entering: true`\n     * to still match a transition, even when `entering === []`.  Contrast that\n     * with `entering: (state) => true` which only matches when a state is actually\n     * being entered.\n     */\n    RegisteredHook.prototype._matchingNodes = function (nodes, criterion) {\n        if (criterion === true)\n            return nodes;\n        var matching = nodes.filter(function (node) { return matchState(node.state, criterion); });\n        return matching.length ? matching : null;\n    };\n    /**\n     * Gets the default match criteria (all `true`)\n     *\n     * Returns an object which has all the criteria match paths as keys and `true` as values, i.e.:\n     *\n     * ```js\n     * {\n     *   to: true,\n     *   from: true,\n     *   entering: true,\n     *   exiting: true,\n     *   retained: true,\n     * }\n     */\n    RegisteredHook.prototype._getDefaultMatchCriteria = function () {\n        return common_1.map(this.tranSvc._pluginapi._getPathTypes(), function () { return true; });\n    };\n    /**\n     * Gets matching nodes as [[IMatchingNodes]]\n     *\n     * Create a IMatchingNodes object from the TransitionHookTypes that is roughly equivalent to:\n     *\n     * ```js\n     * let matches: IMatchingNodes = {\n     *   to:       _matchingNodes([tail(treeChanges.to)],   mc.to),\n     *   from:     _matchingNodes([tail(treeChanges.from)], mc.from),\n     *   exiting:  _matchingNodes(treeChanges.exiting,      mc.exiting),\n     *   retained: _matchingNodes(treeChanges.retained,     mc.retained),\n     *   entering: _matchingNodes(treeChanges.entering,     mc.entering),\n     * };\n     * ```\n     */\n    RegisteredHook.prototype._getMatchingNodes = function (treeChanges) {\n        var _this = this;\n        var criteria = common_1.extend(this._getDefaultMatchCriteria(), this.matchCriteria);\n        var paths = common_1.values(this.tranSvc._pluginapi._getPathTypes());\n        return paths.reduce(function (mn, pathtype) {\n            // STATE scope criteria matches against every node in the path.\n            // TRANSITION scope criteria matches against only the last node in the path\n            var isStateHook = pathtype.scope === interface_1.TransitionHookScope.STATE;\n            var path = treeChanges[pathtype.name] || [];\n            var nodes = isStateHook ? path : [common_1.tail(path)];\n            mn[pathtype.name] = _this._matchingNodes(nodes, criteria[pathtype.name]);\n            return mn;\n        }, {});\n    };\n    /**\n     * Determines if this hook\'s [[matchCriteria]] match the given [[TreeChanges]]\n     *\n     * @returns an IMatchingNodes object, or null. If an IMatchingNodes object is returned, its values\n     * are the matching [[PathNode]]s for each [[HookMatchCriterion]] (to, from, exiting, retained, entering)\n     */\n    RegisteredHook.prototype.matches = function (treeChanges) {\n        var matches = this._getMatchingNodes(treeChanges);\n        // Check if all the criteria matched the TreeChanges object\n        var allMatched = common_1.values(matches).every(common_1.identity);\n        return allMatched ? matches : null;\n    };\n    RegisteredHook.prototype.deregister = function () {\n        this.removeHookFromRegistry(this);\n        this._deregistered = true;\n    };\n    return RegisteredHook;\n}());\nexports.RegisteredHook = RegisteredHook;\n/** @hidden Return a registration function of the requested type. */\nfunction makeEvent(registry, transitionService, eventType) {\n    // Create the object which holds the registered transition hooks.\n    var _registeredHooks = registry._registeredHooks = (registry._registeredHooks || {});\n    var hooks = _registeredHooks[eventType.name] = [];\n    var removeHookFn = common_1.removeFrom(hooks);\n    // Create hook registration function on the IHookRegistry for the event\n    registry[eventType.name] = hookRegistrationFn;\n    function hookRegistrationFn(matchObject, callback, options) {\n        if (options === void 0) { options = {}; }\n        var registeredHook = new RegisteredHook(transitionService, eventType, callback, matchObject, removeHookFn, options);\n        hooks.push(registeredHook);\n        return registeredHook.deregister.bind(registeredHook);\n    }\n    return hookRegistrationFn;\n}\nexports.makeEvent = makeEvent;\n//# sourceMappingURL=hookRegistry.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3RyYW5zaXRpb24vaG9va1JlZ2lzdHJ5LmpzP2U5ZDUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEBjb3JlYXBpXG4gKiBAbW9kdWxlIHRyYW5zaXRpb25cbiAqLyAvKiogZm9yIHR5cGVkb2MgKi9cbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29tbW9uXCIpO1xudmFyIHByZWRpY2F0ZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vcHJlZGljYXRlc1wiKTtcbnZhciBpbnRlcmZhY2VfMSA9IHJlcXVpcmUoXCIuL2ludGVyZmFjZVwiKTsgLy8gaGFzIG9yIGlzIHVzaW5nXG52YXIgZ2xvYl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9nbG9iXCIpO1xuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBnaXZlbiBzdGF0ZSBtYXRjaGVzIHRoZSBtYXRjaENyaXRlcmlhXG4gKlxuICogQGhpZGRlblxuICpcbiAqIEBwYXJhbSBzdGF0ZSBhIFN0YXRlIE9iamVjdCB0byB0ZXN0IGFnYWluc3RcbiAqIEBwYXJhbSBjcml0ZXJpb25cbiAqIC0gSWYgYSBzdHJpbmcsIG1hdGNoU3RhdGUgdXNlcyB0aGUgc3RyaW5nIGFzIGEgZ2xvYi1tYXRjaGVyIGFnYWluc3QgdGhlIHN0YXRlIG5hbWVcbiAqIC0gSWYgYW4gYXJyYXkgKG9mIHN0cmluZ3MpLCBtYXRjaFN0YXRlIHVzZXMgZWFjaCBzdHJpbmcgaW4gdGhlIGFycmF5IGFzIGEgZ2xvYi1tYXRjaGVycyBhZ2FpbnN0IHRoZSBzdGF0ZSBuYW1lXG4gKiAgIGFuZCByZXR1cm5zIGEgcG9zaXRpdmUgbWF0Y2ggaWYgYW55IG9mIHRoZSBnbG9icyBtYXRjaC5cbiAqIC0gSWYgYSBmdW5jdGlvbiwgbWF0Y2hTdGF0ZSBjYWxscyB0aGUgZnVuY3Rpb24gd2l0aCB0aGUgc3RhdGUgYW5kIHJldHVybnMgdHJ1ZSBpZiB0aGUgZnVuY3Rpb24ncyByZXN1bHQgaXMgdHJ1dGh5LlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIG1hdGNoU3RhdGUoc3RhdGUsIGNyaXRlcmlvbikge1xuICAgIHZhciB0b01hdGNoID0gcHJlZGljYXRlc18xLmlzU3RyaW5nKGNyaXRlcmlvbikgPyBbY3JpdGVyaW9uXSA6IGNyaXRlcmlvbjtcbiAgICBmdW5jdGlvbiBtYXRjaEdsb2JzKF9zdGF0ZSkge1xuICAgICAgICB2YXIgZ2xvYlN0cmluZ3MgPSB0b01hdGNoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdsb2JTdHJpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZ2xvYiA9IG5ldyBnbG9iXzEuR2xvYihnbG9iU3RyaW5nc1tpXSk7XG4gICAgICAgICAgICBpZiAoKGdsb2IgJiYgZ2xvYi5tYXRjaGVzKF9zdGF0ZS5uYW1lKSkgfHwgKCFnbG9iICYmIGdsb2JTdHJpbmdzW2ldID09PSBfc3RhdGUubmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBtYXRjaEZuID0gKHByZWRpY2F0ZXNfMS5pc0Z1bmN0aW9uKHRvTWF0Y2gpID8gdG9NYXRjaCA6IG1hdGNoR2xvYnMpO1xuICAgIHJldHVybiAhIW1hdGNoRm4oc3RhdGUpO1xufVxuZXhwb3J0cy5tYXRjaFN0YXRlID0gbWF0Y2hTdGF0ZTtcbi8qKlxuICogQGludGVybmFsYXBpXG4gKiBUaGUgcmVnaXN0cmF0aW9uIGRhdGEgZm9yIGEgcmVnaXN0ZXJlZCB0cmFuc2l0aW9uIGhvb2tcbiAqL1xudmFyIFJlZ2lzdGVyZWRIb29rID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlZ2lzdGVyZWRIb29rKHRyYW5TdmMsIGV2ZW50VHlwZSwgY2FsbGJhY2ssIG1hdGNoQ3JpdGVyaWEsIHJlbW92ZUhvb2tGcm9tUmVnaXN0cnksIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgdGhpcy50cmFuU3ZjID0gdHJhblN2YztcbiAgICAgICAgdGhpcy5ldmVudFR5cGUgPSBldmVudFR5cGU7XG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgICAgdGhpcy5tYXRjaENyaXRlcmlhID0gbWF0Y2hDcml0ZXJpYTtcbiAgICAgICAgdGhpcy5yZW1vdmVIb29rRnJvbVJlZ2lzdHJ5ID0gcmVtb3ZlSG9va0Zyb21SZWdpc3RyeTtcbiAgICAgICAgdGhpcy5pbnZva2VDb3VudCA9IDA7XG4gICAgICAgIHRoaXMuX2RlcmVnaXN0ZXJlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnByaW9yaXR5ID0gb3B0aW9ucy5wcmlvcml0eSB8fCAwO1xuICAgICAgICB0aGlzLmJpbmQgPSBvcHRpb25zLmJpbmQgfHwgbnVsbDtcbiAgICAgICAgdGhpcy5pbnZva2VMaW1pdCA9IG9wdGlvbnMuaW52b2tlTGltaXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG1hdGNoaW5nIFtbUGF0aE5vZGVdXXNcbiAgICAgKlxuICAgICAqIEdpdmVuIGFuIGFycmF5IG9mIFtbUGF0aE5vZGVdXXMsIGFuZCBhIFtbSG9va01hdGNoQ3JpdGVyaW9uXV0sIHJldHVybnMgYW4gYXJyYXkgY29udGFpbmluZ1xuICAgICAqIHRoZSBbW1BhdGhOb2RlXV1zIHRoYXQgdGhlIGNyaXRlcmlhIG1hdGNoZXMsIG9yIGBudWxsYCBpZiB0aGVyZSB3ZXJlIG5vIG1hdGNoaW5nIG5vZGVzLlxuICAgICAqXG4gICAgICogUmV0dXJuaW5nIGBudWxsYCBpcyBzaWduaWZpY2FudCB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIHRoZSBkZWZhdWx0XG4gICAgICogXCJtYXRjaC1hbGwgY3JpdGVyaW9uIHZhbHVlXCIgb2YgYHRydWVgIGNvbXBhcmVkIHRvIGEgYCgpID0+IHRydWVgIGZ1bmN0aW9uLFxuICAgICAqIHdoZW4gdGhlIG5vZGVzIGlzIGFuIGVtcHR5IGFycmF5LlxuICAgICAqXG4gICAgICogVGhpcyBpcyB1c2VmdWwgdG8gYWxsb3cgYSB0cmFuc2l0aW9uIG1hdGNoIGNyaXRlcmlhIG9mIGBlbnRlcmluZzogdHJ1ZWBcbiAgICAgKiB0byBzdGlsbCBtYXRjaCBhIHRyYW5zaXRpb24sIGV2ZW4gd2hlbiBgZW50ZXJpbmcgPT09IFtdYC4gIENvbnRyYXN0IHRoYXRcbiAgICAgKiB3aXRoIGBlbnRlcmluZzogKHN0YXRlKSA9PiB0cnVlYCB3aGljaCBvbmx5IG1hdGNoZXMgd2hlbiBhIHN0YXRlIGlzIGFjdHVhbGx5XG4gICAgICogYmVpbmcgZW50ZXJlZC5cbiAgICAgKi9cbiAgICBSZWdpc3RlcmVkSG9vay5wcm90b3R5cGUuX21hdGNoaW5nTm9kZXMgPSBmdW5jdGlvbiAobm9kZXMsIGNyaXRlcmlvbikge1xuICAgICAgICBpZiAoY3JpdGVyaW9uID09PSB0cnVlKVxuICAgICAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgICAgICB2YXIgbWF0Y2hpbmcgPSBub2Rlcy5maWx0ZXIoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG1hdGNoU3RhdGUobm9kZS5zdGF0ZSwgY3JpdGVyaW9uKTsgfSk7XG4gICAgICAgIHJldHVybiBtYXRjaGluZy5sZW5ndGggPyBtYXRjaGluZyA6IG51bGw7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBkZWZhdWx0IG1hdGNoIGNyaXRlcmlhIChhbGwgYHRydWVgKVxuICAgICAqXG4gICAgICogUmV0dXJucyBhbiBvYmplY3Qgd2hpY2ggaGFzIGFsbCB0aGUgY3JpdGVyaWEgbWF0Y2ggcGF0aHMgYXMga2V5cyBhbmQgYHRydWVgIGFzIHZhbHVlcywgaS5lLjpcbiAgICAgKlxuICAgICAqIGBgYGpzXG4gICAgICoge1xuICAgICAqICAgdG86IHRydWUsXG4gICAgICogICBmcm9tOiB0cnVlLFxuICAgICAqICAgZW50ZXJpbmc6IHRydWUsXG4gICAgICogICBleGl0aW5nOiB0cnVlLFxuICAgICAqICAgcmV0YWluZWQ6IHRydWUsXG4gICAgICogfVxuICAgICAqL1xuICAgIFJlZ2lzdGVyZWRIb29rLnByb3RvdHlwZS5fZ2V0RGVmYXVsdE1hdGNoQ3JpdGVyaWEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjb21tb25fMS5tYXAodGhpcy50cmFuU3ZjLl9wbHVnaW5hcGkuX2dldFBhdGhUeXBlcygpLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldHMgbWF0Y2hpbmcgbm9kZXMgYXMgW1tJTWF0Y2hpbmdOb2Rlc11dXG4gICAgICpcbiAgICAgKiBDcmVhdGUgYSBJTWF0Y2hpbmdOb2RlcyBvYmplY3QgZnJvbSB0aGUgVHJhbnNpdGlvbkhvb2tUeXBlcyB0aGF0IGlzIHJvdWdobHkgZXF1aXZhbGVudCB0bzpcbiAgICAgKlxuICAgICAqIGBgYGpzXG4gICAgICogbGV0IG1hdGNoZXM6IElNYXRjaGluZ05vZGVzID0ge1xuICAgICAqICAgdG86ICAgICAgIF9tYXRjaGluZ05vZGVzKFt0YWlsKHRyZWVDaGFuZ2VzLnRvKV0sICAgbWMudG8pLFxuICAgICAqICAgZnJvbTogICAgIF9tYXRjaGluZ05vZGVzKFt0YWlsKHRyZWVDaGFuZ2VzLmZyb20pXSwgbWMuZnJvbSksXG4gICAgICogICBleGl0aW5nOiAgX21hdGNoaW5nTm9kZXModHJlZUNoYW5nZXMuZXhpdGluZywgICAgICBtYy5leGl0aW5nKSxcbiAgICAgKiAgIHJldGFpbmVkOiBfbWF0Y2hpbmdOb2Rlcyh0cmVlQ2hhbmdlcy5yZXRhaW5lZCwgICAgIG1jLnJldGFpbmVkKSxcbiAgICAgKiAgIGVudGVyaW5nOiBfbWF0Y2hpbmdOb2Rlcyh0cmVlQ2hhbmdlcy5lbnRlcmluZywgICAgIG1jLmVudGVyaW5nKSxcbiAgICAgKiB9O1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIFJlZ2lzdGVyZWRIb29rLnByb3RvdHlwZS5fZ2V0TWF0Y2hpbmdOb2RlcyA9IGZ1bmN0aW9uICh0cmVlQ2hhbmdlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgY3JpdGVyaWEgPSBjb21tb25fMS5leHRlbmQodGhpcy5fZ2V0RGVmYXVsdE1hdGNoQ3JpdGVyaWEoKSwgdGhpcy5tYXRjaENyaXRlcmlhKTtcbiAgICAgICAgdmFyIHBhdGhzID0gY29tbW9uXzEudmFsdWVzKHRoaXMudHJhblN2Yy5fcGx1Z2luYXBpLl9nZXRQYXRoVHlwZXMoKSk7XG4gICAgICAgIHJldHVybiBwYXRocy5yZWR1Y2UoZnVuY3Rpb24gKG1uLCBwYXRodHlwZSkge1xuICAgICAgICAgICAgLy8gU1RBVEUgc2NvcGUgY3JpdGVyaWEgbWF0Y2hlcyBhZ2FpbnN0IGV2ZXJ5IG5vZGUgaW4gdGhlIHBhdGguXG4gICAgICAgICAgICAvLyBUUkFOU0lUSU9OIHNjb3BlIGNyaXRlcmlhIG1hdGNoZXMgYWdhaW5zdCBvbmx5IHRoZSBsYXN0IG5vZGUgaW4gdGhlIHBhdGhcbiAgICAgICAgICAgIHZhciBpc1N0YXRlSG9vayA9IHBhdGh0eXBlLnNjb3BlID09PSBpbnRlcmZhY2VfMS5UcmFuc2l0aW9uSG9va1Njb3BlLlNUQVRFO1xuICAgICAgICAgICAgdmFyIHBhdGggPSB0cmVlQ2hhbmdlc1twYXRodHlwZS5uYW1lXSB8fCBbXTtcbiAgICAgICAgICAgIHZhciBub2RlcyA9IGlzU3RhdGVIb29rID8gcGF0aCA6IFtjb21tb25fMS50YWlsKHBhdGgpXTtcbiAgICAgICAgICAgIG1uW3BhdGh0eXBlLm5hbWVdID0gX3RoaXMuX21hdGNoaW5nTm9kZXMobm9kZXMsIGNyaXRlcmlhW3BhdGh0eXBlLm5hbWVdKTtcbiAgICAgICAgICAgIHJldHVybiBtbjtcbiAgICAgICAgfSwge30pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiB0aGlzIGhvb2sncyBbW21hdGNoQ3JpdGVyaWFdXSBtYXRjaCB0aGUgZ2l2ZW4gW1tUcmVlQ2hhbmdlc11dXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBhbiBJTWF0Y2hpbmdOb2RlcyBvYmplY3QsIG9yIG51bGwuIElmIGFuIElNYXRjaGluZ05vZGVzIG9iamVjdCBpcyByZXR1cm5lZCwgaXRzIHZhbHVlc1xuICAgICAqIGFyZSB0aGUgbWF0Y2hpbmcgW1tQYXRoTm9kZV1dcyBmb3IgZWFjaCBbW0hvb2tNYXRjaENyaXRlcmlvbl1dICh0bywgZnJvbSwgZXhpdGluZywgcmV0YWluZWQsIGVudGVyaW5nKVxuICAgICAqL1xuICAgIFJlZ2lzdGVyZWRIb29rLnByb3RvdHlwZS5tYXRjaGVzID0gZnVuY3Rpb24gKHRyZWVDaGFuZ2VzKSB7XG4gICAgICAgIHZhciBtYXRjaGVzID0gdGhpcy5fZ2V0TWF0Y2hpbmdOb2Rlcyh0cmVlQ2hhbmdlcyk7XG4gICAgICAgIC8vIENoZWNrIGlmIGFsbCB0aGUgY3JpdGVyaWEgbWF0Y2hlZCB0aGUgVHJlZUNoYW5nZXMgb2JqZWN0XG4gICAgICAgIHZhciBhbGxNYXRjaGVkID0gY29tbW9uXzEudmFsdWVzKG1hdGNoZXMpLmV2ZXJ5KGNvbW1vbl8xLmlkZW50aXR5KTtcbiAgICAgICAgcmV0dXJuIGFsbE1hdGNoZWQgPyBtYXRjaGVzIDogbnVsbDtcbiAgICB9O1xuICAgIFJlZ2lzdGVyZWRIb29rLnByb3RvdHlwZS5kZXJlZ2lzdGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJlbW92ZUhvb2tGcm9tUmVnaXN0cnkodGhpcyk7XG4gICAgICAgIHRoaXMuX2RlcmVnaXN0ZXJlZCA9IHRydWU7XG4gICAgfTtcbiAgICByZXR1cm4gUmVnaXN0ZXJlZEhvb2s7XG59KCkpO1xuZXhwb3J0cy5SZWdpc3RlcmVkSG9vayA9IFJlZ2lzdGVyZWRIb29rO1xuLyoqIEBoaWRkZW4gUmV0dXJuIGEgcmVnaXN0cmF0aW9uIGZ1bmN0aW9uIG9mIHRoZSByZXF1ZXN0ZWQgdHlwZS4gKi9cbmZ1bmN0aW9uIG1ha2VFdmVudChyZWdpc3RyeSwgdHJhbnNpdGlvblNlcnZpY2UsIGV2ZW50VHlwZSkge1xuICAgIC8vIENyZWF0ZSB0aGUgb2JqZWN0IHdoaWNoIGhvbGRzIHRoZSByZWdpc3RlcmVkIHRyYW5zaXRpb24gaG9va3MuXG4gICAgdmFyIF9yZWdpc3RlcmVkSG9va3MgPSByZWdpc3RyeS5fcmVnaXN0ZXJlZEhvb2tzID0gKHJlZ2lzdHJ5Ll9yZWdpc3RlcmVkSG9va3MgfHwge30pO1xuICAgIHZhciBob29rcyA9IF9yZWdpc3RlcmVkSG9va3NbZXZlbnRUeXBlLm5hbWVdID0gW107XG4gICAgdmFyIHJlbW92ZUhvb2tGbiA9IGNvbW1vbl8xLnJlbW92ZUZyb20oaG9va3MpO1xuICAgIC8vIENyZWF0ZSBob29rIHJlZ2lzdHJhdGlvbiBmdW5jdGlvbiBvbiB0aGUgSUhvb2tSZWdpc3RyeSBmb3IgdGhlIGV2ZW50XG4gICAgcmVnaXN0cnlbZXZlbnRUeXBlLm5hbWVdID0gaG9va1JlZ2lzdHJhdGlvbkZuO1xuICAgIGZ1bmN0aW9uIGhvb2tSZWdpc3RyYXRpb25GbihtYXRjaE9iamVjdCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgdmFyIHJlZ2lzdGVyZWRIb29rID0gbmV3IFJlZ2lzdGVyZWRIb29rKHRyYW5zaXRpb25TZXJ2aWNlLCBldmVudFR5cGUsIGNhbGxiYWNrLCBtYXRjaE9iamVjdCwgcmVtb3ZlSG9va0ZuLCBvcHRpb25zKTtcbiAgICAgICAgaG9va3MucHVzaChyZWdpc3RlcmVkSG9vayk7XG4gICAgICAgIHJldHVybiByZWdpc3RlcmVkSG9vay5kZXJlZ2lzdGVyLmJpbmQocmVnaXN0ZXJlZEhvb2spO1xuICAgIH1cbiAgICByZXR1cm4gaG9va1JlZ2lzdHJhdGlvbkZuO1xufVxuZXhwb3J0cy5tYWtlRXZlbnQgPSBtYWtlRXZlbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ob29rUmVnaXN0cnkuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3RyYW5zaXRpb24vaG9va1JlZ2lzdHJ5LmpzXG4vLyBtb2R1bGUgaWQgPSA0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///44\n')},function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @module path */ /** for typedoc */\nvar common_1 = __webpack_require__(0);\nvar hof_1 = __webpack_require__(2);\nvar param_1 = __webpack_require__(18);\n/**\n * @internalapi\n *\n * A node in a [[TreeChanges]] path\n *\n * For a [[TreeChanges]] path, this class holds the stateful information for a single node in the path.\n * Each PathNode corresponds to a state being entered, exited, or retained.\n * The stateful information includes parameter values and resolve data.\n */\nvar PathNode = /** @class */ (function () {\n    function PathNode(stateOrNode) {\n        if (stateOrNode instanceof PathNode) {\n            var node = stateOrNode;\n            this.state = node.state;\n            this.paramSchema = node.paramSchema.slice();\n            this.paramValues = common_1.extend({}, node.paramValues);\n            this.resolvables = node.resolvables.slice();\n            this.views = node.views && node.views.slice();\n        }\n        else {\n            var state = stateOrNode;\n            this.state = state;\n            this.paramSchema = state.parameters({ inherit: false });\n            this.paramValues = {};\n            this.resolvables = state.resolvables.map(function (res) { return res.clone(); });\n        }\n    }\n    /** Returns a clone of the PathNode */\n    PathNode.clone = function (node) {\n        return new PathNode(node);\n    };\n    /** Sets [[paramValues]] for the node, from the values of an object hash */\n    PathNode.prototype.applyRawParams = function (params) {\n        var getParamVal = function (paramDef) { return [paramDef.id, paramDef.value(params[paramDef.id])]; };\n        this.paramValues = this.paramSchema.reduce(function (memo, pDef) { return common_1.applyPairs(memo, getParamVal(pDef)); }, {});\n        return this;\n    };\n    /** Gets a specific [[Param]] metadata that belongs to the node */\n    PathNode.prototype.parameter = function (name) {\n        return common_1.find(this.paramSchema, hof_1.propEq('id', name));\n    };\n    /**\n     * @returns true if the state and parameter values for another PathNode are\n     * equal to the state and param values for this PathNode\n     */\n    PathNode.prototype.equals = function (node, paramsFn) {\n        var diff = this.diff(node, paramsFn);\n        return diff && diff.length === 0;\n    };\n    /**\n     * Finds Params with different parameter values on another PathNode.\n     *\n     * Given another node (of the same state), finds the parameter values which differ.\n     * Returns the [[Param]] (schema objects) whose parameter values differ.\n     *\n     * Given another node for a different state, returns `false`\n     *\n     * @param node The node to compare to\n     * @param paramsFn A function that returns which parameters should be compared.\n     * @returns The [[Param]]s which differ, or null if the two nodes are for different states\n     */\n    PathNode.prototype.diff = function (node, paramsFn) {\n        if (this.state !== node.state)\n            return false;\n        var params = paramsFn ? paramsFn(this) : this.paramSchema;\n        return param_1.Param.changed(params, this.paramValues, node.paramValues);\n    };\n    return PathNode;\n}());\nexports.PathNode = PathNode;\n//# sourceMappingURL=pathNode.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3BhdGgvcGF0aE5vZGUuanM/ZTZiNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKiBAbW9kdWxlIHBhdGggKi8gLyoqIGZvciB0eXBlZG9jICovXG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcbnZhciBob2ZfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vaG9mXCIpO1xudmFyIHBhcmFtXzEgPSByZXF1aXJlKFwiLi4vcGFyYW1zL3BhcmFtXCIpO1xuLyoqXG4gKiBAaW50ZXJuYWxhcGlcbiAqXG4gKiBBIG5vZGUgaW4gYSBbW1RyZWVDaGFuZ2VzXV0gcGF0aFxuICpcbiAqIEZvciBhIFtbVHJlZUNoYW5nZXNdXSBwYXRoLCB0aGlzIGNsYXNzIGhvbGRzIHRoZSBzdGF0ZWZ1bCBpbmZvcm1hdGlvbiBmb3IgYSBzaW5nbGUgbm9kZSBpbiB0aGUgcGF0aC5cbiAqIEVhY2ggUGF0aE5vZGUgY29ycmVzcG9uZHMgdG8gYSBzdGF0ZSBiZWluZyBlbnRlcmVkLCBleGl0ZWQsIG9yIHJldGFpbmVkLlxuICogVGhlIHN0YXRlZnVsIGluZm9ybWF0aW9uIGluY2x1ZGVzIHBhcmFtZXRlciB2YWx1ZXMgYW5kIHJlc29sdmUgZGF0YS5cbiAqL1xudmFyIFBhdGhOb2RlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBhdGhOb2RlKHN0YXRlT3JOb2RlKSB7XG4gICAgICAgIGlmIChzdGF0ZU9yTm9kZSBpbnN0YW5jZW9mIFBhdGhOb2RlKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHN0YXRlT3JOb2RlO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IG5vZGUuc3RhdGU7XG4gICAgICAgICAgICB0aGlzLnBhcmFtU2NoZW1hID0gbm9kZS5wYXJhbVNjaGVtYS5zbGljZSgpO1xuICAgICAgICAgICAgdGhpcy5wYXJhbVZhbHVlcyA9IGNvbW1vbl8xLmV4dGVuZCh7fSwgbm9kZS5wYXJhbVZhbHVlcyk7XG4gICAgICAgICAgICB0aGlzLnJlc29sdmFibGVzID0gbm9kZS5yZXNvbHZhYmxlcy5zbGljZSgpO1xuICAgICAgICAgICAgdGhpcy52aWV3cyA9IG5vZGUudmlld3MgJiYgbm9kZS52aWV3cy5zbGljZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHN0YXRlID0gc3RhdGVPck5vZGU7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgICAgICB0aGlzLnBhcmFtU2NoZW1hID0gc3RhdGUucGFyYW1ldGVycyh7IGluaGVyaXQ6IGZhbHNlIH0pO1xuICAgICAgICAgICAgdGhpcy5wYXJhbVZhbHVlcyA9IHt9O1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZhYmxlcyA9IHN0YXRlLnJlc29sdmFibGVzLm1hcChmdW5jdGlvbiAocmVzKSB7IHJldHVybiByZXMuY2xvbmUoKTsgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIFJldHVybnMgYSBjbG9uZSBvZiB0aGUgUGF0aE5vZGUgKi9cbiAgICBQYXRoTm9kZS5jbG9uZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGF0aE5vZGUobm9kZSk7XG4gICAgfTtcbiAgICAvKiogU2V0cyBbW3BhcmFtVmFsdWVzXV0gZm9yIHRoZSBub2RlLCBmcm9tIHRoZSB2YWx1ZXMgb2YgYW4gb2JqZWN0IGhhc2ggKi9cbiAgICBQYXRoTm9kZS5wcm90b3R5cGUuYXBwbHlSYXdQYXJhbXMgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHZhciBnZXRQYXJhbVZhbCA9IGZ1bmN0aW9uIChwYXJhbURlZikgeyByZXR1cm4gW3BhcmFtRGVmLmlkLCBwYXJhbURlZi52YWx1ZShwYXJhbXNbcGFyYW1EZWYuaWRdKV07IH07XG4gICAgICAgIHRoaXMucGFyYW1WYWx1ZXMgPSB0aGlzLnBhcmFtU2NoZW1hLnJlZHVjZShmdW5jdGlvbiAobWVtbywgcERlZikgeyByZXR1cm4gY29tbW9uXzEuYXBwbHlQYWlycyhtZW1vLCBnZXRQYXJhbVZhbChwRGVmKSk7IH0sIHt9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKiogR2V0cyBhIHNwZWNpZmljIFtbUGFyYW1dXSBtZXRhZGF0YSB0aGF0IGJlbG9uZ3MgdG8gdGhlIG5vZGUgKi9cbiAgICBQYXRoTm9kZS5wcm90b3R5cGUucGFyYW1ldGVyID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGNvbW1vbl8xLmZpbmQodGhpcy5wYXJhbVNjaGVtYSwgaG9mXzEucHJvcEVxKCdpZCcsIG5hbWUpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHN0YXRlIGFuZCBwYXJhbWV0ZXIgdmFsdWVzIGZvciBhbm90aGVyIFBhdGhOb2RlIGFyZVxuICAgICAqIGVxdWFsIHRvIHRoZSBzdGF0ZSBhbmQgcGFyYW0gdmFsdWVzIGZvciB0aGlzIFBhdGhOb2RlXG4gICAgICovXG4gICAgUGF0aE5vZGUucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChub2RlLCBwYXJhbXNGbikge1xuICAgICAgICB2YXIgZGlmZiA9IHRoaXMuZGlmZihub2RlLCBwYXJhbXNGbik7XG4gICAgICAgIHJldHVybiBkaWZmICYmIGRpZmYubGVuZ3RoID09PSAwO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRmluZHMgUGFyYW1zIHdpdGggZGlmZmVyZW50IHBhcmFtZXRlciB2YWx1ZXMgb24gYW5vdGhlciBQYXRoTm9kZS5cbiAgICAgKlxuICAgICAqIEdpdmVuIGFub3RoZXIgbm9kZSAob2YgdGhlIHNhbWUgc3RhdGUpLCBmaW5kcyB0aGUgcGFyYW1ldGVyIHZhbHVlcyB3aGljaCBkaWZmZXIuXG4gICAgICogUmV0dXJucyB0aGUgW1tQYXJhbV1dIChzY2hlbWEgb2JqZWN0cykgd2hvc2UgcGFyYW1ldGVyIHZhbHVlcyBkaWZmZXIuXG4gICAgICpcbiAgICAgKiBHaXZlbiBhbm90aGVyIG5vZGUgZm9yIGEgZGlmZmVyZW50IHN0YXRlLCByZXR1cm5zIGBmYWxzZWBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBub2RlIFRoZSBub2RlIHRvIGNvbXBhcmUgdG9cbiAgICAgKiBAcGFyYW0gcGFyYW1zRm4gQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgd2hpY2ggcGFyYW1ldGVycyBzaG91bGQgYmUgY29tcGFyZWQuXG4gICAgICogQHJldHVybnMgVGhlIFtbUGFyYW1dXXMgd2hpY2ggZGlmZmVyLCBvciBudWxsIGlmIHRoZSB0d28gbm9kZXMgYXJlIGZvciBkaWZmZXJlbnQgc3RhdGVzXG4gICAgICovXG4gICAgUGF0aE5vZGUucHJvdG90eXBlLmRpZmYgPSBmdW5jdGlvbiAobm9kZSwgcGFyYW1zRm4pIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IG5vZGUuc3RhdGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBwYXJhbXMgPSBwYXJhbXNGbiA/IHBhcmFtc0ZuKHRoaXMpIDogdGhpcy5wYXJhbVNjaGVtYTtcbiAgICAgICAgcmV0dXJuIHBhcmFtXzEuUGFyYW0uY2hhbmdlZChwYXJhbXMsIHRoaXMucGFyYW1WYWx1ZXMsIG5vZGUucGFyYW1WYWx1ZXMpO1xuICAgIH07XG4gICAgcmV0dXJuIFBhdGhOb2RlO1xufSgpKTtcbmV4cG9ydHMuUGF0aE5vZGUgPSBQYXRoTm9kZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhdGhOb2RlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9wYXRoL3BhdGhOb2RlLmpzXG4vLyBtb2R1bGUgaWQgPSA0NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///45\n")},function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @coreapi\n * @module params\n */\n/** */\nvar common_1 = __webpack_require__(0);\nvar predicates_1 = __webpack_require__(1);\n/**\n * An internal class which implements [[ParamTypeDefinition]].\n *\n * A [[ParamTypeDefinition]] is a plain javascript object used to register custom parameter types.\n * When a param type definition is registered, an instance of this class is created internally.\n *\n * This class has naive implementations for all the [[ParamTypeDefinition]] methods.\n *\n * Used by [[UrlMatcher]] when matching or formatting URLs, or comparing and validating parameter values.\n *\n * #### Example:\n * ```js\n * var paramTypeDef = {\n *   decode: function(val) { return parseInt(val, 10); },\n *   encode: function(val) { return val && val.toString(); },\n *   equals: function(a, b) { return this.is(a) && a === b; },\n *   is: function(val) { return angular.isNumber(val) && isFinite(val) && val % 1 === 0; },\n *   pattern: /\\d+/\n * }\n *\n * var paramType = new ParamType(paramTypeDef);\n * ```\n * @internalapi\n */\nvar ParamType = /** @class */ (function () {\n    /**\n     * @param def  A configuration object which contains the custom type definition.  The object's\n     *        properties will override the default methods and/or pattern in `ParamType`'s public interface.\n     * @returns a new ParamType object\n     */\n    function ParamType(def) {\n        /** @inheritdoc */\n        this.pattern = /.*/;\n        /** @inheritdoc */\n        this.inherit = true;\n        common_1.extend(this, def);\n    }\n    // consider these four methods to be \"abstract methods\" that should be overridden\n    /** @inheritdoc */\n    ParamType.prototype.is = function (val, key) { return true; };\n    /** @inheritdoc */\n    ParamType.prototype.encode = function (val, key) { return val; };\n    /** @inheritdoc */\n    ParamType.prototype.decode = function (val, key) { return val; };\n    /** @inheritdoc */\n    ParamType.prototype.equals = function (a, b) { return a == b; }; // tslint:disable-line:triple-equals\n    ParamType.prototype.$subPattern = function () {\n        var sub = this.pattern.toString();\n        return sub.substr(1, sub.length - 2);\n    };\n    ParamType.prototype.toString = function () {\n        return \"{ParamType:\" + this.name + \"}\";\n    };\n    /** Given an encoded string, or a decoded object, returns a decoded object */\n    ParamType.prototype.$normalize = function (val) {\n        return this.is(val) ? val : this.decode(val);\n    };\n    /**\n     * Wraps an existing custom ParamType as an array of ParamType, depending on 'mode'.\n     * e.g.:\n     * - urlmatcher pattern \"/path?{queryParam[]:int}\"\n     * - url: \"/path?queryParam=1&queryParam=2\n     * - $stateParams.queryParam will be [1, 2]\n     * if `mode` is \"auto\", then\n     * - url: \"/path?queryParam=1 will create $stateParams.queryParam: 1\n     * - url: \"/path?queryParam=1&queryParam=2 will create $stateParams.queryParam: [1, 2]\n     */\n    ParamType.prototype.$asArray = function (mode, isSearch) {\n        if (!mode)\n            return this;\n        if (mode === 'auto' && !isSearch)\n            throw new Error(\"'auto' array mode is for query parameters only\");\n        return new ArrayType(this, mode);\n    };\n    return ParamType;\n}());\nexports.ParamType = ParamType;\n/**\n * Wraps up a `ParamType` object to handle array values.\n * @internalapi\n */\nfunction ArrayType(type, mode) {\n    var _this = this;\n    // Wrap non-array value as array\n    function arrayWrap(val) {\n        return predicates_1.isArray(val) ? val : (predicates_1.isDefined(val) ? [val] : []);\n    }\n    // Unwrap array value for \"auto\" mode. Return undefined for empty array.\n    function arrayUnwrap(val) {\n        switch (val.length) {\n            case 0: return undefined;\n            case 1: return mode === 'auto' ? val[0] : val;\n            default: return val;\n        }\n    }\n    // Wraps type (.is/.encode/.decode) functions to operate on each value of an array\n    function arrayHandler(callback, allTruthyMode) {\n        return function handleArray(val) {\n            if (predicates_1.isArray(val) && val.length === 0)\n                return val;\n            var arr = arrayWrap(val);\n            var result = common_1.map(arr, callback);\n            return (allTruthyMode === true) ? common_1.filter(result, function (x) { return !x; }).length === 0 : arrayUnwrap(result);\n        };\n    }\n    // Wraps type (.equals) functions to operate on each value of an array\n    function arrayEqualsHandler(callback) {\n        return function handleArray(val1, val2) {\n            var left = arrayWrap(val1), right = arrayWrap(val2);\n            if (left.length !== right.length)\n                return false;\n            for (var i = 0; i < left.length; i++) {\n                if (!callback(left[i], right[i]))\n                    return false;\n            }\n            return true;\n        };\n    }\n    ['encode', 'decode', 'equals', '$normalize'].forEach(function (name) {\n        var paramTypeFn = type[name].bind(type);\n        var wrapperFn = name === 'equals' ? arrayEqualsHandler : arrayHandler;\n        _this[name] = wrapperFn(paramTypeFn);\n    });\n    common_1.extend(this, {\n        dynamic: type.dynamic,\n        name: type.name,\n        pattern: type.pattern,\n        inherit: type.inherit,\n        is: arrayHandler(type.is.bind(type), true),\n        $arrayMode: mode,\n    });\n}\n//# sourceMappingURL=paramType.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3BhcmFtcy9wYXJhbVR5cGUuanM/MGZjMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGNvcmVhcGlcbiAqIEBtb2R1bGUgcGFyYW1zXG4gKi9cbi8qKiAqL1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb21tb25cIik7XG52YXIgcHJlZGljYXRlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9wcmVkaWNhdGVzXCIpO1xuLyoqXG4gKiBBbiBpbnRlcm5hbCBjbGFzcyB3aGljaCBpbXBsZW1lbnRzIFtbUGFyYW1UeXBlRGVmaW5pdGlvbl1dLlxuICpcbiAqIEEgW1tQYXJhbVR5cGVEZWZpbml0aW9uXV0gaXMgYSBwbGFpbiBqYXZhc2NyaXB0IG9iamVjdCB1c2VkIHRvIHJlZ2lzdGVyIGN1c3RvbSBwYXJhbWV0ZXIgdHlwZXMuXG4gKiBXaGVuIGEgcGFyYW0gdHlwZSBkZWZpbml0aW9uIGlzIHJlZ2lzdGVyZWQsIGFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MgaXMgY3JlYXRlZCBpbnRlcm5hbGx5LlxuICpcbiAqIFRoaXMgY2xhc3MgaGFzIG5haXZlIGltcGxlbWVudGF0aW9ucyBmb3IgYWxsIHRoZSBbW1BhcmFtVHlwZURlZmluaXRpb25dXSBtZXRob2RzLlxuICpcbiAqIFVzZWQgYnkgW1tVcmxNYXRjaGVyXV0gd2hlbiBtYXRjaGluZyBvciBmb3JtYXR0aW5nIFVSTHMsIG9yIGNvbXBhcmluZyBhbmQgdmFsaWRhdGluZyBwYXJhbWV0ZXIgdmFsdWVzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqIGBgYGpzXG4gKiB2YXIgcGFyYW1UeXBlRGVmID0ge1xuICogICBkZWNvZGU6IGZ1bmN0aW9uKHZhbCkgeyByZXR1cm4gcGFyc2VJbnQodmFsLCAxMCk7IH0sXG4gKiAgIGVuY29kZTogZnVuY3Rpb24odmFsKSB7IHJldHVybiB2YWwgJiYgdmFsLnRvU3RyaW5nKCk7IH0sXG4gKiAgIGVxdWFsczogZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gdGhpcy5pcyhhKSAmJiBhID09PSBiOyB9LFxuICogICBpczogZnVuY3Rpb24odmFsKSB7IHJldHVybiBhbmd1bGFyLmlzTnVtYmVyKHZhbCkgJiYgaXNGaW5pdGUodmFsKSAmJiB2YWwgJSAxID09PSAwOyB9LFxuICogICBwYXR0ZXJuOiAvXFxkKy9cbiAqIH1cbiAqXG4gKiB2YXIgcGFyYW1UeXBlID0gbmV3IFBhcmFtVHlwZShwYXJhbVR5cGVEZWYpO1xuICogYGBgXG4gKiBAaW50ZXJuYWxhcGlcbiAqL1xudmFyIFBhcmFtVHlwZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZGVmICBBIGNvbmZpZ3VyYXRpb24gb2JqZWN0IHdoaWNoIGNvbnRhaW5zIHRoZSBjdXN0b20gdHlwZSBkZWZpbml0aW9uLiAgVGhlIG9iamVjdCdzXG4gICAgICogICAgICAgIHByb3BlcnRpZXMgd2lsbCBvdmVycmlkZSB0aGUgZGVmYXVsdCBtZXRob2RzIGFuZC9vciBwYXR0ZXJuIGluIGBQYXJhbVR5cGVgJ3MgcHVibGljIGludGVyZmFjZS5cbiAgICAgKiBAcmV0dXJucyBhIG5ldyBQYXJhbVR5cGUgb2JqZWN0XG4gICAgICovXG4gICAgZnVuY3Rpb24gUGFyYW1UeXBlKGRlZikge1xuICAgICAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICAgICAgdGhpcy5wYXR0ZXJuID0gLy4qLztcbiAgICAgICAgLyoqIEBpbmhlcml0ZG9jICovXG4gICAgICAgIHRoaXMuaW5oZXJpdCA9IHRydWU7XG4gICAgICAgIGNvbW1vbl8xLmV4dGVuZCh0aGlzLCBkZWYpO1xuICAgIH1cbiAgICAvLyBjb25zaWRlciB0aGVzZSBmb3VyIG1ldGhvZHMgdG8gYmUgXCJhYnN0cmFjdCBtZXRob2RzXCIgdGhhdCBzaG91bGQgYmUgb3ZlcnJpZGRlblxuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgIFBhcmFtVHlwZS5wcm90b3R5cGUuaXMgPSBmdW5jdGlvbiAodmFsLCBrZXkpIHsgcmV0dXJuIHRydWU7IH07XG4gICAgLyoqIEBpbmhlcml0ZG9jICovXG4gICAgUGFyYW1UeXBlLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbiAodmFsLCBrZXkpIHsgcmV0dXJuIHZhbDsgfTtcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBQYXJhbVR5cGUucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uICh2YWwsIGtleSkgeyByZXR1cm4gdmFsOyB9O1xuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgIFBhcmFtVHlwZS5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEgPT0gYjsgfTsgLy8gdHNsaW50OmRpc2FibGUtbGluZTp0cmlwbGUtZXF1YWxzXG4gICAgUGFyYW1UeXBlLnByb3RvdHlwZS4kc3ViUGF0dGVybiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN1YiA9IHRoaXMucGF0dGVybi50b1N0cmluZygpO1xuICAgICAgICByZXR1cm4gc3ViLnN1YnN0cigxLCBzdWIubGVuZ3RoIC0gMik7XG4gICAgfTtcbiAgICBQYXJhbVR5cGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJ7UGFyYW1UeXBlOlwiICsgdGhpcy5uYW1lICsgXCJ9XCI7XG4gICAgfTtcbiAgICAvKiogR2l2ZW4gYW4gZW5jb2RlZCBzdHJpbmcsIG9yIGEgZGVjb2RlZCBvYmplY3QsIHJldHVybnMgYSBkZWNvZGVkIG9iamVjdCAqL1xuICAgIFBhcmFtVHlwZS5wcm90b3R5cGUuJG5vcm1hbGl6ZSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXModmFsKSA/IHZhbCA6IHRoaXMuZGVjb2RlKHZhbCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBXcmFwcyBhbiBleGlzdGluZyBjdXN0b20gUGFyYW1UeXBlIGFzIGFuIGFycmF5IG9mIFBhcmFtVHlwZSwgZGVwZW5kaW5nIG9uICdtb2RlJy5cbiAgICAgKiBlLmcuOlxuICAgICAqIC0gdXJsbWF0Y2hlciBwYXR0ZXJuIFwiL3BhdGg/e3F1ZXJ5UGFyYW1bXTppbnR9XCJcbiAgICAgKiAtIHVybDogXCIvcGF0aD9xdWVyeVBhcmFtPTEmcXVlcnlQYXJhbT0yXG4gICAgICogLSAkc3RhdGVQYXJhbXMucXVlcnlQYXJhbSB3aWxsIGJlIFsxLCAyXVxuICAgICAqIGlmIGBtb2RlYCBpcyBcImF1dG9cIiwgdGhlblxuICAgICAqIC0gdXJsOiBcIi9wYXRoP3F1ZXJ5UGFyYW09MSB3aWxsIGNyZWF0ZSAkc3RhdGVQYXJhbXMucXVlcnlQYXJhbTogMVxuICAgICAqIC0gdXJsOiBcIi9wYXRoP3F1ZXJ5UGFyYW09MSZxdWVyeVBhcmFtPTIgd2lsbCBjcmVhdGUgJHN0YXRlUGFyYW1zLnF1ZXJ5UGFyYW06IFsxLCAyXVxuICAgICAqL1xuICAgIFBhcmFtVHlwZS5wcm90b3R5cGUuJGFzQXJyYXkgPSBmdW5jdGlvbiAobW9kZSwgaXNTZWFyY2gpIHtcbiAgICAgICAgaWYgKCFtb2RlKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGlmIChtb2RlID09PSAnYXV0bycgJiYgIWlzU2VhcmNoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiJ2F1dG8nIGFycmF5IG1vZGUgaXMgZm9yIHF1ZXJ5IHBhcmFtZXRlcnMgb25seVwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBcnJheVR5cGUodGhpcywgbW9kZSk7XG4gICAgfTtcbiAgICByZXR1cm4gUGFyYW1UeXBlO1xufSgpKTtcbmV4cG9ydHMuUGFyYW1UeXBlID0gUGFyYW1UeXBlO1xuLyoqXG4gKiBXcmFwcyB1cCBhIGBQYXJhbVR5cGVgIG9iamVjdCB0byBoYW5kbGUgYXJyYXkgdmFsdWVzLlxuICogQGludGVybmFsYXBpXG4gKi9cbmZ1bmN0aW9uIEFycmF5VHlwZSh0eXBlLCBtb2RlKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAvLyBXcmFwIG5vbi1hcnJheSB2YWx1ZSBhcyBhcnJheVxuICAgIGZ1bmN0aW9uIGFycmF5V3JhcCh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHByZWRpY2F0ZXNfMS5pc0FycmF5KHZhbCkgPyB2YWwgOiAocHJlZGljYXRlc18xLmlzRGVmaW5lZCh2YWwpID8gW3ZhbF0gOiBbXSk7XG4gICAgfVxuICAgIC8vIFVud3JhcCBhcnJheSB2YWx1ZSBmb3IgXCJhdXRvXCIgbW9kZS4gUmV0dXJuIHVuZGVmaW5lZCBmb3IgZW1wdHkgYXJyYXkuXG4gICAgZnVuY3Rpb24gYXJyYXlVbndyYXAodmFsKSB7XG4gICAgICAgIHN3aXRjaCAodmFsLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gbW9kZSA9PT0gJ2F1dG8nID8gdmFsWzBdIDogdmFsO1xuICAgICAgICAgICAgZGVmYXVsdDogcmV0dXJuIHZhbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBXcmFwcyB0eXBlICguaXMvLmVuY29kZS8uZGVjb2RlKSBmdW5jdGlvbnMgdG8gb3BlcmF0ZSBvbiBlYWNoIHZhbHVlIG9mIGFuIGFycmF5XG4gICAgZnVuY3Rpb24gYXJyYXlIYW5kbGVyKGNhbGxiYWNrLCBhbGxUcnV0aHlNb2RlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBoYW5kbGVBcnJheSh2YWwpIHtcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGVzXzEuaXNBcnJheSh2YWwpICYmIHZhbC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgICAgIHZhciBhcnIgPSBhcnJheVdyYXAodmFsKTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBjb21tb25fMS5tYXAoYXJyLCBjYWxsYmFjayk7XG4gICAgICAgICAgICByZXR1cm4gKGFsbFRydXRoeU1vZGUgPT09IHRydWUpID8gY29tbW9uXzEuZmlsdGVyKHJlc3VsdCwgZnVuY3Rpb24gKHgpIHsgcmV0dXJuICF4OyB9KS5sZW5ndGggPT09IDAgOiBhcnJheVVud3JhcChyZXN1bHQpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBXcmFwcyB0eXBlICguZXF1YWxzKSBmdW5jdGlvbnMgdG8gb3BlcmF0ZSBvbiBlYWNoIHZhbHVlIG9mIGFuIGFycmF5XG4gICAgZnVuY3Rpb24gYXJyYXlFcXVhbHNIYW5kbGVyKGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBoYW5kbGVBcnJheSh2YWwxLCB2YWwyKSB7XG4gICAgICAgICAgICB2YXIgbGVmdCA9IGFycmF5V3JhcCh2YWwxKSwgcmlnaHQgPSBhcnJheVdyYXAodmFsMik7XG4gICAgICAgICAgICBpZiAobGVmdC5sZW5ndGggIT09IHJpZ2h0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlZnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNhbGxiYWNrKGxlZnRbaV0sIHJpZ2h0W2ldKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgfVxuICAgIFsnZW5jb2RlJywgJ2RlY29kZScsICdlcXVhbHMnLCAnJG5vcm1hbGl6ZSddLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdmFyIHBhcmFtVHlwZUZuID0gdHlwZVtuYW1lXS5iaW5kKHR5cGUpO1xuICAgICAgICB2YXIgd3JhcHBlckZuID0gbmFtZSA9PT0gJ2VxdWFscycgPyBhcnJheUVxdWFsc0hhbmRsZXIgOiBhcnJheUhhbmRsZXI7XG4gICAgICAgIF90aGlzW25hbWVdID0gd3JhcHBlckZuKHBhcmFtVHlwZUZuKTtcbiAgICB9KTtcbiAgICBjb21tb25fMS5leHRlbmQodGhpcywge1xuICAgICAgICBkeW5hbWljOiB0eXBlLmR5bmFtaWMsXG4gICAgICAgIG5hbWU6IHR5cGUubmFtZSxcbiAgICAgICAgcGF0dGVybjogdHlwZS5wYXR0ZXJuLFxuICAgICAgICBpbmhlcml0OiB0eXBlLmluaGVyaXQsXG4gICAgICAgIGlzOiBhcnJheUhhbmRsZXIodHlwZS5pcy5iaW5kKHR5cGUpLCB0cnVlKSxcbiAgICAgICAgJGFycmF5TW9kZTogbW9kZSxcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcmFtVHlwZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvcGFyYW1zL3BhcmFtVHlwZS5qc1xuLy8gbW9kdWxlIGlkID0gNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///46\n")},function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @coreapi\n * @module transition\n */\n/** for typedoc */\nvar interface_1 = __webpack_require__(16);\nvar transition_1 = __webpack_require__(29);\nvar hookRegistry_1 = __webpack_require__(44);\nvar coreResolvables_1 = __webpack_require__(116);\nvar redirectTo_1 = __webpack_require__(117);\nvar onEnterExitRetain_1 = __webpack_require__(118);\nvar resolve_1 = __webpack_require__(119);\nvar views_1 = __webpack_require__(120);\nvar updateGlobals_1 = __webpack_require__(121);\nvar url_1 = __webpack_require__(122);\nvar lazyLoad_1 = __webpack_require__(86);\nvar transitionEventType_1 = __webpack_require__(87);\nvar transitionHook_1 = __webpack_require__(25);\nvar predicates_1 = __webpack_require__(1);\nvar common_1 = __webpack_require__(0);\nvar hof_1 = __webpack_require__(2);\nvar ignoredTransition_1 = __webpack_require__(123);\nvar invalidTransition_1 = __webpack_require__(124);\n/**\n * The default [[Transition]] options.\n *\n * Include this object when applying custom defaults:\n * let reloadOpts = { reload: true, notify: true }\n * let options = defaults(theirOpts, customDefaults, defaultOptions);\n */\nexports.defaultTransOpts = {\n    location: true,\n    relative: null,\n    inherit: false,\n    notify: true,\n    reload: false,\n    custom: {},\n    current: function () { return null; },\n    source: 'unknown',\n};\n/**\n * This class provides services related to Transitions.\n *\n * - Most importantly, it allows global Transition Hooks to be registered.\n * - It allows the default transition error handler to be set.\n * - It also has a factory function for creating new [[Transition]] objects, (used internally by the [[StateService]]).\n *\n * At bootstrap, [[UIRouter]] creates a single instance (singleton) of this class.\n */\nvar TransitionService = /** @class */ (function () {\n    /** @hidden */\n    function TransitionService(_router) {\n        /** @hidden */\n        this._transitionCount = 0;\n        /** @hidden The transition hook types, such as `onEnter`, `onStart`, etc */\n        this._eventTypes = [];\n        /** @hidden The registered transition hooks */\n        this._registeredHooks = {};\n        /** @hidden The  paths on a criteria object */\n        this._criteriaPaths = {};\n        this._router = _router;\n        this.$view = _router.viewService;\n        this._deregisterHookFns = {};\n        this._pluginapi = common_1.createProxyFunctions(hof_1.val(this), {}, hof_1.val(this), [\n            '_definePathType',\n            '_defineEvent',\n            '_getPathTypes',\n            '_getEvents',\n            'getHooks',\n        ]);\n        this._defineCorePaths();\n        this._defineCoreEvents();\n        this._registerCoreTransitionHooks();\n    }\n    /**\n     * Registers a [[TransitionHookFn]], called *while a transition is being constructed*.\n     *\n     * Registers a transition lifecycle hook, which is invoked during transition construction.\n     *\n     * This low level hook should only be used by plugins.\n     * This can be a useful time for plugins to add resolves or mutate the transition as needed.\n     * The Sticky States plugin uses this hook to modify the treechanges.\n     *\n     * ### Lifecycle\n     *\n     * `onCreate` hooks are invoked *while a transition is being constructed*.\n     *\n     * ### Return value\n     *\n     * The hook's return value is ignored\n     *\n     * @internalapi\n     * @param criteria defines which Transitions the Hook should be invoked for.\n     * @param callback the hook function which will be invoked.\n     * @param options the registration options\n     * @returns a function which deregisters the hook.\n     */\n    TransitionService.prototype.onCreate = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onBefore = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onStart = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onExit = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onRetain = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onEnter = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onFinish = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onSuccess = function (criteria, callback, options) { return; };\n    /** @inheritdoc */\n    TransitionService.prototype.onError = function (criteria, callback, options) { return; };\n    /**\n     * dispose\n     * @internalapi\n     */\n    TransitionService.prototype.dispose = function (router) {\n        common_1.values(this._registeredHooks).forEach(function (hooksArray) { return hooksArray.forEach(function (hook) {\n            hook._deregistered = true;\n            common_1.removeFrom(hooksArray, hook);\n        }); });\n    };\n    /**\n     * Creates a new [[Transition]] object\n     *\n     * This is a factory function for creating new Transition objects.\n     * It is used internally by the [[StateService]] and should generally not be called by application code.\n     *\n     * @param fromPath the path to the current state (the from state)\n     * @param targetState the target state (destination)\n     * @returns a Transition\n     */\n    TransitionService.prototype.create = function (fromPath, targetState) {\n        return new transition_1.Transition(fromPath, targetState, this._router);\n    };\n    /** @hidden */\n    TransitionService.prototype._defineCoreEvents = function () {\n        var Phase = interface_1.TransitionHookPhase;\n        var TH = transitionHook_1.TransitionHook;\n        var paths = this._criteriaPaths;\n        var NORMAL_SORT = false, REVERSE_SORT = true;\n        var SYNCHRONOUS = true;\n        this._defineEvent('onCreate', Phase.CREATE, 0, paths.to, NORMAL_SORT, TH.LOG_REJECTED_RESULT, TH.THROW_ERROR, SYNCHRONOUS);\n        this._defineEvent('onBefore', Phase.BEFORE, 0, paths.to);\n        this._defineEvent('onStart', Phase.RUN, 0, paths.to);\n        this._defineEvent('onExit', Phase.RUN, 100, paths.exiting, REVERSE_SORT);\n        this._defineEvent('onRetain', Phase.RUN, 200, paths.retained);\n        this._defineEvent('onEnter', Phase.RUN, 300, paths.entering);\n        this._defineEvent('onFinish', Phase.RUN, 400, paths.to);\n        this._defineEvent('onSuccess', Phase.SUCCESS, 0, paths.to, NORMAL_SORT, TH.LOG_REJECTED_RESULT, TH.LOG_ERROR, SYNCHRONOUS);\n        this._defineEvent('onError', Phase.ERROR, 0, paths.to, NORMAL_SORT, TH.LOG_REJECTED_RESULT, TH.LOG_ERROR, SYNCHRONOUS);\n    };\n    /** @hidden */\n    TransitionService.prototype._defineCorePaths = function () {\n        var STATE = interface_1.TransitionHookScope.STATE, TRANSITION = interface_1.TransitionHookScope.TRANSITION;\n        this._definePathType('to', TRANSITION);\n        this._definePathType('from', TRANSITION);\n        this._definePathType('exiting', STATE);\n        this._definePathType('retained', STATE);\n        this._definePathType('entering', STATE);\n    };\n    /** @hidden */\n    TransitionService.prototype._defineEvent = function (name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, synchronous) {\n        if (reverseSort === void 0) { reverseSort = false; }\n        if (getResultHandler === void 0) { getResultHandler = transitionHook_1.TransitionHook.HANDLE_RESULT; }\n        if (getErrorHandler === void 0) { getErrorHandler = transitionHook_1.TransitionHook.REJECT_ERROR; }\n        if (synchronous === void 0) { synchronous = false; }\n        var eventType = new transitionEventType_1.TransitionEventType(name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, synchronous);\n        this._eventTypes.push(eventType);\n        hookRegistry_1.makeEvent(this, this, eventType);\n    };\n    /** @hidden */ // tslint:disable-next-line\n    TransitionService.prototype._getEvents = function (phase) {\n        var transitionHookTypes = predicates_1.isDefined(phase) ?\n            this._eventTypes.filter(function (type) { return type.hookPhase === phase; }) :\n            this._eventTypes.slice();\n        return transitionHookTypes.sort(function (l, r) {\n            var cmpByPhase = l.hookPhase - r.hookPhase;\n            return cmpByPhase === 0 ? l.hookOrder - r.hookOrder : cmpByPhase;\n        });\n    };\n    /**\n     * Adds a Path to be used as a criterion against a TreeChanges path\n     *\n     * For example: the `exiting` path in [[HookMatchCriteria]] is a STATE scoped path.\n     * It was defined by calling `defineTreeChangesCriterion('exiting', TransitionHookScope.STATE)`\n     * Each state in the exiting path is checked against the criteria and returned as part of the match.\n     *\n     * Another example: the `to` path in [[HookMatchCriteria]] is a TRANSITION scoped path.\n     * It was defined by calling `defineTreeChangesCriterion('to', TransitionHookScope.TRANSITION)`\n     * Only the tail of the `to` path is checked against the criteria and returned as part of the match.\n     *\n     * @hidden\n     */\n    TransitionService.prototype._definePathType = function (name, hookScope) {\n        this._criteriaPaths[name] = { name: name, scope: hookScope };\n    };\n    /** * @hidden */ // tslint:disable-next-line\n    TransitionService.prototype._getPathTypes = function () {\n        return this._criteriaPaths;\n    };\n    /** @hidden */\n    TransitionService.prototype.getHooks = function (hookName) {\n        return this._registeredHooks[hookName];\n    };\n    /** @hidden */\n    TransitionService.prototype._registerCoreTransitionHooks = function () {\n        var fns = this._deregisterHookFns;\n        fns.addCoreResolves = coreResolvables_1.registerAddCoreResolvables(this);\n        fns.ignored = ignoredTransition_1.registerIgnoredTransitionHook(this);\n        fns.invalid = invalidTransition_1.registerInvalidTransitionHook(this);\n        // Wire up redirectTo hook\n        fns.redirectTo = redirectTo_1.registerRedirectToHook(this);\n        // Wire up onExit/Retain/Enter state hooks\n        fns.onExit = onEnterExitRetain_1.registerOnExitHook(this);\n        fns.onRetain = onEnterExitRetain_1.registerOnRetainHook(this);\n        fns.onEnter = onEnterExitRetain_1.registerOnEnterHook(this);\n        // Wire up Resolve hooks\n        fns.eagerResolve = resolve_1.registerEagerResolvePath(this);\n        fns.lazyResolve = resolve_1.registerLazyResolveState(this);\n        fns.resolveAll = resolve_1.registerResolveRemaining(this);\n        // Wire up the View management hooks\n        fns.loadViews = views_1.registerLoadEnteringViews(this);\n        fns.activateViews = views_1.registerActivateViews(this);\n        // Updates global state after a transition\n        fns.updateGlobals = updateGlobals_1.registerUpdateGlobalState(this);\n        // After globals.current is updated at priority: 10000\n        fns.updateUrl = url_1.registerUpdateUrl(this);\n        // Lazy load state trees\n        fns.lazyLoad = lazyLoad_1.registerLazyLoadHook(this);\n    };\n    return TransitionService;\n}());\nexports.TransitionService = TransitionService;\n//# sourceMappingURL=transitionService.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3RyYW5zaXRpb24vdHJhbnNpdGlvblNlcnZpY2UuanM/NDFmYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGNvcmVhcGlcbiAqIEBtb2R1bGUgdHJhbnNpdGlvblxuICovXG4vKiogZm9yIHR5cGVkb2MgKi9cbnZhciBpbnRlcmZhY2VfMSA9IHJlcXVpcmUoXCIuL2ludGVyZmFjZVwiKTtcbnZhciB0cmFuc2l0aW9uXzEgPSByZXF1aXJlKFwiLi90cmFuc2l0aW9uXCIpO1xudmFyIGhvb2tSZWdpc3RyeV8xID0gcmVxdWlyZShcIi4vaG9va1JlZ2lzdHJ5XCIpO1xudmFyIGNvcmVSZXNvbHZhYmxlc18xID0gcmVxdWlyZShcIi4uL2hvb2tzL2NvcmVSZXNvbHZhYmxlc1wiKTtcbnZhciByZWRpcmVjdFRvXzEgPSByZXF1aXJlKFwiLi4vaG9va3MvcmVkaXJlY3RUb1wiKTtcbnZhciBvbkVudGVyRXhpdFJldGFpbl8xID0gcmVxdWlyZShcIi4uL2hvb2tzL29uRW50ZXJFeGl0UmV0YWluXCIpO1xudmFyIHJlc29sdmVfMSA9IHJlcXVpcmUoXCIuLi9ob29rcy9yZXNvbHZlXCIpO1xudmFyIHZpZXdzXzEgPSByZXF1aXJlKFwiLi4vaG9va3Mvdmlld3NcIik7XG52YXIgdXBkYXRlR2xvYmFsc18xID0gcmVxdWlyZShcIi4uL2hvb2tzL3VwZGF0ZUdsb2JhbHNcIik7XG52YXIgdXJsXzEgPSByZXF1aXJlKFwiLi4vaG9va3MvdXJsXCIpO1xudmFyIGxhenlMb2FkXzEgPSByZXF1aXJlKFwiLi4vaG9va3MvbGF6eUxvYWRcIik7XG52YXIgdHJhbnNpdGlvbkV2ZW50VHlwZV8xID0gcmVxdWlyZShcIi4vdHJhbnNpdGlvbkV2ZW50VHlwZVwiKTtcbnZhciB0cmFuc2l0aW9uSG9va18xID0gcmVxdWlyZShcIi4vdHJhbnNpdGlvbkhvb2tcIik7XG52YXIgcHJlZGljYXRlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9wcmVkaWNhdGVzXCIpO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb21tb25cIik7XG52YXIgaG9mXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2hvZlwiKTtcbnZhciBpZ25vcmVkVHJhbnNpdGlvbl8xID0gcmVxdWlyZShcIi4uL2hvb2tzL2lnbm9yZWRUcmFuc2l0aW9uXCIpO1xudmFyIGludmFsaWRUcmFuc2l0aW9uXzEgPSByZXF1aXJlKFwiLi4vaG9va3MvaW52YWxpZFRyYW5zaXRpb25cIik7XG4vKipcbiAqIFRoZSBkZWZhdWx0IFtbVHJhbnNpdGlvbl1dIG9wdGlvbnMuXG4gKlxuICogSW5jbHVkZSB0aGlzIG9iamVjdCB3aGVuIGFwcGx5aW5nIGN1c3RvbSBkZWZhdWx0czpcbiAqIGxldCByZWxvYWRPcHRzID0geyByZWxvYWQ6IHRydWUsIG5vdGlmeTogdHJ1ZSB9XG4gKiBsZXQgb3B0aW9ucyA9IGRlZmF1bHRzKHRoZWlyT3B0cywgY3VzdG9tRGVmYXVsdHMsIGRlZmF1bHRPcHRpb25zKTtcbiAqL1xuZXhwb3J0cy5kZWZhdWx0VHJhbnNPcHRzID0ge1xuICAgIGxvY2F0aW9uOiB0cnVlLFxuICAgIHJlbGF0aXZlOiBudWxsLFxuICAgIGluaGVyaXQ6IGZhbHNlLFxuICAgIG5vdGlmeTogdHJ1ZSxcbiAgICByZWxvYWQ6IGZhbHNlLFxuICAgIGN1c3RvbToge30sXG4gICAgY3VycmVudDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICBzb3VyY2U6ICd1bmtub3duJyxcbn07XG4vKipcbiAqIFRoaXMgY2xhc3MgcHJvdmlkZXMgc2VydmljZXMgcmVsYXRlZCB0byBUcmFuc2l0aW9ucy5cbiAqXG4gKiAtIE1vc3QgaW1wb3J0YW50bHksIGl0IGFsbG93cyBnbG9iYWwgVHJhbnNpdGlvbiBIb29rcyB0byBiZSByZWdpc3RlcmVkLlxuICogLSBJdCBhbGxvd3MgdGhlIGRlZmF1bHQgdHJhbnNpdGlvbiBlcnJvciBoYW5kbGVyIHRvIGJlIHNldC5cbiAqIC0gSXQgYWxzbyBoYXMgYSBmYWN0b3J5IGZ1bmN0aW9uIGZvciBjcmVhdGluZyBuZXcgW1tUcmFuc2l0aW9uXV0gb2JqZWN0cywgKHVzZWQgaW50ZXJuYWxseSBieSB0aGUgW1tTdGF0ZVNlcnZpY2VdXSkuXG4gKlxuICogQXQgYm9vdHN0cmFwLCBbW1VJUm91dGVyXV0gY3JlYXRlcyBhIHNpbmdsZSBpbnN0YW5jZSAoc2luZ2xldG9uKSBvZiB0aGlzIGNsYXNzLlxuICovXG52YXIgVHJhbnNpdGlvblNlcnZpY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBmdW5jdGlvbiBUcmFuc2l0aW9uU2VydmljZShfcm91dGVyKSB7XG4gICAgICAgIC8qKiBAaGlkZGVuICovXG4gICAgICAgIHRoaXMuX3RyYW5zaXRpb25Db3VudCA9IDA7XG4gICAgICAgIC8qKiBAaGlkZGVuIFRoZSB0cmFuc2l0aW9uIGhvb2sgdHlwZXMsIHN1Y2ggYXMgYG9uRW50ZXJgLCBgb25TdGFydGAsIGV0YyAqL1xuICAgICAgICB0aGlzLl9ldmVudFR5cGVzID0gW107XG4gICAgICAgIC8qKiBAaGlkZGVuIFRoZSByZWdpc3RlcmVkIHRyYW5zaXRpb24gaG9va3MgKi9cbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJlZEhvb2tzID0ge307XG4gICAgICAgIC8qKiBAaGlkZGVuIFRoZSAgcGF0aHMgb24gYSBjcml0ZXJpYSBvYmplY3QgKi9cbiAgICAgICAgdGhpcy5fY3JpdGVyaWFQYXRocyA9IHt9O1xuICAgICAgICB0aGlzLl9yb3V0ZXIgPSBfcm91dGVyO1xuICAgICAgICB0aGlzLiR2aWV3ID0gX3JvdXRlci52aWV3U2VydmljZTtcbiAgICAgICAgdGhpcy5fZGVyZWdpc3Rlckhvb2tGbnMgPSB7fTtcbiAgICAgICAgdGhpcy5fcGx1Z2luYXBpID0gY29tbW9uXzEuY3JlYXRlUHJveHlGdW5jdGlvbnMoaG9mXzEudmFsKHRoaXMpLCB7fSwgaG9mXzEudmFsKHRoaXMpLCBbXG4gICAgICAgICAgICAnX2RlZmluZVBhdGhUeXBlJyxcbiAgICAgICAgICAgICdfZGVmaW5lRXZlbnQnLFxuICAgICAgICAgICAgJ19nZXRQYXRoVHlwZXMnLFxuICAgICAgICAgICAgJ19nZXRFdmVudHMnLFxuICAgICAgICAgICAgJ2dldEhvb2tzJyxcbiAgICAgICAgXSk7XG4gICAgICAgIHRoaXMuX2RlZmluZUNvcmVQYXRocygpO1xuICAgICAgICB0aGlzLl9kZWZpbmVDb3JlRXZlbnRzKCk7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyQ29yZVRyYW5zaXRpb25Ib29rcygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBbW1RyYW5zaXRpb25Ib29rRm5dXSwgY2FsbGVkICp3aGlsZSBhIHRyYW5zaXRpb24gaXMgYmVpbmcgY29uc3RydWN0ZWQqLlxuICAgICAqXG4gICAgICogUmVnaXN0ZXJzIGEgdHJhbnNpdGlvbiBsaWZlY3ljbGUgaG9vaywgd2hpY2ggaXMgaW52b2tlZCBkdXJpbmcgdHJhbnNpdGlvbiBjb25zdHJ1Y3Rpb24uXG4gICAgICpcbiAgICAgKiBUaGlzIGxvdyBsZXZlbCBob29rIHNob3VsZCBvbmx5IGJlIHVzZWQgYnkgcGx1Z2lucy5cbiAgICAgKiBUaGlzIGNhbiBiZSBhIHVzZWZ1bCB0aW1lIGZvciBwbHVnaW5zIHRvIGFkZCByZXNvbHZlcyBvciBtdXRhdGUgdGhlIHRyYW5zaXRpb24gYXMgbmVlZGVkLlxuICAgICAqIFRoZSBTdGlja3kgU3RhdGVzIHBsdWdpbiB1c2VzIHRoaXMgaG9vayB0byBtb2RpZnkgdGhlIHRyZWVjaGFuZ2VzLlxuICAgICAqXG4gICAgICogIyMjIExpZmVjeWNsZVxuICAgICAqXG4gICAgICogYG9uQ3JlYXRlYCBob29rcyBhcmUgaW52b2tlZCAqd2hpbGUgYSB0cmFuc2l0aW9uIGlzIGJlaW5nIGNvbnN0cnVjdGVkKi5cbiAgICAgKlxuICAgICAqICMjIyBSZXR1cm4gdmFsdWVcbiAgICAgKlxuICAgICAqIFRoZSBob29rJ3MgcmV0dXJuIHZhbHVlIGlzIGlnbm9yZWRcbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbGFwaVxuICAgICAqIEBwYXJhbSBjcml0ZXJpYSBkZWZpbmVzIHdoaWNoIFRyYW5zaXRpb25zIHRoZSBIb29rIHNob3VsZCBiZSBpbnZva2VkIGZvci5cbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgdGhlIGhvb2sgZnVuY3Rpb24gd2hpY2ggd2lsbCBiZSBpbnZva2VkLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIHRoZSByZWdpc3RyYXRpb24gb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggZGVyZWdpc3RlcnMgdGhlIGhvb2suXG4gICAgICovXG4gICAgVHJhbnNpdGlvblNlcnZpY2UucHJvdG90eXBlLm9uQ3JlYXRlID0gZnVuY3Rpb24gKGNyaXRlcmlhLCBjYWxsYmFjaywgb3B0aW9ucykgeyByZXR1cm47IH07XG4gICAgLyoqIEBpbmhlcml0ZG9jICovXG4gICAgVHJhbnNpdGlvblNlcnZpY2UucHJvdG90eXBlLm9uQmVmb3JlID0gZnVuY3Rpb24gKGNyaXRlcmlhLCBjYWxsYmFjaywgb3B0aW9ucykgeyByZXR1cm47IH07XG4gICAgLyoqIEBpbmhlcml0ZG9jICovXG4gICAgVHJhbnNpdGlvblNlcnZpY2UucHJvdG90eXBlLm9uU3RhcnQgPSBmdW5jdGlvbiAoY3JpdGVyaWEsIGNhbGxiYWNrLCBvcHRpb25zKSB7IHJldHVybjsgfTtcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBUcmFuc2l0aW9uU2VydmljZS5wcm90b3R5cGUub25FeGl0ID0gZnVuY3Rpb24gKGNyaXRlcmlhLCBjYWxsYmFjaywgb3B0aW9ucykgeyByZXR1cm47IH07XG4gICAgLyoqIEBpbmhlcml0ZG9jICovXG4gICAgVHJhbnNpdGlvblNlcnZpY2UucHJvdG90eXBlLm9uUmV0YWluID0gZnVuY3Rpb24gKGNyaXRlcmlhLCBjYWxsYmFjaywgb3B0aW9ucykgeyByZXR1cm47IH07XG4gICAgLyoqIEBpbmhlcml0ZG9jICovXG4gICAgVHJhbnNpdGlvblNlcnZpY2UucHJvdG90eXBlLm9uRW50ZXIgPSBmdW5jdGlvbiAoY3JpdGVyaWEsIGNhbGxiYWNrLCBvcHRpb25zKSB7IHJldHVybjsgfTtcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBUcmFuc2l0aW9uU2VydmljZS5wcm90b3R5cGUub25GaW5pc2ggPSBmdW5jdGlvbiAoY3JpdGVyaWEsIGNhbGxiYWNrLCBvcHRpb25zKSB7IHJldHVybjsgfTtcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBUcmFuc2l0aW9uU2VydmljZS5wcm90b3R5cGUub25TdWNjZXNzID0gZnVuY3Rpb24gKGNyaXRlcmlhLCBjYWxsYmFjaywgb3B0aW9ucykgeyByZXR1cm47IH07XG4gICAgLyoqIEBpbmhlcml0ZG9jICovXG4gICAgVHJhbnNpdGlvblNlcnZpY2UucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbiAoY3JpdGVyaWEsIGNhbGxiYWNrLCBvcHRpb25zKSB7IHJldHVybjsgfTtcbiAgICAvKipcbiAgICAgKiBkaXNwb3NlXG4gICAgICogQGludGVybmFsYXBpXG4gICAgICovXG4gICAgVHJhbnNpdGlvblNlcnZpY2UucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAocm91dGVyKSB7XG4gICAgICAgIGNvbW1vbl8xLnZhbHVlcyh0aGlzLl9yZWdpc3RlcmVkSG9va3MpLmZvckVhY2goZnVuY3Rpb24gKGhvb2tzQXJyYXkpIHsgcmV0dXJuIGhvb2tzQXJyYXkuZm9yRWFjaChmdW5jdGlvbiAoaG9vaykge1xuICAgICAgICAgICAgaG9vay5fZGVyZWdpc3RlcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbW1vbl8xLnJlbW92ZUZyb20oaG9va3NBcnJheSwgaG9vayk7XG4gICAgICAgIH0pOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgW1tUcmFuc2l0aW9uXV0gb2JqZWN0XG4gICAgICpcbiAgICAgKiBUaGlzIGlzIGEgZmFjdG9yeSBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgbmV3IFRyYW5zaXRpb24gb2JqZWN0cy5cbiAgICAgKiBJdCBpcyB1c2VkIGludGVybmFsbHkgYnkgdGhlIFtbU3RhdGVTZXJ2aWNlXV0gYW5kIHNob3VsZCBnZW5lcmFsbHkgbm90IGJlIGNhbGxlZCBieSBhcHBsaWNhdGlvbiBjb2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZyb21QYXRoIHRoZSBwYXRoIHRvIHRoZSBjdXJyZW50IHN0YXRlICh0aGUgZnJvbSBzdGF0ZSlcbiAgICAgKiBAcGFyYW0gdGFyZ2V0U3RhdGUgdGhlIHRhcmdldCBzdGF0ZSAoZGVzdGluYXRpb24pXG4gICAgICogQHJldHVybnMgYSBUcmFuc2l0aW9uXG4gICAgICovXG4gICAgVHJhbnNpdGlvblNlcnZpY2UucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uIChmcm9tUGF0aCwgdGFyZ2V0U3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0cmFuc2l0aW9uXzEuVHJhbnNpdGlvbihmcm9tUGF0aCwgdGFyZ2V0U3RhdGUsIHRoaXMuX3JvdXRlcik7XG4gICAgfTtcbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIFRyYW5zaXRpb25TZXJ2aWNlLnByb3RvdHlwZS5fZGVmaW5lQ29yZUV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIFBoYXNlID0gaW50ZXJmYWNlXzEuVHJhbnNpdGlvbkhvb2tQaGFzZTtcbiAgICAgICAgdmFyIFRIID0gdHJhbnNpdGlvbkhvb2tfMS5UcmFuc2l0aW9uSG9vaztcbiAgICAgICAgdmFyIHBhdGhzID0gdGhpcy5fY3JpdGVyaWFQYXRocztcbiAgICAgICAgdmFyIE5PUk1BTF9TT1JUID0gZmFsc2UsIFJFVkVSU0VfU09SVCA9IHRydWU7XG4gICAgICAgIHZhciBTWU5DSFJPTk9VUyA9IHRydWU7XG4gICAgICAgIHRoaXMuX2RlZmluZUV2ZW50KCdvbkNyZWF0ZScsIFBoYXNlLkNSRUFURSwgMCwgcGF0aHMudG8sIE5PUk1BTF9TT1JULCBUSC5MT0dfUkVKRUNURURfUkVTVUxULCBUSC5USFJPV19FUlJPUiwgU1lOQ0hST05PVVMpO1xuICAgICAgICB0aGlzLl9kZWZpbmVFdmVudCgnb25CZWZvcmUnLCBQaGFzZS5CRUZPUkUsIDAsIHBhdGhzLnRvKTtcbiAgICAgICAgdGhpcy5fZGVmaW5lRXZlbnQoJ29uU3RhcnQnLCBQaGFzZS5SVU4sIDAsIHBhdGhzLnRvKTtcbiAgICAgICAgdGhpcy5fZGVmaW5lRXZlbnQoJ29uRXhpdCcsIFBoYXNlLlJVTiwgMTAwLCBwYXRocy5leGl0aW5nLCBSRVZFUlNFX1NPUlQpO1xuICAgICAgICB0aGlzLl9kZWZpbmVFdmVudCgnb25SZXRhaW4nLCBQaGFzZS5SVU4sIDIwMCwgcGF0aHMucmV0YWluZWQpO1xuICAgICAgICB0aGlzLl9kZWZpbmVFdmVudCgnb25FbnRlcicsIFBoYXNlLlJVTiwgMzAwLCBwYXRocy5lbnRlcmluZyk7XG4gICAgICAgIHRoaXMuX2RlZmluZUV2ZW50KCdvbkZpbmlzaCcsIFBoYXNlLlJVTiwgNDAwLCBwYXRocy50byk7XG4gICAgICAgIHRoaXMuX2RlZmluZUV2ZW50KCdvblN1Y2Nlc3MnLCBQaGFzZS5TVUNDRVNTLCAwLCBwYXRocy50bywgTk9STUFMX1NPUlQsIFRILkxPR19SRUpFQ1RFRF9SRVNVTFQsIFRILkxPR19FUlJPUiwgU1lOQ0hST05PVVMpO1xuICAgICAgICB0aGlzLl9kZWZpbmVFdmVudCgnb25FcnJvcicsIFBoYXNlLkVSUk9SLCAwLCBwYXRocy50bywgTk9STUFMX1NPUlQsIFRILkxPR19SRUpFQ1RFRF9SRVNVTFQsIFRILkxPR19FUlJPUiwgU1lOQ0hST05PVVMpO1xuICAgIH07XG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBUcmFuc2l0aW9uU2VydmljZS5wcm90b3R5cGUuX2RlZmluZUNvcmVQYXRocyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIFNUQVRFID0gaW50ZXJmYWNlXzEuVHJhbnNpdGlvbkhvb2tTY29wZS5TVEFURSwgVFJBTlNJVElPTiA9IGludGVyZmFjZV8xLlRyYW5zaXRpb25Ib29rU2NvcGUuVFJBTlNJVElPTjtcbiAgICAgICAgdGhpcy5fZGVmaW5lUGF0aFR5cGUoJ3RvJywgVFJBTlNJVElPTik7XG4gICAgICAgIHRoaXMuX2RlZmluZVBhdGhUeXBlKCdmcm9tJywgVFJBTlNJVElPTik7XG4gICAgICAgIHRoaXMuX2RlZmluZVBhdGhUeXBlKCdleGl0aW5nJywgU1RBVEUpO1xuICAgICAgICB0aGlzLl9kZWZpbmVQYXRoVHlwZSgncmV0YWluZWQnLCBTVEFURSk7XG4gICAgICAgIHRoaXMuX2RlZmluZVBhdGhUeXBlKCdlbnRlcmluZycsIFNUQVRFKTtcbiAgICB9O1xuICAgIC8qKiBAaGlkZGVuICovXG4gICAgVHJhbnNpdGlvblNlcnZpY2UucHJvdG90eXBlLl9kZWZpbmVFdmVudCA9IGZ1bmN0aW9uIChuYW1lLCBob29rUGhhc2UsIGhvb2tPcmRlciwgY3JpdGVyaWFNYXRjaFBhdGgsIHJldmVyc2VTb3J0LCBnZXRSZXN1bHRIYW5kbGVyLCBnZXRFcnJvckhhbmRsZXIsIHN5bmNocm9ub3VzKSB7XG4gICAgICAgIGlmIChyZXZlcnNlU29ydCA9PT0gdm9pZCAwKSB7IHJldmVyc2VTb3J0ID0gZmFsc2U7IH1cbiAgICAgICAgaWYgKGdldFJlc3VsdEhhbmRsZXIgPT09IHZvaWQgMCkgeyBnZXRSZXN1bHRIYW5kbGVyID0gdHJhbnNpdGlvbkhvb2tfMS5UcmFuc2l0aW9uSG9vay5IQU5ETEVfUkVTVUxUOyB9XG4gICAgICAgIGlmIChnZXRFcnJvckhhbmRsZXIgPT09IHZvaWQgMCkgeyBnZXRFcnJvckhhbmRsZXIgPSB0cmFuc2l0aW9uSG9va18xLlRyYW5zaXRpb25Ib29rLlJFSkVDVF9FUlJPUjsgfVxuICAgICAgICBpZiAoc3luY2hyb25vdXMgPT09IHZvaWQgMCkgeyBzeW5jaHJvbm91cyA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBldmVudFR5cGUgPSBuZXcgdHJhbnNpdGlvbkV2ZW50VHlwZV8xLlRyYW5zaXRpb25FdmVudFR5cGUobmFtZSwgaG9va1BoYXNlLCBob29rT3JkZXIsIGNyaXRlcmlhTWF0Y2hQYXRoLCByZXZlcnNlU29ydCwgZ2V0UmVzdWx0SGFuZGxlciwgZ2V0RXJyb3JIYW5kbGVyLCBzeW5jaHJvbm91cyk7XG4gICAgICAgIHRoaXMuX2V2ZW50VHlwZXMucHVzaChldmVudFR5cGUpO1xuICAgICAgICBob29rUmVnaXN0cnlfMS5tYWtlRXZlbnQodGhpcywgdGhpcywgZXZlbnRUeXBlKTtcbiAgICB9O1xuICAgIC8qKiBAaGlkZGVuICovIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZVxuICAgIFRyYW5zaXRpb25TZXJ2aWNlLnByb3RvdHlwZS5fZ2V0RXZlbnRzID0gZnVuY3Rpb24gKHBoYXNlKSB7XG4gICAgICAgIHZhciB0cmFuc2l0aW9uSG9va1R5cGVzID0gcHJlZGljYXRlc18xLmlzRGVmaW5lZChwaGFzZSkgP1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRUeXBlcy5maWx0ZXIoZnVuY3Rpb24gKHR5cGUpIHsgcmV0dXJuIHR5cGUuaG9va1BoYXNlID09PSBwaGFzZTsgfSkgOlxuICAgICAgICAgICAgdGhpcy5fZXZlbnRUeXBlcy5zbGljZSgpO1xuICAgICAgICByZXR1cm4gdHJhbnNpdGlvbkhvb2tUeXBlcy5zb3J0KGZ1bmN0aW9uIChsLCByKSB7XG4gICAgICAgICAgICB2YXIgY21wQnlQaGFzZSA9IGwuaG9va1BoYXNlIC0gci5ob29rUGhhc2U7XG4gICAgICAgICAgICByZXR1cm4gY21wQnlQaGFzZSA9PT0gMCA/IGwuaG9va09yZGVyIC0gci5ob29rT3JkZXIgOiBjbXBCeVBoYXNlO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZHMgYSBQYXRoIHRvIGJlIHVzZWQgYXMgYSBjcml0ZXJpb24gYWdhaW5zdCBhIFRyZWVDaGFuZ2VzIHBhdGhcbiAgICAgKlxuICAgICAqIEZvciBleGFtcGxlOiB0aGUgYGV4aXRpbmdgIHBhdGggaW4gW1tIb29rTWF0Y2hDcml0ZXJpYV1dIGlzIGEgU1RBVEUgc2NvcGVkIHBhdGguXG4gICAgICogSXQgd2FzIGRlZmluZWQgYnkgY2FsbGluZyBgZGVmaW5lVHJlZUNoYW5nZXNDcml0ZXJpb24oJ2V4aXRpbmcnLCBUcmFuc2l0aW9uSG9va1Njb3BlLlNUQVRFKWBcbiAgICAgKiBFYWNoIHN0YXRlIGluIHRoZSBleGl0aW5nIHBhdGggaXMgY2hlY2tlZCBhZ2FpbnN0IHRoZSBjcml0ZXJpYSBhbmQgcmV0dXJuZWQgYXMgcGFydCBvZiB0aGUgbWF0Y2guXG4gICAgICpcbiAgICAgKiBBbm90aGVyIGV4YW1wbGU6IHRoZSBgdG9gIHBhdGggaW4gW1tIb29rTWF0Y2hDcml0ZXJpYV1dIGlzIGEgVFJBTlNJVElPTiBzY29wZWQgcGF0aC5cbiAgICAgKiBJdCB3YXMgZGVmaW5lZCBieSBjYWxsaW5nIGBkZWZpbmVUcmVlQ2hhbmdlc0NyaXRlcmlvbigndG8nLCBUcmFuc2l0aW9uSG9va1Njb3BlLlRSQU5TSVRJT04pYFxuICAgICAqIE9ubHkgdGhlIHRhaWwgb2YgdGhlIGB0b2AgcGF0aCBpcyBjaGVja2VkIGFnYWluc3QgdGhlIGNyaXRlcmlhIGFuZCByZXR1cm5lZCBhcyBwYXJ0IG9mIHRoZSBtYXRjaC5cbiAgICAgKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBUcmFuc2l0aW9uU2VydmljZS5wcm90b3R5cGUuX2RlZmluZVBhdGhUeXBlID0gZnVuY3Rpb24gKG5hbWUsIGhvb2tTY29wZSkge1xuICAgICAgICB0aGlzLl9jcml0ZXJpYVBhdGhzW25hbWVdID0geyBuYW1lOiBuYW1lLCBzY29wZTogaG9va1Njb3BlIH07XG4gICAgfTtcbiAgICAvKiogKiBAaGlkZGVuICovIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZVxuICAgIFRyYW5zaXRpb25TZXJ2aWNlLnByb3RvdHlwZS5fZ2V0UGF0aFR5cGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY3JpdGVyaWFQYXRocztcbiAgICB9O1xuICAgIC8qKiBAaGlkZGVuICovXG4gICAgVHJhbnNpdGlvblNlcnZpY2UucHJvdG90eXBlLmdldEhvb2tzID0gZnVuY3Rpb24gKGhvb2tOYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWdpc3RlcmVkSG9va3NbaG9va05hbWVdO1xuICAgIH07XG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBUcmFuc2l0aW9uU2VydmljZS5wcm90b3R5cGUuX3JlZ2lzdGVyQ29yZVRyYW5zaXRpb25Ib29rcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGZucyA9IHRoaXMuX2RlcmVnaXN0ZXJIb29rRm5zO1xuICAgICAgICBmbnMuYWRkQ29yZVJlc29sdmVzID0gY29yZVJlc29sdmFibGVzXzEucmVnaXN0ZXJBZGRDb3JlUmVzb2x2YWJsZXModGhpcyk7XG4gICAgICAgIGZucy5pZ25vcmVkID0gaWdub3JlZFRyYW5zaXRpb25fMS5yZWdpc3Rlcklnbm9yZWRUcmFuc2l0aW9uSG9vayh0aGlzKTtcbiAgICAgICAgZm5zLmludmFsaWQgPSBpbnZhbGlkVHJhbnNpdGlvbl8xLnJlZ2lzdGVySW52YWxpZFRyYW5zaXRpb25Ib29rKHRoaXMpO1xuICAgICAgICAvLyBXaXJlIHVwIHJlZGlyZWN0VG8gaG9va1xuICAgICAgICBmbnMucmVkaXJlY3RUbyA9IHJlZGlyZWN0VG9fMS5yZWdpc3RlclJlZGlyZWN0VG9Ib29rKHRoaXMpO1xuICAgICAgICAvLyBXaXJlIHVwIG9uRXhpdC9SZXRhaW4vRW50ZXIgc3RhdGUgaG9va3NcbiAgICAgICAgZm5zLm9uRXhpdCA9IG9uRW50ZXJFeGl0UmV0YWluXzEucmVnaXN0ZXJPbkV4aXRIb29rKHRoaXMpO1xuICAgICAgICBmbnMub25SZXRhaW4gPSBvbkVudGVyRXhpdFJldGFpbl8xLnJlZ2lzdGVyT25SZXRhaW5Ib29rKHRoaXMpO1xuICAgICAgICBmbnMub25FbnRlciA9IG9uRW50ZXJFeGl0UmV0YWluXzEucmVnaXN0ZXJPbkVudGVySG9vayh0aGlzKTtcbiAgICAgICAgLy8gV2lyZSB1cCBSZXNvbHZlIGhvb2tzXG4gICAgICAgIGZucy5lYWdlclJlc29sdmUgPSByZXNvbHZlXzEucmVnaXN0ZXJFYWdlclJlc29sdmVQYXRoKHRoaXMpO1xuICAgICAgICBmbnMubGF6eVJlc29sdmUgPSByZXNvbHZlXzEucmVnaXN0ZXJMYXp5UmVzb2x2ZVN0YXRlKHRoaXMpO1xuICAgICAgICBmbnMucmVzb2x2ZUFsbCA9IHJlc29sdmVfMS5yZWdpc3RlclJlc29sdmVSZW1haW5pbmcodGhpcyk7XG4gICAgICAgIC8vIFdpcmUgdXAgdGhlIFZpZXcgbWFuYWdlbWVudCBob29rc1xuICAgICAgICBmbnMubG9hZFZpZXdzID0gdmlld3NfMS5yZWdpc3RlckxvYWRFbnRlcmluZ1ZpZXdzKHRoaXMpO1xuICAgICAgICBmbnMuYWN0aXZhdGVWaWV3cyA9IHZpZXdzXzEucmVnaXN0ZXJBY3RpdmF0ZVZpZXdzKHRoaXMpO1xuICAgICAgICAvLyBVcGRhdGVzIGdsb2JhbCBzdGF0ZSBhZnRlciBhIHRyYW5zaXRpb25cbiAgICAgICAgZm5zLnVwZGF0ZUdsb2JhbHMgPSB1cGRhdGVHbG9iYWxzXzEucmVnaXN0ZXJVcGRhdGVHbG9iYWxTdGF0ZSh0aGlzKTtcbiAgICAgICAgLy8gQWZ0ZXIgZ2xvYmFscy5jdXJyZW50IGlzIHVwZGF0ZWQgYXQgcHJpb3JpdHk6IDEwMDAwXG4gICAgICAgIGZucy51cGRhdGVVcmwgPSB1cmxfMS5yZWdpc3RlclVwZGF0ZVVybCh0aGlzKTtcbiAgICAgICAgLy8gTGF6eSBsb2FkIHN0YXRlIHRyZWVzXG4gICAgICAgIGZucy5sYXp5TG9hZCA9IGxhenlMb2FkXzEucmVnaXN0ZXJMYXp5TG9hZEhvb2sodGhpcyk7XG4gICAgfTtcbiAgICByZXR1cm4gVHJhbnNpdGlvblNlcnZpY2U7XG59KCkpO1xuZXhwb3J0cy5UcmFuc2l0aW9uU2VydmljZSA9IFRyYW5zaXRpb25TZXJ2aWNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhbnNpdGlvblNlcnZpY2UuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3RyYW5zaXRpb24vdHJhbnNpdGlvblNlcnZpY2UuanNcbi8vIG1vZHVsZSBpZCA9IDQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///47\n")},function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\nvar common_1 = __webpack_require__(5);\nexports.keyValsToObjectR = function (accum, _a) {\n    var key = _a[0], val = _a[1];\n    if (!accum.hasOwnProperty(key)) {\n        accum[key] = val;\n    }\n    else if (common_1.isArray(accum[key])) {\n        accum[key].push(val);\n    }\n    else {\n        accum[key] = [accum[key], val];\n    }\n    return accum;\n};\nexports.getParams = function (queryString) {\n    return queryString.split('&').filter(common_1.identity).map(common_1.splitEqual).reduce(exports.keyValsToObjectR, {});\n};\nfunction parseUrl(url) {\n    var orEmptyString = function (x) { return x || ''; };\n    var _a = common_1.splitHash(url).map(orEmptyString), beforehash = _a[0], hash = _a[1];\n    var _b = common_1.splitQuery(beforehash).map(orEmptyString), path = _b[0], search = _b[1];\n    return { path: path, search: search, hash: hash, url: url };\n}\nexports.parseUrl = parseUrl;\nexports.buildUrl = function (loc) {\n    var path = loc.path();\n    var searchObject = loc.search();\n    var hash = loc.hash();\n    var search = Object.keys(searchObject).map(function (key) {\n        var param = searchObject[key];\n        var vals = common_1.isArray(param) ? param : [param];\n        return vals.map(function (val) { return key + '=' + val; });\n    }).reduce(common_1.unnestR, []).join('&');\n    return path + (search ? '?' + search : '') + (hash ? '#' + hash : '');\n};\nfunction locationPluginFactory(name, isHtml5, serviceClass, configurationClass) {\n    return function (uiRouter) {\n        var service = uiRouter.locationService = new serviceClass(uiRouter);\n        var configuration = uiRouter.locationConfig = new configurationClass(uiRouter, isHtml5);\n        function dispose(router) {\n            router.dispose(service);\n            router.dispose(configuration);\n        }\n        return { name: name, service: service, configuration: configuration, dispose: dispose };\n    };\n}\nexports.locationPluginFactory = locationPluginFactory;\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3ZhbmlsbGEvdXRpbHMuanM/OWI3ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGludGVybmFsYXBpXG4gKiBAbW9kdWxlIHZhbmlsbGFcbiAqL1xuLyoqICovXG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uXCIpO1xuZXhwb3J0cy5rZXlWYWxzVG9PYmplY3RSID0gZnVuY3Rpb24gKGFjY3VtLCBfYSkge1xuICAgIHZhciBrZXkgPSBfYVswXSwgdmFsID0gX2FbMV07XG4gICAgaWYgKCFhY2N1bS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIGFjY3VtW2tleV0gPSB2YWw7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvbW1vbl8xLmlzQXJyYXkoYWNjdW1ba2V5XSkpIHtcbiAgICAgICAgYWNjdW1ba2V5XS5wdXNoKHZhbCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhY2N1bVtrZXldID0gW2FjY3VtW2tleV0sIHZhbF07XG4gICAgfVxuICAgIHJldHVybiBhY2N1bTtcbn07XG5leHBvcnRzLmdldFBhcmFtcyA9IGZ1bmN0aW9uIChxdWVyeVN0cmluZykge1xuICAgIHJldHVybiBxdWVyeVN0cmluZy5zcGxpdCgnJicpLmZpbHRlcihjb21tb25fMS5pZGVudGl0eSkubWFwKGNvbW1vbl8xLnNwbGl0RXF1YWwpLnJlZHVjZShleHBvcnRzLmtleVZhbHNUb09iamVjdFIsIHt9KTtcbn07XG5mdW5jdGlvbiBwYXJzZVVybCh1cmwpIHtcbiAgICB2YXIgb3JFbXB0eVN0cmluZyA9IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4IHx8ICcnOyB9O1xuICAgIHZhciBfYSA9IGNvbW1vbl8xLnNwbGl0SGFzaCh1cmwpLm1hcChvckVtcHR5U3RyaW5nKSwgYmVmb3JlaGFzaCA9IF9hWzBdLCBoYXNoID0gX2FbMV07XG4gICAgdmFyIF9iID0gY29tbW9uXzEuc3BsaXRRdWVyeShiZWZvcmVoYXNoKS5tYXAob3JFbXB0eVN0cmluZyksIHBhdGggPSBfYlswXSwgc2VhcmNoID0gX2JbMV07XG4gICAgcmV0dXJuIHsgcGF0aDogcGF0aCwgc2VhcmNoOiBzZWFyY2gsIGhhc2g6IGhhc2gsIHVybDogdXJsIH07XG59XG5leHBvcnRzLnBhcnNlVXJsID0gcGFyc2VVcmw7XG5leHBvcnRzLmJ1aWxkVXJsID0gZnVuY3Rpb24gKGxvYykge1xuICAgIHZhciBwYXRoID0gbG9jLnBhdGgoKTtcbiAgICB2YXIgc2VhcmNoT2JqZWN0ID0gbG9jLnNlYXJjaCgpO1xuICAgIHZhciBoYXNoID0gbG9jLmhhc2goKTtcbiAgICB2YXIgc2VhcmNoID0gT2JqZWN0LmtleXMoc2VhcmNoT2JqZWN0KS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgcGFyYW0gPSBzZWFyY2hPYmplY3Rba2V5XTtcbiAgICAgICAgdmFyIHZhbHMgPSBjb21tb25fMS5pc0FycmF5KHBhcmFtKSA/IHBhcmFtIDogW3BhcmFtXTtcbiAgICAgICAgcmV0dXJuIHZhbHMubWFwKGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIGtleSArICc9JyArIHZhbDsgfSk7XG4gICAgfSkucmVkdWNlKGNvbW1vbl8xLnVubmVzdFIsIFtdKS5qb2luKCcmJyk7XG4gICAgcmV0dXJuIHBhdGggKyAoc2VhcmNoID8gJz8nICsgc2VhcmNoIDogJycpICsgKGhhc2ggPyAnIycgKyBoYXNoIDogJycpO1xufTtcbmZ1bmN0aW9uIGxvY2F0aW9uUGx1Z2luRmFjdG9yeShuYW1lLCBpc0h0bWw1LCBzZXJ2aWNlQ2xhc3MsIGNvbmZpZ3VyYXRpb25DbGFzcykge1xuICAgIHJldHVybiBmdW5jdGlvbiAodWlSb3V0ZXIpIHtcbiAgICAgICAgdmFyIHNlcnZpY2UgPSB1aVJvdXRlci5sb2NhdGlvblNlcnZpY2UgPSBuZXcgc2VydmljZUNsYXNzKHVpUm91dGVyKTtcbiAgICAgICAgdmFyIGNvbmZpZ3VyYXRpb24gPSB1aVJvdXRlci5sb2NhdGlvbkNvbmZpZyA9IG5ldyBjb25maWd1cmF0aW9uQ2xhc3ModWlSb3V0ZXIsIGlzSHRtbDUpO1xuICAgICAgICBmdW5jdGlvbiBkaXNwb3NlKHJvdXRlcikge1xuICAgICAgICAgICAgcm91dGVyLmRpc3Bvc2Uoc2VydmljZSk7XG4gICAgICAgICAgICByb3V0ZXIuZGlzcG9zZShjb25maWd1cmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBuYW1lOiBuYW1lLCBzZXJ2aWNlOiBzZXJ2aWNlLCBjb25maWd1cmF0aW9uOiBjb25maWd1cmF0aW9uLCBkaXNwb3NlOiBkaXNwb3NlIH07XG4gICAgfTtcbn1cbmV4cG9ydHMubG9jYXRpb25QbHVnaW5GYWN0b3J5ID0gbG9jYXRpb25QbHVnaW5GYWN0b3J5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3ZhbmlsbGEvdXRpbHMuanNcbi8vIG1vZHVsZSBpZCA9IDQ4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///48\n")},function(module,exports,__webpack_require__){eval("// 7.1.1 ToPrimitive(input [, PreferredType])\nvar isObject = __webpack_require__(22);\n// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n// and the second argument - flag - preferred type is a string\nmodule.exports = function (it, S) {\n  if (!isObject(it)) return it;\n  var fn, val;\n  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;\n  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;\n  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;\n  throw TypeError(\"Can't convert object to primitive value\");\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLXByaW1pdGl2ZS5qcz8zMjYzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIDcuMS4xIFRvUHJpbWl0aXZlKGlucHV0IFssIFByZWZlcnJlZFR5cGVdKVxudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG4vLyBpbnN0ZWFkIG9mIHRoZSBFUzYgc3BlYyB2ZXJzaW9uLCB3ZSBkaWRuJ3QgaW1wbGVtZW50IEBAdG9QcmltaXRpdmUgY2FzZVxuLy8gYW5kIHRoZSBzZWNvbmQgYXJndW1lbnQgLSBmbGFnIC0gcHJlZmVycmVkIHR5cGUgaXMgYSBzdHJpbmdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCBTKSB7XG4gIGlmICghaXNPYmplY3QoaXQpKSByZXR1cm4gaXQ7XG4gIHZhciBmbiwgdmFsO1xuICBpZiAoUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKHR5cGVvZiAoZm4gPSBpdC52YWx1ZU9mKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGl0KSkpIHJldHVybiB2YWw7XG4gIGlmICghUyAmJiB0eXBlb2YgKGZuID0gaXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1wcmltaXRpdmUuanNcbi8vIG1vZHVsZSBpZCA9IDQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///49\n")},function(module,exports){eval("var toString = {}.toString;\n\nmodule.exports = function (it) {\n  return toString.call(it).slice(8, -1);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NvZi5qcz80N2QzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChpdCkuc2xpY2UoOCwgLTEpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jb2YuanNcbi8vIG1vZHVsZSBpZCA9IDUwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///50\n")},function(module,exports){eval('// 7.2.1 RequireObjectCoercible(argument)\nmodule.exports = function (it) {\n  if (it == undefined) throw TypeError("Can\'t call method on  " + it);\n  return it;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2RlZmluZWQuanM/ZTc2OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyA3LjIuMSBSZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGFyZ3VtZW50KVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGl0ID09IHVuZGVmaW5lZCkgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2RlZmluZWQuanNcbi8vIG1vZHVsZSBpZCA9IDUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///51\n')},function(module,exports){eval("// 7.1.4 ToInteger\nvar ceil = Math.ceil;\nvar floor = Math.floor;\nmodule.exports = function (it) {\n  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWludGVnZXIuanM/NTJlMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyA3LjEuNCBUb0ludGVnZXJcbnZhciBjZWlsID0gTWF0aC5jZWlsO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpc05hTihpdCA9ICtpdCkgPyAwIDogKGl0ID4gMCA/IGZsb29yIDogY2VpbCkoaXQpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1pbnRlZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA1MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///52\n")},function(module,exports,__webpack_require__){eval("var shared = __webpack_require__(54)('keys');\nvar uid = __webpack_require__(37);\nmodule.exports = function (key) {\n  return shared[key] || (shared[key] = uid(key));\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NoYXJlZC1rZXkuanM/NmIxZCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgc2hhcmVkID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ2tleXMnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuL191aWQnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gc2hhcmVkW2tleV0gfHwgKHNoYXJlZFtrZXldID0gdWlkKGtleSkpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zaGFyZWQta2V5LmpzXG4vLyBtb2R1bGUgaWQgPSA1M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///53\n")},function(module,exports,__webpack_require__){eval("var global = __webpack_require__(9);\nvar SHARED = '__core-js_shared__';\nvar store = global[SHARED] || (global[SHARED] = {});\nmodule.exports = function (key) {\n  return store[key] || (store[key] = {});\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NoYXJlZC5qcz83YmMwIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJztcbnZhciBzdG9yZSA9IGdsb2JhbFtTSEFSRURdIHx8IChnbG9iYWxbU0hBUkVEXSA9IHt9KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHt9KTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2hhcmVkLmpzXG4vLyBtb2R1bGUgaWQgPSA1NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///54\n")},function(module,exports){eval("// IE 8- don't enum bug keys\nmodule.exports = (\n  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'\n).split(',');\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2VudW0tYnVnLWtleXMuanM/YzY3NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJRSA4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgJ2NvbnN0cnVjdG9yLGhhc093blByb3BlcnR5LGlzUHJvdG90eXBlT2YscHJvcGVydHlJc0VudW1lcmFibGUsdG9Mb2NhbGVTdHJpbmcsdG9TdHJpbmcsdmFsdWVPZidcbikuc3BsaXQoJywnKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19lbnVtLWJ1Zy1rZXlzLmpzXG4vLyBtb2R1bGUgaWQgPSA1NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///55\n")},function(module,exports){eval("exports.f = Object.getOwnPropertySymbols;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BzLmpzP2Q2NDQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wcy5qc1xuLy8gbW9kdWxlIGlkID0gNTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///56\n")},function(module,exports,__webpack_require__){eval("// 7.1.13 ToObject(argument)\nvar defined = __webpack_require__(51);\nmodule.exports = function (it) {\n  return Object(defined(it));\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLW9iamVjdC5qcz9iMDFkIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIDcuMS4xMyBUb09iamVjdChhcmd1bWVudClcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIE9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLW9iamVjdC5qc1xuLy8gbW9kdWxlIGlkID0gNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///57\n")},function(module,exports,__webpack_require__){eval('module.exports = { "default": __webpack_require__(155), __esModule: true };//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL2dldC1pdGVyYXRvci5qcz8wNGVkIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9nZXQtaXRlcmF0b3JcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvZ2V0LWl0ZXJhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSA1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///58\n')},function(module,exports){eval("module.exports = true;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2xpYnJhcnkuanM/M2I4OCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHRydWU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fbGlicmFyeS5qc1xuLy8gbW9kdWxlIGlkID0gNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///59\n")},function(module,exports,__webpack_require__){eval("// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\nvar anObject = __webpack_require__(21);\nvar dPs = __webpack_require__(160);\nvar enumBugKeys = __webpack_require__(55);\nvar IE_PROTO = __webpack_require__(53)('IE_PROTO');\nvar Empty = function () { /* empty */ };\nvar PROTOTYPE = 'prototype';\n\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar createDict = function () {\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = __webpack_require__(97)('iframe');\n  var i = enumBugKeys.length;\n  var lt = '<';\n  var gt = '>';\n  var iframeDocument;\n  iframe.style.display = 'none';\n  __webpack_require__(161).appendChild(iframe);\n  iframe.src = 'javascript:'; // eslint-disable-line no-script-url\n  // createDict = iframe.contentWindow.Object;\n  // html.removeChild(iframe);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);\n  iframeDocument.close();\n  createDict = iframeDocument.F;\n  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];\n  return createDict();\n};\n\nmodule.exports = Object.create || function create(O, Properties) {\n  var result;\n  if (O !== null) {\n    Empty[PROTOTYPE] = anObject(O);\n    result = new Empty();\n    Empty[PROTOTYPE] = null;\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\n    result[IE_PROTO] = O;\n  } else result = createDict();\n  return Properties === undefined ? result : dPs(result, Properties);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1jcmVhdGUuanM/NjI4NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGRQcyA9IHJlcXVpcmUoJy4vX29iamVjdC1kcHMnKTtcbnZhciBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcbnZhciBFbXB0eSA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIGlmcmFtZSBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxudmFyIGNyZWF0ZURpY3QgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXG4gIHZhciBpZnJhbWUgPSByZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2lmcmFtZScpO1xuICB2YXIgaSA9IGVudW1CdWdLZXlzLmxlbmd0aDtcbiAgdmFyIGx0ID0gJzwnO1xuICB2YXIgZ3QgPSAnPic7XG4gIHZhciBpZnJhbWVEb2N1bWVudDtcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIHJlcXVpcmUoJy4vX2h0bWwnKS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zY3JpcHQtdXJsXG4gIC8vIGNyZWF0ZURpY3QgPSBpZnJhbWUuY29udGVudFdpbmRvdy5PYmplY3Q7XG4gIC8vIGh0bWwucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICBpZnJhbWVEb2N1bWVudC53cml0ZShsdCArICdzY3JpcHQnICsgZ3QgKyAnZG9jdW1lbnQuRj1PYmplY3QnICsgbHQgKyAnL3NjcmlwdCcgKyBndCk7XG4gIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XG4gIGNyZWF0ZURpY3QgPSBpZnJhbWVEb2N1bWVudC5GO1xuICB3aGlsZSAoaS0tKSBkZWxldGUgY3JlYXRlRGljdFtQUk9UT1RZUEVdW2VudW1CdWdLZXlzW2ldXTtcbiAgcmV0dXJuIGNyZWF0ZURpY3QoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcykge1xuICB2YXIgcmVzdWx0O1xuICBpZiAoTyAhPT0gbnVsbCkge1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBhbk9iamVjdChPKTtcbiAgICByZXN1bHQgPSBuZXcgRW1wdHkoKTtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gbnVsbDtcbiAgICAvLyBhZGQgXCJfX3Byb3RvX19cIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsXG4gICAgcmVzdWx0W0lFX1BST1RPXSA9IE87XG4gIH0gZWxzZSByZXN1bHQgPSBjcmVhdGVEaWN0KCk7XG4gIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiBkUHMocmVzdWx0LCBQcm9wZXJ0aWVzKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWNyZWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gNjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///60\n")},function(module,exports,__webpack_require__){eval("var def = __webpack_require__(12).f;\nvar has = __webpack_require__(14);\nvar TAG = __webpack_require__(10)('toStringTag');\n\nmodule.exports = function (it, tag, stat) {\n  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3NldC10by1zdHJpbmctdGFnLmpzPzdiYTkiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGRlZiA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0LCB0YWcsIHN0YXQpIHtcbiAgaWYgKGl0ICYmICFoYXMoaXQgPSBzdGF0ID8gaXQgOiBpdC5wcm90b3R5cGUsIFRBRykpIGRlZihpdCwgVEFHLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IHRhZyB9KTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2V0LXRvLXN0cmluZy10YWcuanNcbi8vIG1vZHVsZSBpZCA9IDYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///61\n")},function(module,exports,__webpack_require__){eval('module.exports = { "default": __webpack_require__(166), __esModule: true };//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL2pzb24vc3RyaW5naWZ5LmpzPzlhZjEiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL2pzb24vc3RyaW5naWZ5XCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL2pzb24vc3RyaW5naWZ5LmpzXG4vLyBtb2R1bGUgaWQgPSA2MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///62\n')},function(module,exports,__webpack_require__){"use strict";eval('\n\nexports.__esModule = true;\n\nvar _typeof2 = __webpack_require__(106);\n\nvar _typeof3 = _interopRequireDefault(_typeof2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = function (self, call) {\n  if (!self) {\n    throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called");\n  }\n\n  return call && ((typeof call === "undefined" ? "undefined" : (0, _typeof3.default)(call)) === "object" || typeof call === "function") ? call : self;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4uanM/Y2YwYSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF90eXBlb2YyID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvdHlwZW9mXCIpO1xuXG52YXIgX3R5cGVvZjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90eXBlb2YyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKHNlbGYsIGNhbGwpIHtcbiAgaWYgKCFzZWxmKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIGNhbGwgJiYgKCh0eXBlb2YgY2FsbCA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiAoMCwgX3R5cGVvZjMuZGVmYXVsdCkoY2FsbCkpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuLmpzXG4vLyBtb2R1bGUgaWQgPSA2M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///63\n')},function(module,exports,__webpack_require__){eval("exports.f = __webpack_require__(10);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy1leHQuanM/MmExZSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnRzLmYgPSByZXF1aXJlKCcuL193a3MnKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL193a3MtZXh0LmpzXG4vLyBtb2R1bGUgaWQgPSA2NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///64\n")},function(module,exports,__webpack_require__){eval("var global = __webpack_require__(9);\nvar core = __webpack_require__(4);\nvar LIBRARY = __webpack_require__(59);\nvar wksExt = __webpack_require__(64);\nvar defineProperty = __webpack_require__(12).f;\nmodule.exports = function (name) {\n  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});\n  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3drcy1kZWZpbmUuanM/NzJiOSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgY29yZSA9IHJlcXVpcmUoJy4vX2NvcmUnKTtcbnZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xudmFyIHdrc0V4dCA9IHJlcXVpcmUoJy4vX3drcy1leHQnKTtcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHZhciAkU3ltYm9sID0gY29yZS5TeW1ib2wgfHwgKGNvcmUuU3ltYm9sID0gTElCUkFSWSA/IHt9IDogZ2xvYmFsLlN5bWJvbCB8fCB7fSk7XG4gIGlmIChuYW1lLmNoYXJBdCgwKSAhPSAnXycgJiYgIShuYW1lIGluICRTeW1ib2wpKSBkZWZpbmVQcm9wZXJ0eSgkU3ltYm9sLCBuYW1lLCB7IHZhbHVlOiB3a3NFeHQuZihuYW1lKSB9KTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fd2tzLWRlZmluZS5qc1xuLy8gbW9kdWxlIGlkID0gNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///65\n")},function(module,exports,__webpack_require__){eval("var pIE = __webpack_require__(38);\nvar createDesc = __webpack_require__(35);\nvar toIObject = __webpack_require__(15);\nvar toPrimitive = __webpack_require__(49);\nvar has = __webpack_require__(14);\nvar IE8_DOM_DEFINE = __webpack_require__(96);\nvar gOPD = Object.getOwnPropertyDescriptor;\n\nexports.f = __webpack_require__(13) ? gOPD : function getOwnPropertyDescriptor(O, P) {\n  O = toIObject(O);\n  P = toPrimitive(P, true);\n  if (IE8_DOM_DEFINE) try {\n    return gOPD(O, P);\n  } catch (e) { /* empty */ }\n  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1nb3BkLmpzPzJjYTYiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHBJRSA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKTtcbnZhciBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vX3RvLXByaW1pdGl2ZScpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIElFOF9ET01fREVGSU5FID0gcmVxdWlyZSgnLi9faWU4LWRvbS1kZWZpbmUnKTtcbnZhciBnT1BEID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuZXhwb3J0cy5mID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSA/IGdPUEQgOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCkge1xuICBPID0gdG9JT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gZ09QRChPLCBQKTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG4gIGlmIChoYXMoTywgUCkpIHJldHVybiBjcmVhdGVEZXNjKCFwSUUuZi5jYWxsKE8sIFApLCBPW1BdKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcGQuanNcbi8vIG1vZHVsZSBpZCA9IDY2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///66\n")},function(module,exports,__webpack_require__){"use strict";eval('\n\nexports.__esModule = true;\n\nvar _getPrototypeOf = __webpack_require__(41);\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _getOwnPropertyDescriptor = __webpack_require__(181);\n\nvar _getOwnPropertyDescriptor2 = _interopRequireDefault(_getOwnPropertyDescriptor);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = function get(object, property, receiver) {\n  if (object === null) object = Function.prototype;\n  var desc = (0, _getOwnPropertyDescriptor2.default)(object, property);\n\n  if (desc === undefined) {\n    var parent = (0, _getPrototypeOf2.default)(object);\n\n    if (parent === null) {\n      return undefined;\n    } else {\n      return get(parent, property, receiver);\n    }\n  } else if ("value" in desc) {\n    return desc.value;\n  } else {\n    var getter = desc.get;\n\n    if (getter === undefined) {\n      return undefined;\n    }\n\n    return getter.call(receiver);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL2dldC5qcz9jODRiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2dldFByb3RvdHlwZU9mID0gcmVxdWlyZShcIi4uL2NvcmUtanMvb2JqZWN0L2dldC1wcm90b3R5cGUtb2ZcIik7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0UHJvdG90eXBlT2YpO1xuXG52YXIgX2dldE93blByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL29iamVjdC9nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JcIik7XG5cbnZhciBfZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldE93blByb3BlcnR5RGVzY3JpcHRvcik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG4gIHZhciBkZXNjID0gKDAsIF9nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IyLmRlZmF1bHQpKG9iamVjdCwgcHJvcGVydHkpO1xuXG4gIGlmIChkZXNjID09PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgcGFyZW50ID0gKDAsIF9nZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkob2JqZWN0KTtcblxuICAgIGlmIChwYXJlbnQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykge1xuICAgIHJldHVybiBkZXNjLnZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHZhciBnZXR0ZXIgPSBkZXNjLmdldDtcblxuICAgIGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpO1xuICB9XG59O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy9nZXQuanNcbi8vIG1vZHVsZSBpZCA9IDY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///67\n')},function(module,exports,__webpack_require__){"use strict";eval('\n\nexports.__esModule = true;\n\nvar _setPrototypeOf = __webpack_require__(184);\n\nvar _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);\n\nvar _create = __webpack_require__(188);\n\nvar _create2 = _interopRequireDefault(_create);\n\nvar _typeof2 = __webpack_require__(106);\n\nvar _typeof3 = _interopRequireDefault(_typeof2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = function (subClass, superClass) {\n  if (typeof superClass !== "function" && superClass !== null) {\n    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : (0, _typeof3.default)(superClass)));\n  }\n\n  subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL2luaGVyaXRzLmpzPzNkZmQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiLi4vY29yZS1qcy9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZlwiKTtcblxudmFyIF9zZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zZXRQcm90b3R5cGVPZik7XG5cbnZhciBfY3JlYXRlID0gcmVxdWlyZShcIi4uL2NvcmUtanMvb2JqZWN0L2NyZWF0ZVwiKTtcblxudmFyIF9jcmVhdGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlKTtcblxudmFyIF90eXBlb2YyID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvdHlwZW9mXCIpO1xuXG52YXIgX3R5cGVvZjMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90eXBlb2YyKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArICh0eXBlb2Ygc3VwZXJDbGFzcyA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiAoMCwgX3R5cGVvZjMuZGVmYXVsdCkoc3VwZXJDbGFzcykpKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9ICgwLCBfY3JlYXRlMi5kZWZhdWx0KShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mMi5kZWZhdWx0ID8gKDAsIF9zZXRQcm90b3R5cGVPZjIuZGVmYXVsdCkoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9oZWxwZXJzL2luaGVyaXRzLmpzXG4vLyBtb2R1bGUgaWQgPSA2OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///68\n')},function(module,exports){eval('/** \n* @license ng-prettyjson - v0.2.0\n* (c) 2013 Julien VALERY https://github.com/darul75/ng-prettyjson\n* License: MIT \n**/\n!function(a){"use strict";a.module("ngPrettyJson",[]).directive("prettyJson",["$compile","$templateCache","ngPrettyJsonFunctions",function(b,c,d){var e=a.isDefined;return{restrict:"AE",scope:{json:"=",prettyJson:"=",onEdit:"&"},template:"<div></div>",replace:!0,link:function(f,g,h){var i={},j=null;f.id=h.id||"prettyjson",f.editActivated=!1,f.edition=h.edition,f.aceEditor=void 0!==window.ace;\n// compile template\nvar k=b(c.get("ng-prettyjson/ng-prettyjson-panel.tmpl.html"))(f,function(a,b){b.tmplElt=a});g.removeAttr("id"),g.append(k);\n// prefer the "json" attribute over the "prettyJson" one.\n// the value on the scope might not be defined yet, so look at the markup.\nvar l,m=e(h.json)?"json":"prettyJson",n=function(a){var b=d.syntaxHighlight(a)||"";return b=b.replace(/\\{/g,"<span class=\'sep\'>{</span>").replace(/\\}/g,"<span class=\'sep\'>}</span>").replace(/\\[/g,"<span class=\'sep\'>[</span>").replace(/\\]/g,"<span class=\'sep\'>]</span>").replace(/\\,/g,"<span class=\'sep\'>,</span>"),e(a)?f.tmplElt.find("pre").html(b):f.tmplElt.find("pre").empty()};l=f.$watch(m,function(b){\n// BACKWARDS COMPATIBILITY:\n// if newValue is an object, and we find a `json` property,\n// then stop watching on `exp`.\na.isObject(b)&&e(b.json)?(l(),f.$watch(m+".json",function(a){f.editActivated||n(a),i=a},!0)):(f.editActivated||n(b),i=b),j&&(j.removeListener("change",o),j.setValue(JSON.stringify(b,null,"\t")),j.on("change",o),j.resize())},!0);var o=function(a){try{i=JSON.parse(j.getValue()),f.parsable=!0}catch(b){f.parsable=!1}\n// trigger update\nf.$apply(function(){})},p=i;f.edit=function(){return f.aceEditor?(f.editActivated?(j&&(document.getElementById(f.id).env=null),n(p),i=p,f.parsable=!1):(p=i,j=ace.edit(f.id),j.setAutoScrollEditorIntoView(!0),j.setOptions({maxLines:1/0}),j.on("change",o),j.getSession().setMode("ace/mode/json")),void(f.editActivated=!f.editActivated)):void(console&&console.log("\'ace lib is missing\'"))},f.update=function(){f[m]=i,f.$emit("json-updated",i),f.onEdit&&f.onEdit({newJson:i}),this.edit()}}}}]).factory("ngPrettyJsonFunctions",function(){\n// cache some regular expressions\nvar b={entities:/((&)|(<)|(>))/g,json:/"(\\\\u[a-zA-Z0-9]{4}|\\\\[^u]|[^\\\\"])*"(\\s*:)?|\\b(true|false|(null))\\b|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g},c=["&amp;","&lt;","&gt;"],d=["number","string","key","boolean","null"],e=function(){var a=arguments.length-2;do a--;while(!arguments[a]);return a},f=function(a){var b;\n// the final two arguments are the length, and the entire string itself;\n// we don\'t care about those.\nif(arguments.length<7)throw new Error("markup() must be called from String.prototype.replace()");return b=e.apply(null,arguments),\'<span class="\'+d[b]+\'">\'+a+"</span>"},g=function(){var a;if(arguments.length<5)throw new Error("makeEntities() must be called from String.prototype.replace()");return a=e.apply(null,arguments),c[a-2]},h=function(c){return a.isString(c)||(c=JSON.stringify(c,null,2)),a.isDefined(c)?c.replace(b.entities,g).replace(b.json,f):void 0};return{syntaxHighlight:h,makeEntities:g,markup:f,rx:b}})}(window.angular),function(a){"use strict";a.module("ngPrettyJson").run(["$templateCache",function(a){a.put("ng-prettyjson/ng-prettyjson-panel.tmpl.html",\'<div><button type="button" ng-click="edit()" ng-show="edition && !editActivated">Edit</button><button type="button" ng-click="edit()" ng-show="edition && editActivated">Cancel</button><button type="button" ng-click="update()" ng-show="editActivated && parsable">Update</button><pre class="pretty-json" id="{{id}}"></pre></div>\')}])}(window.angular);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmctcHJldHR5anNvbi9kaXN0L25nLXByZXR0eWpzb24ubWluLmpzP2Y4ZjciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIFxuKiBAbGljZW5zZSBuZy1wcmV0dHlqc29uIC0gdjAuMi4wXG4qIChjKSAyMDEzIEp1bGllbiBWQUxFUlkgaHR0cHM6Ly9naXRodWIuY29tL2RhcnVsNzUvbmctcHJldHR5anNvblxuKiBMaWNlbnNlOiBNSVQgXG4qKi9cbiFmdW5jdGlvbihhKXtcInVzZSBzdHJpY3RcIjthLm1vZHVsZShcIm5nUHJldHR5SnNvblwiLFtdKS5kaXJlY3RpdmUoXCJwcmV0dHlKc29uXCIsW1wiJGNvbXBpbGVcIixcIiR0ZW1wbGF0ZUNhY2hlXCIsXCJuZ1ByZXR0eUpzb25GdW5jdGlvbnNcIixmdW5jdGlvbihiLGMsZCl7dmFyIGU9YS5pc0RlZmluZWQ7cmV0dXJue3Jlc3RyaWN0OlwiQUVcIixzY29wZTp7anNvbjpcIj1cIixwcmV0dHlKc29uOlwiPVwiLG9uRWRpdDpcIiZcIn0sdGVtcGxhdGU6XCI8ZGl2PjwvZGl2PlwiLHJlcGxhY2U6ITAsbGluazpmdW5jdGlvbihmLGcsaCl7dmFyIGk9e30saj1udWxsO2YuaWQ9aC5pZHx8XCJwcmV0dHlqc29uXCIsZi5lZGl0QWN0aXZhdGVkPSExLGYuZWRpdGlvbj1oLmVkaXRpb24sZi5hY2VFZGl0b3I9dm9pZCAwIT09d2luZG93LmFjZTtcbi8vIGNvbXBpbGUgdGVtcGxhdGVcbnZhciBrPWIoYy5nZXQoXCJuZy1wcmV0dHlqc29uL25nLXByZXR0eWpzb24tcGFuZWwudG1wbC5odG1sXCIpKShmLGZ1bmN0aW9uKGEsYil7Yi50bXBsRWx0PWF9KTtnLnJlbW92ZUF0dHIoXCJpZFwiKSxnLmFwcGVuZChrKTtcbi8vIHByZWZlciB0aGUgXCJqc29uXCIgYXR0cmlidXRlIG92ZXIgdGhlIFwicHJldHR5SnNvblwiIG9uZS5cbi8vIHRoZSB2YWx1ZSBvbiB0aGUgc2NvcGUgbWlnaHQgbm90IGJlIGRlZmluZWQgeWV0LCBzbyBsb29rIGF0IHRoZSBtYXJrdXAuXG52YXIgbCxtPWUoaC5qc29uKT9cImpzb25cIjpcInByZXR0eUpzb25cIixuPWZ1bmN0aW9uKGEpe3ZhciBiPWQuc3ludGF4SGlnaGxpZ2h0KGEpfHxcIlwiO3JldHVybiBiPWIucmVwbGFjZSgvXFx7L2csXCI8c3BhbiBjbGFzcz0nc2VwJz57PC9zcGFuPlwiKS5yZXBsYWNlKC9cXH0vZyxcIjxzcGFuIGNsYXNzPSdzZXAnPn08L3NwYW4+XCIpLnJlcGxhY2UoL1xcWy9nLFwiPHNwYW4gY2xhc3M9J3NlcCc+Wzwvc3Bhbj5cIikucmVwbGFjZSgvXFxdL2csXCI8c3BhbiBjbGFzcz0nc2VwJz5dPC9zcGFuPlwiKS5yZXBsYWNlKC9cXCwvZyxcIjxzcGFuIGNsYXNzPSdzZXAnPiw8L3NwYW4+XCIpLGUoYSk/Zi50bXBsRWx0LmZpbmQoXCJwcmVcIikuaHRtbChiKTpmLnRtcGxFbHQuZmluZChcInByZVwiKS5lbXB0eSgpfTtsPWYuJHdhdGNoKG0sZnVuY3Rpb24oYil7XG4vLyBCQUNLV0FSRFMgQ09NUEFUSUJJTElUWTpcbi8vIGlmIG5ld1ZhbHVlIGlzIGFuIG9iamVjdCwgYW5kIHdlIGZpbmQgYSBganNvbmAgcHJvcGVydHksXG4vLyB0aGVuIHN0b3Agd2F0Y2hpbmcgb24gYGV4cGAuXG5hLmlzT2JqZWN0KGIpJiZlKGIuanNvbik/KGwoKSxmLiR3YXRjaChtK1wiLmpzb25cIixmdW5jdGlvbihhKXtmLmVkaXRBY3RpdmF0ZWR8fG4oYSksaT1hfSwhMCkpOihmLmVkaXRBY3RpdmF0ZWR8fG4oYiksaT1iKSxqJiYoai5yZW1vdmVMaXN0ZW5lcihcImNoYW5nZVwiLG8pLGouc2V0VmFsdWUoSlNPTi5zdHJpbmdpZnkoYixudWxsLFwiXHRcIikpLGoub24oXCJjaGFuZ2VcIixvKSxqLnJlc2l6ZSgpKX0sITApO3ZhciBvPWZ1bmN0aW9uKGEpe3RyeXtpPUpTT04ucGFyc2Uoai5nZXRWYWx1ZSgpKSxmLnBhcnNhYmxlPSEwfWNhdGNoKGIpe2YucGFyc2FibGU9ITF9XG4vLyB0cmlnZ2VyIHVwZGF0ZVxuZi4kYXBwbHkoZnVuY3Rpb24oKXt9KX0scD1pO2YuZWRpdD1mdW5jdGlvbigpe3JldHVybiBmLmFjZUVkaXRvcj8oZi5lZGl0QWN0aXZhdGVkPyhqJiYoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZi5pZCkuZW52PW51bGwpLG4ocCksaT1wLGYucGFyc2FibGU9ITEpOihwPWksaj1hY2UuZWRpdChmLmlkKSxqLnNldEF1dG9TY3JvbGxFZGl0b3JJbnRvVmlldyghMCksai5zZXRPcHRpb25zKHttYXhMaW5lczoxLzB9KSxqLm9uKFwiY2hhbmdlXCIsbyksai5nZXRTZXNzaW9uKCkuc2V0TW9kZShcImFjZS9tb2RlL2pzb25cIikpLHZvaWQoZi5lZGl0QWN0aXZhdGVkPSFmLmVkaXRBY3RpdmF0ZWQpKTp2b2lkKGNvbnNvbGUmJmNvbnNvbGUubG9nKFwiJ2FjZSBsaWIgaXMgbWlzc2luZydcIikpfSxmLnVwZGF0ZT1mdW5jdGlvbigpe2ZbbV09aSxmLiRlbWl0KFwianNvbi11cGRhdGVkXCIsaSksZi5vbkVkaXQmJmYub25FZGl0KHtuZXdKc29uOml9KSx0aGlzLmVkaXQoKX19fX1dKS5mYWN0b3J5KFwibmdQcmV0dHlKc29uRnVuY3Rpb25zXCIsZnVuY3Rpb24oKXtcbi8vIGNhY2hlIHNvbWUgcmVndWxhciBleHByZXNzaW9uc1xudmFyIGI9e2VudGl0aWVzOi8oKCYpfCg8KXwoPikpL2csanNvbjovXCIoXFxcXHVbYS16QS1aMC05XXs0fXxcXFxcW151XXxbXlxcXFxcIl0pKlwiKFxccyo6KT98XFxiKHRydWV8ZmFsc2V8KG51bGwpKVxcYnwtP1xcZCsoPzpcXC5cXGQqKT8oPzpbZUVdWytcXC1dP1xcZCspPy9nfSxjPVtcIiZhbXA7XCIsXCImbHQ7XCIsXCImZ3Q7XCJdLGQ9W1wibnVtYmVyXCIsXCJzdHJpbmdcIixcImtleVwiLFwiYm9vbGVhblwiLFwibnVsbFwiXSxlPWZ1bmN0aW9uKCl7dmFyIGE9YXJndW1lbnRzLmxlbmd0aC0yO2RvIGEtLTt3aGlsZSghYXJndW1lbnRzW2FdKTtyZXR1cm4gYX0sZj1mdW5jdGlvbihhKXt2YXIgYjtcbi8vIHRoZSBmaW5hbCB0d28gYXJndW1lbnRzIGFyZSB0aGUgbGVuZ3RoLCBhbmQgdGhlIGVudGlyZSBzdHJpbmcgaXRzZWxmO1xuLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCB0aG9zZS5cbmlmKGFyZ3VtZW50cy5sZW5ndGg8Nyl0aHJvdyBuZXcgRXJyb3IoXCJtYXJrdXAoKSBtdXN0IGJlIGNhbGxlZCBmcm9tIFN0cmluZy5wcm90b3R5cGUucmVwbGFjZSgpXCIpO3JldHVybiBiPWUuYXBwbHkobnVsbCxhcmd1bWVudHMpLCc8c3BhbiBjbGFzcz1cIicrZFtiXSsnXCI+JythK1wiPC9zcGFuPlwifSxnPWZ1bmN0aW9uKCl7dmFyIGE7aWYoYXJndW1lbnRzLmxlbmd0aDw1KXRocm93IG5ldyBFcnJvcihcIm1ha2VFbnRpdGllcygpIG11c3QgYmUgY2FsbGVkIGZyb20gU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlKClcIik7cmV0dXJuIGE9ZS5hcHBseShudWxsLGFyZ3VtZW50cyksY1thLTJdfSxoPWZ1bmN0aW9uKGMpe3JldHVybiBhLmlzU3RyaW5nKGMpfHwoYz1KU09OLnN0cmluZ2lmeShjLG51bGwsMikpLGEuaXNEZWZpbmVkKGMpP2MucmVwbGFjZShiLmVudGl0aWVzLGcpLnJlcGxhY2UoYi5qc29uLGYpOnZvaWQgMH07cmV0dXJue3N5bnRheEhpZ2hsaWdodDpoLG1ha2VFbnRpdGllczpnLG1hcmt1cDpmLHJ4OmJ9fSl9KHdpbmRvdy5hbmd1bGFyKSxmdW5jdGlvbihhKXtcInVzZSBzdHJpY3RcIjthLm1vZHVsZShcIm5nUHJldHR5SnNvblwiKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIixmdW5jdGlvbihhKXthLnB1dChcIm5nLXByZXR0eWpzb24vbmctcHJldHR5anNvbi1wYW5lbC50bXBsLmh0bWxcIiwnPGRpdj48YnV0dG9uIHR5cGU9XCJidXR0b25cIiBuZy1jbGljaz1cImVkaXQoKVwiIG5nLXNob3c9XCJlZGl0aW9uICYmICFlZGl0QWN0aXZhdGVkXCI+RWRpdDwvYnV0dG9uPjxidXR0b24gdHlwZT1cImJ1dHRvblwiIG5nLWNsaWNrPVwiZWRpdCgpXCIgbmctc2hvdz1cImVkaXRpb24gJiYgZWRpdEFjdGl2YXRlZFwiPkNhbmNlbDwvYnV0dG9uPjxidXR0b24gdHlwZT1cImJ1dHRvblwiIG5nLWNsaWNrPVwidXBkYXRlKClcIiBuZy1zaG93PVwiZWRpdEFjdGl2YXRlZCAmJiBwYXJzYWJsZVwiPlVwZGF0ZTwvYnV0dG9uPjxwcmUgY2xhc3M9XCJwcmV0dHktanNvblwiIGlkPVwie3tpZH19XCI+PC9wcmU+PC9kaXY+Jyl9XSl9KHdpbmRvdy5hbmd1bGFyKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9uZy1wcmV0dHlqc29uL2Rpc3QvbmctcHJldHR5anNvbi5taW4uanNcbi8vIG1vZHVsZSBpZCA9IDY5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///69\n')},function(module,exports,__webpack_require__){"use strict";eval("\n/**\n * @coreapi\n * @module transition\n */ /** for typedoc */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar common_1 = __webpack_require__(0);\nvar predicates_1 = __webpack_require__(1);\nvar interface_1 = __webpack_require__(16);\nvar transitionHook_1 = __webpack_require__(25);\n/**\n * This class returns applicable TransitionHooks for a specific Transition instance.\n *\n * Hooks ([[RegisteredHook]]) may be registered globally, e.g., $transitions.onEnter(...), or locally, e.g.\n * myTransition.onEnter(...).  The HookBuilder finds matching RegisteredHooks (where the match criteria is\n * determined by the type of hook)\n *\n * The HookBuilder also converts RegisteredHooks objects to TransitionHook objects, which are used to run a Transition.\n *\n * The HookBuilder constructor is given the $transitions service and a Transition instance.  Thus, a HookBuilder\n * instance may only be used for one specific Transition object. (side note: the _treeChanges accessor is private\n * in the Transition class, so we must also provide the Transition's _treeChanges)\n *\n */\nvar HookBuilder = /** @class */ (function () {\n    function HookBuilder(transition) {\n        this.transition = transition;\n    }\n    HookBuilder.prototype.buildHooksForPhase = function (phase) {\n        var _this = this;\n        var $transitions = this.transition.router.transitionService;\n        return $transitions._pluginapi._getEvents(phase)\n            .map(function (type) { return _this.buildHooks(type); })\n            .reduce(common_1.unnestR, [])\n            .filter(common_1.identity);\n    };\n    /**\n     * Returns an array of newly built TransitionHook objects.\n     *\n     * - Finds all RegisteredHooks registered for the given `hookType` which matched the transition's [[TreeChanges]].\n     * - Finds [[PathNode]] (or `PathNode[]`) to use as the TransitionHook context(s)\n     * - For each of the [[PathNode]]s, creates a TransitionHook\n     *\n     * @param hookType the type of the hook registration function, e.g., 'onEnter', 'onFinish'.\n     */\n    HookBuilder.prototype.buildHooks = function (hookType) {\n        var transition = this.transition;\n        var treeChanges = transition.treeChanges();\n        // Find all the matching registered hooks for a given hook type\n        var matchingHooks = this.getMatchingHooks(hookType, treeChanges);\n        if (!matchingHooks)\n            return [];\n        var baseHookOptions = {\n            transition: transition,\n            current: transition.options().current,\n        };\n        var makeTransitionHooks = function (hook) {\n            // Fetch the Nodes that caused this hook to match.\n            var matches = hook.matches(treeChanges);\n            // Select the PathNode[] that will be used as TransitionHook context objects\n            var matchingNodes = matches[hookType.criteriaMatchPath.name];\n            // Return an array of HookTuples\n            return matchingNodes.map(function (node) {\n                var _options = common_1.extend({\n                    bind: hook.bind,\n                    traceData: { hookType: hookType.name, context: node },\n                }, baseHookOptions);\n                var state = hookType.criteriaMatchPath.scope === interface_1.TransitionHookScope.STATE ? node.state.self : null;\n                var transitionHook = new transitionHook_1.TransitionHook(transition, state, hook, _options);\n                return { hook: hook, node: node, transitionHook: transitionHook };\n            });\n        };\n        return matchingHooks.map(makeTransitionHooks)\n            .reduce(common_1.unnestR, [])\n            .sort(tupleSort(hookType.reverseSort))\n            .map(function (tuple) { return tuple.transitionHook; });\n    };\n    /**\n     * Finds all RegisteredHooks from:\n     * - The Transition object instance hook registry\n     * - The TransitionService ($transitions) global hook registry\n     *\n     * which matched:\n     * - the eventType\n     * - the matchCriteria (to, from, exiting, retained, entering)\n     *\n     * @returns an array of matched [[RegisteredHook]]s\n     */\n    HookBuilder.prototype.getMatchingHooks = function (hookType, treeChanges) {\n        var isCreate = hookType.hookPhase === interface_1.TransitionHookPhase.CREATE;\n        // Instance and Global hook registries\n        var $transitions = this.transition.router.transitionService;\n        var registries = isCreate ? [$transitions] : [this.transition, $transitions];\n        return registries.map(function (reg) { return reg.getHooks(hookType.name); }) // Get named hooks from registries\n            .filter(common_1.assertPredicate(predicates_1.isArray, \"broken event named: \" + hookType.name)) // Sanity check\n            .reduce(common_1.unnestR, []) // Un-nest RegisteredHook[][] to RegisteredHook[] array\n            .filter(function (hook) { return hook.matches(treeChanges); }); // Only those satisfying matchCriteria\n    };\n    return HookBuilder;\n}());\nexports.HookBuilder = HookBuilder;\n/**\n * A factory for a sort function for HookTuples.\n *\n * The sort function first compares the PathNode depth (how deep in the state tree a node is), then compares\n * the EventHook priority.\n *\n * @param reverseDepthSort a boolean, when true, reverses the sort order for the node depth\n * @returns a tuple sort function\n */\nfunction tupleSort(reverseDepthSort) {\n    if (reverseDepthSort === void 0) { reverseDepthSort = false; }\n    return function nodeDepthThenPriority(l, r) {\n        var factor = reverseDepthSort ? -1 : 1;\n        var depthDelta = (l.node.state.path.length - r.node.state.path.length) * factor;\n        return depthDelta !== 0 ? depthDelta : r.hook.priority - l.hook.priority;\n    };\n}\n//# sourceMappingURL=hookBuilder.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3RyYW5zaXRpb24vaG9va0J1aWxkZXIuanM/Yzg1ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGNvcmVhcGlcbiAqIEBtb2R1bGUgdHJhbnNpdGlvblxuICovIC8qKiBmb3IgdHlwZWRvYyAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb21tb25cIik7XG52YXIgcHJlZGljYXRlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9wcmVkaWNhdGVzXCIpO1xudmFyIGludGVyZmFjZV8xID0gcmVxdWlyZShcIi4vaW50ZXJmYWNlXCIpO1xudmFyIHRyYW5zaXRpb25Ib29rXzEgPSByZXF1aXJlKFwiLi90cmFuc2l0aW9uSG9va1wiKTtcbi8qKlxuICogVGhpcyBjbGFzcyByZXR1cm5zIGFwcGxpY2FibGUgVHJhbnNpdGlvbkhvb2tzIGZvciBhIHNwZWNpZmljIFRyYW5zaXRpb24gaW5zdGFuY2UuXG4gKlxuICogSG9va3MgKFtbUmVnaXN0ZXJlZEhvb2tdXSkgbWF5IGJlIHJlZ2lzdGVyZWQgZ2xvYmFsbHksIGUuZy4sICR0cmFuc2l0aW9ucy5vbkVudGVyKC4uLiksIG9yIGxvY2FsbHksIGUuZy5cbiAqIG15VHJhbnNpdGlvbi5vbkVudGVyKC4uLikuICBUaGUgSG9va0J1aWxkZXIgZmluZHMgbWF0Y2hpbmcgUmVnaXN0ZXJlZEhvb2tzICh3aGVyZSB0aGUgbWF0Y2ggY3JpdGVyaWEgaXNcbiAqIGRldGVybWluZWQgYnkgdGhlIHR5cGUgb2YgaG9vaylcbiAqXG4gKiBUaGUgSG9va0J1aWxkZXIgYWxzbyBjb252ZXJ0cyBSZWdpc3RlcmVkSG9va3Mgb2JqZWN0cyB0byBUcmFuc2l0aW9uSG9vayBvYmplY3RzLCB3aGljaCBhcmUgdXNlZCB0byBydW4gYSBUcmFuc2l0aW9uLlxuICpcbiAqIFRoZSBIb29rQnVpbGRlciBjb25zdHJ1Y3RvciBpcyBnaXZlbiB0aGUgJHRyYW5zaXRpb25zIHNlcnZpY2UgYW5kIGEgVHJhbnNpdGlvbiBpbnN0YW5jZS4gIFRodXMsIGEgSG9va0J1aWxkZXJcbiAqIGluc3RhbmNlIG1heSBvbmx5IGJlIHVzZWQgZm9yIG9uZSBzcGVjaWZpYyBUcmFuc2l0aW9uIG9iamVjdC4gKHNpZGUgbm90ZTogdGhlIF90cmVlQ2hhbmdlcyBhY2Nlc3NvciBpcyBwcml2YXRlXG4gKiBpbiB0aGUgVHJhbnNpdGlvbiBjbGFzcywgc28gd2UgbXVzdCBhbHNvIHByb3ZpZGUgdGhlIFRyYW5zaXRpb24ncyBfdHJlZUNoYW5nZXMpXG4gKlxuICovXG52YXIgSG9va0J1aWxkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSG9va0J1aWxkZXIodHJhbnNpdGlvbikge1xuICAgICAgICB0aGlzLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uO1xuICAgIH1cbiAgICBIb29rQnVpbGRlci5wcm90b3R5cGUuYnVpbGRIb29rc0ZvclBoYXNlID0gZnVuY3Rpb24gKHBoYXNlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAkdHJhbnNpdGlvbnMgPSB0aGlzLnRyYW5zaXRpb24ucm91dGVyLnRyYW5zaXRpb25TZXJ2aWNlO1xuICAgICAgICByZXR1cm4gJHRyYW5zaXRpb25zLl9wbHVnaW5hcGkuX2dldEV2ZW50cyhwaGFzZSlcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHR5cGUpIHsgcmV0dXJuIF90aGlzLmJ1aWxkSG9va3ModHlwZSk7IH0pXG4gICAgICAgICAgICAucmVkdWNlKGNvbW1vbl8xLnVubmVzdFIsIFtdKVxuICAgICAgICAgICAgLmZpbHRlcihjb21tb25fMS5pZGVudGl0eSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIG5ld2x5IGJ1aWx0IFRyYW5zaXRpb25Ib29rIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiAtIEZpbmRzIGFsbCBSZWdpc3RlcmVkSG9va3MgcmVnaXN0ZXJlZCBmb3IgdGhlIGdpdmVuIGBob29rVHlwZWAgd2hpY2ggbWF0Y2hlZCB0aGUgdHJhbnNpdGlvbidzIFtbVHJlZUNoYW5nZXNdXS5cbiAgICAgKiAtIEZpbmRzIFtbUGF0aE5vZGVdXSAob3IgYFBhdGhOb2RlW11gKSB0byB1c2UgYXMgdGhlIFRyYW5zaXRpb25Ib29rIGNvbnRleHQocylcbiAgICAgKiAtIEZvciBlYWNoIG9mIHRoZSBbW1BhdGhOb2RlXV1zLCBjcmVhdGVzIGEgVHJhbnNpdGlvbkhvb2tcbiAgICAgKlxuICAgICAqIEBwYXJhbSBob29rVHlwZSB0aGUgdHlwZSBvZiB0aGUgaG9vayByZWdpc3RyYXRpb24gZnVuY3Rpb24sIGUuZy4sICdvbkVudGVyJywgJ29uRmluaXNoJy5cbiAgICAgKi9cbiAgICBIb29rQnVpbGRlci5wcm90b3R5cGUuYnVpbGRIb29rcyA9IGZ1bmN0aW9uIChob29rVHlwZSkge1xuICAgICAgICB2YXIgdHJhbnNpdGlvbiA9IHRoaXMudHJhbnNpdGlvbjtcbiAgICAgICAgdmFyIHRyZWVDaGFuZ2VzID0gdHJhbnNpdGlvbi50cmVlQ2hhbmdlcygpO1xuICAgICAgICAvLyBGaW5kIGFsbCB0aGUgbWF0Y2hpbmcgcmVnaXN0ZXJlZCBob29rcyBmb3IgYSBnaXZlbiBob29rIHR5cGVcbiAgICAgICAgdmFyIG1hdGNoaW5nSG9va3MgPSB0aGlzLmdldE1hdGNoaW5nSG9va3MoaG9va1R5cGUsIHRyZWVDaGFuZ2VzKTtcbiAgICAgICAgaWYgKCFtYXRjaGluZ0hvb2tzKVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB2YXIgYmFzZUhvb2tPcHRpb25zID0ge1xuICAgICAgICAgICAgdHJhbnNpdGlvbjogdHJhbnNpdGlvbixcbiAgICAgICAgICAgIGN1cnJlbnQ6IHRyYW5zaXRpb24ub3B0aW9ucygpLmN1cnJlbnQsXG4gICAgICAgIH07XG4gICAgICAgIHZhciBtYWtlVHJhbnNpdGlvbkhvb2tzID0gZnVuY3Rpb24gKGhvb2spIHtcbiAgICAgICAgICAgIC8vIEZldGNoIHRoZSBOb2RlcyB0aGF0IGNhdXNlZCB0aGlzIGhvb2sgdG8gbWF0Y2guXG4gICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IGhvb2subWF0Y2hlcyh0cmVlQ2hhbmdlcyk7XG4gICAgICAgICAgICAvLyBTZWxlY3QgdGhlIFBhdGhOb2RlW10gdGhhdCB3aWxsIGJlIHVzZWQgYXMgVHJhbnNpdGlvbkhvb2sgY29udGV4dCBvYmplY3RzXG4gICAgICAgICAgICB2YXIgbWF0Y2hpbmdOb2RlcyA9IG1hdGNoZXNbaG9va1R5cGUuY3JpdGVyaWFNYXRjaFBhdGgubmFtZV07XG4gICAgICAgICAgICAvLyBSZXR1cm4gYW4gYXJyYXkgb2YgSG9va1R1cGxlc1xuICAgICAgICAgICAgcmV0dXJuIG1hdGNoaW5nTm9kZXMubWFwKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9vcHRpb25zID0gY29tbW9uXzEuZXh0ZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgYmluZDogaG9vay5iaW5kLFxuICAgICAgICAgICAgICAgICAgICB0cmFjZURhdGE6IHsgaG9va1R5cGU6IGhvb2tUeXBlLm5hbWUsIGNvbnRleHQ6IG5vZGUgfSxcbiAgICAgICAgICAgICAgICB9LCBiYXNlSG9va09wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHZhciBzdGF0ZSA9IGhvb2tUeXBlLmNyaXRlcmlhTWF0Y2hQYXRoLnNjb3BlID09PSBpbnRlcmZhY2VfMS5UcmFuc2l0aW9uSG9va1Njb3BlLlNUQVRFID8gbm9kZS5zdGF0ZS5zZWxmIDogbnVsbDtcbiAgICAgICAgICAgICAgICB2YXIgdHJhbnNpdGlvbkhvb2sgPSBuZXcgdHJhbnNpdGlvbkhvb2tfMS5UcmFuc2l0aW9uSG9vayh0cmFuc2l0aW9uLCBzdGF0ZSwgaG9vaywgX29wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGhvb2s6IGhvb2ssIG5vZGU6IG5vZGUsIHRyYW5zaXRpb25Ib29rOiB0cmFuc2l0aW9uSG9vayB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBtYXRjaGluZ0hvb2tzLm1hcChtYWtlVHJhbnNpdGlvbkhvb2tzKVxuICAgICAgICAgICAgLnJlZHVjZShjb21tb25fMS51bm5lc3RSLCBbXSlcbiAgICAgICAgICAgIC5zb3J0KHR1cGxlU29ydChob29rVHlwZS5yZXZlcnNlU29ydCkpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uICh0dXBsZSkgeyByZXR1cm4gdHVwbGUudHJhbnNpdGlvbkhvb2s7IH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRmluZHMgYWxsIFJlZ2lzdGVyZWRIb29rcyBmcm9tOlxuICAgICAqIC0gVGhlIFRyYW5zaXRpb24gb2JqZWN0IGluc3RhbmNlIGhvb2sgcmVnaXN0cnlcbiAgICAgKiAtIFRoZSBUcmFuc2l0aW9uU2VydmljZSAoJHRyYW5zaXRpb25zKSBnbG9iYWwgaG9vayByZWdpc3RyeVxuICAgICAqXG4gICAgICogd2hpY2ggbWF0Y2hlZDpcbiAgICAgKiAtIHRoZSBldmVudFR5cGVcbiAgICAgKiAtIHRoZSBtYXRjaENyaXRlcmlhICh0bywgZnJvbSwgZXhpdGluZywgcmV0YWluZWQsIGVudGVyaW5nKVxuICAgICAqXG4gICAgICogQHJldHVybnMgYW4gYXJyYXkgb2YgbWF0Y2hlZCBbW1JlZ2lzdGVyZWRIb29rXV1zXG4gICAgICovXG4gICAgSG9va0J1aWxkZXIucHJvdG90eXBlLmdldE1hdGNoaW5nSG9va3MgPSBmdW5jdGlvbiAoaG9va1R5cGUsIHRyZWVDaGFuZ2VzKSB7XG4gICAgICAgIHZhciBpc0NyZWF0ZSA9IGhvb2tUeXBlLmhvb2tQaGFzZSA9PT0gaW50ZXJmYWNlXzEuVHJhbnNpdGlvbkhvb2tQaGFzZS5DUkVBVEU7XG4gICAgICAgIC8vIEluc3RhbmNlIGFuZCBHbG9iYWwgaG9vayByZWdpc3RyaWVzXG4gICAgICAgIHZhciAkdHJhbnNpdGlvbnMgPSB0aGlzLnRyYW5zaXRpb24ucm91dGVyLnRyYW5zaXRpb25TZXJ2aWNlO1xuICAgICAgICB2YXIgcmVnaXN0cmllcyA9IGlzQ3JlYXRlID8gWyR0cmFuc2l0aW9uc10gOiBbdGhpcy50cmFuc2l0aW9uLCAkdHJhbnNpdGlvbnNdO1xuICAgICAgICByZXR1cm4gcmVnaXN0cmllcy5tYXAoZnVuY3Rpb24gKHJlZykgeyByZXR1cm4gcmVnLmdldEhvb2tzKGhvb2tUeXBlLm5hbWUpOyB9KSAvLyBHZXQgbmFtZWQgaG9va3MgZnJvbSByZWdpc3RyaWVzXG4gICAgICAgICAgICAuZmlsdGVyKGNvbW1vbl8xLmFzc2VydFByZWRpY2F0ZShwcmVkaWNhdGVzXzEuaXNBcnJheSwgXCJicm9rZW4gZXZlbnQgbmFtZWQ6IFwiICsgaG9va1R5cGUubmFtZSkpIC8vIFNhbml0eSBjaGVja1xuICAgICAgICAgICAgLnJlZHVjZShjb21tb25fMS51bm5lc3RSLCBbXSkgLy8gVW4tbmVzdCBSZWdpc3RlcmVkSG9va1tdW10gdG8gUmVnaXN0ZXJlZEhvb2tbXSBhcnJheVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoaG9vaykgeyByZXR1cm4gaG9vay5tYXRjaGVzKHRyZWVDaGFuZ2VzKTsgfSk7IC8vIE9ubHkgdGhvc2Ugc2F0aXNmeWluZyBtYXRjaENyaXRlcmlhXG4gICAgfTtcbiAgICByZXR1cm4gSG9va0J1aWxkZXI7XG59KCkpO1xuZXhwb3J0cy5Ib29rQnVpbGRlciA9IEhvb2tCdWlsZGVyO1xuLyoqXG4gKiBBIGZhY3RvcnkgZm9yIGEgc29ydCBmdW5jdGlvbiBmb3IgSG9va1R1cGxlcy5cbiAqXG4gKiBUaGUgc29ydCBmdW5jdGlvbiBmaXJzdCBjb21wYXJlcyB0aGUgUGF0aE5vZGUgZGVwdGggKGhvdyBkZWVwIGluIHRoZSBzdGF0ZSB0cmVlIGEgbm9kZSBpcyksIHRoZW4gY29tcGFyZXNcbiAqIHRoZSBFdmVudEhvb2sgcHJpb3JpdHkuXG4gKlxuICogQHBhcmFtIHJldmVyc2VEZXB0aFNvcnQgYSBib29sZWFuLCB3aGVuIHRydWUsIHJldmVyc2VzIHRoZSBzb3J0IG9yZGVyIGZvciB0aGUgbm9kZSBkZXB0aFxuICogQHJldHVybnMgYSB0dXBsZSBzb3J0IGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIHR1cGxlU29ydChyZXZlcnNlRGVwdGhTb3J0KSB7XG4gICAgaWYgKHJldmVyc2VEZXB0aFNvcnQgPT09IHZvaWQgMCkgeyByZXZlcnNlRGVwdGhTb3J0ID0gZmFsc2U7IH1cbiAgICByZXR1cm4gZnVuY3Rpb24gbm9kZURlcHRoVGhlblByaW9yaXR5KGwsIHIpIHtcbiAgICAgICAgdmFyIGZhY3RvciA9IHJldmVyc2VEZXB0aFNvcnQgPyAtMSA6IDE7XG4gICAgICAgIHZhciBkZXB0aERlbHRhID0gKGwubm9kZS5zdGF0ZS5wYXRoLmxlbmd0aCAtIHIubm9kZS5zdGF0ZS5wYXRoLmxlbmd0aCkgKiBmYWN0b3I7XG4gICAgICAgIHJldHVybiBkZXB0aERlbHRhICE9PSAwID8gZGVwdGhEZWx0YSA6IHIuaG9vay5wcmlvcml0eSAtIGwuaG9vay5wcmlvcml0eTtcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aG9va0J1aWxkZXIuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3RyYW5zaXRpb24vaG9va0J1aWxkZXIuanNcbi8vIG1vZHVsZSBpZCA9IDcwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///70\n")},function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @internalapi */\nexports.resolvePolicies = {\n    when: {\n        LAZY: 'LAZY',\n        EAGER: 'EAGER',\n    },\n    async: {\n        WAIT: 'WAIT',\n        NOWAIT: 'NOWAIT',\n        RXWAIT: 'RXWAIT',\n    },\n};\n//# sourceMappingURL=interface.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3Jlc29sdmUvaW50ZXJmYWNlLmpzP2I4ZWYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKiogQGludGVybmFsYXBpICovXG5leHBvcnRzLnJlc29sdmVQb2xpY2llcyA9IHtcbiAgICB3aGVuOiB7XG4gICAgICAgIExBWlk6ICdMQVpZJyxcbiAgICAgICAgRUFHRVI6ICdFQUdFUicsXG4gICAgfSxcbiAgICBhc3luYzoge1xuICAgICAgICBXQUlUOiAnV0FJVCcsXG4gICAgICAgIE5PV0FJVDogJ05PV0FJVCcsXG4gICAgICAgIFJYV0FJVDogJ1JYV0FJVCcsXG4gICAgfSxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnRlcmZhY2UuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3Jlc29sdmUvaW50ZXJmYWNlLmpzXG4vLyBtb2R1bGUgaWQgPSA3MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///71\n")},function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @coreapi\n * @module params\n */\n/** */\nvar common_1 = __webpack_require__(0);\nvar predicates_1 = __webpack_require__(1);\nvar hof_1 = __webpack_require__(2);\nvar coreservices_1 = __webpack_require__(3);\nvar paramType_1 = __webpack_require__(46);\n/**\n * A registry for parameter types.\n *\n * This registry manages the built-in (and custom) parameter types.\n *\n * The built-in parameter types are:\n *\n * - [[string]]\n * - [[path]]\n * - [[query]]\n * - [[hash]]\n * - [[int]]\n * - [[bool]]\n * - [[date]]\n * - [[json]]\n * - [[any]]\n */\nvar ParamTypes = /** @class */ (function () {\n    /** @internalapi */\n    function ParamTypes() {\n        /** @hidden */\n        this.enqueue = true;\n        /** @hidden */\n        this.typeQueue = [];\n        /** @internalapi */\n        this.defaultTypes = common_1.pick(ParamTypes.prototype, ['hash', 'string', 'query', 'path', 'int', 'bool', 'date', 'json', 'any']);\n        // Register default types. Store them in the prototype of this.types.\n        var makeType = function (definition, name) {\n            return new paramType_1.ParamType(common_1.extend({ name: name }, definition));\n        };\n        this.types = common_1.inherit(common_1.map(this.defaultTypes, makeType), {});\n    }\n    /** @internalapi */\n    ParamTypes.prototype.dispose = function () {\n        this.types = {};\n    };\n    /**\n     * Registers a parameter type\n     *\n     * End users should call [[UrlMatcherFactory.type]], which delegates to this method.\n     */\n    ParamTypes.prototype.type = function (name, definition, definitionFn) {\n        if (!predicates_1.isDefined(definition))\n            return this.types[name];\n        if (this.types.hasOwnProperty(name))\n            throw new Error(\"A type named '\" + name + \"' has already been defined.\");\n        this.types[name] = new paramType_1.ParamType(common_1.extend({ name: name }, definition));\n        if (definitionFn) {\n            this.typeQueue.push({ name: name, def: definitionFn });\n            if (!this.enqueue)\n                this._flushTypeQueue();\n        }\n        return this;\n    };\n    /** @internalapi */\n    ParamTypes.prototype._flushTypeQueue = function () {\n        while (this.typeQueue.length) {\n            var type = this.typeQueue.shift();\n            if (type.pattern)\n                throw new Error(\"You cannot override a type's .pattern at runtime.\");\n            common_1.extend(this.types[type.name], coreservices_1.services.$injector.invoke(type.def));\n        }\n    };\n    return ParamTypes;\n}());\nexports.ParamTypes = ParamTypes;\n/** @hidden */\nfunction initDefaultTypes() {\n    var makeDefaultType = function (def) {\n        var valToString = function (val) {\n            return val != null ? val.toString() : val;\n        };\n        var defaultTypeBase = {\n            encode: valToString,\n            decode: valToString,\n            is: hof_1.is(String),\n            pattern: /.*/,\n            // tslint:disable-next-line:triple-equals\n            equals: function (a, b) { return a == b; },\n        };\n        return common_1.extend({}, defaultTypeBase, def);\n    };\n    // Default Parameter Type Definitions\n    common_1.extend(ParamTypes.prototype, {\n        string: makeDefaultType({}),\n        path: makeDefaultType({\n            pattern: /[^/]*/,\n        }),\n        query: makeDefaultType({}),\n        hash: makeDefaultType({\n            inherit: false,\n        }),\n        int: makeDefaultType({\n            decode: function (val) { return parseInt(val, 10); },\n            is: function (val) {\n                return !predicates_1.isNullOrUndefined(val) && this.decode(val.toString()) === val;\n            },\n            pattern: /-?\\d+/,\n        }),\n        bool: makeDefaultType({\n            encode: function (val) { return val && 1 || 0; },\n            decode: function (val) { return parseInt(val, 10) !== 0; },\n            is: hof_1.is(Boolean),\n            pattern: /0|1/,\n        }),\n        date: makeDefaultType({\n            encode: function (val) {\n                return !this.is(val) ? undefined : [\n                    val.getFullYear(),\n                    ('0' + (val.getMonth() + 1)).slice(-2),\n                    ('0' + val.getDate()).slice(-2),\n                ].join('-');\n            },\n            decode: function (val) {\n                if (this.is(val))\n                    return val;\n                var match = this.capture.exec(val);\n                return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;\n            },\n            is: function (val) { return val instanceof Date && !isNaN(val.valueOf()); },\n            equals: function (l, r) {\n                return ['getFullYear', 'getMonth', 'getDate']\n                    .reduce(function (acc, fn) { return acc && l[fn]() === r[fn](); }, true);\n            },\n            pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,\n            capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/,\n        }),\n        json: makeDefaultType({\n            encode: common_1.toJson,\n            decode: common_1.fromJson,\n            is: hof_1.is(Object),\n            equals: common_1.equals,\n            pattern: /[^/]*/,\n        }),\n        // does not encode/decode\n        any: makeDefaultType({\n            encode: common_1.identity,\n            decode: common_1.identity,\n            is: function () { return true; },\n            equals: common_1.equals,\n        }),\n    });\n}\ninitDefaultTypes();\n//# sourceMappingURL=paramTypes.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3BhcmFtcy9wYXJhbVR5cGVzLmpzP2YzNzQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEBjb3JlYXBpXG4gKiBAbW9kdWxlIHBhcmFtc1xuICovXG4vKiogKi9cbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29tbW9uXCIpO1xudmFyIHByZWRpY2F0ZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vcHJlZGljYXRlc1wiKTtcbnZhciBob2ZfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vaG9mXCIpO1xudmFyIGNvcmVzZXJ2aWNlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb3Jlc2VydmljZXNcIik7XG52YXIgcGFyYW1UeXBlXzEgPSByZXF1aXJlKFwiLi9wYXJhbVR5cGVcIik7XG4vKipcbiAqIEEgcmVnaXN0cnkgZm9yIHBhcmFtZXRlciB0eXBlcy5cbiAqXG4gKiBUaGlzIHJlZ2lzdHJ5IG1hbmFnZXMgdGhlIGJ1aWx0LWluIChhbmQgY3VzdG9tKSBwYXJhbWV0ZXIgdHlwZXMuXG4gKlxuICogVGhlIGJ1aWx0LWluIHBhcmFtZXRlciB0eXBlcyBhcmU6XG4gKlxuICogLSBbW3N0cmluZ11dXG4gKiAtIFtbcGF0aF1dXG4gKiAtIFtbcXVlcnldXVxuICogLSBbW2hhc2hdXVxuICogLSBbW2ludF1dXG4gKiAtIFtbYm9vbF1dXG4gKiAtIFtbZGF0ZV1dXG4gKiAtIFtbanNvbl1dXG4gKiAtIFtbYW55XV1cbiAqL1xudmFyIFBhcmFtVHlwZXMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqIEBpbnRlcm5hbGFwaSAqL1xuICAgIGZ1bmN0aW9uIFBhcmFtVHlwZXMoKSB7XG4gICAgICAgIC8qKiBAaGlkZGVuICovXG4gICAgICAgIHRoaXMuZW5xdWV1ZSA9IHRydWU7XG4gICAgICAgIC8qKiBAaGlkZGVuICovXG4gICAgICAgIHRoaXMudHlwZVF1ZXVlID0gW107XG4gICAgICAgIC8qKiBAaW50ZXJuYWxhcGkgKi9cbiAgICAgICAgdGhpcy5kZWZhdWx0VHlwZXMgPSBjb21tb25fMS5waWNrKFBhcmFtVHlwZXMucHJvdG90eXBlLCBbJ2hhc2gnLCAnc3RyaW5nJywgJ3F1ZXJ5JywgJ3BhdGgnLCAnaW50JywgJ2Jvb2wnLCAnZGF0ZScsICdqc29uJywgJ2FueSddKTtcbiAgICAgICAgLy8gUmVnaXN0ZXIgZGVmYXVsdCB0eXBlcy4gU3RvcmUgdGhlbSBpbiB0aGUgcHJvdG90eXBlIG9mIHRoaXMudHlwZXMuXG4gICAgICAgIHZhciBtYWtlVHlwZSA9IGZ1bmN0aW9uIChkZWZpbml0aW9uLCBuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHBhcmFtVHlwZV8xLlBhcmFtVHlwZShjb21tb25fMS5leHRlbmQoeyBuYW1lOiBuYW1lIH0sIGRlZmluaXRpb24pKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy50eXBlcyA9IGNvbW1vbl8xLmluaGVyaXQoY29tbW9uXzEubWFwKHRoaXMuZGVmYXVsdFR5cGVzLCBtYWtlVHlwZSksIHt9KTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbGFwaSAqL1xuICAgIFBhcmFtVHlwZXMucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudHlwZXMgPSB7fTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIHBhcmFtZXRlciB0eXBlXG4gICAgICpcbiAgICAgKiBFbmQgdXNlcnMgc2hvdWxkIGNhbGwgW1tVcmxNYXRjaGVyRmFjdG9yeS50eXBlXV0sIHdoaWNoIGRlbGVnYXRlcyB0byB0aGlzIG1ldGhvZC5cbiAgICAgKi9cbiAgICBQYXJhbVR5cGVzLnByb3RvdHlwZS50eXBlID0gZnVuY3Rpb24gKG5hbWUsIGRlZmluaXRpb24sIGRlZmluaXRpb25Gbikge1xuICAgICAgICBpZiAoIXByZWRpY2F0ZXNfMS5pc0RlZmluZWQoZGVmaW5pdGlvbikpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50eXBlc1tuYW1lXTtcbiAgICAgICAgaWYgKHRoaXMudHlwZXMuaGFzT3duUHJvcGVydHkobmFtZSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBIHR5cGUgbmFtZWQgJ1wiICsgbmFtZSArIFwiJyBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQuXCIpO1xuICAgICAgICB0aGlzLnR5cGVzW25hbWVdID0gbmV3IHBhcmFtVHlwZV8xLlBhcmFtVHlwZShjb21tb25fMS5leHRlbmQoeyBuYW1lOiBuYW1lIH0sIGRlZmluaXRpb24pKTtcbiAgICAgICAgaWYgKGRlZmluaXRpb25Gbikge1xuICAgICAgICAgICAgdGhpcy50eXBlUXVldWUucHVzaCh7IG5hbWU6IG5hbWUsIGRlZjogZGVmaW5pdGlvbkZuIH0pO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmVucXVldWUpXG4gICAgICAgICAgICAgICAgdGhpcy5fZmx1c2hUeXBlUXVldWUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWxhcGkgKi9cbiAgICBQYXJhbVR5cGVzLnByb3RvdHlwZS5fZmx1c2hUeXBlUXVldWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLnR5cGVRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gdGhpcy50eXBlUXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgIGlmICh0eXBlLnBhdHRlcm4pXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IGNhbm5vdCBvdmVycmlkZSBhIHR5cGUncyAucGF0dGVybiBhdCBydW50aW1lLlwiKTtcbiAgICAgICAgICAgIGNvbW1vbl8xLmV4dGVuZCh0aGlzLnR5cGVzW3R5cGUubmFtZV0sIGNvcmVzZXJ2aWNlc18xLnNlcnZpY2VzLiRpbmplY3Rvci5pbnZva2UodHlwZS5kZWYpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFBhcmFtVHlwZXM7XG59KCkpO1xuZXhwb3J0cy5QYXJhbVR5cGVzID0gUGFyYW1UeXBlcztcbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiBpbml0RGVmYXVsdFR5cGVzKCkge1xuICAgIHZhciBtYWtlRGVmYXVsdFR5cGUgPSBmdW5jdGlvbiAoZGVmKSB7XG4gICAgICAgIHZhciB2YWxUb1N0cmluZyA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWwgIT0gbnVsbCA/IHZhbC50b1N0cmluZygpIDogdmFsO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgZGVmYXVsdFR5cGVCYXNlID0ge1xuICAgICAgICAgICAgZW5jb2RlOiB2YWxUb1N0cmluZyxcbiAgICAgICAgICAgIGRlY29kZTogdmFsVG9TdHJpbmcsXG4gICAgICAgICAgICBpczogaG9mXzEuaXMoU3RyaW5nKSxcbiAgICAgICAgICAgIHBhdHRlcm46IC8uKi8sXG4gICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6dHJpcGxlLWVxdWFsc1xuICAgICAgICAgICAgZXF1YWxzOiBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYSA9PSBiOyB9LFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gY29tbW9uXzEuZXh0ZW5kKHt9LCBkZWZhdWx0VHlwZUJhc2UsIGRlZik7XG4gICAgfTtcbiAgICAvLyBEZWZhdWx0IFBhcmFtZXRlciBUeXBlIERlZmluaXRpb25zXG4gICAgY29tbW9uXzEuZXh0ZW5kKFBhcmFtVHlwZXMucHJvdG90eXBlLCB7XG4gICAgICAgIHN0cmluZzogbWFrZURlZmF1bHRUeXBlKHt9KSxcbiAgICAgICAgcGF0aDogbWFrZURlZmF1bHRUeXBlKHtcbiAgICAgICAgICAgIHBhdHRlcm46IC9bXi9dKi8sXG4gICAgICAgIH0pLFxuICAgICAgICBxdWVyeTogbWFrZURlZmF1bHRUeXBlKHt9KSxcbiAgICAgICAgaGFzaDogbWFrZURlZmF1bHRUeXBlKHtcbiAgICAgICAgICAgIGluaGVyaXQ6IGZhbHNlLFxuICAgICAgICB9KSxcbiAgICAgICAgaW50OiBtYWtlRGVmYXVsdFR5cGUoe1xuICAgICAgICAgICAgZGVjb2RlOiBmdW5jdGlvbiAodmFsKSB7IHJldHVybiBwYXJzZUludCh2YWwsIDEwKTsgfSxcbiAgICAgICAgICAgIGlzOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFwcmVkaWNhdGVzXzEuaXNOdWxsT3JVbmRlZmluZWQodmFsKSAmJiB0aGlzLmRlY29kZSh2YWwudG9TdHJpbmcoKSkgPT09IHZhbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXR0ZXJuOiAvLT9cXGQrLyxcbiAgICAgICAgfSksXG4gICAgICAgIGJvb2w6IG1ha2VEZWZhdWx0VHlwZSh7XG4gICAgICAgICAgICBlbmNvZGU6IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIHZhbCAmJiAxIHx8IDA7IH0sXG4gICAgICAgICAgICBkZWNvZGU6IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIHBhcnNlSW50KHZhbCwgMTApICE9PSAwOyB9LFxuICAgICAgICAgICAgaXM6IGhvZl8xLmlzKEJvb2xlYW4pLFxuICAgICAgICAgICAgcGF0dGVybjogLzB8MS8sXG4gICAgICAgIH0pLFxuICAgICAgICBkYXRlOiBtYWtlRGVmYXVsdFR5cGUoe1xuICAgICAgICAgICAgZW5jb2RlOiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICF0aGlzLmlzKHZhbCkgPyB1bmRlZmluZWQgOiBbXG4gICAgICAgICAgICAgICAgICAgIHZhbC5nZXRGdWxsWWVhcigpLFxuICAgICAgICAgICAgICAgICAgICAoJzAnICsgKHZhbC5nZXRNb250aCgpICsgMSkpLnNsaWNlKC0yKSxcbiAgICAgICAgICAgICAgICAgICAgKCcwJyArIHZhbC5nZXREYXRlKCkpLnNsaWNlKC0yKSxcbiAgICAgICAgICAgICAgICBdLmpvaW4oJy0nKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZWNvZGU6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pcyh2YWwpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IHRoaXMuY2FwdHVyZS5leGVjKHZhbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoID8gbmV3IERhdGUobWF0Y2hbMV0sIG1hdGNoWzJdIC0gMSwgbWF0Y2hbM10pIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzOiBmdW5jdGlvbiAodmFsKSB7IHJldHVybiB2YWwgaW5zdGFuY2VvZiBEYXRlICYmICFpc05hTih2YWwudmFsdWVPZigpKTsgfSxcbiAgICAgICAgICAgIGVxdWFsczogZnVuY3Rpb24gKGwsIHIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWydnZXRGdWxsWWVhcicsICdnZXRNb250aCcsICdnZXREYXRlJ11cbiAgICAgICAgICAgICAgICAgICAgLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBmbikgeyByZXR1cm4gYWNjICYmIGxbZm5dKCkgPT09IHJbZm5dKCk7IH0sIHRydWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhdHRlcm46IC9bMC05XXs0fS0oPzowWzEtOV18MVswLTJdKS0oPzowWzEtOV18WzEtMl1bMC05XXwzWzAtMV0pLyxcbiAgICAgICAgICAgIGNhcHR1cmU6IC8oWzAtOV17NH0pLSgwWzEtOV18MVswLTJdKS0oMFsxLTldfFsxLTJdWzAtOV18M1swLTFdKS8sXG4gICAgICAgIH0pLFxuICAgICAgICBqc29uOiBtYWtlRGVmYXVsdFR5cGUoe1xuICAgICAgICAgICAgZW5jb2RlOiBjb21tb25fMS50b0pzb24sXG4gICAgICAgICAgICBkZWNvZGU6IGNvbW1vbl8xLmZyb21Kc29uLFxuICAgICAgICAgICAgaXM6IGhvZl8xLmlzKE9iamVjdCksXG4gICAgICAgICAgICBlcXVhbHM6IGNvbW1vbl8xLmVxdWFscyxcbiAgICAgICAgICAgIHBhdHRlcm46IC9bXi9dKi8sXG4gICAgICAgIH0pLFxuICAgICAgICAvLyBkb2VzIG5vdCBlbmNvZGUvZGVjb2RlXG4gICAgICAgIGFueTogbWFrZURlZmF1bHRUeXBlKHtcbiAgICAgICAgICAgIGVuY29kZTogY29tbW9uXzEuaWRlbnRpdHksXG4gICAgICAgICAgICBkZWNvZGU6IGNvbW1vbl8xLmlkZW50aXR5LFxuICAgICAgICAgICAgaXM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRydWU7IH0sXG4gICAgICAgICAgICBlcXVhbHM6IGNvbW1vbl8xLmVxdWFscyxcbiAgICAgICAgfSksXG4gICAgfSk7XG59XG5pbml0RGVmYXVsdFR5cGVzKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJhbVR5cGVzLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9wYXJhbXMvcGFyYW1UeXBlcy5qc1xuLy8gbW9kdWxlIGlkID0gNzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///72\n")},function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\n/**\n * @coreapi\n * @module params\n */\n/** */\nvar common_1 = __webpack_require__(0);\n/** @internalapi */\nvar StateParams = /** @class */ (function () {\n    function StateParams(params) {\n        if (params === void 0) { params = {}; }\n        common_1.extend(this, params);\n    }\n    /**\n     * Merges a set of parameters with all parameters inherited between the common parents of the\n     * current state and a given destination state.\n     *\n     * @param {Object} newParams The set of parameters which will be composited with inherited params.\n     * @param {Object} $current Internal definition of object representing the current state.\n     * @param {Object} $to Internal definition of object representing state to transition to.\n     */\n    StateParams.prototype.$inherit = function (newParams, $current, $to) {\n        var parentParams;\n        var parents = common_1.ancestors($current, $to), inherited = {}, inheritList = [];\n        for (var i in parents) {\n            if (!parents[i] || !parents[i].params)\n                continue;\n            parentParams = Object.keys(parents[i].params);\n            if (!parentParams.length)\n                continue;\n            for (var j in parentParams) {\n                if (inheritList.indexOf(parentParams[j]) >= 0)\n                    continue;\n                inheritList.push(parentParams[j]);\n                inherited[parentParams[j]] = this[parentParams[j]];\n            }\n        }\n        return common_1.extend({}, inherited, newParams);\n    };\n    return StateParams;\n}());\nexports.StateParams = StateParams;\n//# sourceMappingURL=stateParams.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3BhcmFtcy9zdGF0ZVBhcmFtcy5qcz81ZGIxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAY29yZWFwaVxuICogQG1vZHVsZSBwYXJhbXNcbiAqL1xuLyoqICovXG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcbi8qKiBAaW50ZXJuYWxhcGkgKi9cbnZhciBTdGF0ZVBhcmFtcyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdGF0ZVBhcmFtcyhwYXJhbXMpIHtcbiAgICAgICAgaWYgKHBhcmFtcyA9PT0gdm9pZCAwKSB7IHBhcmFtcyA9IHt9OyB9XG4gICAgICAgIGNvbW1vbl8xLmV4dGVuZCh0aGlzLCBwYXJhbXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXJnZXMgYSBzZXQgb2YgcGFyYW1ldGVycyB3aXRoIGFsbCBwYXJhbWV0ZXJzIGluaGVyaXRlZCBiZXR3ZWVuIHRoZSBjb21tb24gcGFyZW50cyBvZiB0aGVcbiAgICAgKiBjdXJyZW50IHN0YXRlIGFuZCBhIGdpdmVuIGRlc3RpbmF0aW9uIHN0YXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG5ld1BhcmFtcyBUaGUgc2V0IG9mIHBhcmFtZXRlcnMgd2hpY2ggd2lsbCBiZSBjb21wb3NpdGVkIHdpdGggaW5oZXJpdGVkIHBhcmFtcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gJGN1cnJlbnQgSW50ZXJuYWwgZGVmaW5pdGlvbiBvZiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IHN0YXRlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSAkdG8gSW50ZXJuYWwgZGVmaW5pdGlvbiBvZiBvYmplY3QgcmVwcmVzZW50aW5nIHN0YXRlIHRvIHRyYW5zaXRpb24gdG8uXG4gICAgICovXG4gICAgU3RhdGVQYXJhbXMucHJvdG90eXBlLiRpbmhlcml0ID0gZnVuY3Rpb24gKG5ld1BhcmFtcywgJGN1cnJlbnQsICR0bykge1xuICAgICAgICB2YXIgcGFyZW50UGFyYW1zO1xuICAgICAgICB2YXIgcGFyZW50cyA9IGNvbW1vbl8xLmFuY2VzdG9ycygkY3VycmVudCwgJHRvKSwgaW5oZXJpdGVkID0ge30sIGluaGVyaXRMaXN0ID0gW107XG4gICAgICAgIGZvciAodmFyIGkgaW4gcGFyZW50cykge1xuICAgICAgICAgICAgaWYgKCFwYXJlbnRzW2ldIHx8ICFwYXJlbnRzW2ldLnBhcmFtcylcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIHBhcmVudFBhcmFtcyA9IE9iamVjdC5rZXlzKHBhcmVudHNbaV0ucGFyYW1zKTtcbiAgICAgICAgICAgIGlmICghcGFyZW50UGFyYW1zLmxlbmd0aClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGZvciAodmFyIGogaW4gcGFyZW50UGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluaGVyaXRMaXN0LmluZGV4T2YocGFyZW50UGFyYW1zW2pdKSA+PSAwKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBpbmhlcml0TGlzdC5wdXNoKHBhcmVudFBhcmFtc1tqXSk7XG4gICAgICAgICAgICAgICAgaW5oZXJpdGVkW3BhcmVudFBhcmFtc1tqXV0gPSB0aGlzW3BhcmVudFBhcmFtc1tqXV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbW1vbl8xLmV4dGVuZCh7fSwgaW5oZXJpdGVkLCBuZXdQYXJhbXMpO1xuICAgIH07XG4gICAgcmV0dXJuIFN0YXRlUGFyYW1zO1xufSgpKTtcbmV4cG9ydHMuU3RhdGVQYXJhbXMgPSBTdGF0ZVBhcmFtcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0YXRlUGFyYW1zLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9wYXJhbXMvc3RhdGVQYXJhbXMuanNcbi8vIG1vZHVsZSBpZCA9IDczXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///73\n')},function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @module state */ /** for typedoc */\nvar common_1 = __webpack_require__(0);\nvar predicates_1 = __webpack_require__(1);\nvar strings_1 = __webpack_require__(6);\nvar hof_1 = __webpack_require__(2);\nvar resolvable_1 = __webpack_require__(26);\nvar coreservices_1 = __webpack_require__(3);\nvar parseUrl = function (url) {\n    if (!predicates_1.isString(url))\n        return false;\n    var root = url.charAt(0) === '^';\n    return { val: root ? url.substring(1) : url, root: root };\n};\nfunction nameBuilder(state) {\n    return state.name;\n}\nfunction selfBuilder(state) {\n    state.self.$$state = function () { return state; };\n    return state.self;\n}\nfunction dataBuilder(state) {\n    if (state.parent && state.parent.data) {\n        state.data = state.self.data = common_1.inherit(state.parent.data, state.data);\n    }\n    return state.data;\n}\nvar getUrlBuilder = function ($urlMatcherFactoryProvider, root) {\n    return function urlBuilder(state) {\n        var stateDec = state;\n        // For future states, i.e., states whose name ends with `.**`,\n        // match anything that starts with the url prefix\n        if (stateDec && stateDec.url && stateDec.name && stateDec.name.match(/\\.\\*\\*$/)) {\n            stateDec.url += '{remainder:any}'; // match any path (.*)\n        }\n        var parsed = parseUrl(stateDec.url), parent = state.parent;\n        var url = !parsed ? stateDec.url : $urlMatcherFactoryProvider.compile(parsed.val, {\n            params: state.params || {},\n            paramMap: function (paramConfig, isSearch) {\n                if (stateDec.reloadOnSearch === false && isSearch)\n                    paramConfig = common_1.extend(paramConfig || {}, { dynamic: true });\n                return paramConfig;\n            },\n        });\n        if (!url)\n            return null;\n        if (!$urlMatcherFactoryProvider.isMatcher(url))\n            throw new Error(\"Invalid url '\" + url + \"' in state '\" + state + \"'\");\n        return (parsed && parsed.root) ? url : ((parent && parent.navigable) || root()).url.append(url);\n    };\n};\nvar getNavigableBuilder = function (isRoot) {\n    return function navigableBuilder(state) {\n        return !isRoot(state) && state.url ? state : (state.parent ? state.parent.navigable : null);\n    };\n};\nvar getParamsBuilder = function (paramFactory) {\n    return function paramsBuilder(state) {\n        var makeConfigParam = function (config, id) { return paramFactory.fromConfig(id, null, config); };\n        var urlParams = (state.url && state.url.parameters({ inherit: false })) || [];\n        var nonUrlParams = common_1.values(common_1.mapObj(common_1.omit(state.params || {}, urlParams.map(hof_1.prop('id'))), makeConfigParam));\n        return urlParams.concat(nonUrlParams).map(function (p) { return [p.id, p]; }).reduce(common_1.applyPairs, {});\n    };\n};\nfunction pathBuilder(state) {\n    return state.parent ? state.parent.path.concat(state) : /*root*/ [state];\n}\nfunction includesBuilder(state) {\n    var includes = state.parent ? common_1.extend({}, state.parent.includes) : {};\n    includes[state.name] = true;\n    return includes;\n}\n/**\n * This is a [[StateBuilder.builder]] function for the `resolve:` block on a [[StateDeclaration]].\n *\n * When the [[StateBuilder]] builds a [[StateObject]] object from a raw [[StateDeclaration]], this builder\n * validates the `resolve` property and converts it to a [[Resolvable]] array.\n *\n * resolve: input value can be:\n *\n * {\n *   // analyzed but not injected\n *   myFooResolve: function() { return \"myFooData\"; },\n *\n *   // function.toString() parsed, \"DependencyName\" dep as string (not min-safe)\n *   myBarResolve: function(DependencyName) { return DependencyName.fetchSomethingAsPromise() },\n *\n *   // Array split; \"DependencyName\" dep as string\n *   myBazResolve: [ \"DependencyName\", function(dep) { return dep.fetchSomethingAsPromise() },\n *\n *   // Array split; DependencyType dep as token (compared using ===)\n *   myQuxResolve: [ DependencyType, function(dep) { return dep.fetchSometingAsPromise() },\n *\n *   // val.$inject used as deps\n *   // where:\n *   //     corgeResolve.$inject = [\"DependencyName\"];\n *   //     function corgeResolve(dep) { dep.fetchSometingAsPromise() }\n *   // then \"DependencyName\" dep as string\n *   myCorgeResolve: corgeResolve,\n *\n *  // inject service by name\n *  // When a string is found, desugar creating a resolve that injects the named service\n *   myGraultResolve: \"SomeService\"\n * }\n *\n * or:\n *\n * [\n *   new Resolvable(\"myFooResolve\", function() { return \"myFooData\" }),\n *   new Resolvable(\"myBarResolve\", function(dep) { return dep.fetchSomethingAsPromise() }, [ \"DependencyName\" ]),\n *   { provide: \"myBazResolve\", useFactory: function(dep) { dep.fetchSomethingAsPromise() }, deps: [ \"DependencyName\" ] }\n * ]\n */\nfunction resolvablesBuilder(state) {\n    /** convert resolve: {} and resolvePolicy: {} objects to an array of tuples */\n    var objects2Tuples = function (resolveObj, resolvePolicies) {\n        return Object.keys(resolveObj || {}).map(function (token) { return ({ token: token, val: resolveObj[token], deps: undefined, policy: resolvePolicies[token] }); });\n    };\n    /** fetch DI annotations from a function or ng1-style array */\n    var annotate = function (fn) {\n        var $injector = coreservices_1.services.$injector;\n        // ng1 doesn't have an $injector until runtime.\n        // If the $injector doesn't exist, use \"deferred\" literal as a\n        // marker indicating they should be annotated when runtime starts\n        return fn['$inject'] || ($injector && $injector.annotate(fn, $injector.strictDi)) || 'deferred';\n    };\n    /** true if the object has both `token` and `resolveFn`, and is probably a [[ResolveLiteral]] */\n    var isResolveLiteral = function (obj) { return !!(obj.token && obj.resolveFn); };\n    /** true if the object looks like a provide literal, or a ng2 Provider */\n    var isLikeNg2Provider = function (obj) { return !!((obj.provide || obj.token) && (obj.useValue || obj.useFactory || obj.useExisting || obj.useClass)); };\n    /** true if the object looks like a tuple from obj2Tuples */\n    var isTupleFromObj = function (obj) { return !!(obj && obj.val && (predicates_1.isString(obj.val) || predicates_1.isArray(obj.val) || predicates_1.isFunction(obj.val))); };\n    /** extracts the token from a Provider or provide literal */\n    var getToken = function (p) { return p.provide || p.token; };\n    /** Given a literal resolve or provider object, returns a Resolvable */\n    var literal2Resolvable = hof_1.pattern([\n        [hof_1.prop('resolveFn'), function (p) { return new resolvable_1.Resolvable(getToken(p), p.resolveFn, p.deps, p.policy); }],\n        [hof_1.prop('useFactory'), function (p) { return new resolvable_1.Resolvable(getToken(p), p.useFactory, (p.deps || p.dependencies), p.policy); }],\n        [hof_1.prop('useClass'), function (p) { return new resolvable_1.Resolvable(getToken(p), function () { return new p.useClass(); }, [], p.policy); }],\n        [hof_1.prop('useValue'), function (p) { return new resolvable_1.Resolvable(getToken(p), function () { return p.useValue; }, [], p.policy, p.useValue); }],\n        [hof_1.prop('useExisting'), function (p) { return new resolvable_1.Resolvable(getToken(p), common_1.identity, [p.useExisting], p.policy); }],\n    ]);\n    var tuple2Resolvable = hof_1.pattern([\n        [hof_1.pipe(hof_1.prop('val'), predicates_1.isString), function (tuple) { return new resolvable_1.Resolvable(tuple.token, common_1.identity, [tuple.val], tuple.policy); }],\n        [hof_1.pipe(hof_1.prop('val'), predicates_1.isArray), function (tuple) { return new resolvable_1.Resolvable(tuple.token, common_1.tail(tuple.val), tuple.val.slice(0, -1), tuple.policy); }],\n        [hof_1.pipe(hof_1.prop('val'), predicates_1.isFunction), function (tuple) { return new resolvable_1.Resolvable(tuple.token, tuple.val, annotate(tuple.val), tuple.policy); }],\n    ]);\n    var item2Resolvable = hof_1.pattern([\n        [hof_1.is(resolvable_1.Resolvable), function (r) { return r; }],\n        [isResolveLiteral, literal2Resolvable],\n        [isLikeNg2Provider, literal2Resolvable],\n        [isTupleFromObj, tuple2Resolvable],\n        [hof_1.val(true), function (obj) { throw new Error('Invalid resolve value: ' + strings_1.stringify(obj)); }],\n    ]);\n    // If resolveBlock is already an array, use it as-is.\n    // Otherwise, assume it's an object and convert to an Array of tuples\n    var decl = state.resolve;\n    var items = predicates_1.isArray(decl) ? decl : objects2Tuples(decl, state.resolvePolicy || {});\n    return items.map(item2Resolvable);\n}\nexports.resolvablesBuilder = resolvablesBuilder;\n/**\n * @internalapi A internal global service\n *\n * StateBuilder is a factory for the internal [[StateObject]] objects.\n *\n * When you register a state with the [[StateRegistry]], you register a plain old javascript object which\n * conforms to the [[StateDeclaration]] interface.  This factory takes that object and builds the corresponding\n * [[StateObject]] object, which has an API and is used internally.\n *\n * Custom properties or API may be added to the internal [[StateObject]] object by registering a decorator function\n * using the [[builder]] method.\n */\nvar StateBuilder = /** @class */ (function () {\n    function StateBuilder(matcher, urlMatcherFactory) {\n        this.matcher = matcher;\n        var self = this;\n        var root = function () { return matcher.find(''); };\n        var isRoot = function (state) { return state.name === ''; };\n        function parentBuilder(state) {\n            if (isRoot(state))\n                return null;\n            return matcher.find(self.parentName(state)) || root();\n        }\n        this.builders = {\n            name: [nameBuilder],\n            self: [selfBuilder],\n            parent: [parentBuilder],\n            data: [dataBuilder],\n            // Build a URLMatcher if necessary, either via a relative or absolute URL\n            url: [getUrlBuilder(urlMatcherFactory, root)],\n            // Keep track of the closest ancestor state that has a URL (i.e. is navigable)\n            navigable: [getNavigableBuilder(isRoot)],\n            params: [getParamsBuilder(urlMatcherFactory.paramFactory)],\n            // Each framework-specific ui-router implementation should define its own `views` builder\n            // e.g., src/ng1/statebuilders/views.ts\n            views: [],\n            // Keep a full path from the root down to this state as this is needed for state activation.\n            path: [pathBuilder],\n            // Speed up $state.includes() as it's used a lot\n            includes: [includesBuilder],\n            resolvables: [resolvablesBuilder],\n        };\n    }\n    /**\n     * Registers a [[BuilderFunction]] for a specific [[StateObject]] property (e.g., `parent`, `url`, or `path`).\n     * More than one BuilderFunction can be registered for a given property.\n     *\n     * The BuilderFunction(s) will be used to define the property on any subsequently built [[StateObject]] objects.\n     *\n     * @param name The name of the State property being registered for.\n     * @param fn The BuilderFunction which will be used to build the State property\n     * @returns a function which deregisters the BuilderFunction\n     */\n    StateBuilder.prototype.builder = function (name, fn) {\n        var builders = this.builders;\n        var array = builders[name] || [];\n        // Backwards compat: if only one builder exists, return it, else return whole arary.\n        if (predicates_1.isString(name) && !predicates_1.isDefined(fn))\n            return array.length > 1 ? array : array[0];\n        if (!predicates_1.isString(name) || !predicates_1.isFunction(fn))\n            return;\n        builders[name] = array;\n        builders[name].push(fn);\n        return function () { return builders[name].splice(builders[name].indexOf(fn, 1)) && null; };\n    };\n    /**\n     * Builds all of the properties on an essentially blank State object, returning a State object which has all its\n     * properties and API built.\n     *\n     * @param state an uninitialized State object\n     * @returns the built State object\n     */\n    StateBuilder.prototype.build = function (state) {\n        var _a = this, matcher = _a.matcher, builders = _a.builders;\n        var parent = this.parentName(state);\n        if (parent && !matcher.find(parent, undefined, false)) {\n            return null;\n        }\n        for (var key in builders) {\n            if (!builders.hasOwnProperty(key))\n                continue;\n            var chain = builders[key].reduce(function (parentFn, step) { return function (_state) { return step(_state, parentFn); }; }, common_1.noop);\n            state[key] = chain(state);\n        }\n        return state;\n    };\n    StateBuilder.prototype.parentName = function (state) {\n        // name = 'foo.bar.baz.**'\n        var name = state.name || '';\n        // segments = ['foo', 'bar', 'baz', '.**']\n        var segments = name.split('.');\n        // segments = ['foo', 'bar', 'baz']\n        var lastSegment = segments.pop();\n        // segments = ['foo', 'bar'] (ignore .** segment for future states)\n        if (lastSegment === '**')\n            segments.pop();\n        if (segments.length) {\n            if (state.parent) {\n                throw new Error(\"States that specify the 'parent:' property should not have a '.' in their name (\" + name + \")\");\n            }\n            // 'foo.bar'\n            return segments.join('.');\n        }\n        if (!state.parent)\n            return '';\n        return predicates_1.isString(state.parent) ? state.parent : state.parent.name;\n    };\n    StateBuilder.prototype.name = function (state) {\n        var name = state.name;\n        if (name.indexOf('.') !== -1 || !state.parent)\n            return name;\n        var parentName = predicates_1.isString(state.parent) ? state.parent : state.parent.name;\n        return parentName ? parentName + '.' + name : name;\n    };\n    return StateBuilder;\n}());\nexports.StateBuilder = StateBuilder;\n//# sourceMappingURL=stateBuilder.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3N0YXRlL3N0YXRlQnVpbGRlci5qcz80ZDFhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqIEBtb2R1bGUgc3RhdGUgKi8gLyoqIGZvciB0eXBlZG9jICovXG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcbnZhciBwcmVkaWNhdGVzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3ByZWRpY2F0ZXNcIik7XG52YXIgc3RyaW5nc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9zdHJpbmdzXCIpO1xudmFyIGhvZl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9ob2ZcIik7XG52YXIgcmVzb2x2YWJsZV8xID0gcmVxdWlyZShcIi4uL3Jlc29sdmUvcmVzb2x2YWJsZVwiKTtcbnZhciBjb3Jlc2VydmljZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29yZXNlcnZpY2VzXCIpO1xudmFyIHBhcnNlVXJsID0gZnVuY3Rpb24gKHVybCkge1xuICAgIGlmICghcHJlZGljYXRlc18xLmlzU3RyaW5nKHVybCkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB2YXIgcm9vdCA9IHVybC5jaGFyQXQoMCkgPT09ICdeJztcbiAgICByZXR1cm4geyB2YWw6IHJvb3QgPyB1cmwuc3Vic3RyaW5nKDEpIDogdXJsLCByb290OiByb290IH07XG59O1xuZnVuY3Rpb24gbmFtZUJ1aWxkZXIoc3RhdGUpIHtcbiAgICByZXR1cm4gc3RhdGUubmFtZTtcbn1cbmZ1bmN0aW9uIHNlbGZCdWlsZGVyKHN0YXRlKSB7XG4gICAgc3RhdGUuc2VsZi4kJHN0YXRlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RhdGU7IH07XG4gICAgcmV0dXJuIHN0YXRlLnNlbGY7XG59XG5mdW5jdGlvbiBkYXRhQnVpbGRlcihzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5wYXJlbnQgJiYgc3RhdGUucGFyZW50LmRhdGEpIHtcbiAgICAgICAgc3RhdGUuZGF0YSA9IHN0YXRlLnNlbGYuZGF0YSA9IGNvbW1vbl8xLmluaGVyaXQoc3RhdGUucGFyZW50LmRhdGEsIHN0YXRlLmRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gc3RhdGUuZGF0YTtcbn1cbnZhciBnZXRVcmxCdWlsZGVyID0gZnVuY3Rpb24gKCR1cmxNYXRjaGVyRmFjdG9yeVByb3ZpZGVyLCByb290KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVybEJ1aWxkZXIoc3RhdGUpIHtcbiAgICAgICAgdmFyIHN0YXRlRGVjID0gc3RhdGU7XG4gICAgICAgIC8vIEZvciBmdXR1cmUgc3RhdGVzLCBpLmUuLCBzdGF0ZXMgd2hvc2UgbmFtZSBlbmRzIHdpdGggYC4qKmAsXG4gICAgICAgIC8vIG1hdGNoIGFueXRoaW5nIHRoYXQgc3RhcnRzIHdpdGggdGhlIHVybCBwcmVmaXhcbiAgICAgICAgaWYgKHN0YXRlRGVjICYmIHN0YXRlRGVjLnVybCAmJiBzdGF0ZURlYy5uYW1lICYmIHN0YXRlRGVjLm5hbWUubWF0Y2goL1xcLlxcKlxcKiQvKSkge1xuICAgICAgICAgICAgc3RhdGVEZWMudXJsICs9ICd7cmVtYWluZGVyOmFueX0nOyAvLyBtYXRjaCBhbnkgcGF0aCAoLiopXG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhcnNlZCA9IHBhcnNlVXJsKHN0YXRlRGVjLnVybCksIHBhcmVudCA9IHN0YXRlLnBhcmVudDtcbiAgICAgICAgdmFyIHVybCA9ICFwYXJzZWQgPyBzdGF0ZURlYy51cmwgOiAkdXJsTWF0Y2hlckZhY3RvcnlQcm92aWRlci5jb21waWxlKHBhcnNlZC52YWwsIHtcbiAgICAgICAgICAgIHBhcmFtczogc3RhdGUucGFyYW1zIHx8IHt9LFxuICAgICAgICAgICAgcGFyYW1NYXA6IGZ1bmN0aW9uIChwYXJhbUNvbmZpZywgaXNTZWFyY2gpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGVEZWMucmVsb2FkT25TZWFyY2ggPT09IGZhbHNlICYmIGlzU2VhcmNoKVxuICAgICAgICAgICAgICAgICAgICBwYXJhbUNvbmZpZyA9IGNvbW1vbl8xLmV4dGVuZChwYXJhbUNvbmZpZyB8fCB7fSwgeyBkeW5hbWljOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJhbUNvbmZpZztcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXVybClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpZiAoISR1cmxNYXRjaGVyRmFjdG9yeVByb3ZpZGVyLmlzTWF0Y2hlcih1cmwpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB1cmwgJ1wiICsgdXJsICsgXCInIGluIHN0YXRlICdcIiArIHN0YXRlICsgXCInXCIpO1xuICAgICAgICByZXR1cm4gKHBhcnNlZCAmJiBwYXJzZWQucm9vdCkgPyB1cmwgOiAoKHBhcmVudCAmJiBwYXJlbnQubmF2aWdhYmxlKSB8fCByb290KCkpLnVybC5hcHBlbmQodXJsKTtcbiAgICB9O1xufTtcbnZhciBnZXROYXZpZ2FibGVCdWlsZGVyID0gZnVuY3Rpb24gKGlzUm9vdCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBuYXZpZ2FibGVCdWlsZGVyKHN0YXRlKSB7XG4gICAgICAgIHJldHVybiAhaXNSb290KHN0YXRlKSAmJiBzdGF0ZS51cmwgPyBzdGF0ZSA6IChzdGF0ZS5wYXJlbnQgPyBzdGF0ZS5wYXJlbnQubmF2aWdhYmxlIDogbnVsbCk7XG4gICAgfTtcbn07XG52YXIgZ2V0UGFyYW1zQnVpbGRlciA9IGZ1bmN0aW9uIChwYXJhbUZhY3RvcnkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gcGFyYW1zQnVpbGRlcihzdGF0ZSkge1xuICAgICAgICB2YXIgbWFrZUNvbmZpZ1BhcmFtID0gZnVuY3Rpb24gKGNvbmZpZywgaWQpIHsgcmV0dXJuIHBhcmFtRmFjdG9yeS5mcm9tQ29uZmlnKGlkLCBudWxsLCBjb25maWcpOyB9O1xuICAgICAgICB2YXIgdXJsUGFyYW1zID0gKHN0YXRlLnVybCAmJiBzdGF0ZS51cmwucGFyYW1ldGVycyh7IGluaGVyaXQ6IGZhbHNlIH0pKSB8fCBbXTtcbiAgICAgICAgdmFyIG5vblVybFBhcmFtcyA9IGNvbW1vbl8xLnZhbHVlcyhjb21tb25fMS5tYXBPYmooY29tbW9uXzEub21pdChzdGF0ZS5wYXJhbXMgfHwge30sIHVybFBhcmFtcy5tYXAoaG9mXzEucHJvcCgnaWQnKSkpLCBtYWtlQ29uZmlnUGFyYW0pKTtcbiAgICAgICAgcmV0dXJuIHVybFBhcmFtcy5jb25jYXQobm9uVXJsUGFyYW1zKS5tYXAoZnVuY3Rpb24gKHApIHsgcmV0dXJuIFtwLmlkLCBwXTsgfSkucmVkdWNlKGNvbW1vbl8xLmFwcGx5UGFpcnMsIHt9KTtcbiAgICB9O1xufTtcbmZ1bmN0aW9uIHBhdGhCdWlsZGVyKHN0YXRlKSB7XG4gICAgcmV0dXJuIHN0YXRlLnBhcmVudCA/IHN0YXRlLnBhcmVudC5wYXRoLmNvbmNhdChzdGF0ZSkgOiAvKnJvb3QqLyBbc3RhdGVdO1xufVxuZnVuY3Rpb24gaW5jbHVkZXNCdWlsZGVyKHN0YXRlKSB7XG4gICAgdmFyIGluY2x1ZGVzID0gc3RhdGUucGFyZW50ID8gY29tbW9uXzEuZXh0ZW5kKHt9LCBzdGF0ZS5wYXJlbnQuaW5jbHVkZXMpIDoge307XG4gICAgaW5jbHVkZXNbc3RhdGUubmFtZV0gPSB0cnVlO1xuICAgIHJldHVybiBpbmNsdWRlcztcbn1cbi8qKlxuICogVGhpcyBpcyBhIFtbU3RhdGVCdWlsZGVyLmJ1aWxkZXJdXSBmdW5jdGlvbiBmb3IgdGhlIGByZXNvbHZlOmAgYmxvY2sgb24gYSBbW1N0YXRlRGVjbGFyYXRpb25dXS5cbiAqXG4gKiBXaGVuIHRoZSBbW1N0YXRlQnVpbGRlcl1dIGJ1aWxkcyBhIFtbU3RhdGVPYmplY3RdXSBvYmplY3QgZnJvbSBhIHJhdyBbW1N0YXRlRGVjbGFyYXRpb25dXSwgdGhpcyBidWlsZGVyXG4gKiB2YWxpZGF0ZXMgdGhlIGByZXNvbHZlYCBwcm9wZXJ0eSBhbmQgY29udmVydHMgaXQgdG8gYSBbW1Jlc29sdmFibGVdXSBhcnJheS5cbiAqXG4gKiByZXNvbHZlOiBpbnB1dCB2YWx1ZSBjYW4gYmU6XG4gKlxuICoge1xuICogICAvLyBhbmFseXplZCBidXQgbm90IGluamVjdGVkXG4gKiAgIG15Rm9vUmVzb2x2ZTogZnVuY3Rpb24oKSB7IHJldHVybiBcIm15Rm9vRGF0YVwiOyB9LFxuICpcbiAqICAgLy8gZnVuY3Rpb24udG9TdHJpbmcoKSBwYXJzZWQsIFwiRGVwZW5kZW5jeU5hbWVcIiBkZXAgYXMgc3RyaW5nIChub3QgbWluLXNhZmUpXG4gKiAgIG15QmFyUmVzb2x2ZTogZnVuY3Rpb24oRGVwZW5kZW5jeU5hbWUpIHsgcmV0dXJuIERlcGVuZGVuY3lOYW1lLmZldGNoU29tZXRoaW5nQXNQcm9taXNlKCkgfSxcbiAqXG4gKiAgIC8vIEFycmF5IHNwbGl0OyBcIkRlcGVuZGVuY3lOYW1lXCIgZGVwIGFzIHN0cmluZ1xuICogICBteUJhelJlc29sdmU6IFsgXCJEZXBlbmRlbmN5TmFtZVwiLCBmdW5jdGlvbihkZXApIHsgcmV0dXJuIGRlcC5mZXRjaFNvbWV0aGluZ0FzUHJvbWlzZSgpIH0sXG4gKlxuICogICAvLyBBcnJheSBzcGxpdDsgRGVwZW5kZW5jeVR5cGUgZGVwIGFzIHRva2VuIChjb21wYXJlZCB1c2luZyA9PT0pXG4gKiAgIG15UXV4UmVzb2x2ZTogWyBEZXBlbmRlbmN5VHlwZSwgZnVuY3Rpb24oZGVwKSB7IHJldHVybiBkZXAuZmV0Y2hTb21ldGluZ0FzUHJvbWlzZSgpIH0sXG4gKlxuICogICAvLyB2YWwuJGluamVjdCB1c2VkIGFzIGRlcHNcbiAqICAgLy8gd2hlcmU6XG4gKiAgIC8vICAgICBjb3JnZVJlc29sdmUuJGluamVjdCA9IFtcIkRlcGVuZGVuY3lOYW1lXCJdO1xuICogICAvLyAgICAgZnVuY3Rpb24gY29yZ2VSZXNvbHZlKGRlcCkgeyBkZXAuZmV0Y2hTb21ldGluZ0FzUHJvbWlzZSgpIH1cbiAqICAgLy8gdGhlbiBcIkRlcGVuZGVuY3lOYW1lXCIgZGVwIGFzIHN0cmluZ1xuICogICBteUNvcmdlUmVzb2x2ZTogY29yZ2VSZXNvbHZlLFxuICpcbiAqICAvLyBpbmplY3Qgc2VydmljZSBieSBuYW1lXG4gKiAgLy8gV2hlbiBhIHN0cmluZyBpcyBmb3VuZCwgZGVzdWdhciBjcmVhdGluZyBhIHJlc29sdmUgdGhhdCBpbmplY3RzIHRoZSBuYW1lZCBzZXJ2aWNlXG4gKiAgIG15R3JhdWx0UmVzb2x2ZTogXCJTb21lU2VydmljZVwiXG4gKiB9XG4gKlxuICogb3I6XG4gKlxuICogW1xuICogICBuZXcgUmVzb2x2YWJsZShcIm15Rm9vUmVzb2x2ZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIFwibXlGb29EYXRhXCIgfSksXG4gKiAgIG5ldyBSZXNvbHZhYmxlKFwibXlCYXJSZXNvbHZlXCIsIGZ1bmN0aW9uKGRlcCkgeyByZXR1cm4gZGVwLmZldGNoU29tZXRoaW5nQXNQcm9taXNlKCkgfSwgWyBcIkRlcGVuZGVuY3lOYW1lXCIgXSksXG4gKiAgIHsgcHJvdmlkZTogXCJteUJhelJlc29sdmVcIiwgdXNlRmFjdG9yeTogZnVuY3Rpb24oZGVwKSB7IGRlcC5mZXRjaFNvbWV0aGluZ0FzUHJvbWlzZSgpIH0sIGRlcHM6IFsgXCJEZXBlbmRlbmN5TmFtZVwiIF0gfVxuICogXVxuICovXG5mdW5jdGlvbiByZXNvbHZhYmxlc0J1aWxkZXIoc3RhdGUpIHtcbiAgICAvKiogY29udmVydCByZXNvbHZlOiB7fSBhbmQgcmVzb2x2ZVBvbGljeToge30gb2JqZWN0cyB0byBhbiBhcnJheSBvZiB0dXBsZXMgKi9cbiAgICB2YXIgb2JqZWN0czJUdXBsZXMgPSBmdW5jdGlvbiAocmVzb2x2ZU9iaiwgcmVzb2x2ZVBvbGljaWVzKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhyZXNvbHZlT2JqIHx8IHt9KS5tYXAoZnVuY3Rpb24gKHRva2VuKSB7IHJldHVybiAoeyB0b2tlbjogdG9rZW4sIHZhbDogcmVzb2x2ZU9ialt0b2tlbl0sIGRlcHM6IHVuZGVmaW5lZCwgcG9saWN5OiByZXNvbHZlUG9saWNpZXNbdG9rZW5dIH0pOyB9KTtcbiAgICB9O1xuICAgIC8qKiBmZXRjaCBESSBhbm5vdGF0aW9ucyBmcm9tIGEgZnVuY3Rpb24gb3IgbmcxLXN0eWxlIGFycmF5ICovXG4gICAgdmFyIGFubm90YXRlID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHZhciAkaW5qZWN0b3IgPSBjb3Jlc2VydmljZXNfMS5zZXJ2aWNlcy4kaW5qZWN0b3I7XG4gICAgICAgIC8vIG5nMSBkb2Vzbid0IGhhdmUgYW4gJGluamVjdG9yIHVudGlsIHJ1bnRpbWUuXG4gICAgICAgIC8vIElmIHRoZSAkaW5qZWN0b3IgZG9lc24ndCBleGlzdCwgdXNlIFwiZGVmZXJyZWRcIiBsaXRlcmFsIGFzIGFcbiAgICAgICAgLy8gbWFya2VyIGluZGljYXRpbmcgdGhleSBzaG91bGQgYmUgYW5ub3RhdGVkIHdoZW4gcnVudGltZSBzdGFydHNcbiAgICAgICAgcmV0dXJuIGZuWyckaW5qZWN0J10gfHwgKCRpbmplY3RvciAmJiAkaW5qZWN0b3IuYW5ub3RhdGUoZm4sICRpbmplY3Rvci5zdHJpY3REaSkpIHx8ICdkZWZlcnJlZCc7XG4gICAgfTtcbiAgICAvKiogdHJ1ZSBpZiB0aGUgb2JqZWN0IGhhcyBib3RoIGB0b2tlbmAgYW5kIGByZXNvbHZlRm5gLCBhbmQgaXMgcHJvYmFibHkgYSBbW1Jlc29sdmVMaXRlcmFsXV0gKi9cbiAgICB2YXIgaXNSZXNvbHZlTGl0ZXJhbCA9IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuICEhKG9iai50b2tlbiAmJiBvYmoucmVzb2x2ZUZuKTsgfTtcbiAgICAvKiogdHJ1ZSBpZiB0aGUgb2JqZWN0IGxvb2tzIGxpa2UgYSBwcm92aWRlIGxpdGVyYWwsIG9yIGEgbmcyIFByb3ZpZGVyICovXG4gICAgdmFyIGlzTGlrZU5nMlByb3ZpZGVyID0gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gISEoKG9iai5wcm92aWRlIHx8IG9iai50b2tlbikgJiYgKG9iai51c2VWYWx1ZSB8fCBvYmoudXNlRmFjdG9yeSB8fCBvYmoudXNlRXhpc3RpbmcgfHwgb2JqLnVzZUNsYXNzKSk7IH07XG4gICAgLyoqIHRydWUgaWYgdGhlIG9iamVjdCBsb29rcyBsaWtlIGEgdHVwbGUgZnJvbSBvYmoyVHVwbGVzICovXG4gICAgdmFyIGlzVHVwbGVGcm9tT2JqID0gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gISEob2JqICYmIG9iai52YWwgJiYgKHByZWRpY2F0ZXNfMS5pc1N0cmluZyhvYmoudmFsKSB8fCBwcmVkaWNhdGVzXzEuaXNBcnJheShvYmoudmFsKSB8fCBwcmVkaWNhdGVzXzEuaXNGdW5jdGlvbihvYmoudmFsKSkpOyB9O1xuICAgIC8qKiBleHRyYWN0cyB0aGUgdG9rZW4gZnJvbSBhIFByb3ZpZGVyIG9yIHByb3ZpZGUgbGl0ZXJhbCAqL1xuICAgIHZhciBnZXRUb2tlbiA9IGZ1bmN0aW9uIChwKSB7IHJldHVybiBwLnByb3ZpZGUgfHwgcC50b2tlbjsgfTtcbiAgICAvKiogR2l2ZW4gYSBsaXRlcmFsIHJlc29sdmUgb3IgcHJvdmlkZXIgb2JqZWN0LCByZXR1cm5zIGEgUmVzb2x2YWJsZSAqL1xuICAgIHZhciBsaXRlcmFsMlJlc29sdmFibGUgPSBob2ZfMS5wYXR0ZXJuKFtcbiAgICAgICAgW2hvZl8xLnByb3AoJ3Jlc29sdmVGbicpLCBmdW5jdGlvbiAocCkgeyByZXR1cm4gbmV3IHJlc29sdmFibGVfMS5SZXNvbHZhYmxlKGdldFRva2VuKHApLCBwLnJlc29sdmVGbiwgcC5kZXBzLCBwLnBvbGljeSk7IH1dLFxuICAgICAgICBbaG9mXzEucHJvcCgndXNlRmFjdG9yeScpLCBmdW5jdGlvbiAocCkgeyByZXR1cm4gbmV3IHJlc29sdmFibGVfMS5SZXNvbHZhYmxlKGdldFRva2VuKHApLCBwLnVzZUZhY3RvcnksIChwLmRlcHMgfHwgcC5kZXBlbmRlbmNpZXMpLCBwLnBvbGljeSk7IH1dLFxuICAgICAgICBbaG9mXzEucHJvcCgndXNlQ2xhc3MnKSwgZnVuY3Rpb24gKHApIHsgcmV0dXJuIG5ldyByZXNvbHZhYmxlXzEuUmVzb2x2YWJsZShnZXRUb2tlbihwKSwgZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IHAudXNlQ2xhc3MoKTsgfSwgW10sIHAucG9saWN5KTsgfV0sXG4gICAgICAgIFtob2ZfMS5wcm9wKCd1c2VWYWx1ZScpLCBmdW5jdGlvbiAocCkgeyByZXR1cm4gbmV3IHJlc29sdmFibGVfMS5SZXNvbHZhYmxlKGdldFRva2VuKHApLCBmdW5jdGlvbiAoKSB7IHJldHVybiBwLnVzZVZhbHVlOyB9LCBbXSwgcC5wb2xpY3ksIHAudXNlVmFsdWUpOyB9XSxcbiAgICAgICAgW2hvZl8xLnByb3AoJ3VzZUV4aXN0aW5nJyksIGZ1bmN0aW9uIChwKSB7IHJldHVybiBuZXcgcmVzb2x2YWJsZV8xLlJlc29sdmFibGUoZ2V0VG9rZW4ocCksIGNvbW1vbl8xLmlkZW50aXR5LCBbcC51c2VFeGlzdGluZ10sIHAucG9saWN5KTsgfV0sXG4gICAgXSk7XG4gICAgdmFyIHR1cGxlMlJlc29sdmFibGUgPSBob2ZfMS5wYXR0ZXJuKFtcbiAgICAgICAgW2hvZl8xLnBpcGUoaG9mXzEucHJvcCgndmFsJyksIHByZWRpY2F0ZXNfMS5pc1N0cmluZyksIGZ1bmN0aW9uICh0dXBsZSkgeyByZXR1cm4gbmV3IHJlc29sdmFibGVfMS5SZXNvbHZhYmxlKHR1cGxlLnRva2VuLCBjb21tb25fMS5pZGVudGl0eSwgW3R1cGxlLnZhbF0sIHR1cGxlLnBvbGljeSk7IH1dLFxuICAgICAgICBbaG9mXzEucGlwZShob2ZfMS5wcm9wKCd2YWwnKSwgcHJlZGljYXRlc18xLmlzQXJyYXkpLCBmdW5jdGlvbiAodHVwbGUpIHsgcmV0dXJuIG5ldyByZXNvbHZhYmxlXzEuUmVzb2x2YWJsZSh0dXBsZS50b2tlbiwgY29tbW9uXzEudGFpbCh0dXBsZS52YWwpLCB0dXBsZS52YWwuc2xpY2UoMCwgLTEpLCB0dXBsZS5wb2xpY3kpOyB9XSxcbiAgICAgICAgW2hvZl8xLnBpcGUoaG9mXzEucHJvcCgndmFsJyksIHByZWRpY2F0ZXNfMS5pc0Z1bmN0aW9uKSwgZnVuY3Rpb24gKHR1cGxlKSB7IHJldHVybiBuZXcgcmVzb2x2YWJsZV8xLlJlc29sdmFibGUodHVwbGUudG9rZW4sIHR1cGxlLnZhbCwgYW5ub3RhdGUodHVwbGUudmFsKSwgdHVwbGUucG9saWN5KTsgfV0sXG4gICAgXSk7XG4gICAgdmFyIGl0ZW0yUmVzb2x2YWJsZSA9IGhvZl8xLnBhdHRlcm4oW1xuICAgICAgICBbaG9mXzEuaXMocmVzb2x2YWJsZV8xLlJlc29sdmFibGUpLCBmdW5jdGlvbiAocikgeyByZXR1cm4gcjsgfV0sXG4gICAgICAgIFtpc1Jlc29sdmVMaXRlcmFsLCBsaXRlcmFsMlJlc29sdmFibGVdLFxuICAgICAgICBbaXNMaWtlTmcyUHJvdmlkZXIsIGxpdGVyYWwyUmVzb2x2YWJsZV0sXG4gICAgICAgIFtpc1R1cGxlRnJvbU9iaiwgdHVwbGUyUmVzb2x2YWJsZV0sXG4gICAgICAgIFtob2ZfMS52YWwodHJ1ZSksIGZ1bmN0aW9uIChvYmopIHsgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHJlc29sdmUgdmFsdWU6ICcgKyBzdHJpbmdzXzEuc3RyaW5naWZ5KG9iaikpOyB9XSxcbiAgICBdKTtcbiAgICAvLyBJZiByZXNvbHZlQmxvY2sgaXMgYWxyZWFkeSBhbiBhcnJheSwgdXNlIGl0IGFzLWlzLlxuICAgIC8vIE90aGVyd2lzZSwgYXNzdW1lIGl0J3MgYW4gb2JqZWN0IGFuZCBjb252ZXJ0IHRvIGFuIEFycmF5IG9mIHR1cGxlc1xuICAgIHZhciBkZWNsID0gc3RhdGUucmVzb2x2ZTtcbiAgICB2YXIgaXRlbXMgPSBwcmVkaWNhdGVzXzEuaXNBcnJheShkZWNsKSA/IGRlY2wgOiBvYmplY3RzMlR1cGxlcyhkZWNsLCBzdGF0ZS5yZXNvbHZlUG9saWN5IHx8IHt9KTtcbiAgICByZXR1cm4gaXRlbXMubWFwKGl0ZW0yUmVzb2x2YWJsZSk7XG59XG5leHBvcnRzLnJlc29sdmFibGVzQnVpbGRlciA9IHJlc29sdmFibGVzQnVpbGRlcjtcbi8qKlxuICogQGludGVybmFsYXBpIEEgaW50ZXJuYWwgZ2xvYmFsIHNlcnZpY2VcbiAqXG4gKiBTdGF0ZUJ1aWxkZXIgaXMgYSBmYWN0b3J5IGZvciB0aGUgaW50ZXJuYWwgW1tTdGF0ZU9iamVjdF1dIG9iamVjdHMuXG4gKlxuICogV2hlbiB5b3UgcmVnaXN0ZXIgYSBzdGF0ZSB3aXRoIHRoZSBbW1N0YXRlUmVnaXN0cnldXSwgeW91IHJlZ2lzdGVyIGEgcGxhaW4gb2xkIGphdmFzY3JpcHQgb2JqZWN0IHdoaWNoXG4gKiBjb25mb3JtcyB0byB0aGUgW1tTdGF0ZURlY2xhcmF0aW9uXV0gaW50ZXJmYWNlLiAgVGhpcyBmYWN0b3J5IHRha2VzIHRoYXQgb2JqZWN0IGFuZCBidWlsZHMgdGhlIGNvcnJlc3BvbmRpbmdcbiAqIFtbU3RhdGVPYmplY3RdXSBvYmplY3QsIHdoaWNoIGhhcyBhbiBBUEkgYW5kIGlzIHVzZWQgaW50ZXJuYWxseS5cbiAqXG4gKiBDdXN0b20gcHJvcGVydGllcyBvciBBUEkgbWF5IGJlIGFkZGVkIHRvIHRoZSBpbnRlcm5hbCBbW1N0YXRlT2JqZWN0XV0gb2JqZWN0IGJ5IHJlZ2lzdGVyaW5nIGEgZGVjb3JhdG9yIGZ1bmN0aW9uXG4gKiB1c2luZyB0aGUgW1tidWlsZGVyXV0gbWV0aG9kLlxuICovXG52YXIgU3RhdGVCdWlsZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0YXRlQnVpbGRlcihtYXRjaGVyLCB1cmxNYXRjaGVyRmFjdG9yeSkge1xuICAgICAgICB0aGlzLm1hdGNoZXIgPSBtYXRjaGVyO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciByb290ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbWF0Y2hlci5maW5kKCcnKTsgfTtcbiAgICAgICAgdmFyIGlzUm9vdCA9IGZ1bmN0aW9uIChzdGF0ZSkgeyByZXR1cm4gc3RhdGUubmFtZSA9PT0gJyc7IH07XG4gICAgICAgIGZ1bmN0aW9uIHBhcmVudEJ1aWxkZXIoc3RhdGUpIHtcbiAgICAgICAgICAgIGlmIChpc1Jvb3Qoc3RhdGUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXIuZmluZChzZWxmLnBhcmVudE5hbWUoc3RhdGUpKSB8fCByb290KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5idWlsZGVycyA9IHtcbiAgICAgICAgICAgIG5hbWU6IFtuYW1lQnVpbGRlcl0sXG4gICAgICAgICAgICBzZWxmOiBbc2VsZkJ1aWxkZXJdLFxuICAgICAgICAgICAgcGFyZW50OiBbcGFyZW50QnVpbGRlcl0sXG4gICAgICAgICAgICBkYXRhOiBbZGF0YUJ1aWxkZXJdLFxuICAgICAgICAgICAgLy8gQnVpbGQgYSBVUkxNYXRjaGVyIGlmIG5lY2Vzc2FyeSwgZWl0aGVyIHZpYSBhIHJlbGF0aXZlIG9yIGFic29sdXRlIFVSTFxuICAgICAgICAgICAgdXJsOiBbZ2V0VXJsQnVpbGRlcih1cmxNYXRjaGVyRmFjdG9yeSwgcm9vdCldLFxuICAgICAgICAgICAgLy8gS2VlcCB0cmFjayBvZiB0aGUgY2xvc2VzdCBhbmNlc3RvciBzdGF0ZSB0aGF0IGhhcyBhIFVSTCAoaS5lLiBpcyBuYXZpZ2FibGUpXG4gICAgICAgICAgICBuYXZpZ2FibGU6IFtnZXROYXZpZ2FibGVCdWlsZGVyKGlzUm9vdCldLFxuICAgICAgICAgICAgcGFyYW1zOiBbZ2V0UGFyYW1zQnVpbGRlcih1cmxNYXRjaGVyRmFjdG9yeS5wYXJhbUZhY3RvcnkpXSxcbiAgICAgICAgICAgIC8vIEVhY2ggZnJhbWV3b3JrLXNwZWNpZmljIHVpLXJvdXRlciBpbXBsZW1lbnRhdGlvbiBzaG91bGQgZGVmaW5lIGl0cyBvd24gYHZpZXdzYCBidWlsZGVyXG4gICAgICAgICAgICAvLyBlLmcuLCBzcmMvbmcxL3N0YXRlYnVpbGRlcnMvdmlld3MudHNcbiAgICAgICAgICAgIHZpZXdzOiBbXSxcbiAgICAgICAgICAgIC8vIEtlZXAgYSBmdWxsIHBhdGggZnJvbSB0aGUgcm9vdCBkb3duIHRvIHRoaXMgc3RhdGUgYXMgdGhpcyBpcyBuZWVkZWQgZm9yIHN0YXRlIGFjdGl2YXRpb24uXG4gICAgICAgICAgICBwYXRoOiBbcGF0aEJ1aWxkZXJdLFxuICAgICAgICAgICAgLy8gU3BlZWQgdXAgJHN0YXRlLmluY2x1ZGVzKCkgYXMgaXQncyB1c2VkIGEgbG90XG4gICAgICAgICAgICBpbmNsdWRlczogW2luY2x1ZGVzQnVpbGRlcl0sXG4gICAgICAgICAgICByZXNvbHZhYmxlczogW3Jlc29sdmFibGVzQnVpbGRlcl0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIFtbQnVpbGRlckZ1bmN0aW9uXV0gZm9yIGEgc3BlY2lmaWMgW1tTdGF0ZU9iamVjdF1dIHByb3BlcnR5IChlLmcuLCBgcGFyZW50YCwgYHVybGAsIG9yIGBwYXRoYCkuXG4gICAgICogTW9yZSB0aGFuIG9uZSBCdWlsZGVyRnVuY3Rpb24gY2FuIGJlIHJlZ2lzdGVyZWQgZm9yIGEgZ2l2ZW4gcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBUaGUgQnVpbGRlckZ1bmN0aW9uKHMpIHdpbGwgYmUgdXNlZCB0byBkZWZpbmUgdGhlIHByb3BlcnR5IG9uIGFueSBzdWJzZXF1ZW50bHkgYnVpbHQgW1tTdGF0ZU9iamVjdF1dIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgU3RhdGUgcHJvcGVydHkgYmVpbmcgcmVnaXN0ZXJlZCBmb3IuXG4gICAgICogQHBhcmFtIGZuIFRoZSBCdWlsZGVyRnVuY3Rpb24gd2hpY2ggd2lsbCBiZSB1c2VkIHRvIGJ1aWxkIHRoZSBTdGF0ZSBwcm9wZXJ0eVxuICAgICAqIEByZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggZGVyZWdpc3RlcnMgdGhlIEJ1aWxkZXJGdW5jdGlvblxuICAgICAqL1xuICAgIFN0YXRlQnVpbGRlci5wcm90b3R5cGUuYnVpbGRlciA9IGZ1bmN0aW9uIChuYW1lLCBmbikge1xuICAgICAgICB2YXIgYnVpbGRlcnMgPSB0aGlzLmJ1aWxkZXJzO1xuICAgICAgICB2YXIgYXJyYXkgPSBidWlsZGVyc1tuYW1lXSB8fCBbXTtcbiAgICAgICAgLy8gQmFja3dhcmRzIGNvbXBhdDogaWYgb25seSBvbmUgYnVpbGRlciBleGlzdHMsIHJldHVybiBpdCwgZWxzZSByZXR1cm4gd2hvbGUgYXJhcnkuXG4gICAgICAgIGlmIChwcmVkaWNhdGVzXzEuaXNTdHJpbmcobmFtZSkgJiYgIXByZWRpY2F0ZXNfMS5pc0RlZmluZWQoZm4pKVxuICAgICAgICAgICAgcmV0dXJuIGFycmF5Lmxlbmd0aCA+IDEgPyBhcnJheSA6IGFycmF5WzBdO1xuICAgICAgICBpZiAoIXByZWRpY2F0ZXNfMS5pc1N0cmluZyhuYW1lKSB8fCAhcHJlZGljYXRlc18xLmlzRnVuY3Rpb24oZm4pKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBidWlsZGVyc1tuYW1lXSA9IGFycmF5O1xuICAgICAgICBidWlsZGVyc1tuYW1lXS5wdXNoKGZuKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJ1aWxkZXJzW25hbWVdLnNwbGljZShidWlsZGVyc1tuYW1lXS5pbmRleE9mKGZuLCAxKSkgJiYgbnVsbDsgfTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEJ1aWxkcyBhbGwgb2YgdGhlIHByb3BlcnRpZXMgb24gYW4gZXNzZW50aWFsbHkgYmxhbmsgU3RhdGUgb2JqZWN0LCByZXR1cm5pbmcgYSBTdGF0ZSBvYmplY3Qgd2hpY2ggaGFzIGFsbCBpdHNcbiAgICAgKiBwcm9wZXJ0aWVzIGFuZCBBUEkgYnVpbHQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RhdGUgYW4gdW5pbml0aWFsaXplZCBTdGF0ZSBvYmplY3RcbiAgICAgKiBAcmV0dXJucyB0aGUgYnVpbHQgU3RhdGUgb2JqZWN0XG4gICAgICovXG4gICAgU3RhdGVCdWlsZGVyLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBtYXRjaGVyID0gX2EubWF0Y2hlciwgYnVpbGRlcnMgPSBfYS5idWlsZGVycztcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50TmFtZShzdGF0ZSk7XG4gICAgICAgIGlmIChwYXJlbnQgJiYgIW1hdGNoZXIuZmluZChwYXJlbnQsIHVuZGVmaW5lZCwgZmFsc2UpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gYnVpbGRlcnMpIHtcbiAgICAgICAgICAgIGlmICghYnVpbGRlcnMuaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIHZhciBjaGFpbiA9IGJ1aWxkZXJzW2tleV0ucmVkdWNlKGZ1bmN0aW9uIChwYXJlbnRGbiwgc3RlcCkgeyByZXR1cm4gZnVuY3Rpb24gKF9zdGF0ZSkgeyByZXR1cm4gc3RlcChfc3RhdGUsIHBhcmVudEZuKTsgfTsgfSwgY29tbW9uXzEubm9vcCk7XG4gICAgICAgICAgICBzdGF0ZVtrZXldID0gY2hhaW4oc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9O1xuICAgIFN0YXRlQnVpbGRlci5wcm90b3R5cGUucGFyZW50TmFtZSA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICAvLyBuYW1lID0gJ2Zvby5iYXIuYmF6LioqJ1xuICAgICAgICB2YXIgbmFtZSA9IHN0YXRlLm5hbWUgfHwgJyc7XG4gICAgICAgIC8vIHNlZ21lbnRzID0gWydmb28nLCAnYmFyJywgJ2JheicsICcuKionXVxuICAgICAgICB2YXIgc2VnbWVudHMgPSBuYW1lLnNwbGl0KCcuJyk7XG4gICAgICAgIC8vIHNlZ21lbnRzID0gWydmb28nLCAnYmFyJywgJ2JheiddXG4gICAgICAgIHZhciBsYXN0U2VnbWVudCA9IHNlZ21lbnRzLnBvcCgpO1xuICAgICAgICAvLyBzZWdtZW50cyA9IFsnZm9vJywgJ2JhciddIChpZ25vcmUgLioqIHNlZ21lbnQgZm9yIGZ1dHVyZSBzdGF0ZXMpXG4gICAgICAgIGlmIChsYXN0U2VnbWVudCA9PT0gJyoqJylcbiAgICAgICAgICAgIHNlZ21lbnRzLnBvcCgpO1xuICAgICAgICBpZiAoc2VnbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3RhdGVzIHRoYXQgc3BlY2lmeSB0aGUgJ3BhcmVudDonIHByb3BlcnR5IHNob3VsZCBub3QgaGF2ZSBhICcuJyBpbiB0aGVpciBuYW1lIChcIiArIG5hbWUgKyBcIilcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyAnZm9vLmJhcidcbiAgICAgICAgICAgIHJldHVybiBzZWdtZW50cy5qb2luKCcuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzdGF0ZS5wYXJlbnQpXG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIHJldHVybiBwcmVkaWNhdGVzXzEuaXNTdHJpbmcoc3RhdGUucGFyZW50KSA/IHN0YXRlLnBhcmVudCA6IHN0YXRlLnBhcmVudC5uYW1lO1xuICAgIH07XG4gICAgU3RhdGVCdWlsZGVyLnByb3RvdHlwZS5uYW1lID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIHZhciBuYW1lID0gc3RhdGUubmFtZTtcbiAgICAgICAgaWYgKG5hbWUuaW5kZXhPZignLicpICE9PSAtMSB8fCAhc3RhdGUucGFyZW50KVxuICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgIHZhciBwYXJlbnROYW1lID0gcHJlZGljYXRlc18xLmlzU3RyaW5nKHN0YXRlLnBhcmVudCkgPyBzdGF0ZS5wYXJlbnQgOiBzdGF0ZS5wYXJlbnQubmFtZTtcbiAgICAgICAgcmV0dXJuIHBhcmVudE5hbWUgPyBwYXJlbnROYW1lICsgJy4nICsgbmFtZSA6IG5hbWU7XG4gICAgfTtcbiAgICByZXR1cm4gU3RhdGVCdWlsZGVyO1xufSgpKTtcbmV4cG9ydHMuU3RhdGVCdWlsZGVyID0gU3RhdGVCdWlsZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RhdGVCdWlsZGVyLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9zdGF0ZS9zdGF0ZUJ1aWxkZXIuanNcbi8vIG1vZHVsZSBpZCA9IDc0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///74\n")},function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @module state */ /** for typedoc */\nvar predicates_1 = __webpack_require__(1);\nvar common_1 = __webpack_require__(0);\nvar StateMatcher = /** @class */ (function () {\n    function StateMatcher(_states) {\n        this._states = _states;\n    }\n    StateMatcher.prototype.isRelative = function (stateName) {\n        stateName = stateName || '';\n        return stateName.indexOf('.') === 0 || stateName.indexOf('^') === 0;\n    };\n    StateMatcher.prototype.find = function (stateOrName, base, matchGlob) {\n        if (matchGlob === void 0) { matchGlob = true; }\n        if (!stateOrName && stateOrName !== '')\n            return undefined;\n        var isStr = predicates_1.isString(stateOrName);\n        var name = isStr ? stateOrName : stateOrName.name;\n        if (this.isRelative(name))\n            name = this.resolvePath(name, base);\n        var state = this._states[name];\n        if (state && (isStr || (!isStr && (state === stateOrName || state.self === stateOrName)))) {\n            return state;\n        }\n        else if (isStr && matchGlob) {\n            var _states = common_1.values(this._states);\n            var matches = _states.filter(function (_state) {\n                return _state.__stateObjectCache.nameGlob &&\n                    _state.__stateObjectCache.nameGlob.matches(name);\n            });\n            if (matches.length > 1) {\n                // tslint:disable-next-line:no-console\n                console.log(\"stateMatcher.find: Found multiple matches for \" + name + \" using glob: \", matches.map(function (match) { return match.name; }));\n            }\n            return matches[0];\n        }\n        return undefined;\n    };\n    StateMatcher.prototype.resolvePath = function (name, base) {\n        if (!base)\n            throw new Error(\"No reference point given for path '\" + name + \"'\");\n        var baseState = this.find(base);\n        var splitName = name.split('.');\n        var pathLength = splitName.length;\n        var i = 0, current = baseState;\n        for (; i < pathLength; i++) {\n            if (splitName[i] === '' && i === 0) {\n                current = baseState;\n                continue;\n            }\n            if (splitName[i] === '^') {\n                if (!current.parent)\n                    throw new Error(\"Path '\" + name + \"' not valid for state '\" + baseState.name + \"'\");\n                current = current.parent;\n                continue;\n            }\n            break;\n        }\n        var relName = splitName.slice(i).join('.');\n        return current.name + (current.name && relName ? '.' : '') + relName;\n    };\n    return StateMatcher;\n}());\nexports.StateMatcher = StateMatcher;\n//# sourceMappingURL=stateMatcher.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3N0YXRlL3N0YXRlTWF0Y2hlci5qcz85MDBjIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqIEBtb2R1bGUgc3RhdGUgKi8gLyoqIGZvciB0eXBlZG9jICovXG52YXIgcHJlZGljYXRlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9wcmVkaWNhdGVzXCIpO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb21tb25cIik7XG52YXIgU3RhdGVNYXRjaGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0YXRlTWF0Y2hlcihfc3RhdGVzKSB7XG4gICAgICAgIHRoaXMuX3N0YXRlcyA9IF9zdGF0ZXM7XG4gICAgfVxuICAgIFN0YXRlTWF0Y2hlci5wcm90b3R5cGUuaXNSZWxhdGl2ZSA9IGZ1bmN0aW9uIChzdGF0ZU5hbWUpIHtcbiAgICAgICAgc3RhdGVOYW1lID0gc3RhdGVOYW1lIHx8ICcnO1xuICAgICAgICByZXR1cm4gc3RhdGVOYW1lLmluZGV4T2YoJy4nKSA9PT0gMCB8fCBzdGF0ZU5hbWUuaW5kZXhPZignXicpID09PSAwO1xuICAgIH07XG4gICAgU3RhdGVNYXRjaGVyLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gKHN0YXRlT3JOYW1lLCBiYXNlLCBtYXRjaEdsb2IpIHtcbiAgICAgICAgaWYgKG1hdGNoR2xvYiA9PT0gdm9pZCAwKSB7IG1hdGNoR2xvYiA9IHRydWU7IH1cbiAgICAgICAgaWYgKCFzdGF0ZU9yTmFtZSAmJiBzdGF0ZU9yTmFtZSAhPT0gJycpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgaXNTdHIgPSBwcmVkaWNhdGVzXzEuaXNTdHJpbmcoc3RhdGVPck5hbWUpO1xuICAgICAgICB2YXIgbmFtZSA9IGlzU3RyID8gc3RhdGVPck5hbWUgOiBzdGF0ZU9yTmFtZS5uYW1lO1xuICAgICAgICBpZiAodGhpcy5pc1JlbGF0aXZlKG5hbWUpKVxuICAgICAgICAgICAgbmFtZSA9IHRoaXMucmVzb2x2ZVBhdGgobmFtZSwgYmFzZSk7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuX3N0YXRlc1tuYW1lXTtcbiAgICAgICAgaWYgKHN0YXRlICYmIChpc1N0ciB8fCAoIWlzU3RyICYmIChzdGF0ZSA9PT0gc3RhdGVPck5hbWUgfHwgc3RhdGUuc2VsZiA9PT0gc3RhdGVPck5hbWUpKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1N0ciAmJiBtYXRjaEdsb2IpIHtcbiAgICAgICAgICAgIHZhciBfc3RhdGVzID0gY29tbW9uXzEudmFsdWVzKHRoaXMuX3N0YXRlcyk7XG4gICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IF9zdGF0ZXMuZmlsdGVyKGZ1bmN0aW9uIChfc3RhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3N0YXRlLl9fc3RhdGVPYmplY3RDYWNoZS5uYW1lR2xvYiAmJlxuICAgICAgICAgICAgICAgICAgICBfc3RhdGUuX19zdGF0ZU9iamVjdENhY2hlLm5hbWVHbG9iLm1hdGNoZXMobmFtZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChtYXRjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tY29uc29sZVxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwic3RhdGVNYXRjaGVyLmZpbmQ6IEZvdW5kIG11bHRpcGxlIG1hdGNoZXMgZm9yIFwiICsgbmFtZSArIFwiIHVzaW5nIGdsb2I6IFwiLCBtYXRjaGVzLm1hcChmdW5jdGlvbiAobWF0Y2gpIHsgcmV0dXJuIG1hdGNoLm5hbWU7IH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXRjaGVzWzBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICBTdGF0ZU1hdGNoZXIucHJvdG90eXBlLnJlc29sdmVQYXRoID0gZnVuY3Rpb24gKG5hbWUsIGJhc2UpIHtcbiAgICAgICAgaWYgKCFiYXNlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gcmVmZXJlbmNlIHBvaW50IGdpdmVuIGZvciBwYXRoICdcIiArIG5hbWUgKyBcIidcIik7XG4gICAgICAgIHZhciBiYXNlU3RhdGUgPSB0aGlzLmZpbmQoYmFzZSk7XG4gICAgICAgIHZhciBzcGxpdE5hbWUgPSBuYW1lLnNwbGl0KCcuJyk7XG4gICAgICAgIHZhciBwYXRoTGVuZ3RoID0gc3BsaXROYW1lLmxlbmd0aDtcbiAgICAgICAgdmFyIGkgPSAwLCBjdXJyZW50ID0gYmFzZVN0YXRlO1xuICAgICAgICBmb3IgKDsgaSA8IHBhdGhMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHNwbGl0TmFtZVtpXSA9PT0gJycgJiYgaSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBiYXNlU3RhdGU7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3BsaXROYW1lW2ldID09PSAnXicpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnQucGFyZW50KVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXRoICdcIiArIG5hbWUgKyBcIicgbm90IHZhbGlkIGZvciBzdGF0ZSAnXCIgKyBiYXNlU3RhdGUubmFtZSArIFwiJ1wiKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVsTmFtZSA9IHNwbGl0TmFtZS5zbGljZShpKS5qb2luKCcuJyk7XG4gICAgICAgIHJldHVybiBjdXJyZW50Lm5hbWUgKyAoY3VycmVudC5uYW1lICYmIHJlbE5hbWUgPyAnLicgOiAnJykgKyByZWxOYW1lO1xuICAgIH07XG4gICAgcmV0dXJuIFN0YXRlTWF0Y2hlcjtcbn0oKSk7XG5leHBvcnRzLlN0YXRlTWF0Y2hlciA9IFN0YXRlTWF0Y2hlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0YXRlTWF0Y2hlci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvc3RhdGUvc3RhdGVNYXRjaGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA3NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///75\n")},function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @module state */ /** for typedoc */\nvar common_1 = __webpack_require__(0);\nvar predicates_1 = __webpack_require__(1);\nvar stateObject_1 = __webpack_require__(42);\nvar hof_1 = __webpack_require__(2);\n/** @internalapi */\nvar StateQueueManager = /** @class */ (function () {\n    function StateQueueManager($registry, $urlRouter, states, builder, listeners) {\n        this.$registry = $registry;\n        this.$urlRouter = $urlRouter;\n        this.states = states;\n        this.builder = builder;\n        this.listeners = listeners;\n        this.queue = [];\n        this.matcher = $registry.matcher;\n    }\n    /** @internalapi */\n    StateQueueManager.prototype.dispose = function () {\n        this.queue = [];\n    };\n    StateQueueManager.prototype.register = function (stateDecl) {\n        var queue = this.queue;\n        var state = stateObject_1.StateObject.create(stateDecl);\n        var name = state.name;\n        if (!predicates_1.isString(name))\n            throw new Error('State must have a valid name');\n        if (this.states.hasOwnProperty(name) || common_1.inArray(queue.map(hof_1.prop('name')), name))\n            throw new Error(\"State '\" + name + \"' is already defined\");\n        queue.push(state);\n        this.flush();\n        return state;\n    };\n    StateQueueManager.prototype.flush = function () {\n        var _this = this;\n        var _a = this, queue = _a.queue, states = _a.states, builder = _a.builder;\n        var registered = [], // states that got registered\n        orphans = [], // states that don't yet have a parent registered\n        previousQueueLength = {}; // keep track of how long the queue when an orphan was first encountered\n        var getState = function (name) {\n            return _this.states.hasOwnProperty(name) && _this.states[name];\n        };\n        while (queue.length > 0) {\n            var state = queue.shift();\n            var name_1 = state.name;\n            var result = builder.build(state);\n            var orphanIdx = orphans.indexOf(state);\n            if (result) {\n                var existingState = getState(name_1);\n                if (existingState && existingState.name === name_1) {\n                    throw new Error(\"State '\" + name_1 + \"' is already defined\");\n                }\n                var existingFutureState = getState(name_1 + '.**');\n                if (existingFutureState) {\n                    // Remove future state of the same name\n                    this.$registry.deregister(existingFutureState);\n                }\n                states[name_1] = state;\n                this.attachRoute(state);\n                if (orphanIdx >= 0)\n                    orphans.splice(orphanIdx, 1);\n                registered.push(state);\n                continue;\n            }\n            var prev = previousQueueLength[name_1];\n            previousQueueLength[name_1] = queue.length;\n            if (orphanIdx >= 0 && prev === queue.length) {\n                // Wait until two consecutive iterations where no additional states were dequeued successfully.\n                // throw new Error(`Cannot register orphaned state '${name}'`);\n                queue.push(state);\n                return states;\n            }\n            else if (orphanIdx < 0) {\n                orphans.push(state);\n            }\n            queue.push(state);\n        }\n        if (registered.length) {\n            this.listeners.forEach(function (listener) { return listener('registered', registered.map(function (s) { return s.self; })); });\n        }\n        return states;\n    };\n    StateQueueManager.prototype.attachRoute = function (state) {\n        if (state.abstract || !state.url)\n            return;\n        this.$urlRouter.rule(this.$urlRouter.urlRuleFactory.create(state));\n    };\n    return StateQueueManager;\n}());\nexports.StateQueueManager = StateQueueManager;\n//# sourceMappingURL=stateQueueManager.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3N0YXRlL3N0YXRlUXVldWVNYW5hZ2VyLmpzPzY4N2QiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKiogQG1vZHVsZSBzdGF0ZSAqLyAvKiogZm9yIHR5cGVkb2MgKi9cbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29tbW9uXCIpO1xudmFyIHByZWRpY2F0ZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vcHJlZGljYXRlc1wiKTtcbnZhciBzdGF0ZU9iamVjdF8xID0gcmVxdWlyZShcIi4vc3RhdGVPYmplY3RcIik7XG52YXIgaG9mXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2hvZlwiKTtcbi8qKiBAaW50ZXJuYWxhcGkgKi9cbnZhciBTdGF0ZVF1ZXVlTWFuYWdlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdGF0ZVF1ZXVlTWFuYWdlcigkcmVnaXN0cnksICR1cmxSb3V0ZXIsIHN0YXRlcywgYnVpbGRlciwgbGlzdGVuZXJzKSB7XG4gICAgICAgIHRoaXMuJHJlZ2lzdHJ5ID0gJHJlZ2lzdHJ5O1xuICAgICAgICB0aGlzLiR1cmxSb3V0ZXIgPSAkdXJsUm91dGVyO1xuICAgICAgICB0aGlzLnN0YXRlcyA9IHN0YXRlcztcbiAgICAgICAgdGhpcy5idWlsZGVyID0gYnVpbGRlcjtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG4gICAgICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICAgICAgdGhpcy5tYXRjaGVyID0gJHJlZ2lzdHJ5Lm1hdGNoZXI7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWxhcGkgKi9cbiAgICBTdGF0ZVF1ZXVlTWFuYWdlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgIH07XG4gICAgU3RhdGVRdWV1ZU1hbmFnZXIucHJvdG90eXBlLnJlZ2lzdGVyID0gZnVuY3Rpb24gKHN0YXRlRGVjbCkge1xuICAgICAgICB2YXIgcXVldWUgPSB0aGlzLnF1ZXVlO1xuICAgICAgICB2YXIgc3RhdGUgPSBzdGF0ZU9iamVjdF8xLlN0YXRlT2JqZWN0LmNyZWF0ZShzdGF0ZURlY2wpO1xuICAgICAgICB2YXIgbmFtZSA9IHN0YXRlLm5hbWU7XG4gICAgICAgIGlmICghcHJlZGljYXRlc18xLmlzU3RyaW5nKG5hbWUpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdGF0ZSBtdXN0IGhhdmUgYSB2YWxpZCBuYW1lJyk7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSB8fCBjb21tb25fMS5pbkFycmF5KHF1ZXVlLm1hcChob2ZfMS5wcm9wKCduYW1lJykpLCBuYW1lKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0YXRlICdcIiArIG5hbWUgKyBcIicgaXMgYWxyZWFkeSBkZWZpbmVkXCIpO1xuICAgICAgICBxdWV1ZS5wdXNoKHN0YXRlKTtcbiAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfTtcbiAgICBTdGF0ZVF1ZXVlTWFuYWdlci5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHF1ZXVlID0gX2EucXVldWUsIHN0YXRlcyA9IF9hLnN0YXRlcywgYnVpbGRlciA9IF9hLmJ1aWxkZXI7XG4gICAgICAgIHZhciByZWdpc3RlcmVkID0gW10sIC8vIHN0YXRlcyB0aGF0IGdvdCByZWdpc3RlcmVkXG4gICAgICAgIG9ycGhhbnMgPSBbXSwgLy8gc3RhdGVzIHRoYXQgZG9uJ3QgeWV0IGhhdmUgYSBwYXJlbnQgcmVnaXN0ZXJlZFxuICAgICAgICBwcmV2aW91c1F1ZXVlTGVuZ3RoID0ge307IC8vIGtlZXAgdHJhY2sgb2YgaG93IGxvbmcgdGhlIHF1ZXVlIHdoZW4gYW4gb3JwaGFuIHdhcyBmaXJzdCBlbmNvdW50ZXJlZFxuICAgICAgICB2YXIgZ2V0U3RhdGUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnN0YXRlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiBfdGhpcy5zdGF0ZXNbbmFtZV07XG4gICAgICAgIH07XG4gICAgICAgIHdoaWxlIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgc3RhdGUgPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgdmFyIG5hbWVfMSA9IHN0YXRlLm5hbWU7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gYnVpbGRlci5idWlsZChzdGF0ZSk7XG4gICAgICAgICAgICB2YXIgb3JwaGFuSWR4ID0gb3JwaGFucy5pbmRleE9mKHN0YXRlKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXhpc3RpbmdTdGF0ZSA9IGdldFN0YXRlKG5hbWVfMSk7XG4gICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nU3RhdGUgJiYgZXhpc3RpbmdTdGF0ZS5uYW1lID09PSBuYW1lXzEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3RhdGUgJ1wiICsgbmFtZV8xICsgXCInIGlzIGFscmVhZHkgZGVmaW5lZFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGV4aXN0aW5nRnV0dXJlU3RhdGUgPSBnZXRTdGF0ZShuYW1lXzEgKyAnLioqJyk7XG4gICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nRnV0dXJlU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGZ1dHVyZSBzdGF0ZSBvZiB0aGUgc2FtZSBuYW1lXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJHJlZ2lzdHJ5LmRlcmVnaXN0ZXIoZXhpc3RpbmdGdXR1cmVTdGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YXRlc1tuYW1lXzFdID0gc3RhdGU7XG4gICAgICAgICAgICAgICAgdGhpcy5hdHRhY2hSb3V0ZShzdGF0ZSk7XG4gICAgICAgICAgICAgICAgaWYgKG9ycGhhbklkeCA+PSAwKVxuICAgICAgICAgICAgICAgICAgICBvcnBoYW5zLnNwbGljZShvcnBoYW5JZHgsIDEpO1xuICAgICAgICAgICAgICAgIHJlZ2lzdGVyZWQucHVzaChzdGF0ZSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcHJldiA9IHByZXZpb3VzUXVldWVMZW5ndGhbbmFtZV8xXTtcbiAgICAgICAgICAgIHByZXZpb3VzUXVldWVMZW5ndGhbbmFtZV8xXSA9IHF1ZXVlLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChvcnBoYW5JZHggPj0gMCAmJiBwcmV2ID09PSBxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBXYWl0IHVudGlsIHR3byBjb25zZWN1dGl2ZSBpdGVyYXRpb25zIHdoZXJlIG5vIGFkZGl0aW9uYWwgc3RhdGVzIHdlcmUgZGVxdWV1ZWQgc3VjY2Vzc2Z1bGx5LlxuICAgICAgICAgICAgICAgIC8vIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHJlZ2lzdGVyIG9ycGhhbmVkIHN0YXRlICcke25hbWV9J2ApO1xuICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2goc3RhdGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvcnBoYW5JZHggPCAwKSB7XG4gICAgICAgICAgICAgICAgb3JwaGFucy5wdXNoKHN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHF1ZXVlLnB1c2goc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWdpc3RlcmVkLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHsgcmV0dXJuIGxpc3RlbmVyKCdyZWdpc3RlcmVkJywgcmVnaXN0ZXJlZC5tYXAoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMuc2VsZjsgfSkpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdGVzO1xuICAgIH07XG4gICAgU3RhdGVRdWV1ZU1hbmFnZXIucHJvdG90eXBlLmF0dGFjaFJvdXRlID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIGlmIChzdGF0ZS5hYnN0cmFjdCB8fCAhc3RhdGUudXJsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLiR1cmxSb3V0ZXIucnVsZSh0aGlzLiR1cmxSb3V0ZXIudXJsUnVsZUZhY3RvcnkuY3JlYXRlKHN0YXRlKSk7XG4gICAgfTtcbiAgICByZXR1cm4gU3RhdGVRdWV1ZU1hbmFnZXI7XG59KCkpO1xuZXhwb3J0cy5TdGF0ZVF1ZXVlTWFuYWdlciA9IFN0YXRlUXVldWVNYW5hZ2VyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RhdGVRdWV1ZU1hbmFnZXIuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3N0YXRlL3N0YXRlUXVldWVNYW5hZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA3NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///76\n")},function(module,exports,__webpack_require__){"use strict";eval("\n/**\n * @coreapi\n * @module state\n */ /** for typedoc */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar stateMatcher_1 = __webpack_require__(75);\nvar stateBuilder_1 = __webpack_require__(74);\nvar stateQueueManager_1 = __webpack_require__(76);\nvar common_1 = __webpack_require__(0);\nvar hof_1 = __webpack_require__(2);\nvar StateRegistry = /** @class */ (function () {\n    /** @internalapi */\n    function StateRegistry(_router) {\n        this._router = _router;\n        this.states = {};\n        this.listeners = [];\n        this.matcher = new stateMatcher_1.StateMatcher(this.states);\n        this.builder = new stateBuilder_1.StateBuilder(this.matcher, _router.urlMatcherFactory);\n        this.stateQueue = new stateQueueManager_1.StateQueueManager(this, _router.urlRouter, this.states, this.builder, this.listeners);\n        this._registerRoot();\n    }\n    /** @internalapi */\n    StateRegistry.prototype._registerRoot = function () {\n        var rootStateDef = {\n            name: '',\n            url: '^',\n            views: null,\n            params: {\n                '#': { value: null, type: 'hash', dynamic: true },\n            },\n            abstract: true,\n        };\n        var _root = this._root = this.stateQueue.register(rootStateDef);\n        _root.navigable = null;\n    };\n    /** @internalapi */\n    StateRegistry.prototype.dispose = function () {\n        var _this = this;\n        this.stateQueue.dispose();\n        this.listeners = [];\n        this.get().forEach(function (state) { return _this.get(state) && _this.deregister(state); });\n    };\n    /**\n     * Listen for a State Registry events\n     *\n     * Adds a callback that is invoked when states are registered or deregistered with the StateRegistry.\n     *\n     * #### Example:\n     * ```js\n     * let allStates = registry.get();\n     *\n     * // Later, invoke deregisterFn() to remove the listener\n     * let deregisterFn = registry.onStatesChanged((event, states) => {\n     *   switch(event) {\n     *     case: 'registered':\n     *       states.forEach(state => allStates.push(state));\n     *       break;\n     *     case: 'deregistered':\n     *       states.forEach(state => {\n     *         let idx = allStates.indexOf(state);\n     *         if (idx !== -1) allStates.splice(idx, 1);\n     *       });\n     *       break;\n     *   }\n     * });\n     * ```\n     *\n     * @param listener a callback function invoked when the registered states changes.\n     *        The function receives two parameters, `event` and `state`.\n     *        See [[StateRegistryListener]]\n     * @return a function that deregisters the listener\n     */\n    StateRegistry.prototype.onStatesChanged = function (listener) {\n        this.listeners.push(listener);\n        return function deregisterListener() {\n            common_1.removeFrom(this.listeners)(listener);\n        }.bind(this);\n    };\n    /**\n     * Gets the implicit root state\n     *\n     * Gets the root of the state tree.\n     * The root state is implicitly created by UI-Router.\n     * Note: this returns the internal [[StateObject]] representation, not a [[StateDeclaration]]\n     *\n     * @return the root [[StateObject]]\n     */\n    StateRegistry.prototype.root = function () {\n        return this._root;\n    };\n    /**\n     * Adds a state to the registry\n     *\n     * Registers a [[StateDeclaration]] or queues it for registration.\n     *\n     * Note: a state will be queued if the state's parent isn't yet registered.\n     *\n     * @param stateDefinition the definition of the state to register.\n     * @returns the internal [[StateObject]] object.\n     *          If the state was successfully registered, then the object is fully built (See: [[StateBuilder]]).\n     *          If the state was only queued, then the object is not fully built.\n     */\n    StateRegistry.prototype.register = function (stateDefinition) {\n        return this.stateQueue.register(stateDefinition);\n    };\n    /** @hidden */\n    StateRegistry.prototype._deregisterTree = function (state) {\n        var _this = this;\n        var all = this.get().map(function (s) { return s.$$state(); });\n        var getChildren = function (states) {\n            var _children = all.filter(function (s) { return states.indexOf(s.parent) !== -1; });\n            return _children.length === 0 ? _children : _children.concat(getChildren(_children));\n        };\n        var children = getChildren([state]);\n        var deregistered = [state].concat(children).reverse();\n        deregistered.forEach(function (_state) {\n            var $ur = _this._router.urlRouter;\n            // Remove URL rule\n            $ur.rules().filter(hof_1.propEq('state', _state)).forEach($ur.removeRule.bind($ur));\n            // Remove state from registry\n            delete _this.states[_state.name];\n        });\n        return deregistered;\n    };\n    /**\n     * Removes a state from the registry\n     *\n     * This removes a state from the registry.\n     * If the state has children, they are are also removed from the registry.\n     *\n     * @param stateOrName the state's name or object representation\n     * @returns {StateObject[]} a list of removed states\n     */\n    StateRegistry.prototype.deregister = function (stateOrName) {\n        var _state = this.get(stateOrName);\n        if (!_state)\n            throw new Error(\"Can't deregister state; not found: \" + stateOrName);\n        var deregisteredStates = this._deregisterTree(_state.$$state());\n        this.listeners.forEach(function (listener) { return listener('deregistered', deregisteredStates.map(function (s) { return s.self; })); });\n        return deregisteredStates;\n    };\n    StateRegistry.prototype.get = function (stateOrName, base) {\n        var _this = this;\n        if (arguments.length === 0)\n            return Object.keys(this.states).map(function (name) { return _this.states[name].self; });\n        var found = this.matcher.find(stateOrName, base);\n        return found && found.self || null;\n    };\n    StateRegistry.prototype.decorator = function (name, func) {\n        return this.builder.builder(name, func);\n    };\n    return StateRegistry;\n}());\nexports.StateRegistry = StateRegistry;\n//# sourceMappingURL=stateRegistry.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3N0YXRlL3N0YXRlUmVnaXN0cnkuanM/ZTZmOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQGNvcmVhcGlcbiAqIEBtb2R1bGUgc3RhdGVcbiAqLyAvKiogZm9yIHR5cGVkb2MgKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBzdGF0ZU1hdGNoZXJfMSA9IHJlcXVpcmUoXCIuL3N0YXRlTWF0Y2hlclwiKTtcbnZhciBzdGF0ZUJ1aWxkZXJfMSA9IHJlcXVpcmUoXCIuL3N0YXRlQnVpbGRlclwiKTtcbnZhciBzdGF0ZVF1ZXVlTWFuYWdlcl8xID0gcmVxdWlyZShcIi4vc3RhdGVRdWV1ZU1hbmFnZXJcIik7XG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcbnZhciBob2ZfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vaG9mXCIpO1xudmFyIFN0YXRlUmVnaXN0cnkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqIEBpbnRlcm5hbGFwaSAqL1xuICAgIGZ1bmN0aW9uIFN0YXRlUmVnaXN0cnkoX3JvdXRlcikge1xuICAgICAgICB0aGlzLl9yb3V0ZXIgPSBfcm91dGVyO1xuICAgICAgICB0aGlzLnN0YXRlcyA9IHt9O1xuICAgICAgICB0aGlzLmxpc3RlbmVycyA9IFtdO1xuICAgICAgICB0aGlzLm1hdGNoZXIgPSBuZXcgc3RhdGVNYXRjaGVyXzEuU3RhdGVNYXRjaGVyKHRoaXMuc3RhdGVzKTtcbiAgICAgICAgdGhpcy5idWlsZGVyID0gbmV3IHN0YXRlQnVpbGRlcl8xLlN0YXRlQnVpbGRlcih0aGlzLm1hdGNoZXIsIF9yb3V0ZXIudXJsTWF0Y2hlckZhY3RvcnkpO1xuICAgICAgICB0aGlzLnN0YXRlUXVldWUgPSBuZXcgc3RhdGVRdWV1ZU1hbmFnZXJfMS5TdGF0ZVF1ZXVlTWFuYWdlcih0aGlzLCBfcm91dGVyLnVybFJvdXRlciwgdGhpcy5zdGF0ZXMsIHRoaXMuYnVpbGRlciwgdGhpcy5saXN0ZW5lcnMpO1xuICAgICAgICB0aGlzLl9yZWdpc3RlclJvb3QoKTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbGFwaSAqL1xuICAgIFN0YXRlUmVnaXN0cnkucHJvdG90eXBlLl9yZWdpc3RlclJvb3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByb290U3RhdGVEZWYgPSB7XG4gICAgICAgICAgICBuYW1lOiAnJyxcbiAgICAgICAgICAgIHVybDogJ14nLFxuICAgICAgICAgICAgdmlld3M6IG51bGwsXG4gICAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgICAgICAnIyc6IHsgdmFsdWU6IG51bGwsIHR5cGU6ICdoYXNoJywgZHluYW1pYzogdHJ1ZSB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFic3RyYWN0OiB0cnVlLFxuICAgICAgICB9O1xuICAgICAgICB2YXIgX3Jvb3QgPSB0aGlzLl9yb290ID0gdGhpcy5zdGF0ZVF1ZXVlLnJlZ2lzdGVyKHJvb3RTdGF0ZURlZik7XG4gICAgICAgIF9yb290Lm5hdmlnYWJsZSA9IG51bGw7XG4gICAgfTtcbiAgICAvKiogQGludGVybmFsYXBpICovXG4gICAgU3RhdGVSZWdpc3RyeS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5zdGF0ZVF1ZXVlLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgdGhpcy5nZXQoKS5mb3JFYWNoKGZ1bmN0aW9uIChzdGF0ZSkgeyByZXR1cm4gX3RoaXMuZ2V0KHN0YXRlKSAmJiBfdGhpcy5kZXJlZ2lzdGVyKHN0YXRlKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBMaXN0ZW4gZm9yIGEgU3RhdGUgUmVnaXN0cnkgZXZlbnRzXG4gICAgICpcbiAgICAgKiBBZGRzIGEgY2FsbGJhY2sgdGhhdCBpcyBpbnZva2VkIHdoZW4gc3RhdGVzIGFyZSByZWdpc3RlcmVkIG9yIGRlcmVnaXN0ZXJlZCB3aXRoIHRoZSBTdGF0ZVJlZ2lzdHJ5LlxuICAgICAqXG4gICAgICogIyMjIyBFeGFtcGxlOlxuICAgICAqIGBgYGpzXG4gICAgICogbGV0IGFsbFN0YXRlcyA9IHJlZ2lzdHJ5LmdldCgpO1xuICAgICAqXG4gICAgICogLy8gTGF0ZXIsIGludm9rZSBkZXJlZ2lzdGVyRm4oKSB0byByZW1vdmUgdGhlIGxpc3RlbmVyXG4gICAgICogbGV0IGRlcmVnaXN0ZXJGbiA9IHJlZ2lzdHJ5Lm9uU3RhdGVzQ2hhbmdlZCgoZXZlbnQsIHN0YXRlcykgPT4ge1xuICAgICAqICAgc3dpdGNoKGV2ZW50KSB7XG4gICAgICogICAgIGNhc2U6ICdyZWdpc3RlcmVkJzpcbiAgICAgKiAgICAgICBzdGF0ZXMuZm9yRWFjaChzdGF0ZSA9PiBhbGxTdGF0ZXMucHVzaChzdGF0ZSkpO1xuICAgICAqICAgICAgIGJyZWFrO1xuICAgICAqICAgICBjYXNlOiAnZGVyZWdpc3RlcmVkJzpcbiAgICAgKiAgICAgICBzdGF0ZXMuZm9yRWFjaChzdGF0ZSA9PiB7XG4gICAgICogICAgICAgICBsZXQgaWR4ID0gYWxsU3RhdGVzLmluZGV4T2Yoc3RhdGUpO1xuICAgICAqICAgICAgICAgaWYgKGlkeCAhPT0gLTEpIGFsbFN0YXRlcy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgKiAgICAgICB9KTtcbiAgICAgKiAgICAgICBicmVhaztcbiAgICAgKiAgIH1cbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBsaXN0ZW5lciBhIGNhbGxiYWNrIGZ1bmN0aW9uIGludm9rZWQgd2hlbiB0aGUgcmVnaXN0ZXJlZCBzdGF0ZXMgY2hhbmdlcy5cbiAgICAgKiAgICAgICAgVGhlIGZ1bmN0aW9uIHJlY2VpdmVzIHR3byBwYXJhbWV0ZXJzLCBgZXZlbnRgIGFuZCBgc3RhdGVgLlxuICAgICAqICAgICAgICBTZWUgW1tTdGF0ZVJlZ2lzdHJ5TGlzdGVuZXJdXVxuICAgICAqIEByZXR1cm4gYSBmdW5jdGlvbiB0aGF0IGRlcmVnaXN0ZXJzIHRoZSBsaXN0ZW5lclxuICAgICAqL1xuICAgIFN0YXRlUmVnaXN0cnkucHJvdG90eXBlLm9uU3RhdGVzQ2hhbmdlZCA9IGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLmxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGRlcmVnaXN0ZXJMaXN0ZW5lcigpIHtcbiAgICAgICAgICAgIGNvbW1vbl8xLnJlbW92ZUZyb20odGhpcy5saXN0ZW5lcnMpKGxpc3RlbmVyKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaW1wbGljaXQgcm9vdCBzdGF0ZVxuICAgICAqXG4gICAgICogR2V0cyB0aGUgcm9vdCBvZiB0aGUgc3RhdGUgdHJlZS5cbiAgICAgKiBUaGUgcm9vdCBzdGF0ZSBpcyBpbXBsaWNpdGx5IGNyZWF0ZWQgYnkgVUktUm91dGVyLlxuICAgICAqIE5vdGU6IHRoaXMgcmV0dXJucyB0aGUgaW50ZXJuYWwgW1tTdGF0ZU9iamVjdF1dIHJlcHJlc2VudGF0aW9uLCBub3QgYSBbW1N0YXRlRGVjbGFyYXRpb25dXVxuICAgICAqXG4gICAgICogQHJldHVybiB0aGUgcm9vdCBbW1N0YXRlT2JqZWN0XV1cbiAgICAgKi9cbiAgICBTdGF0ZVJlZ2lzdHJ5LnByb3RvdHlwZS5yb290ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcm9vdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZHMgYSBzdGF0ZSB0byB0aGUgcmVnaXN0cnlcbiAgICAgKlxuICAgICAqIFJlZ2lzdGVycyBhIFtbU3RhdGVEZWNsYXJhdGlvbl1dIG9yIHF1ZXVlcyBpdCBmb3IgcmVnaXN0cmF0aW9uLlxuICAgICAqXG4gICAgICogTm90ZTogYSBzdGF0ZSB3aWxsIGJlIHF1ZXVlZCBpZiB0aGUgc3RhdGUncyBwYXJlbnQgaXNuJ3QgeWV0IHJlZ2lzdGVyZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RhdGVEZWZpbml0aW9uIHRoZSBkZWZpbml0aW9uIG9mIHRoZSBzdGF0ZSB0byByZWdpc3Rlci5cbiAgICAgKiBAcmV0dXJucyB0aGUgaW50ZXJuYWwgW1tTdGF0ZU9iamVjdF1dIG9iamVjdC5cbiAgICAgKiAgICAgICAgICBJZiB0aGUgc3RhdGUgd2FzIHN1Y2Nlc3NmdWxseSByZWdpc3RlcmVkLCB0aGVuIHRoZSBvYmplY3QgaXMgZnVsbHkgYnVpbHQgKFNlZTogW1tTdGF0ZUJ1aWxkZXJdXSkuXG4gICAgICogICAgICAgICAgSWYgdGhlIHN0YXRlIHdhcyBvbmx5IHF1ZXVlZCwgdGhlbiB0aGUgb2JqZWN0IGlzIG5vdCBmdWxseSBidWlsdC5cbiAgICAgKi9cbiAgICBTdGF0ZVJlZ2lzdHJ5LnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChzdGF0ZURlZmluaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGVRdWV1ZS5yZWdpc3RlcihzdGF0ZURlZmluaXRpb24pO1xuICAgIH07XG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBTdGF0ZVJlZ2lzdHJ5LnByb3RvdHlwZS5fZGVyZWdpc3RlclRyZWUgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGFsbCA9IHRoaXMuZ2V0KCkubWFwKGZ1bmN0aW9uIChzKSB7IHJldHVybiBzLiQkc3RhdGUoKTsgfSk7XG4gICAgICAgIHZhciBnZXRDaGlsZHJlbiA9IGZ1bmN0aW9uIChzdGF0ZXMpIHtcbiAgICAgICAgICAgIHZhciBfY2hpbGRyZW4gPSBhbGwuZmlsdGVyKGZ1bmN0aW9uIChzKSB7IHJldHVybiBzdGF0ZXMuaW5kZXhPZihzLnBhcmVudCkgIT09IC0xOyB9KTtcbiAgICAgICAgICAgIHJldHVybiBfY2hpbGRyZW4ubGVuZ3RoID09PSAwID8gX2NoaWxkcmVuIDogX2NoaWxkcmVuLmNvbmNhdChnZXRDaGlsZHJlbihfY2hpbGRyZW4pKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gZ2V0Q2hpbGRyZW4oW3N0YXRlXSk7XG4gICAgICAgIHZhciBkZXJlZ2lzdGVyZWQgPSBbc3RhdGVdLmNvbmNhdChjaGlsZHJlbikucmV2ZXJzZSgpO1xuICAgICAgICBkZXJlZ2lzdGVyZWQuZm9yRWFjaChmdW5jdGlvbiAoX3N0YXRlKSB7XG4gICAgICAgICAgICB2YXIgJHVyID0gX3RoaXMuX3JvdXRlci51cmxSb3V0ZXI7XG4gICAgICAgICAgICAvLyBSZW1vdmUgVVJMIHJ1bGVcbiAgICAgICAgICAgICR1ci5ydWxlcygpLmZpbHRlcihob2ZfMS5wcm9wRXEoJ3N0YXRlJywgX3N0YXRlKSkuZm9yRWFjaCgkdXIucmVtb3ZlUnVsZS5iaW5kKCR1cikpO1xuICAgICAgICAgICAgLy8gUmVtb3ZlIHN0YXRlIGZyb20gcmVnaXN0cnlcbiAgICAgICAgICAgIGRlbGV0ZSBfdGhpcy5zdGF0ZXNbX3N0YXRlLm5hbWVdO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRlcmVnaXN0ZXJlZDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBzdGF0ZSBmcm9tIHRoZSByZWdpc3RyeVxuICAgICAqXG4gICAgICogVGhpcyByZW1vdmVzIGEgc3RhdGUgZnJvbSB0aGUgcmVnaXN0cnkuXG4gICAgICogSWYgdGhlIHN0YXRlIGhhcyBjaGlsZHJlbiwgdGhleSBhcmUgYXJlIGFsc28gcmVtb3ZlZCBmcm9tIHRoZSByZWdpc3RyeS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdGF0ZU9yTmFtZSB0aGUgc3RhdGUncyBuYW1lIG9yIG9iamVjdCByZXByZXNlbnRhdGlvblxuICAgICAqIEByZXR1cm5zIHtTdGF0ZU9iamVjdFtdfSBhIGxpc3Qgb2YgcmVtb3ZlZCBzdGF0ZXNcbiAgICAgKi9cbiAgICBTdGF0ZVJlZ2lzdHJ5LnByb3RvdHlwZS5kZXJlZ2lzdGVyID0gZnVuY3Rpb24gKHN0YXRlT3JOYW1lKSB7XG4gICAgICAgIHZhciBfc3RhdGUgPSB0aGlzLmdldChzdGF0ZU9yTmFtZSk7XG4gICAgICAgIGlmICghX3N0YXRlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgZGVyZWdpc3RlciBzdGF0ZTsgbm90IGZvdW5kOiBcIiArIHN0YXRlT3JOYW1lKTtcbiAgICAgICAgdmFyIGRlcmVnaXN0ZXJlZFN0YXRlcyA9IHRoaXMuX2RlcmVnaXN0ZXJUcmVlKF9zdGF0ZS4kJHN0YXRlKCkpO1xuICAgICAgICB0aGlzLmxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikgeyByZXR1cm4gbGlzdGVuZXIoJ2RlcmVnaXN0ZXJlZCcsIGRlcmVnaXN0ZXJlZFN0YXRlcy5tYXAoZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMuc2VsZjsgfSkpOyB9KTtcbiAgICAgICAgcmV0dXJuIGRlcmVnaXN0ZXJlZFN0YXRlcztcbiAgICB9O1xuICAgIFN0YXRlUmVnaXN0cnkucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChzdGF0ZU9yTmFtZSwgYmFzZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnN0YXRlcykubWFwKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBfdGhpcy5zdGF0ZXNbbmFtZV0uc2VsZjsgfSk7XG4gICAgICAgIHZhciBmb3VuZCA9IHRoaXMubWF0Y2hlci5maW5kKHN0YXRlT3JOYW1lLCBiYXNlKTtcbiAgICAgICAgcmV0dXJuIGZvdW5kICYmIGZvdW5kLnNlbGYgfHwgbnVsbDtcbiAgICB9O1xuICAgIFN0YXRlUmVnaXN0cnkucHJvdG90eXBlLmRlY29yYXRvciA9IGZ1bmN0aW9uIChuYW1lLCBmdW5jKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1aWxkZXIuYnVpbGRlcihuYW1lLCBmdW5jKTtcbiAgICB9O1xuICAgIHJldHVybiBTdGF0ZVJlZ2lzdHJ5O1xufSgpKTtcbmV4cG9ydHMuU3RhdGVSZWdpc3RyeSA9IFN0YXRlUmVnaXN0cnk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdGF0ZVJlZ2lzdHJ5LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9zdGF0ZS9zdGF0ZVJlZ2lzdHJ5LmpzXG4vLyBtb2R1bGUgaWQgPSA3N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///77\n")},function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @coreapi\n * @module state\n */\n/** */\nvar common_1 = __webpack_require__(0);\nvar predicates_1 = __webpack_require__(1);\nvar queue_1 = __webpack_require__(43);\nvar coreservices_1 = __webpack_require__(3);\nvar pathUtils_1 = __webpack_require__(30);\nvar pathNode_1 = __webpack_require__(45);\nvar transitionService_1 = __webpack_require__(47);\nvar rejectFactory_1 = __webpack_require__(24);\nvar targetState_1 = __webpack_require__(17);\nvar param_1 = __webpack_require__(18);\nvar glob_1 = __webpack_require__(28);\nvar resolveContext_1 = __webpack_require__(31);\nvar lazyLoad_1 = __webpack_require__(86);\nvar hof_1 = __webpack_require__(2);\n/**\n * Provides state related service functions\n *\n * This class provides services related to ui-router states.\n * An instance of this class is located on the global [[UIRouter]] object.\n */\nvar StateService = /** @class */ (function () {\n    /** @internalapi */\n    function StateService(router) {\n        this.router = router;\n        /** @internalapi */\n        this.invalidCallbacks = [];\n        /** @hidden */\n        this._defaultErrorHandler = function $defaultErrorHandler($error$) {\n            if ($error$ instanceof Error && $error$.stack) {\n                console.error($error$);\n                console.error($error$.stack);\n            }\n            else if ($error$ instanceof rejectFactory_1.Rejection) {\n                console.error($error$.toString());\n                if ($error$.detail && $error$.detail.stack)\n                    console.error($error$.detail.stack);\n            }\n            else {\n                console.error($error$);\n            }\n        };\n        var getters = ['current', '$current', 'params', 'transition'];\n        var boundFns = Object.keys(StateService.prototype).filter(hof_1.not(common_1.inArray(getters)));\n        common_1.createProxyFunctions(hof_1.val(StateService.prototype), this, hof_1.val(this), boundFns);\n    }\n    Object.defineProperty(StateService.prototype, \"transition\", {\n        /**\n         * The [[Transition]] currently in progress (or null)\n         *\n         * This is a passthrough through to [[UIRouterGlobals.transition]]\n         */\n        get: function () { return this.router.globals.transition; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StateService.prototype, \"params\", {\n        /**\n         * The latest successful state parameters\n         *\n         * This is a passthrough through to [[UIRouterGlobals.params]]\n         */\n        get: function () { return this.router.globals.params; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StateService.prototype, \"current\", {\n        /**\n         * The current [[StateDeclaration]]\n         *\n         * This is a passthrough through to [[UIRouterGlobals.current]]\n         */\n        get: function () { return this.router.globals.current; },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(StateService.prototype, \"$current\", {\n        /**\n         * The current [[StateObject]]\n         *\n         * This is a passthrough through to [[UIRouterGlobals.$current]]\n         */\n        get: function () { return this.router.globals.$current; },\n        enumerable: true,\n        configurable: true\n    });\n    /** @internalapi */\n    StateService.prototype.dispose = function () {\n        this.defaultErrorHandler(common_1.noop);\n        this.invalidCallbacks = [];\n    };\n    /**\n     * Handler for when [[transitionTo]] is called with an invalid state.\n     *\n     * Invokes the [[onInvalid]] callbacks, in natural order.\n     * Each callback's return value is checked in sequence until one of them returns an instance of TargetState.\n     * The results of the callbacks are wrapped in $q.when(), so the callbacks may return promises.\n     *\n     * If a callback returns an TargetState, then it is used as arguments to $state.transitionTo() and the result returned.\n     *\n     * @internalapi\n     */\n    StateService.prototype._handleInvalidTargetState = function (fromPath, toState) {\n        var _this = this;\n        var fromState = pathUtils_1.PathUtils.makeTargetState(this.router.stateRegistry, fromPath);\n        var globals = this.router.globals;\n        var latestThing = function () { return globals.transitionHistory.peekTail(); };\n        var latest = latestThing();\n        var callbackQueue = new queue_1.Queue(this.invalidCallbacks.slice());\n        var injector = new resolveContext_1.ResolveContext(fromPath).injector();\n        var checkForRedirect = function (result) {\n            if (!(result instanceof targetState_1.TargetState)) {\n                return;\n            }\n            var target = result;\n            // Recreate the TargetState, in case the state is now defined.\n            target = _this.target(target.identifier(), target.params(), target.options());\n            if (!target.valid()) {\n                return rejectFactory_1.Rejection.invalid(target.error()).toPromise();\n            }\n            if (latestThing() !== latest) {\n                return rejectFactory_1.Rejection.superseded().toPromise();\n            }\n            return _this.transitionTo(target.identifier(), target.params(), target.options());\n        };\n        function invokeNextCallback() {\n            var nextCallback = callbackQueue.dequeue();\n            if (nextCallback === undefined)\n                return rejectFactory_1.Rejection.invalid(toState.error()).toPromise();\n            var callbackResult = coreservices_1.services.$q.when(nextCallback(toState, fromState, injector));\n            return callbackResult.then(checkForRedirect).then(function (result) { return result || invokeNextCallback(); });\n        }\n        return invokeNextCallback();\n    };\n    /**\n     * Registers an Invalid State handler\n     *\n     * Registers a [[OnInvalidCallback]] function to be invoked when [[StateService.transitionTo]]\n     * has been called with an invalid state reference parameter\n     *\n     * Example:\n     * ```js\n     * stateService.onInvalid(function(to, from, injector) {\n     *   if (to.name() === 'foo') {\n     *     let lazyLoader = injector.get('LazyLoadService');\n     *     return lazyLoader.load('foo')\n     *         .then(() => stateService.target('foo'));\n     *   }\n     * });\n     * ```\n     *\n     * @param {function} callback invoked when the toState is invalid\n     *   This function receives the (invalid) toState, the fromState, and an injector.\n     *   The function may optionally return a [[TargetState]] or a Promise for a TargetState.\n     *   If one is returned, it is treated as a redirect.\n     *\n     * @returns a function which deregisters the callback\n     */\n    StateService.prototype.onInvalid = function (callback) {\n        this.invalidCallbacks.push(callback);\n        return function deregisterListener() {\n            common_1.removeFrom(this.invalidCallbacks)(callback);\n        }.bind(this);\n    };\n    /**\n     * Reloads the current state\n     *\n     * A method that force reloads the current state, or a partial state hierarchy.\n     * All resolves are re-resolved, and components reinstantiated.\n     *\n     * #### Example:\n     * ```js\n     * let app angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.reload = function(){\n     *     $state.reload();\n     *   }\n     * });\n     * ```\n     *\n     * Note: `reload()` is just an alias for:\n     *\n     * ```js\n     * $state.transitionTo($state.current, $state.params, {\n     *   reload: true, inherit: false\n     * });\n     * ```\n     *\n     * @param reloadState A state name or a state object.\n     *    If present, this state and all its children will be reloaded, but ancestors will not reload.\n     *\n     * #### Example:\n     * ```js\n     * //assuming app application consists of 3 states: 'contacts', 'contacts.detail', 'contacts.detail.item'\n     * //and current state is 'contacts.detail.item'\n     * let app angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.reload = function(){\n     *     //will reload 'contact.detail' and nested 'contact.detail.item' states\n     *     $state.reload('contact.detail');\n     *   }\n     * });\n     * ```\n     *\n     * @returns A promise representing the state of the new transition. See [[StateService.go]]\n     */\n    StateService.prototype.reload = function (reloadState) {\n        return this.transitionTo(this.current, this.params, {\n            reload: predicates_1.isDefined(reloadState) ? reloadState : true,\n            inherit: false,\n            notify: false,\n        });\n    };\n    /**\n     * Transition to a different state and/or parameters\n     *\n     * Convenience method for transitioning to a new state.\n     *\n     * `$state.go` calls `$state.transitionTo` internally but automatically sets options to\n     * `{ location: true, inherit: true, relative: router.globals.$current, notify: true }`.\n     * This allows you to use either an absolute or relative `to` argument (because of `relative: router.globals.$current`).\n     * It also allows you to specify * only the parameters you'd like to update, while letting unspecified parameters\n     * inherit from the current parameter values (because of `inherit: true`).\n     *\n     * #### Example:\n     * ```js\n     * let app = angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.changeState = function () {\n     *     $state.go('contact.detail');\n     *   };\n     * });\n     * ```\n     *\n     * @param to Absolute state name, state object, or relative state path (relative to current state).\n     *\n     * Some examples:\n     *\n     * - `$state.go('contact.detail')` - will go to the `contact.detail` state\n     * - `$state.go('^')` - will go to the parent state\n     * - `$state.go('^.sibling')` - if current state is `home.child`, will go to the `home.sibling` state\n     * - `$state.go('.child.grandchild')` - if current state is home, will go to the `home.child.grandchild` state\n     *\n     * @param params A map of the parameters that will be sent to the state, will populate $stateParams.\n     *\n     *    Any parameters that are not specified will be inherited from current parameter values (because of `inherit: true`).\n     *    This allows, for example, going to a sibling state that shares parameters defined by a parent state.\n     *\n     * @param options Transition options\n     *\n     * @returns {promise} A promise representing the state of the new transition.\n     */\n    StateService.prototype.go = function (to, params, options) {\n        var defautGoOpts = { relative: this.$current, inherit: true };\n        var transOpts = common_1.defaults(options, defautGoOpts, transitionService_1.defaultTransOpts);\n        return this.transitionTo(to, params, transOpts);\n    };\n    /**\n     * Creates a [[TargetState]]\n     *\n     * This is a factory method for creating a TargetState\n     *\n     * This may be returned from a Transition Hook to redirect a transition, for example.\n     */\n    StateService.prototype.target = function (identifier, params, options) {\n        if (options === void 0) { options = {}; }\n        // If we're reloading, find the state object to reload from\n        if (predicates_1.isObject(options.reload) && !options.reload.name)\n            throw new Error('Invalid reload state object');\n        var reg = this.router.stateRegistry;\n        options.reloadState = options.reload === true ? reg.root() : reg.matcher.find(options.reload, options.relative);\n        if (options.reload && !options.reloadState)\n            throw new Error(\"No such reload state '\" + (predicates_1.isString(options.reload) ? options.reload : options.reload.name) + \"'\");\n        return new targetState_1.TargetState(this.router.stateRegistry, identifier, params, options);\n    };\n    StateService.prototype.getCurrentPath = function () {\n        var _this = this;\n        var globals = this.router.globals;\n        var latestSuccess = globals.successfulTransitions.peekTail();\n        var rootPath = function () { return [new pathNode_1.PathNode(_this.router.stateRegistry.root())]; };\n        return latestSuccess ? latestSuccess.treeChanges().to : rootPath();\n    };\n    /**\n     * Low-level method for transitioning to a new state.\n     *\n     * The [[go]] method (which uses `transitionTo` internally) is recommended in most situations.\n     *\n     * #### Example:\n     * ```js\n     * let app = angular.module('app', ['ui.router']);\n     *\n     * app.controller('ctrl', function ($scope, $state) {\n     *   $scope.changeState = function () {\n     *     $state.transitionTo('contact.detail');\n     *   };\n     * });\n     * ```\n     *\n     * @param to State name or state object.\n     * @param toParams A map of the parameters that will be sent to the state,\n     *      will populate $stateParams.\n     * @param options Transition options\n     *\n     * @returns A promise representing the state of the new transition. See [[go]]\n     */\n    StateService.prototype.transitionTo = function (to, toParams, options) {\n        var _this = this;\n        if (toParams === void 0) { toParams = {}; }\n        if (options === void 0) { options = {}; }\n        var router = this.router;\n        var globals = router.globals;\n        options = common_1.defaults(options, transitionService_1.defaultTransOpts);\n        var getCurrent = function () {\n            return globals.transition;\n        };\n        options = common_1.extend(options, { current: getCurrent });\n        var ref = this.target(to, toParams, options);\n        var currentPath = this.getCurrentPath();\n        if (!ref.exists())\n            return this._handleInvalidTargetState(currentPath, ref);\n        if (!ref.valid())\n            return common_1.silentRejection(ref.error());\n        /**\n         * Special handling for Ignored, Aborted, and Redirected transitions\n         *\n         * The semantics for the transition.run() promise and the StateService.transitionTo()\n         * promise differ. For instance, the run() promise may be rejected because it was\n         * IGNORED, but the transitionTo() promise is resolved because from the user perspective\n         * no error occurred.  Likewise, the transition.run() promise may be rejected because of\n         * a Redirect, but the transitionTo() promise is chained to the new Transition's promise.\n         */\n        var rejectedTransitionHandler = function (trans) { return function (error) {\n            if (error instanceof rejectFactory_1.Rejection) {\n                var isLatest = router.globals.lastStartedTransitionId === trans.$id;\n                if (error.type === rejectFactory_1.RejectType.IGNORED) {\n                    isLatest && router.urlRouter.update();\n                    // Consider ignored `Transition.run()` as a successful `transitionTo`\n                    return coreservices_1.services.$q.when(globals.current);\n                }\n                var detail = error.detail;\n                if (error.type === rejectFactory_1.RejectType.SUPERSEDED && error.redirected && detail instanceof targetState_1.TargetState) {\n                    // If `Transition.run()` was redirected, allow the `transitionTo()` promise to resolve successfully\n                    // by returning the promise for the new (redirect) `Transition.run()`.\n                    var redirect = trans.redirect(detail);\n                    return redirect.run().catch(rejectedTransitionHandler(redirect));\n                }\n                if (error.type === rejectFactory_1.RejectType.ABORTED) {\n                    isLatest && router.urlRouter.update();\n                    return coreservices_1.services.$q.reject(error);\n                }\n            }\n            var errorHandler = _this.defaultErrorHandler();\n            errorHandler(error);\n            return coreservices_1.services.$q.reject(error);\n        }; };\n        var transition = this.router.transitionService.create(currentPath, ref);\n        var transitionToPromise = transition.run().catch(rejectedTransitionHandler(transition));\n        common_1.silenceUncaughtInPromise(transitionToPromise); // issue #2676\n        // Return a promise for the transition, which also has the transition object on it.\n        return common_1.extend(transitionToPromise, { transition: transition });\n    };\n    /**\n     * Checks if the current state *is* the provided state\n     *\n     * Similar to [[includes]] but only checks for the full state name.\n     * If params is supplied then it will be tested for strict equality against the current\n     * active params object, so all params must match with none missing and no extras.\n     *\n     * #### Example:\n     * ```js\n     * $state.$current.name = 'contacts.details.item';\n     *\n     * // absolute name\n     * $state.is('contact.details.item'); // returns true\n     * $state.is(contactDetailItemStateObject); // returns true\n     * ```\n     *\n     * // relative name (. and ^), typically from a template\n     * // E.g. from the 'contacts.details' template\n     * ```html\n     * <div ng-class=\"{highlighted: $state.is('.item')}\">Item</div>\n     * ```\n     *\n     * @param stateOrName The state name (absolute or relative) or state object you'd like to check.\n     * @param params A param object, e.g. `{sectionId: section.id}`, that you'd like\n     * to test against the current active state.\n     * @param options An options object. The options are:\n     *   - `relative`: If `stateOrName` is a relative state name and `options.relative` is set, .is will\n     *     test relative to `options.relative` state (or name).\n     *\n     * @returns Returns true if it is the state.\n     */\n    StateService.prototype.is = function (stateOrName, params, options) {\n        options = common_1.defaults(options, { relative: this.$current });\n        var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative);\n        if (!predicates_1.isDefined(state))\n            return undefined;\n        if (this.$current !== state)\n            return false;\n        if (!params)\n            return true;\n        var schema = state.parameters({ inherit: true, matchingKeys: params });\n        return param_1.Param.equals(schema, param_1.Param.values(schema, params), this.params);\n    };\n    /**\n     * Checks if the current state *includes* the provided state\n     *\n     * A method to determine if the current active state is equal to or is the child of the\n     * state stateName. If any params are passed then they will be tested for a match as well.\n     * Not all the parameters need to be passed, just the ones you'd like to test for equality.\n     *\n     * #### Example when `$state.$current.name === 'contacts.details.item'`\n     * ```js\n     * // Using partial names\n     * $state.includes(\"contacts\"); // returns true\n     * $state.includes(\"contacts.details\"); // returns true\n     * $state.includes(\"contacts.details.item\"); // returns true\n     * $state.includes(\"contacts.list\"); // returns false\n     * $state.includes(\"about\"); // returns false\n     * ```\n     *\n     * #### Glob Examples when `* $state.$current.name === 'contacts.details.item.url'`:\n     * ```js\n     * $state.includes(\"*.details.*.*\"); // returns true\n     * $state.includes(\"*.details.**\"); // returns true\n     * $state.includes(\"**.item.**\"); // returns true\n     * $state.includes(\"*.details.item.url\"); // returns true\n     * $state.includes(\"*.details.*.url\"); // returns true\n     * $state.includes(\"*.details.*\"); // returns false\n     * $state.includes(\"item.**\"); // returns false\n     * ```\n     *\n     * @param stateOrName A partial name, relative name, glob pattern,\n     *   or state object to be searched for within the current state name.\n     * @param params A param object, e.g. `{sectionId: section.id}`,\n     *   that you'd like to test against the current active state.\n     * @param options An options object. The options are:\n     *   - `relative`: If `stateOrName` is a relative state name and `options.relative` is set, .is will\n     *     test relative to `options.relative` state (or name).\n     *\n     * @returns {boolean} Returns true if it does include the state\n     */\n    StateService.prototype.includes = function (stateOrName, params, options) {\n        options = common_1.defaults(options, { relative: this.$current });\n        var glob = predicates_1.isString(stateOrName) && glob_1.Glob.fromString(stateOrName);\n        if (glob) {\n            if (!glob.matches(this.$current.name))\n                return false;\n            stateOrName = this.$current.name;\n        }\n        var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative), include = this.$current.includes;\n        if (!predicates_1.isDefined(state))\n            return undefined;\n        if (!predicates_1.isDefined(include[state.name]))\n            return false;\n        if (!params)\n            return true;\n        var schema = state.parameters({ inherit: true, matchingKeys: params });\n        return param_1.Param.equals(schema, param_1.Param.values(schema, params), this.params);\n    };\n    /**\n     * Generates a URL for a state and parameters\n     *\n     * Returns the url for the given state populated with the given params.\n     *\n     * #### Example:\n     * ```js\n     * expect($state.href(\"about.person\", { person: \"bob\" })).toEqual(\"/about/bob\");\n     * ```\n     *\n     * @param stateOrName The state name or state object you'd like to generate a url from.\n     * @param params An object of parameter values to fill the state's required parameters.\n     * @param options Options object. The options are:\n     *\n     * @returns {string} compiled state url\n     */\n    StateService.prototype.href = function (stateOrName, params, options) {\n        var defaultHrefOpts = {\n            lossy: true,\n            inherit: true,\n            absolute: false,\n            relative: this.$current,\n        };\n        options = common_1.defaults(options, defaultHrefOpts);\n        params = params || {};\n        var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative);\n        if (!predicates_1.isDefined(state))\n            return null;\n        if (options.inherit)\n            params = this.params.$inherit(params, this.$current, state);\n        var nav = (state && options.lossy) ? state.navigable : state;\n        if (!nav || nav.url === undefined || nav.url === null) {\n            return null;\n        }\n        return this.router.urlRouter.href(nav.url, params, {\n            absolute: options.absolute,\n        });\n    };\n    /**\n     * Sets or gets the default [[transitionTo]] error handler.\n     *\n     * The error handler is called when a [[Transition]] is rejected or when any error occurred during the Transition.\n     * This includes errors caused by resolves and transition hooks.\n     *\n     * Note:\n     * This handler does not receive certain Transition rejections.\n     * Redirected and Ignored Transitions are not considered to be errors by [[StateService.transitionTo]].\n     *\n     * The built-in default error handler logs the error to the console.\n     *\n     * You can provide your own custom handler.\n     *\n     * #### Example:\n     * ```js\n     * stateService.defaultErrorHandler(function() {\n     *   // Do not log transitionTo errors\n     * });\n     * ```\n     *\n     * @param handler a global error handler function\n     * @returns the current global error handler\n     */\n    StateService.prototype.defaultErrorHandler = function (handler) {\n        return this._defaultErrorHandler = handler || this._defaultErrorHandler;\n    };\n    StateService.prototype.get = function (stateOrName, base) {\n        var reg = this.router.stateRegistry;\n        if (arguments.length === 0)\n            return reg.get();\n        return reg.get(stateOrName, base || this.$current);\n    };\n    /**\n     * Lazy loads a state\n     *\n     * Explicitly runs a state's [[StateDeclaration.lazyLoad]] function.\n     *\n     * @param stateOrName the state that should be lazy loaded\n     * @param transition the optional Transition context to use (if the lazyLoad function requires an injector, etc)\n     * Note: If no transition is provided, a noop transition is created using the from the current state to the current state.\n     * This noop transition is not actually run.\n     *\n     * @returns a promise to lazy load\n     */\n    StateService.prototype.lazyLoad = function (stateOrName, transition) {\n        var state = this.get(stateOrName);\n        if (!state || !state.lazyLoad)\n            throw new Error('Can not lazy load ' + stateOrName);\n        var currentPath = this.getCurrentPath();\n        var target = pathUtils_1.PathUtils.makeTargetState(this.router.stateRegistry, currentPath);\n        transition = transition || this.router.transitionService.create(currentPath, target);\n        return lazyLoad_1.lazyLoadState(transition, state);\n    };\n    return StateService;\n}());\nexports.StateService = StateService;\n//# sourceMappingURL=stateService.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3N0YXRlL3N0YXRlU2VydmljZS5qcz85MzEyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAY29yZWFwaVxuICogQG1vZHVsZSBzdGF0ZVxuICovXG4vKiogKi9cbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29tbW9uXCIpO1xudmFyIHByZWRpY2F0ZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vcHJlZGljYXRlc1wiKTtcbnZhciBxdWV1ZV8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9xdWV1ZVwiKTtcbnZhciBjb3Jlc2VydmljZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29yZXNlcnZpY2VzXCIpO1xudmFyIHBhdGhVdGlsc18xID0gcmVxdWlyZShcIi4uL3BhdGgvcGF0aFV0aWxzXCIpO1xudmFyIHBhdGhOb2RlXzEgPSByZXF1aXJlKFwiLi4vcGF0aC9wYXRoTm9kZVwiKTtcbnZhciB0cmFuc2l0aW9uU2VydmljZV8xID0gcmVxdWlyZShcIi4uL3RyYW5zaXRpb24vdHJhbnNpdGlvblNlcnZpY2VcIik7XG52YXIgcmVqZWN0RmFjdG9yeV8xID0gcmVxdWlyZShcIi4uL3RyYW5zaXRpb24vcmVqZWN0RmFjdG9yeVwiKTtcbnZhciB0YXJnZXRTdGF0ZV8xID0gcmVxdWlyZShcIi4vdGFyZ2V0U3RhdGVcIik7XG52YXIgcGFyYW1fMSA9IHJlcXVpcmUoXCIuLi9wYXJhbXMvcGFyYW1cIik7XG52YXIgZ2xvYl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9nbG9iXCIpO1xudmFyIHJlc29sdmVDb250ZXh0XzEgPSByZXF1aXJlKFwiLi4vcmVzb2x2ZS9yZXNvbHZlQ29udGV4dFwiKTtcbnZhciBsYXp5TG9hZF8xID0gcmVxdWlyZShcIi4uL2hvb2tzL2xhenlMb2FkXCIpO1xudmFyIGhvZl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9ob2ZcIik7XG4vKipcbiAqIFByb3ZpZGVzIHN0YXRlIHJlbGF0ZWQgc2VydmljZSBmdW5jdGlvbnNcbiAqXG4gKiBUaGlzIGNsYXNzIHByb3ZpZGVzIHNlcnZpY2VzIHJlbGF0ZWQgdG8gdWktcm91dGVyIHN0YXRlcy5cbiAqIEFuIGluc3RhbmNlIG9mIHRoaXMgY2xhc3MgaXMgbG9jYXRlZCBvbiB0aGUgZ2xvYmFsIFtbVUlSb3V0ZXJdXSBvYmplY3QuXG4gKi9cbnZhciBTdGF0ZVNlcnZpY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqIEBpbnRlcm5hbGFwaSAqL1xuICAgIGZ1bmN0aW9uIFN0YXRlU2VydmljZShyb3V0ZXIpIHtcbiAgICAgICAgdGhpcy5yb3V0ZXIgPSByb3V0ZXI7XG4gICAgICAgIC8qKiBAaW50ZXJuYWxhcGkgKi9cbiAgICAgICAgdGhpcy5pbnZhbGlkQ2FsbGJhY2tzID0gW107XG4gICAgICAgIC8qKiBAaGlkZGVuICovXG4gICAgICAgIHRoaXMuX2RlZmF1bHRFcnJvckhhbmRsZXIgPSBmdW5jdGlvbiAkZGVmYXVsdEVycm9ySGFuZGxlcigkZXJyb3IkKSB7XG4gICAgICAgICAgICBpZiAoJGVycm9yJCBpbnN0YW5jZW9mIEVycm9yICYmICRlcnJvciQuc3RhY2spIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCRlcnJvciQpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJGVycm9yJC5zdGFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgkZXJyb3IkIGluc3RhbmNlb2YgcmVqZWN0RmFjdG9yeV8xLlJlamVjdGlvbikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJGVycm9yJC50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICBpZiAoJGVycm9yJC5kZXRhaWwgJiYgJGVycm9yJC5kZXRhaWwuc3RhY2spXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJGVycm9yJC5kZXRhaWwuc3RhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcigkZXJyb3IkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGdldHRlcnMgPSBbJ2N1cnJlbnQnLCAnJGN1cnJlbnQnLCAncGFyYW1zJywgJ3RyYW5zaXRpb24nXTtcbiAgICAgICAgdmFyIGJvdW5kRm5zID0gT2JqZWN0LmtleXMoU3RhdGVTZXJ2aWNlLnByb3RvdHlwZSkuZmlsdGVyKGhvZl8xLm5vdChjb21tb25fMS5pbkFycmF5KGdldHRlcnMpKSk7XG4gICAgICAgIGNvbW1vbl8xLmNyZWF0ZVByb3h5RnVuY3Rpb25zKGhvZl8xLnZhbChTdGF0ZVNlcnZpY2UucHJvdG90eXBlKSwgdGhpcywgaG9mXzEudmFsKHRoaXMpLCBib3VuZEZucyk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdGF0ZVNlcnZpY2UucHJvdG90eXBlLCBcInRyYW5zaXRpb25cIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIFtbVHJhbnNpdGlvbl1dIGN1cnJlbnRseSBpbiBwcm9ncmVzcyAob3IgbnVsbClcbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBpcyBhIHBhc3N0aHJvdWdoIHRocm91Z2ggdG8gW1tVSVJvdXRlckdsb2JhbHMudHJhbnNpdGlvbl1dXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucm91dGVyLmdsb2JhbHMudHJhbnNpdGlvbjsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0YXRlU2VydmljZS5wcm90b3R5cGUsIFwicGFyYW1zXCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsYXRlc3Qgc3VjY2Vzc2Z1bCBzdGF0ZSBwYXJhbWV0ZXJzXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgaXMgYSBwYXNzdGhyb3VnaCB0aHJvdWdoIHRvIFtbVUlSb3V0ZXJHbG9iYWxzLnBhcmFtc11dXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucm91dGVyLmdsb2JhbHMucGFyYW1zOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RhdGVTZXJ2aWNlLnByb3RvdHlwZSwgXCJjdXJyZW50XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjdXJyZW50IFtbU3RhdGVEZWNsYXJhdGlvbl1dXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgaXMgYSBwYXNzdGhyb3VnaCB0aHJvdWdoIHRvIFtbVUlSb3V0ZXJHbG9iYWxzLmN1cnJlbnRdXVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnJvdXRlci5nbG9iYWxzLmN1cnJlbnQ7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdGF0ZVNlcnZpY2UucHJvdG90eXBlLCBcIiRjdXJyZW50XCIsIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjdXJyZW50IFtbU3RhdGVPYmplY3RdXVxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGlzIGEgcGFzc3Rocm91Z2ggdGhyb3VnaCB0byBbW1VJUm91dGVyR2xvYmFscy4kY3VycmVudF1dXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMucm91dGVyLmdsb2JhbHMuJGN1cnJlbnQ7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIC8qKiBAaW50ZXJuYWxhcGkgKi9cbiAgICBTdGF0ZVNlcnZpY2UucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZGVmYXVsdEVycm9ySGFuZGxlcihjb21tb25fMS5ub29wKTtcbiAgICAgICAgdGhpcy5pbnZhbGlkQ2FsbGJhY2tzID0gW107XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGVyIGZvciB3aGVuIFtbdHJhbnNpdGlvblRvXV0gaXMgY2FsbGVkIHdpdGggYW4gaW52YWxpZCBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEludm9rZXMgdGhlIFtbb25JbnZhbGlkXV0gY2FsbGJhY2tzLCBpbiBuYXR1cmFsIG9yZGVyLlxuICAgICAqIEVhY2ggY2FsbGJhY2sncyByZXR1cm4gdmFsdWUgaXMgY2hlY2tlZCBpbiBzZXF1ZW5jZSB1bnRpbCBvbmUgb2YgdGhlbSByZXR1cm5zIGFuIGluc3RhbmNlIG9mIFRhcmdldFN0YXRlLlxuICAgICAqIFRoZSByZXN1bHRzIG9mIHRoZSBjYWxsYmFja3MgYXJlIHdyYXBwZWQgaW4gJHEud2hlbigpLCBzbyB0aGUgY2FsbGJhY2tzIG1heSByZXR1cm4gcHJvbWlzZXMuXG4gICAgICpcbiAgICAgKiBJZiBhIGNhbGxiYWNrIHJldHVybnMgYW4gVGFyZ2V0U3RhdGUsIHRoZW4gaXQgaXMgdXNlZCBhcyBhcmd1bWVudHMgdG8gJHN0YXRlLnRyYW5zaXRpb25UbygpIGFuZCB0aGUgcmVzdWx0IHJldHVybmVkLlxuICAgICAqXG4gICAgICogQGludGVybmFsYXBpXG4gICAgICovXG4gICAgU3RhdGVTZXJ2aWNlLnByb3RvdHlwZS5faGFuZGxlSW52YWxpZFRhcmdldFN0YXRlID0gZnVuY3Rpb24gKGZyb21QYXRoLCB0b1N0YXRlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBmcm9tU3RhdGUgPSBwYXRoVXRpbHNfMS5QYXRoVXRpbHMubWFrZVRhcmdldFN0YXRlKHRoaXMucm91dGVyLnN0YXRlUmVnaXN0cnksIGZyb21QYXRoKTtcbiAgICAgICAgdmFyIGdsb2JhbHMgPSB0aGlzLnJvdXRlci5nbG9iYWxzO1xuICAgICAgICB2YXIgbGF0ZXN0VGhpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBnbG9iYWxzLnRyYW5zaXRpb25IaXN0b3J5LnBlZWtUYWlsKCk7IH07XG4gICAgICAgIHZhciBsYXRlc3QgPSBsYXRlc3RUaGluZygpO1xuICAgICAgICB2YXIgY2FsbGJhY2tRdWV1ZSA9IG5ldyBxdWV1ZV8xLlF1ZXVlKHRoaXMuaW52YWxpZENhbGxiYWNrcy5zbGljZSgpKTtcbiAgICAgICAgdmFyIGluamVjdG9yID0gbmV3IHJlc29sdmVDb250ZXh0XzEuUmVzb2x2ZUNvbnRleHQoZnJvbVBhdGgpLmluamVjdG9yKCk7XG4gICAgICAgIHZhciBjaGVja0ZvclJlZGlyZWN0ID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKCEocmVzdWx0IGluc3RhbmNlb2YgdGFyZ2V0U3RhdGVfMS5UYXJnZXRTdGF0ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gcmVzdWx0O1xuICAgICAgICAgICAgLy8gUmVjcmVhdGUgdGhlIFRhcmdldFN0YXRlLCBpbiBjYXNlIHRoZSBzdGF0ZSBpcyBub3cgZGVmaW5lZC5cbiAgICAgICAgICAgIHRhcmdldCA9IF90aGlzLnRhcmdldCh0YXJnZXQuaWRlbnRpZmllcigpLCB0YXJnZXQucGFyYW1zKCksIHRhcmdldC5vcHRpb25zKCkpO1xuICAgICAgICAgICAgaWYgKCF0YXJnZXQudmFsaWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWplY3RGYWN0b3J5XzEuUmVqZWN0aW9uLmludmFsaWQodGFyZ2V0LmVycm9yKCkpLnRvUHJvbWlzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxhdGVzdFRoaW5nKCkgIT09IGxhdGVzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWplY3RGYWN0b3J5XzEuUmVqZWN0aW9uLnN1cGVyc2VkZWQoKS50b1Byb21pc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfdGhpcy50cmFuc2l0aW9uVG8odGFyZ2V0LmlkZW50aWZpZXIoKSwgdGFyZ2V0LnBhcmFtcygpLCB0YXJnZXQub3B0aW9ucygpKTtcbiAgICAgICAgfTtcbiAgICAgICAgZnVuY3Rpb24gaW52b2tlTmV4dENhbGxiYWNrKCkge1xuICAgICAgICAgICAgdmFyIG5leHRDYWxsYmFjayA9IGNhbGxiYWNrUXVldWUuZGVxdWV1ZSgpO1xuICAgICAgICAgICAgaWYgKG5leHRDYWxsYmFjayA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHJldHVybiByZWplY3RGYWN0b3J5XzEuUmVqZWN0aW9uLmludmFsaWQodG9TdGF0ZS5lcnJvcigpKS50b1Byb21pc2UoKTtcbiAgICAgICAgICAgIHZhciBjYWxsYmFja1Jlc3VsdCA9IGNvcmVzZXJ2aWNlc18xLnNlcnZpY2VzLiRxLndoZW4obmV4dENhbGxiYWNrKHRvU3RhdGUsIGZyb21TdGF0ZSwgaW5qZWN0b3IpKTtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFja1Jlc3VsdC50aGVuKGNoZWNrRm9yUmVkaXJlY3QpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkgeyByZXR1cm4gcmVzdWx0IHx8IGludm9rZU5leHRDYWxsYmFjaygpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW52b2tlTmV4dENhbGxiYWNrKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYW4gSW52YWxpZCBTdGF0ZSBoYW5kbGVyXG4gICAgICpcbiAgICAgKiBSZWdpc3RlcnMgYSBbW09uSW52YWxpZENhbGxiYWNrXV0gZnVuY3Rpb24gdG8gYmUgaW52b2tlZCB3aGVuIFtbU3RhdGVTZXJ2aWNlLnRyYW5zaXRpb25Ub11dXG4gICAgICogaGFzIGJlZW4gY2FsbGVkIHdpdGggYW4gaW52YWxpZCBzdGF0ZSByZWZlcmVuY2UgcGFyYW1ldGVyXG4gICAgICpcbiAgICAgKiBFeGFtcGxlOlxuICAgICAqIGBgYGpzXG4gICAgICogc3RhdGVTZXJ2aWNlLm9uSW52YWxpZChmdW5jdGlvbih0bywgZnJvbSwgaW5qZWN0b3IpIHtcbiAgICAgKiAgIGlmICh0by5uYW1lKCkgPT09ICdmb28nKSB7XG4gICAgICogICAgIGxldCBsYXp5TG9hZGVyID0gaW5qZWN0b3IuZ2V0KCdMYXp5TG9hZFNlcnZpY2UnKTtcbiAgICAgKiAgICAgcmV0dXJuIGxhenlMb2FkZXIubG9hZCgnZm9vJylcbiAgICAgKiAgICAgICAgIC50aGVuKCgpID0+IHN0YXRlU2VydmljZS50YXJnZXQoJ2ZvbycpKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIGludm9rZWQgd2hlbiB0aGUgdG9TdGF0ZSBpcyBpbnZhbGlkXG4gICAgICogICBUaGlzIGZ1bmN0aW9uIHJlY2VpdmVzIHRoZSAoaW52YWxpZCkgdG9TdGF0ZSwgdGhlIGZyb21TdGF0ZSwgYW5kIGFuIGluamVjdG9yLlxuICAgICAqICAgVGhlIGZ1bmN0aW9uIG1heSBvcHRpb25hbGx5IHJldHVybiBhIFtbVGFyZ2V0U3RhdGVdXSBvciBhIFByb21pc2UgZm9yIGEgVGFyZ2V0U3RhdGUuXG4gICAgICogICBJZiBvbmUgaXMgcmV0dXJuZWQsIGl0IGlzIHRyZWF0ZWQgYXMgYSByZWRpcmVjdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2ggZGVyZWdpc3RlcnMgdGhlIGNhbGxiYWNrXG4gICAgICovXG4gICAgU3RhdGVTZXJ2aWNlLnByb3RvdHlwZS5vbkludmFsaWQgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5pbnZhbGlkQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gZGVyZWdpc3Rlckxpc3RlbmVyKCkge1xuICAgICAgICAgICAgY29tbW9uXzEucmVtb3ZlRnJvbSh0aGlzLmludmFsaWRDYWxsYmFja3MpKGNhbGxiYWNrKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVsb2FkcyB0aGUgY3VycmVudCBzdGF0ZVxuICAgICAqXG4gICAgICogQSBtZXRob2QgdGhhdCBmb3JjZSByZWxvYWRzIHRoZSBjdXJyZW50IHN0YXRlLCBvciBhIHBhcnRpYWwgc3RhdGUgaGllcmFyY2h5LlxuICAgICAqIEFsbCByZXNvbHZlcyBhcmUgcmUtcmVzb2x2ZWQsIGFuZCBjb21wb25lbnRzIHJlaW5zdGFudGlhdGVkLlxuICAgICAqXG4gICAgICogIyMjIyBFeGFtcGxlOlxuICAgICAqIGBgYGpzXG4gICAgICogbGV0IGFwcCBhbmd1bGFyLm1vZHVsZSgnYXBwJywgWyd1aS5yb3V0ZXInXSk7XG4gICAgICpcbiAgICAgKiBhcHAuY29udHJvbGxlcignY3RybCcsIGZ1bmN0aW9uICgkc2NvcGUsICRzdGF0ZSkge1xuICAgICAqICAgJHNjb3BlLnJlbG9hZCA9IGZ1bmN0aW9uKCl7XG4gICAgICogICAgICRzdGF0ZS5yZWxvYWQoKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIE5vdGU6IGByZWxvYWQoKWAgaXMganVzdCBhbiBhbGlhcyBmb3I6XG4gICAgICpcbiAgICAgKiBgYGBqc1xuICAgICAqICRzdGF0ZS50cmFuc2l0aW9uVG8oJHN0YXRlLmN1cnJlbnQsICRzdGF0ZS5wYXJhbXMsIHtcbiAgICAgKiAgIHJlbG9hZDogdHJ1ZSwgaW5oZXJpdDogZmFsc2VcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSByZWxvYWRTdGF0ZSBBIHN0YXRlIG5hbWUgb3IgYSBzdGF0ZSBvYmplY3QuXG4gICAgICogICAgSWYgcHJlc2VudCwgdGhpcyBzdGF0ZSBhbmQgYWxsIGl0cyBjaGlsZHJlbiB3aWxsIGJlIHJlbG9hZGVkLCBidXQgYW5jZXN0b3JzIHdpbGwgbm90IHJlbG9hZC5cbiAgICAgKlxuICAgICAqICMjIyMgRXhhbXBsZTpcbiAgICAgKiBgYGBqc1xuICAgICAqIC8vYXNzdW1pbmcgYXBwIGFwcGxpY2F0aW9uIGNvbnNpc3RzIG9mIDMgc3RhdGVzOiAnY29udGFjdHMnLCAnY29udGFjdHMuZGV0YWlsJywgJ2NvbnRhY3RzLmRldGFpbC5pdGVtJ1xuICAgICAqIC8vYW5kIGN1cnJlbnQgc3RhdGUgaXMgJ2NvbnRhY3RzLmRldGFpbC5pdGVtJ1xuICAgICAqIGxldCBhcHAgYW5ndWxhci5tb2R1bGUoJ2FwcCcsIFsndWkucm91dGVyJ10pO1xuICAgICAqXG4gICAgICogYXBwLmNvbnRyb2xsZXIoJ2N0cmwnLCBmdW5jdGlvbiAoJHNjb3BlLCAkc3RhdGUpIHtcbiAgICAgKiAgICRzY29wZS5yZWxvYWQgPSBmdW5jdGlvbigpe1xuICAgICAqICAgICAvL3dpbGwgcmVsb2FkICdjb250YWN0LmRldGFpbCcgYW5kIG5lc3RlZCAnY29udGFjdC5kZXRhaWwuaXRlbScgc3RhdGVzXG4gICAgICogICAgICRzdGF0ZS5yZWxvYWQoJ2NvbnRhY3QuZGV0YWlsJyk7XG4gICAgICogICB9XG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgcmVwcmVzZW50aW5nIHRoZSBzdGF0ZSBvZiB0aGUgbmV3IHRyYW5zaXRpb24uIFNlZSBbW1N0YXRlU2VydmljZS5nb11dXG4gICAgICovXG4gICAgU3RhdGVTZXJ2aWNlLnByb3RvdHlwZS5yZWxvYWQgPSBmdW5jdGlvbiAocmVsb2FkU3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNpdGlvblRvKHRoaXMuY3VycmVudCwgdGhpcy5wYXJhbXMsIHtcbiAgICAgICAgICAgIHJlbG9hZDogcHJlZGljYXRlc18xLmlzRGVmaW5lZChyZWxvYWRTdGF0ZSkgPyByZWxvYWRTdGF0ZSA6IHRydWUsXG4gICAgICAgICAgICBpbmhlcml0OiBmYWxzZSxcbiAgICAgICAgICAgIG5vdGlmeTogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogVHJhbnNpdGlvbiB0byBhIGRpZmZlcmVudCBzdGF0ZSBhbmQvb3IgcGFyYW1ldGVyc1xuICAgICAqXG4gICAgICogQ29udmVuaWVuY2UgbWV0aG9kIGZvciB0cmFuc2l0aW9uaW5nIHRvIGEgbmV3IHN0YXRlLlxuICAgICAqXG4gICAgICogYCRzdGF0ZS5nb2AgY2FsbHMgYCRzdGF0ZS50cmFuc2l0aW9uVG9gIGludGVybmFsbHkgYnV0IGF1dG9tYXRpY2FsbHkgc2V0cyBvcHRpb25zIHRvXG4gICAgICogYHsgbG9jYXRpb246IHRydWUsIGluaGVyaXQ6IHRydWUsIHJlbGF0aXZlOiByb3V0ZXIuZ2xvYmFscy4kY3VycmVudCwgbm90aWZ5OiB0cnVlIH1gLlxuICAgICAqIFRoaXMgYWxsb3dzIHlvdSB0byB1c2UgZWl0aGVyIGFuIGFic29sdXRlIG9yIHJlbGF0aXZlIGB0b2AgYXJndW1lbnQgKGJlY2F1c2Ugb2YgYHJlbGF0aXZlOiByb3V0ZXIuZ2xvYmFscy4kY3VycmVudGApLlxuICAgICAqIEl0IGFsc28gYWxsb3dzIHlvdSB0byBzcGVjaWZ5ICogb25seSB0aGUgcGFyYW1ldGVycyB5b3UnZCBsaWtlIHRvIHVwZGF0ZSwgd2hpbGUgbGV0dGluZyB1bnNwZWNpZmllZCBwYXJhbWV0ZXJzXG4gICAgICogaW5oZXJpdCBmcm9tIHRoZSBjdXJyZW50IHBhcmFtZXRlciB2YWx1ZXMgKGJlY2F1c2Ugb2YgYGluaGVyaXQ6IHRydWVgKS5cbiAgICAgKlxuICAgICAqICMjIyMgRXhhbXBsZTpcbiAgICAgKiBgYGBqc1xuICAgICAqIGxldCBhcHAgPSBhbmd1bGFyLm1vZHVsZSgnYXBwJywgWyd1aS5yb3V0ZXInXSk7XG4gICAgICpcbiAgICAgKiBhcHAuY29udHJvbGxlcignY3RybCcsIGZ1bmN0aW9uICgkc2NvcGUsICRzdGF0ZSkge1xuICAgICAqICAgJHNjb3BlLmNoYW5nZVN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAqICAgICAkc3RhdGUuZ28oJ2NvbnRhY3QuZGV0YWlsJyk7XG4gICAgICogICB9O1xuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIHRvIEFic29sdXRlIHN0YXRlIG5hbWUsIHN0YXRlIG9iamVjdCwgb3IgcmVsYXRpdmUgc3RhdGUgcGF0aCAocmVsYXRpdmUgdG8gY3VycmVudCBzdGF0ZSkuXG4gICAgICpcbiAgICAgKiBTb21lIGV4YW1wbGVzOlxuICAgICAqXG4gICAgICogLSBgJHN0YXRlLmdvKCdjb250YWN0LmRldGFpbCcpYCAtIHdpbGwgZ28gdG8gdGhlIGBjb250YWN0LmRldGFpbGAgc3RhdGVcbiAgICAgKiAtIGAkc3RhdGUuZ28oJ14nKWAgLSB3aWxsIGdvIHRvIHRoZSBwYXJlbnQgc3RhdGVcbiAgICAgKiAtIGAkc3RhdGUuZ28oJ14uc2libGluZycpYCAtIGlmIGN1cnJlbnQgc3RhdGUgaXMgYGhvbWUuY2hpbGRgLCB3aWxsIGdvIHRvIHRoZSBgaG9tZS5zaWJsaW5nYCBzdGF0ZVxuICAgICAqIC0gYCRzdGF0ZS5nbygnLmNoaWxkLmdyYW5kY2hpbGQnKWAgLSBpZiBjdXJyZW50IHN0YXRlIGlzIGhvbWUsIHdpbGwgZ28gdG8gdGhlIGBob21lLmNoaWxkLmdyYW5kY2hpbGRgIHN0YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIEEgbWFwIG9mIHRoZSBwYXJhbWV0ZXJzIHRoYXQgd2lsbCBiZSBzZW50IHRvIHRoZSBzdGF0ZSwgd2lsbCBwb3B1bGF0ZSAkc3RhdGVQYXJhbXMuXG4gICAgICpcbiAgICAgKiAgICBBbnkgcGFyYW1ldGVycyB0aGF0IGFyZSBub3Qgc3BlY2lmaWVkIHdpbGwgYmUgaW5oZXJpdGVkIGZyb20gY3VycmVudCBwYXJhbWV0ZXIgdmFsdWVzIChiZWNhdXNlIG9mIGBpbmhlcml0OiB0cnVlYCkuXG4gICAgICogICAgVGhpcyBhbGxvd3MsIGZvciBleGFtcGxlLCBnb2luZyB0byBhIHNpYmxpbmcgc3RhdGUgdGhhdCBzaGFyZXMgcGFyYW1ldGVycyBkZWZpbmVkIGJ5IGEgcGFyZW50IHN0YXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgVHJhbnNpdGlvbiBvcHRpb25zXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7cHJvbWlzZX0gQSBwcm9taXNlIHJlcHJlc2VudGluZyB0aGUgc3RhdGUgb2YgdGhlIG5ldyB0cmFuc2l0aW9uLlxuICAgICAqL1xuICAgIFN0YXRlU2VydmljZS5wcm90b3R5cGUuZ28gPSBmdW5jdGlvbiAodG8sIHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICB2YXIgZGVmYXV0R29PcHRzID0geyByZWxhdGl2ZTogdGhpcy4kY3VycmVudCwgaW5oZXJpdDogdHJ1ZSB9O1xuICAgICAgICB2YXIgdHJhbnNPcHRzID0gY29tbW9uXzEuZGVmYXVsdHMob3B0aW9ucywgZGVmYXV0R29PcHRzLCB0cmFuc2l0aW9uU2VydmljZV8xLmRlZmF1bHRUcmFuc09wdHMpO1xuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2l0aW9uVG8odG8sIHBhcmFtcywgdHJhbnNPcHRzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBbW1RhcmdldFN0YXRlXV1cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgYSBmYWN0b3J5IG1ldGhvZCBmb3IgY3JlYXRpbmcgYSBUYXJnZXRTdGF0ZVxuICAgICAqXG4gICAgICogVGhpcyBtYXkgYmUgcmV0dXJuZWQgZnJvbSBhIFRyYW5zaXRpb24gSG9vayB0byByZWRpcmVjdCBhIHRyYW5zaXRpb24sIGZvciBleGFtcGxlLlxuICAgICAqL1xuICAgIFN0YXRlU2VydmljZS5wcm90b3R5cGUudGFyZ2V0ID0gZnVuY3Rpb24gKGlkZW50aWZpZXIsIHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICAvLyBJZiB3ZSdyZSByZWxvYWRpbmcsIGZpbmQgdGhlIHN0YXRlIG9iamVjdCB0byByZWxvYWQgZnJvbVxuICAgICAgICBpZiAocHJlZGljYXRlc18xLmlzT2JqZWN0KG9wdGlvbnMucmVsb2FkKSAmJiAhb3B0aW9ucy5yZWxvYWQubmFtZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByZWxvYWQgc3RhdGUgb2JqZWN0Jyk7XG4gICAgICAgIHZhciByZWcgPSB0aGlzLnJvdXRlci5zdGF0ZVJlZ2lzdHJ5O1xuICAgICAgICBvcHRpb25zLnJlbG9hZFN0YXRlID0gb3B0aW9ucy5yZWxvYWQgPT09IHRydWUgPyByZWcucm9vdCgpIDogcmVnLm1hdGNoZXIuZmluZChvcHRpb25zLnJlbG9hZCwgb3B0aW9ucy5yZWxhdGl2ZSk7XG4gICAgICAgIGlmIChvcHRpb25zLnJlbG9hZCAmJiAhb3B0aW9ucy5yZWxvYWRTdGF0ZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHN1Y2ggcmVsb2FkIHN0YXRlICdcIiArIChwcmVkaWNhdGVzXzEuaXNTdHJpbmcob3B0aW9ucy5yZWxvYWQpID8gb3B0aW9ucy5yZWxvYWQgOiBvcHRpb25zLnJlbG9hZC5uYW1lKSArIFwiJ1wiKTtcbiAgICAgICAgcmV0dXJuIG5ldyB0YXJnZXRTdGF0ZV8xLlRhcmdldFN0YXRlKHRoaXMucm91dGVyLnN0YXRlUmVnaXN0cnksIGlkZW50aWZpZXIsIHBhcmFtcywgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBTdGF0ZVNlcnZpY2UucHJvdG90eXBlLmdldEN1cnJlbnRQYXRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZ2xvYmFscyA9IHRoaXMucm91dGVyLmdsb2JhbHM7XG4gICAgICAgIHZhciBsYXRlc3RTdWNjZXNzID0gZ2xvYmFscy5zdWNjZXNzZnVsVHJhbnNpdGlvbnMucGVla1RhaWwoKTtcbiAgICAgICAgdmFyIHJvb3RQYXRoID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW25ldyBwYXRoTm9kZV8xLlBhdGhOb2RlKF90aGlzLnJvdXRlci5zdGF0ZVJlZ2lzdHJ5LnJvb3QoKSldOyB9O1xuICAgICAgICByZXR1cm4gbGF0ZXN0U3VjY2VzcyA/IGxhdGVzdFN1Y2Nlc3MudHJlZUNoYW5nZXMoKS50byA6IHJvb3RQYXRoKCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBMb3ctbGV2ZWwgbWV0aG9kIGZvciB0cmFuc2l0aW9uaW5nIHRvIGEgbmV3IHN0YXRlLlxuICAgICAqXG4gICAgICogVGhlIFtbZ29dXSBtZXRob2QgKHdoaWNoIHVzZXMgYHRyYW5zaXRpb25Ub2AgaW50ZXJuYWxseSkgaXMgcmVjb21tZW5kZWQgaW4gbW9zdCBzaXR1YXRpb25zLlxuICAgICAqXG4gICAgICogIyMjIyBFeGFtcGxlOlxuICAgICAqIGBgYGpzXG4gICAgICogbGV0IGFwcCA9IGFuZ3VsYXIubW9kdWxlKCdhcHAnLCBbJ3VpLnJvdXRlciddKTtcbiAgICAgKlxuICAgICAqIGFwcC5jb250cm9sbGVyKCdjdHJsJywgZnVuY3Rpb24gKCRzY29wZSwgJHN0YXRlKSB7XG4gICAgICogICAkc2NvcGUuY2hhbmdlU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICogICAgICRzdGF0ZS50cmFuc2l0aW9uVG8oJ2NvbnRhY3QuZGV0YWlsJyk7XG4gICAgICogICB9O1xuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIHRvIFN0YXRlIG5hbWUgb3Igc3RhdGUgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB0b1BhcmFtcyBBIG1hcCBvZiB0aGUgcGFyYW1ldGVycyB0aGF0IHdpbGwgYmUgc2VudCB0byB0aGUgc3RhdGUsXG4gICAgICogICAgICB3aWxsIHBvcHVsYXRlICRzdGF0ZVBhcmFtcy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBUcmFuc2l0aW9uIG9wdGlvbnNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSByZXByZXNlbnRpbmcgdGhlIHN0YXRlIG9mIHRoZSBuZXcgdHJhbnNpdGlvbi4gU2VlIFtbZ29dXVxuICAgICAqL1xuICAgIFN0YXRlU2VydmljZS5wcm90b3R5cGUudHJhbnNpdGlvblRvID0gZnVuY3Rpb24gKHRvLCB0b1BhcmFtcywgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodG9QYXJhbXMgPT09IHZvaWQgMCkgeyB0b1BhcmFtcyA9IHt9OyB9XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHZhciByb3V0ZXIgPSB0aGlzLnJvdXRlcjtcbiAgICAgICAgdmFyIGdsb2JhbHMgPSByb3V0ZXIuZ2xvYmFscztcbiAgICAgICAgb3B0aW9ucyA9IGNvbW1vbl8xLmRlZmF1bHRzKG9wdGlvbnMsIHRyYW5zaXRpb25TZXJ2aWNlXzEuZGVmYXVsdFRyYW5zT3B0cyk7XG4gICAgICAgIHZhciBnZXRDdXJyZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGdsb2JhbHMudHJhbnNpdGlvbjtcbiAgICAgICAgfTtcbiAgICAgICAgb3B0aW9ucyA9IGNvbW1vbl8xLmV4dGVuZChvcHRpb25zLCB7IGN1cnJlbnQ6IGdldEN1cnJlbnQgfSk7XG4gICAgICAgIHZhciByZWYgPSB0aGlzLnRhcmdldCh0bywgdG9QYXJhbXMsIG9wdGlvbnMpO1xuICAgICAgICB2YXIgY3VycmVudFBhdGggPSB0aGlzLmdldEN1cnJlbnRQYXRoKCk7XG4gICAgICAgIGlmICghcmVmLmV4aXN0cygpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZUludmFsaWRUYXJnZXRTdGF0ZShjdXJyZW50UGF0aCwgcmVmKTtcbiAgICAgICAgaWYgKCFyZWYudmFsaWQoKSlcbiAgICAgICAgICAgIHJldHVybiBjb21tb25fMS5zaWxlbnRSZWplY3Rpb24ocmVmLmVycm9yKCkpO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3BlY2lhbCBoYW5kbGluZyBmb3IgSWdub3JlZCwgQWJvcnRlZCwgYW5kIFJlZGlyZWN0ZWQgdHJhbnNpdGlvbnNcbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIHNlbWFudGljcyBmb3IgdGhlIHRyYW5zaXRpb24ucnVuKCkgcHJvbWlzZSBhbmQgdGhlIFN0YXRlU2VydmljZS50cmFuc2l0aW9uVG8oKVxuICAgICAgICAgKiBwcm9taXNlIGRpZmZlci4gRm9yIGluc3RhbmNlLCB0aGUgcnVuKCkgcHJvbWlzZSBtYXkgYmUgcmVqZWN0ZWQgYmVjYXVzZSBpdCB3YXNcbiAgICAgICAgICogSUdOT1JFRCwgYnV0IHRoZSB0cmFuc2l0aW9uVG8oKSBwcm9taXNlIGlzIHJlc29sdmVkIGJlY2F1c2UgZnJvbSB0aGUgdXNlciBwZXJzcGVjdGl2ZVxuICAgICAgICAgKiBubyBlcnJvciBvY2N1cnJlZC4gIExpa2V3aXNlLCB0aGUgdHJhbnNpdGlvbi5ydW4oKSBwcm9taXNlIG1heSBiZSByZWplY3RlZCBiZWNhdXNlIG9mXG4gICAgICAgICAqIGEgUmVkaXJlY3QsIGJ1dCB0aGUgdHJhbnNpdGlvblRvKCkgcHJvbWlzZSBpcyBjaGFpbmVkIHRvIHRoZSBuZXcgVHJhbnNpdGlvbidzIHByb21pc2UuXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgcmVqZWN0ZWRUcmFuc2l0aW9uSGFuZGxlciA9IGZ1bmN0aW9uICh0cmFucykgeyByZXR1cm4gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiByZWplY3RGYWN0b3J5XzEuUmVqZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzTGF0ZXN0ID0gcm91dGVyLmdsb2JhbHMubGFzdFN0YXJ0ZWRUcmFuc2l0aW9uSWQgPT09IHRyYW5zLiRpZDtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IudHlwZSA9PT0gcmVqZWN0RmFjdG9yeV8xLlJlamVjdFR5cGUuSUdOT1JFRCkge1xuICAgICAgICAgICAgICAgICAgICBpc0xhdGVzdCAmJiByb3V0ZXIudXJsUm91dGVyLnVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBDb25zaWRlciBpZ25vcmVkIGBUcmFuc2l0aW9uLnJ1bigpYCBhcyBhIHN1Y2Nlc3NmdWwgYHRyYW5zaXRpb25Ub2BcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvcmVzZXJ2aWNlc18xLnNlcnZpY2VzLiRxLndoZW4oZ2xvYmFscy5jdXJyZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGRldGFpbCA9IGVycm9yLmRldGFpbDtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IudHlwZSA9PT0gcmVqZWN0RmFjdG9yeV8xLlJlamVjdFR5cGUuU1VQRVJTRURFRCAmJiBlcnJvci5yZWRpcmVjdGVkICYmIGRldGFpbCBpbnN0YW5jZW9mIHRhcmdldFN0YXRlXzEuVGFyZ2V0U3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgYFRyYW5zaXRpb24ucnVuKClgIHdhcyByZWRpcmVjdGVkLCBhbGxvdyB0aGUgYHRyYW5zaXRpb25UbygpYCBwcm9taXNlIHRvIHJlc29sdmUgc3VjY2Vzc2Z1bGx5XG4gICAgICAgICAgICAgICAgICAgIC8vIGJ5IHJldHVybmluZyB0aGUgcHJvbWlzZSBmb3IgdGhlIG5ldyAocmVkaXJlY3QpIGBUcmFuc2l0aW9uLnJ1bigpYC5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlZGlyZWN0ID0gdHJhbnMucmVkaXJlY3QoZGV0YWlsKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlZGlyZWN0LnJ1bigpLmNhdGNoKHJlamVjdGVkVHJhbnNpdGlvbkhhbmRsZXIocmVkaXJlY3QpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLnR5cGUgPT09IHJlamVjdEZhY3RvcnlfMS5SZWplY3RUeXBlLkFCT1JURUQpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNMYXRlc3QgJiYgcm91dGVyLnVybFJvdXRlci51cGRhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvcmVzZXJ2aWNlc18xLnNlcnZpY2VzLiRxLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGVycm9ySGFuZGxlciA9IF90aGlzLmRlZmF1bHRFcnJvckhhbmRsZXIoKTtcbiAgICAgICAgICAgIGVycm9ySGFuZGxlcihlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gY29yZXNlcnZpY2VzXzEuc2VydmljZXMuJHEucmVqZWN0KGVycm9yKTtcbiAgICAgICAgfTsgfTtcbiAgICAgICAgdmFyIHRyYW5zaXRpb24gPSB0aGlzLnJvdXRlci50cmFuc2l0aW9uU2VydmljZS5jcmVhdGUoY3VycmVudFBhdGgsIHJlZik7XG4gICAgICAgIHZhciB0cmFuc2l0aW9uVG9Qcm9taXNlID0gdHJhbnNpdGlvbi5ydW4oKS5jYXRjaChyZWplY3RlZFRyYW5zaXRpb25IYW5kbGVyKHRyYW5zaXRpb24pKTtcbiAgICAgICAgY29tbW9uXzEuc2lsZW5jZVVuY2F1Z2h0SW5Qcm9taXNlKHRyYW5zaXRpb25Ub1Byb21pc2UpOyAvLyBpc3N1ZSAjMjY3NlxuICAgICAgICAvLyBSZXR1cm4gYSBwcm9taXNlIGZvciB0aGUgdHJhbnNpdGlvbiwgd2hpY2ggYWxzbyBoYXMgdGhlIHRyYW5zaXRpb24gb2JqZWN0IG9uIGl0LlxuICAgICAgICByZXR1cm4gY29tbW9uXzEuZXh0ZW5kKHRyYW5zaXRpb25Ub1Byb21pc2UsIHsgdHJhbnNpdGlvbjogdHJhbnNpdGlvbiB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgY3VycmVudCBzdGF0ZSAqaXMqIHRoZSBwcm92aWRlZCBzdGF0ZVxuICAgICAqXG4gICAgICogU2ltaWxhciB0byBbW2luY2x1ZGVzXV0gYnV0IG9ubHkgY2hlY2tzIGZvciB0aGUgZnVsbCBzdGF0ZSBuYW1lLlxuICAgICAqIElmIHBhcmFtcyBpcyBzdXBwbGllZCB0aGVuIGl0IHdpbGwgYmUgdGVzdGVkIGZvciBzdHJpY3QgZXF1YWxpdHkgYWdhaW5zdCB0aGUgY3VycmVudFxuICAgICAqIGFjdGl2ZSBwYXJhbXMgb2JqZWN0LCBzbyBhbGwgcGFyYW1zIG11c3QgbWF0Y2ggd2l0aCBub25lIG1pc3NpbmcgYW5kIG5vIGV4dHJhcy5cbiAgICAgKlxuICAgICAqICMjIyMgRXhhbXBsZTpcbiAgICAgKiBgYGBqc1xuICAgICAqICRzdGF0ZS4kY3VycmVudC5uYW1lID0gJ2NvbnRhY3RzLmRldGFpbHMuaXRlbSc7XG4gICAgICpcbiAgICAgKiAvLyBhYnNvbHV0ZSBuYW1lXG4gICAgICogJHN0YXRlLmlzKCdjb250YWN0LmRldGFpbHMuaXRlbScpOyAvLyByZXR1cm5zIHRydWVcbiAgICAgKiAkc3RhdGUuaXMoY29udGFjdERldGFpbEl0ZW1TdGF0ZU9iamVjdCk7IC8vIHJldHVybnMgdHJ1ZVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogLy8gcmVsYXRpdmUgbmFtZSAoLiBhbmQgXiksIHR5cGljYWxseSBmcm9tIGEgdGVtcGxhdGVcbiAgICAgKiAvLyBFLmcuIGZyb20gdGhlICdjb250YWN0cy5kZXRhaWxzJyB0ZW1wbGF0ZVxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2IG5nLWNsYXNzPVwie2hpZ2hsaWdodGVkOiAkc3RhdGUuaXMoJy5pdGVtJyl9XCI+SXRlbTwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIHN0YXRlT3JOYW1lIFRoZSBzdGF0ZSBuYW1lIChhYnNvbHV0ZSBvciByZWxhdGl2ZSkgb3Igc3RhdGUgb2JqZWN0IHlvdSdkIGxpa2UgdG8gY2hlY2suXG4gICAgICogQHBhcmFtIHBhcmFtcyBBIHBhcmFtIG9iamVjdCwgZS5nLiBge3NlY3Rpb25JZDogc2VjdGlvbi5pZH1gLCB0aGF0IHlvdSdkIGxpa2VcbiAgICAgKiB0byB0ZXN0IGFnYWluc3QgdGhlIGN1cnJlbnQgYWN0aXZlIHN0YXRlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIEFuIG9wdGlvbnMgb2JqZWN0LiBUaGUgb3B0aW9ucyBhcmU6XG4gICAgICogICAtIGByZWxhdGl2ZWA6IElmIGBzdGF0ZU9yTmFtZWAgaXMgYSByZWxhdGl2ZSBzdGF0ZSBuYW1lIGFuZCBgb3B0aW9ucy5yZWxhdGl2ZWAgaXMgc2V0LCAuaXMgd2lsbFxuICAgICAqICAgICB0ZXN0IHJlbGF0aXZlIHRvIGBvcHRpb25zLnJlbGF0aXZlYCBzdGF0ZSAob3IgbmFtZSkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBSZXR1cm5zIHRydWUgaWYgaXQgaXMgdGhlIHN0YXRlLlxuICAgICAqL1xuICAgIFN0YXRlU2VydmljZS5wcm90b3R5cGUuaXMgPSBmdW5jdGlvbiAoc3RhdGVPck5hbWUsIHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gY29tbW9uXzEuZGVmYXVsdHMob3B0aW9ucywgeyByZWxhdGl2ZTogdGhpcy4kY3VycmVudCB9KTtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5yb3V0ZXIuc3RhdGVSZWdpc3RyeS5tYXRjaGVyLmZpbmQoc3RhdGVPck5hbWUsIG9wdGlvbnMucmVsYXRpdmUpO1xuICAgICAgICBpZiAoIXByZWRpY2F0ZXNfMS5pc0RlZmluZWQoc3RhdGUpKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHRoaXMuJGN1cnJlbnQgIT09IHN0YXRlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIXBhcmFtcylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB2YXIgc2NoZW1hID0gc3RhdGUucGFyYW1ldGVycyh7IGluaGVyaXQ6IHRydWUsIG1hdGNoaW5nS2V5czogcGFyYW1zIH0pO1xuICAgICAgICByZXR1cm4gcGFyYW1fMS5QYXJhbS5lcXVhbHMoc2NoZW1hLCBwYXJhbV8xLlBhcmFtLnZhbHVlcyhzY2hlbWEsIHBhcmFtcyksIHRoaXMucGFyYW1zKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgY3VycmVudCBzdGF0ZSAqaW5jbHVkZXMqIHRoZSBwcm92aWRlZCBzdGF0ZVxuICAgICAqXG4gICAgICogQSBtZXRob2QgdG8gZGV0ZXJtaW5lIGlmIHRoZSBjdXJyZW50IGFjdGl2ZSBzdGF0ZSBpcyBlcXVhbCB0byBvciBpcyB0aGUgY2hpbGQgb2YgdGhlXG4gICAgICogc3RhdGUgc3RhdGVOYW1lLiBJZiBhbnkgcGFyYW1zIGFyZSBwYXNzZWQgdGhlbiB0aGV5IHdpbGwgYmUgdGVzdGVkIGZvciBhIG1hdGNoIGFzIHdlbGwuXG4gICAgICogTm90IGFsbCB0aGUgcGFyYW1ldGVycyBuZWVkIHRvIGJlIHBhc3NlZCwganVzdCB0aGUgb25lcyB5b3UnZCBsaWtlIHRvIHRlc3QgZm9yIGVxdWFsaXR5LlxuICAgICAqXG4gICAgICogIyMjIyBFeGFtcGxlIHdoZW4gYCRzdGF0ZS4kY3VycmVudC5uYW1lID09PSAnY29udGFjdHMuZGV0YWlscy5pdGVtJ2BcbiAgICAgKiBgYGBqc1xuICAgICAqIC8vIFVzaW5nIHBhcnRpYWwgbmFtZXNcbiAgICAgKiAkc3RhdGUuaW5jbHVkZXMoXCJjb250YWN0c1wiKTsgLy8gcmV0dXJucyB0cnVlXG4gICAgICogJHN0YXRlLmluY2x1ZGVzKFwiY29udGFjdHMuZGV0YWlsc1wiKTsgLy8gcmV0dXJucyB0cnVlXG4gICAgICogJHN0YXRlLmluY2x1ZGVzKFwiY29udGFjdHMuZGV0YWlscy5pdGVtXCIpOyAvLyByZXR1cm5zIHRydWVcbiAgICAgKiAkc3RhdGUuaW5jbHVkZXMoXCJjb250YWN0cy5saXN0XCIpOyAvLyByZXR1cm5zIGZhbHNlXG4gICAgICogJHN0YXRlLmluY2x1ZGVzKFwiYWJvdXRcIik7IC8vIHJldHVybnMgZmFsc2VcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqICMjIyMgR2xvYiBFeGFtcGxlcyB3aGVuIGAqICRzdGF0ZS4kY3VycmVudC5uYW1lID09PSAnY29udGFjdHMuZGV0YWlscy5pdGVtLnVybCdgOlxuICAgICAqIGBgYGpzXG4gICAgICogJHN0YXRlLmluY2x1ZGVzKFwiKi5kZXRhaWxzLiouKlwiKTsgLy8gcmV0dXJucyB0cnVlXG4gICAgICogJHN0YXRlLmluY2x1ZGVzKFwiKi5kZXRhaWxzLioqXCIpOyAvLyByZXR1cm5zIHRydWVcbiAgICAgKiAkc3RhdGUuaW5jbHVkZXMoXCIqKi5pdGVtLioqXCIpOyAvLyByZXR1cm5zIHRydWVcbiAgICAgKiAkc3RhdGUuaW5jbHVkZXMoXCIqLmRldGFpbHMuaXRlbS51cmxcIik7IC8vIHJldHVybnMgdHJ1ZVxuICAgICAqICRzdGF0ZS5pbmNsdWRlcyhcIiouZGV0YWlscy4qLnVybFwiKTsgLy8gcmV0dXJucyB0cnVlXG4gICAgICogJHN0YXRlLmluY2x1ZGVzKFwiKi5kZXRhaWxzLipcIik7IC8vIHJldHVybnMgZmFsc2VcbiAgICAgKiAkc3RhdGUuaW5jbHVkZXMoXCJpdGVtLioqXCIpOyAvLyByZXR1cm5zIGZhbHNlXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RhdGVPck5hbWUgQSBwYXJ0aWFsIG5hbWUsIHJlbGF0aXZlIG5hbWUsIGdsb2IgcGF0dGVybixcbiAgICAgKiAgIG9yIHN0YXRlIG9iamVjdCB0byBiZSBzZWFyY2hlZCBmb3Igd2l0aGluIHRoZSBjdXJyZW50IHN0YXRlIG5hbWUuXG4gICAgICogQHBhcmFtIHBhcmFtcyBBIHBhcmFtIG9iamVjdCwgZS5nLiBge3NlY3Rpb25JZDogc2VjdGlvbi5pZH1gLFxuICAgICAqICAgdGhhdCB5b3UnZCBsaWtlIHRvIHRlc3QgYWdhaW5zdCB0aGUgY3VycmVudCBhY3RpdmUgc3RhdGUuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgQW4gb3B0aW9ucyBvYmplY3QuIFRoZSBvcHRpb25zIGFyZTpcbiAgICAgKiAgIC0gYHJlbGF0aXZlYDogSWYgYHN0YXRlT3JOYW1lYCBpcyBhIHJlbGF0aXZlIHN0YXRlIG5hbWUgYW5kIGBvcHRpb25zLnJlbGF0aXZlYCBpcyBzZXQsIC5pcyB3aWxsXG4gICAgICogICAgIHRlc3QgcmVsYXRpdmUgdG8gYG9wdGlvbnMucmVsYXRpdmVgIHN0YXRlIChvciBuYW1lKS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgaXQgZG9lcyBpbmNsdWRlIHRoZSBzdGF0ZVxuICAgICAqL1xuICAgIFN0YXRlU2VydmljZS5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiAoc3RhdGVPck5hbWUsIHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gY29tbW9uXzEuZGVmYXVsdHMob3B0aW9ucywgeyByZWxhdGl2ZTogdGhpcy4kY3VycmVudCB9KTtcbiAgICAgICAgdmFyIGdsb2IgPSBwcmVkaWNhdGVzXzEuaXNTdHJpbmcoc3RhdGVPck5hbWUpICYmIGdsb2JfMS5HbG9iLmZyb21TdHJpbmcoc3RhdGVPck5hbWUpO1xuICAgICAgICBpZiAoZ2xvYikge1xuICAgICAgICAgICAgaWYgKCFnbG9iLm1hdGNoZXModGhpcy4kY3VycmVudC5uYW1lKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBzdGF0ZU9yTmFtZSA9IHRoaXMuJGN1cnJlbnQubmFtZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLnJvdXRlci5zdGF0ZVJlZ2lzdHJ5Lm1hdGNoZXIuZmluZChzdGF0ZU9yTmFtZSwgb3B0aW9ucy5yZWxhdGl2ZSksIGluY2x1ZGUgPSB0aGlzLiRjdXJyZW50LmluY2x1ZGVzO1xuICAgICAgICBpZiAoIXByZWRpY2F0ZXNfMS5pc0RlZmluZWQoc3RhdGUpKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCFwcmVkaWNhdGVzXzEuaXNEZWZpbmVkKGluY2x1ZGVbc3RhdGUubmFtZV0pKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIXBhcmFtcylcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB2YXIgc2NoZW1hID0gc3RhdGUucGFyYW1ldGVycyh7IGluaGVyaXQ6IHRydWUsIG1hdGNoaW5nS2V5czogcGFyYW1zIH0pO1xuICAgICAgICByZXR1cm4gcGFyYW1fMS5QYXJhbS5lcXVhbHMoc2NoZW1hLCBwYXJhbV8xLlBhcmFtLnZhbHVlcyhzY2hlbWEsIHBhcmFtcyksIHRoaXMucGFyYW1zKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIFVSTCBmb3IgYSBzdGF0ZSBhbmQgcGFyYW1ldGVyc1xuICAgICAqXG4gICAgICogUmV0dXJucyB0aGUgdXJsIGZvciB0aGUgZ2l2ZW4gc3RhdGUgcG9wdWxhdGVkIHdpdGggdGhlIGdpdmVuIHBhcmFtcy5cbiAgICAgKlxuICAgICAqICMjIyMgRXhhbXBsZTpcbiAgICAgKiBgYGBqc1xuICAgICAqIGV4cGVjdCgkc3RhdGUuaHJlZihcImFib3V0LnBlcnNvblwiLCB7IHBlcnNvbjogXCJib2JcIiB9KSkudG9FcXVhbChcIi9hYm91dC9ib2JcIik7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RhdGVPck5hbWUgVGhlIHN0YXRlIG5hbWUgb3Igc3RhdGUgb2JqZWN0IHlvdSdkIGxpa2UgdG8gZ2VuZXJhdGUgYSB1cmwgZnJvbS5cbiAgICAgKiBAcGFyYW0gcGFyYW1zIEFuIG9iamVjdCBvZiBwYXJhbWV0ZXIgdmFsdWVzIHRvIGZpbGwgdGhlIHN0YXRlJ3MgcmVxdWlyZWQgcGFyYW1ldGVycy5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIG9iamVjdC4gVGhlIG9wdGlvbnMgYXJlOlxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ30gY29tcGlsZWQgc3RhdGUgdXJsXG4gICAgICovXG4gICAgU3RhdGVTZXJ2aWNlLnByb3RvdHlwZS5ocmVmID0gZnVuY3Rpb24gKHN0YXRlT3JOYW1lLCBwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGRlZmF1bHRIcmVmT3B0cyA9IHtcbiAgICAgICAgICAgIGxvc3N5OiB0cnVlLFxuICAgICAgICAgICAgaW5oZXJpdDogdHJ1ZSxcbiAgICAgICAgICAgIGFic29sdXRlOiBmYWxzZSxcbiAgICAgICAgICAgIHJlbGF0aXZlOiB0aGlzLiRjdXJyZW50LFxuICAgICAgICB9O1xuICAgICAgICBvcHRpb25zID0gY29tbW9uXzEuZGVmYXVsdHMob3B0aW9ucywgZGVmYXVsdEhyZWZPcHRzKTtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLnJvdXRlci5zdGF0ZVJlZ2lzdHJ5Lm1hdGNoZXIuZmluZChzdGF0ZU9yTmFtZSwgb3B0aW9ucy5yZWxhdGl2ZSk7XG4gICAgICAgIGlmICghcHJlZGljYXRlc18xLmlzRGVmaW5lZChzdGF0ZSkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKG9wdGlvbnMuaW5oZXJpdClcbiAgICAgICAgICAgIHBhcmFtcyA9IHRoaXMucGFyYW1zLiRpbmhlcml0KHBhcmFtcywgdGhpcy4kY3VycmVudCwgc3RhdGUpO1xuICAgICAgICB2YXIgbmF2ID0gKHN0YXRlICYmIG9wdGlvbnMubG9zc3kpID8gc3RhdGUubmF2aWdhYmxlIDogc3RhdGU7XG4gICAgICAgIGlmICghbmF2IHx8IG5hdi51cmwgPT09IHVuZGVmaW5lZCB8fCBuYXYudXJsID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yb3V0ZXIudXJsUm91dGVyLmhyZWYobmF2LnVybCwgcGFyYW1zLCB7XG4gICAgICAgICAgICBhYnNvbHV0ZTogb3B0aW9ucy5hYnNvbHV0ZSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTZXRzIG9yIGdldHMgdGhlIGRlZmF1bHQgW1t0cmFuc2l0aW9uVG9dXSBlcnJvciBoYW5kbGVyLlxuICAgICAqXG4gICAgICogVGhlIGVycm9yIGhhbmRsZXIgaXMgY2FsbGVkIHdoZW4gYSBbW1RyYW5zaXRpb25dXSBpcyByZWplY3RlZCBvciB3aGVuIGFueSBlcnJvciBvY2N1cnJlZCBkdXJpbmcgdGhlIFRyYW5zaXRpb24uXG4gICAgICogVGhpcyBpbmNsdWRlcyBlcnJvcnMgY2F1c2VkIGJ5IHJlc29sdmVzIGFuZCB0cmFuc2l0aW9uIGhvb2tzLlxuICAgICAqXG4gICAgICogTm90ZTpcbiAgICAgKiBUaGlzIGhhbmRsZXIgZG9lcyBub3QgcmVjZWl2ZSBjZXJ0YWluIFRyYW5zaXRpb24gcmVqZWN0aW9ucy5cbiAgICAgKiBSZWRpcmVjdGVkIGFuZCBJZ25vcmVkIFRyYW5zaXRpb25zIGFyZSBub3QgY29uc2lkZXJlZCB0byBiZSBlcnJvcnMgYnkgW1tTdGF0ZVNlcnZpY2UudHJhbnNpdGlvblRvXV0uXG4gICAgICpcbiAgICAgKiBUaGUgYnVpbHQtaW4gZGVmYXVsdCBlcnJvciBoYW5kbGVyIGxvZ3MgdGhlIGVycm9yIHRvIHRoZSBjb25zb2xlLlxuICAgICAqXG4gICAgICogWW91IGNhbiBwcm92aWRlIHlvdXIgb3duIGN1c3RvbSBoYW5kbGVyLlxuICAgICAqXG4gICAgICogIyMjIyBFeGFtcGxlOlxuICAgICAqIGBgYGpzXG4gICAgICogc3RhdGVTZXJ2aWNlLmRlZmF1bHRFcnJvckhhbmRsZXIoZnVuY3Rpb24oKSB7XG4gICAgICogICAvLyBEbyBub3QgbG9nIHRyYW5zaXRpb25UbyBlcnJvcnNcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBoYW5kbGVyIGEgZ2xvYmFsIGVycm9yIGhhbmRsZXIgZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB0aGUgY3VycmVudCBnbG9iYWwgZXJyb3IgaGFuZGxlclxuICAgICAqL1xuICAgIFN0YXRlU2VydmljZS5wcm90b3R5cGUuZGVmYXVsdEVycm9ySGFuZGxlciA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWZhdWx0RXJyb3JIYW5kbGVyID0gaGFuZGxlciB8fCB0aGlzLl9kZWZhdWx0RXJyb3JIYW5kbGVyO1xuICAgIH07XG4gICAgU3RhdGVTZXJ2aWNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAoc3RhdGVPck5hbWUsIGJhc2UpIHtcbiAgICAgICAgdmFyIHJlZyA9IHRoaXMucm91dGVyLnN0YXRlUmVnaXN0cnk7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHJlZy5nZXQoKTtcbiAgICAgICAgcmV0dXJuIHJlZy5nZXQoc3RhdGVPck5hbWUsIGJhc2UgfHwgdGhpcy4kY3VycmVudCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBMYXp5IGxvYWRzIGEgc3RhdGVcbiAgICAgKlxuICAgICAqIEV4cGxpY2l0bHkgcnVucyBhIHN0YXRlJ3MgW1tTdGF0ZURlY2xhcmF0aW9uLmxhenlMb2FkXV0gZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RhdGVPck5hbWUgdGhlIHN0YXRlIHRoYXQgc2hvdWxkIGJlIGxhenkgbG9hZGVkXG4gICAgICogQHBhcmFtIHRyYW5zaXRpb24gdGhlIG9wdGlvbmFsIFRyYW5zaXRpb24gY29udGV4dCB0byB1c2UgKGlmIHRoZSBsYXp5TG9hZCBmdW5jdGlvbiByZXF1aXJlcyBhbiBpbmplY3RvciwgZXRjKVxuICAgICAqIE5vdGU6IElmIG5vIHRyYW5zaXRpb24gaXMgcHJvdmlkZWQsIGEgbm9vcCB0cmFuc2l0aW9uIGlzIGNyZWF0ZWQgdXNpbmcgdGhlIGZyb20gdGhlIGN1cnJlbnQgc3RhdGUgdG8gdGhlIGN1cnJlbnQgc3RhdGUuXG4gICAgICogVGhpcyBub29wIHRyYW5zaXRpb24gaXMgbm90IGFjdHVhbGx5IHJ1bi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGEgcHJvbWlzZSB0byBsYXp5IGxvYWRcbiAgICAgKi9cbiAgICBTdGF0ZVNlcnZpY2UucHJvdG90eXBlLmxhenlMb2FkID0gZnVuY3Rpb24gKHN0YXRlT3JOYW1lLCB0cmFuc2l0aW9uKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuZ2V0KHN0YXRlT3JOYW1lKTtcbiAgICAgICAgaWYgKCFzdGF0ZSB8fCAhc3RhdGUubGF6eUxvYWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBub3QgbGF6eSBsb2FkICcgKyBzdGF0ZU9yTmFtZSk7XG4gICAgICAgIHZhciBjdXJyZW50UGF0aCA9IHRoaXMuZ2V0Q3VycmVudFBhdGgoKTtcbiAgICAgICAgdmFyIHRhcmdldCA9IHBhdGhVdGlsc18xLlBhdGhVdGlscy5tYWtlVGFyZ2V0U3RhdGUodGhpcy5yb3V0ZXIuc3RhdGVSZWdpc3RyeSwgY3VycmVudFBhdGgpO1xuICAgICAgICB0cmFuc2l0aW9uID0gdHJhbnNpdGlvbiB8fCB0aGlzLnJvdXRlci50cmFuc2l0aW9uU2VydmljZS5jcmVhdGUoY3VycmVudFBhdGgsIHRhcmdldCk7XG4gICAgICAgIHJldHVybiBsYXp5TG9hZF8xLmxhenlMb2FkU3RhdGUodHJhbnNpdGlvbiwgc3RhdGUpO1xuICAgIH07XG4gICAgcmV0dXJuIFN0YXRlU2VydmljZTtcbn0oKSk7XG5leHBvcnRzLlN0YXRlU2VydmljZSA9IFN0YXRlU2VydmljZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0YXRlU2VydmljZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvc3RhdGUvc3RhdGVTZXJ2aWNlLmpzXG4vLyBtb2R1bGUgaWQgPSA3OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///78\n")},function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @coreapi\n * @module core\n */ /** */\nvar urlMatcherFactory_1 = __webpack_require__(80);\nvar urlRouter_1 = __webpack_require__(81);\nvar transitionService_1 = __webpack_require__(47);\nvar view_1 = __webpack_require__(83);\nvar stateRegistry_1 = __webpack_require__(77);\nvar stateService_1 = __webpack_require__(78);\nvar globals_1 = __webpack_require__(84);\nvar common_1 = __webpack_require__(0);\nvar predicates_1 = __webpack_require__(1);\nvar urlService_1 = __webpack_require__(85);\nvar trace_1 = __webpack_require__(8);\n/** @hidden */\nvar _routerInstance = 0;\n/**\n * The master class used to instantiate an instance of UI-Router.\n *\n * UI-Router (for each specific framework) will create an instance of this class during bootstrap.\n * This class instantiates and wires the UI-Router services together.\n *\n * After a new instance of the UIRouter class is created, it should be configured for your app.\n * For instance, app states should be registered with the [[UIRouter.stateRegistry]].\n *\n * ---\n *\n * Normally the framework code will bootstrap UI-Router.\n * If you are bootstrapping UIRouter manually, tell it to monitor the URL by calling\n * [[UrlService.listen]] then [[UrlService.sync]].\n */\nvar UIRouter = /** @class */ (function () {\n    /**\n     * Creates a new `UIRouter` object\n     *\n     * @param locationService a [[LocationServices]] implementation\n     * @param locationConfig a [[LocationConfig]] implementation\n     * @internalapi\n     */\n    function UIRouter(locationService, locationConfig) {\n        if (locationService === void 0) { locationService = urlService_1.UrlService.locationServiceStub; }\n        if (locationConfig === void 0) { locationConfig = urlService_1.UrlService.locationConfigStub; }\n        this.locationService = locationService;\n        this.locationConfig = locationConfig;\n        /** @hidden */ this.$id = _routerInstance++;\n        /** @hidden */ this._disposed = false;\n        /** @hidden */ this._disposables = [];\n        /** Provides trace information to the console */\n        this.trace = trace_1.trace;\n        /** Provides services related to ui-view synchronization */\n        this.viewService = new view_1.ViewService();\n        /** Provides services related to Transitions */\n        this.transitionService = new transitionService_1.TransitionService(this);\n        /** Global router state */\n        this.globals = new globals_1.UIRouterGlobals();\n        /**\n         * Deprecated for public use. Use [[urlService]] instead.\n         * @deprecated Use [[urlService]] instead\n         */\n        this.urlMatcherFactory = new urlMatcherFactory_1.UrlMatcherFactory();\n        /**\n         * Deprecated for public use. Use [[urlService]] instead.\n         * @deprecated Use [[urlService]] instead\n         */\n        this.urlRouter = new urlRouter_1.UrlRouter(this);\n        /** Provides a registry for states, and related registration services */\n        this.stateRegistry = new stateRegistry_1.StateRegistry(this);\n        /** Provides services related to states */\n        this.stateService = new stateService_1.StateService(this);\n        /** Provides services related to the URL */\n        this.urlService = new urlService_1.UrlService(this);\n        /** @hidden plugin instances are registered here */\n        this._plugins = {};\n        this.viewService._pluginapi._rootViewContext(this.stateRegistry.root());\n        this.globals.$current = this.stateRegistry.root();\n        this.globals.current = this.globals.$current.self;\n        this.disposable(this.globals);\n        this.disposable(this.stateService);\n        this.disposable(this.stateRegistry);\n        this.disposable(this.transitionService);\n        this.disposable(this.urlRouter);\n        this.disposable(locationService);\n        this.disposable(locationConfig);\n    }\n    /** Registers an object to be notified when the router is disposed */\n    UIRouter.prototype.disposable = function (disposable) {\n        this._disposables.push(disposable);\n    };\n    /**\n     * Disposes this router instance\n     *\n     * When called, clears resources retained by the router by calling `dispose(this)` on all\n     * registered [[disposable]] objects.\n     *\n     * Or, if a `disposable` object is provided, calls `dispose(this)` on that object only.\n     *\n     * @param disposable (optional) the disposable to dispose\n     */\n    UIRouter.prototype.dispose = function (disposable) {\n        var _this = this;\n        if (disposable && predicates_1.isFunction(disposable.dispose)) {\n            disposable.dispose(this);\n            return undefined;\n        }\n        this._disposed = true;\n        this._disposables.slice().forEach(function (d) {\n            try {\n                typeof d.dispose === 'function' && d.dispose(_this);\n                common_1.removeFrom(_this._disposables, d);\n            }\n            catch (ignored) { }\n        });\n    };\n    /**\n     * Adds a plugin to UI-Router\n     *\n     * This method adds a UI-Router Plugin.\n     * A plugin can enhance or change UI-Router behavior using any public API.\n     *\n     * #### Example:\n     * ```js\n     * import { MyCoolPlugin } from \"ui-router-cool-plugin\";\n     *\n     * var plugin = router.addPlugin(MyCoolPlugin);\n     * ```\n     *\n     * ### Plugin authoring\n     *\n     * A plugin is simply a class (or constructor function) which accepts a [[UIRouter]] instance and (optionally) an options object.\n     *\n     * The plugin can implement its functionality using any of the public APIs of [[UIRouter]].\n     * For example, it may configure router options or add a Transition Hook.\n     *\n     * The plugin can then be published as a separate module.\n     *\n     * #### Example:\n     * ```js\n     * export class MyAuthPlugin implements UIRouterPlugin {\n     *   constructor(router: UIRouter, options: any) {\n     *     this.name = \"MyAuthPlugin\";\n     *     let $transitions = router.transitionService;\n     *     let $state = router.stateService;\n     *\n     *     let authCriteria = {\n     *       to: (state) => state.data && state.data.requiresAuth\n     *     };\n     *\n     *     function authHook(transition: Transition) {\n     *       let authService = transition.injector().get('AuthService');\n     *       if (!authService.isAuthenticated()) {\n     *         return $state.target('login');\n     *       }\n     *     }\n     *\n     *     $transitions.onStart(authCriteria, authHook);\n     *   }\n     * }\n     * ```\n     *\n     * @param plugin one of:\n     *        - a plugin class which implements [[UIRouterPlugin]]\n     *        - a constructor function for a [[UIRouterPlugin]] which accepts a [[UIRouter]] instance\n     *        - a factory function which accepts a [[UIRouter]] instance and returns a [[UIRouterPlugin]] instance\n     * @param options options to pass to the plugin class/factory\n     * @returns the registered plugin instance\n     */\n    UIRouter.prototype.plugin = function (plugin, options) {\n        if (options === void 0) { options = {}; }\n        var pluginInstance = new plugin(this, options);\n        if (!pluginInstance.name)\n            throw new Error('Required property `name` missing on plugin: ' + pluginInstance);\n        this._disposables.push(pluginInstance);\n        return this._plugins[pluginInstance.name] = pluginInstance;\n    };\n    UIRouter.prototype.getPlugin = function (pluginName) {\n        return pluginName ? this._plugins[pluginName] : common_1.values(this._plugins);\n    };\n    return UIRouter;\n}());\nexports.UIRouter = UIRouter;\n//# sourceMappingURL=router.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNzkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3JvdXRlci5qcz9jZTdlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAY29yZWFwaVxuICogQG1vZHVsZSBjb3JlXG4gKi8gLyoqICovXG52YXIgdXJsTWF0Y2hlckZhY3RvcnlfMSA9IHJlcXVpcmUoXCIuL3VybC91cmxNYXRjaGVyRmFjdG9yeVwiKTtcbnZhciB1cmxSb3V0ZXJfMSA9IHJlcXVpcmUoXCIuL3VybC91cmxSb3V0ZXJcIik7XG52YXIgdHJhbnNpdGlvblNlcnZpY2VfMSA9IHJlcXVpcmUoXCIuL3RyYW5zaXRpb24vdHJhbnNpdGlvblNlcnZpY2VcIik7XG52YXIgdmlld18xID0gcmVxdWlyZShcIi4vdmlldy92aWV3XCIpO1xudmFyIHN0YXRlUmVnaXN0cnlfMSA9IHJlcXVpcmUoXCIuL3N0YXRlL3N0YXRlUmVnaXN0cnlcIik7XG52YXIgc3RhdGVTZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi9zdGF0ZS9zdGF0ZVNlcnZpY2VcIik7XG52YXIgZ2xvYmFsc18xID0gcmVxdWlyZShcIi4vZ2xvYmFsc1wiKTtcbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuL2NvbW1vbi9jb21tb25cIik7XG52YXIgcHJlZGljYXRlc18xID0gcmVxdWlyZShcIi4vY29tbW9uL3ByZWRpY2F0ZXNcIik7XG52YXIgdXJsU2VydmljZV8xID0gcmVxdWlyZShcIi4vdXJsL3VybFNlcnZpY2VcIik7XG52YXIgdHJhY2VfMSA9IHJlcXVpcmUoXCIuL2NvbW1vbi90cmFjZVwiKTtcbi8qKiBAaGlkZGVuICovXG52YXIgX3JvdXRlckluc3RhbmNlID0gMDtcbi8qKlxuICogVGhlIG1hc3RlciBjbGFzcyB1c2VkIHRvIGluc3RhbnRpYXRlIGFuIGluc3RhbmNlIG9mIFVJLVJvdXRlci5cbiAqXG4gKiBVSS1Sb3V0ZXIgKGZvciBlYWNoIHNwZWNpZmljIGZyYW1ld29yaykgd2lsbCBjcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBjbGFzcyBkdXJpbmcgYm9vdHN0cmFwLlxuICogVGhpcyBjbGFzcyBpbnN0YW50aWF0ZXMgYW5kIHdpcmVzIHRoZSBVSS1Sb3V0ZXIgc2VydmljZXMgdG9nZXRoZXIuXG4gKlxuICogQWZ0ZXIgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIFVJUm91dGVyIGNsYXNzIGlzIGNyZWF0ZWQsIGl0IHNob3VsZCBiZSBjb25maWd1cmVkIGZvciB5b3VyIGFwcC5cbiAqIEZvciBpbnN0YW5jZSwgYXBwIHN0YXRlcyBzaG91bGQgYmUgcmVnaXN0ZXJlZCB3aXRoIHRoZSBbW1VJUm91dGVyLnN0YXRlUmVnaXN0cnldXS5cbiAqXG4gKiAtLS1cbiAqXG4gKiBOb3JtYWxseSB0aGUgZnJhbWV3b3JrIGNvZGUgd2lsbCBib290c3RyYXAgVUktUm91dGVyLlxuICogSWYgeW91IGFyZSBib290c3RyYXBwaW5nIFVJUm91dGVyIG1hbnVhbGx5LCB0ZWxsIGl0IHRvIG1vbml0b3IgdGhlIFVSTCBieSBjYWxsaW5nXG4gKiBbW1VybFNlcnZpY2UubGlzdGVuXV0gdGhlbiBbW1VybFNlcnZpY2Uuc3luY11dLlxuICovXG52YXIgVUlSb3V0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBgVUlSb3V0ZXJgIG9iamVjdFxuICAgICAqXG4gICAgICogQHBhcmFtIGxvY2F0aW9uU2VydmljZSBhIFtbTG9jYXRpb25TZXJ2aWNlc11dIGltcGxlbWVudGF0aW9uXG4gICAgICogQHBhcmFtIGxvY2F0aW9uQ29uZmlnIGEgW1tMb2NhdGlvbkNvbmZpZ11dIGltcGxlbWVudGF0aW9uXG4gICAgICogQGludGVybmFsYXBpXG4gICAgICovXG4gICAgZnVuY3Rpb24gVUlSb3V0ZXIobG9jYXRpb25TZXJ2aWNlLCBsb2NhdGlvbkNvbmZpZykge1xuICAgICAgICBpZiAobG9jYXRpb25TZXJ2aWNlID09PSB2b2lkIDApIHsgbG9jYXRpb25TZXJ2aWNlID0gdXJsU2VydmljZV8xLlVybFNlcnZpY2UubG9jYXRpb25TZXJ2aWNlU3R1YjsgfVxuICAgICAgICBpZiAobG9jYXRpb25Db25maWcgPT09IHZvaWQgMCkgeyBsb2NhdGlvbkNvbmZpZyA9IHVybFNlcnZpY2VfMS5VcmxTZXJ2aWNlLmxvY2F0aW9uQ29uZmlnU3R1YjsgfVxuICAgICAgICB0aGlzLmxvY2F0aW9uU2VydmljZSA9IGxvY2F0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy5sb2NhdGlvbkNvbmZpZyA9IGxvY2F0aW9uQ29uZmlnO1xuICAgICAgICAvKiogQGhpZGRlbiAqLyB0aGlzLiRpZCA9IF9yb3V0ZXJJbnN0YW5jZSsrO1xuICAgICAgICAvKiogQGhpZGRlbiAqLyB0aGlzLl9kaXNwb3NlZCA9IGZhbHNlO1xuICAgICAgICAvKiogQGhpZGRlbiAqLyB0aGlzLl9kaXNwb3NhYmxlcyA9IFtdO1xuICAgICAgICAvKiogUHJvdmlkZXMgdHJhY2UgaW5mb3JtYXRpb24gdG8gdGhlIGNvbnNvbGUgKi9cbiAgICAgICAgdGhpcy50cmFjZSA9IHRyYWNlXzEudHJhY2U7XG4gICAgICAgIC8qKiBQcm92aWRlcyBzZXJ2aWNlcyByZWxhdGVkIHRvIHVpLXZpZXcgc3luY2hyb25pemF0aW9uICovXG4gICAgICAgIHRoaXMudmlld1NlcnZpY2UgPSBuZXcgdmlld18xLlZpZXdTZXJ2aWNlKCk7XG4gICAgICAgIC8qKiBQcm92aWRlcyBzZXJ2aWNlcyByZWxhdGVkIHRvIFRyYW5zaXRpb25zICovXG4gICAgICAgIHRoaXMudHJhbnNpdGlvblNlcnZpY2UgPSBuZXcgdHJhbnNpdGlvblNlcnZpY2VfMS5UcmFuc2l0aW9uU2VydmljZSh0aGlzKTtcbiAgICAgICAgLyoqIEdsb2JhbCByb3V0ZXIgc3RhdGUgKi9cbiAgICAgICAgdGhpcy5nbG9iYWxzID0gbmV3IGdsb2JhbHNfMS5VSVJvdXRlckdsb2JhbHMoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlcHJlY2F0ZWQgZm9yIHB1YmxpYyB1c2UuIFVzZSBbW3VybFNlcnZpY2VdXSBpbnN0ZWFkLlxuICAgICAgICAgKiBAZGVwcmVjYXRlZCBVc2UgW1t1cmxTZXJ2aWNlXV0gaW5zdGVhZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy51cmxNYXRjaGVyRmFjdG9yeSA9IG5ldyB1cmxNYXRjaGVyRmFjdG9yeV8xLlVybE1hdGNoZXJGYWN0b3J5KCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZXByZWNhdGVkIGZvciBwdWJsaWMgdXNlLiBVc2UgW1t1cmxTZXJ2aWNlXV0gaW5zdGVhZC5cbiAgICAgICAgICogQGRlcHJlY2F0ZWQgVXNlIFtbdXJsU2VydmljZV1dIGluc3RlYWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudXJsUm91dGVyID0gbmV3IHVybFJvdXRlcl8xLlVybFJvdXRlcih0aGlzKTtcbiAgICAgICAgLyoqIFByb3ZpZGVzIGEgcmVnaXN0cnkgZm9yIHN0YXRlcywgYW5kIHJlbGF0ZWQgcmVnaXN0cmF0aW9uIHNlcnZpY2VzICovXG4gICAgICAgIHRoaXMuc3RhdGVSZWdpc3RyeSA9IG5ldyBzdGF0ZVJlZ2lzdHJ5XzEuU3RhdGVSZWdpc3RyeSh0aGlzKTtcbiAgICAgICAgLyoqIFByb3ZpZGVzIHNlcnZpY2VzIHJlbGF0ZWQgdG8gc3RhdGVzICovXG4gICAgICAgIHRoaXMuc3RhdGVTZXJ2aWNlID0gbmV3IHN0YXRlU2VydmljZV8xLlN0YXRlU2VydmljZSh0aGlzKTtcbiAgICAgICAgLyoqIFByb3ZpZGVzIHNlcnZpY2VzIHJlbGF0ZWQgdG8gdGhlIFVSTCAqL1xuICAgICAgICB0aGlzLnVybFNlcnZpY2UgPSBuZXcgdXJsU2VydmljZV8xLlVybFNlcnZpY2UodGhpcyk7XG4gICAgICAgIC8qKiBAaGlkZGVuIHBsdWdpbiBpbnN0YW5jZXMgYXJlIHJlZ2lzdGVyZWQgaGVyZSAqL1xuICAgICAgICB0aGlzLl9wbHVnaW5zID0ge307XG4gICAgICAgIHRoaXMudmlld1NlcnZpY2UuX3BsdWdpbmFwaS5fcm9vdFZpZXdDb250ZXh0KHRoaXMuc3RhdGVSZWdpc3RyeS5yb290KCkpO1xuICAgICAgICB0aGlzLmdsb2JhbHMuJGN1cnJlbnQgPSB0aGlzLnN0YXRlUmVnaXN0cnkucm9vdCgpO1xuICAgICAgICB0aGlzLmdsb2JhbHMuY3VycmVudCA9IHRoaXMuZ2xvYmFscy4kY3VycmVudC5zZWxmO1xuICAgICAgICB0aGlzLmRpc3Bvc2FibGUodGhpcy5nbG9iYWxzKTtcbiAgICAgICAgdGhpcy5kaXNwb3NhYmxlKHRoaXMuc3RhdGVTZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5kaXNwb3NhYmxlKHRoaXMuc3RhdGVSZWdpc3RyeSk7XG4gICAgICAgIHRoaXMuZGlzcG9zYWJsZSh0aGlzLnRyYW5zaXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5kaXNwb3NhYmxlKHRoaXMudXJsUm91dGVyKTtcbiAgICAgICAgdGhpcy5kaXNwb3NhYmxlKGxvY2F0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuZGlzcG9zYWJsZShsb2NhdGlvbkNvbmZpZyk7XG4gICAgfVxuICAgIC8qKiBSZWdpc3RlcnMgYW4gb2JqZWN0IHRvIGJlIG5vdGlmaWVkIHdoZW4gdGhlIHJvdXRlciBpcyBkaXNwb3NlZCAqL1xuICAgIFVJUm91dGVyLnByb3RvdHlwZS5kaXNwb3NhYmxlID0gZnVuY3Rpb24gKGRpc3Bvc2FibGUpIHtcbiAgICAgICAgdGhpcy5fZGlzcG9zYWJsZXMucHVzaChkaXNwb3NhYmxlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERpc3Bvc2VzIHRoaXMgcm91dGVyIGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBXaGVuIGNhbGxlZCwgY2xlYXJzIHJlc291cmNlcyByZXRhaW5lZCBieSB0aGUgcm91dGVyIGJ5IGNhbGxpbmcgYGRpc3Bvc2UodGhpcylgIG9uIGFsbFxuICAgICAqIHJlZ2lzdGVyZWQgW1tkaXNwb3NhYmxlXV0gb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIE9yLCBpZiBhIGBkaXNwb3NhYmxlYCBvYmplY3QgaXMgcHJvdmlkZWQsIGNhbGxzIGBkaXNwb3NlKHRoaXMpYCBvbiB0aGF0IG9iamVjdCBvbmx5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGRpc3Bvc2FibGUgKG9wdGlvbmFsKSB0aGUgZGlzcG9zYWJsZSB0byBkaXNwb3NlXG4gICAgICovXG4gICAgVUlSb3V0ZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoZGlzcG9zYWJsZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoZGlzcG9zYWJsZSAmJiBwcmVkaWNhdGVzXzEuaXNGdW5jdGlvbihkaXNwb3NhYmxlLmRpc3Bvc2UpKSB7XG4gICAgICAgICAgICBkaXNwb3NhYmxlLmRpc3Bvc2UodGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fZGlzcG9zYWJsZXMuc2xpY2UoKS5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHR5cGVvZiBkLmRpc3Bvc2UgPT09ICdmdW5jdGlvbicgJiYgZC5kaXNwb3NlKF90aGlzKTtcbiAgICAgICAgICAgICAgICBjb21tb25fMS5yZW1vdmVGcm9tKF90aGlzLl9kaXNwb3NhYmxlcywgZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoaWdub3JlZCkgeyB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQWRkcyBhIHBsdWdpbiB0byBVSS1Sb3V0ZXJcbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGFkZHMgYSBVSS1Sb3V0ZXIgUGx1Z2luLlxuICAgICAqIEEgcGx1Z2luIGNhbiBlbmhhbmNlIG9yIGNoYW5nZSBVSS1Sb3V0ZXIgYmVoYXZpb3IgdXNpbmcgYW55IHB1YmxpYyBBUEkuXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGU6XG4gICAgICogYGBganNcbiAgICAgKiBpbXBvcnQgeyBNeUNvb2xQbHVnaW4gfSBmcm9tIFwidWktcm91dGVyLWNvb2wtcGx1Z2luXCI7XG4gICAgICpcbiAgICAgKiB2YXIgcGx1Z2luID0gcm91dGVyLmFkZFBsdWdpbihNeUNvb2xQbHVnaW4pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogIyMjIFBsdWdpbiBhdXRob3JpbmdcbiAgICAgKlxuICAgICAqIEEgcGx1Z2luIGlzIHNpbXBseSBhIGNsYXNzIChvciBjb25zdHJ1Y3RvciBmdW5jdGlvbikgd2hpY2ggYWNjZXB0cyBhIFtbVUlSb3V0ZXJdXSBpbnN0YW5jZSBhbmQgKG9wdGlvbmFsbHkpIGFuIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqXG4gICAgICogVGhlIHBsdWdpbiBjYW4gaW1wbGVtZW50IGl0cyBmdW5jdGlvbmFsaXR5IHVzaW5nIGFueSBvZiB0aGUgcHVibGljIEFQSXMgb2YgW1tVSVJvdXRlcl1dLlxuICAgICAqIEZvciBleGFtcGxlLCBpdCBtYXkgY29uZmlndXJlIHJvdXRlciBvcHRpb25zIG9yIGFkZCBhIFRyYW5zaXRpb24gSG9vay5cbiAgICAgKlxuICAgICAqIFRoZSBwbHVnaW4gY2FuIHRoZW4gYmUgcHVibGlzaGVkIGFzIGEgc2VwYXJhdGUgbW9kdWxlLlxuICAgICAqXG4gICAgICogIyMjIyBFeGFtcGxlOlxuICAgICAqIGBgYGpzXG4gICAgICogZXhwb3J0IGNsYXNzIE15QXV0aFBsdWdpbiBpbXBsZW1lbnRzIFVJUm91dGVyUGx1Z2luIHtcbiAgICAgKiAgIGNvbnN0cnVjdG9yKHJvdXRlcjogVUlSb3V0ZXIsIG9wdGlvbnM6IGFueSkge1xuICAgICAqICAgICB0aGlzLm5hbWUgPSBcIk15QXV0aFBsdWdpblwiO1xuICAgICAqICAgICBsZXQgJHRyYW5zaXRpb25zID0gcm91dGVyLnRyYW5zaXRpb25TZXJ2aWNlO1xuICAgICAqICAgICBsZXQgJHN0YXRlID0gcm91dGVyLnN0YXRlU2VydmljZTtcbiAgICAgKlxuICAgICAqICAgICBsZXQgYXV0aENyaXRlcmlhID0ge1xuICAgICAqICAgICAgIHRvOiAoc3RhdGUpID0+IHN0YXRlLmRhdGEgJiYgc3RhdGUuZGF0YS5yZXF1aXJlc0F1dGhcbiAgICAgKiAgICAgfTtcbiAgICAgKlxuICAgICAqICAgICBmdW5jdGlvbiBhdXRoSG9vayh0cmFuc2l0aW9uOiBUcmFuc2l0aW9uKSB7XG4gICAgICogICAgICAgbGV0IGF1dGhTZXJ2aWNlID0gdHJhbnNpdGlvbi5pbmplY3RvcigpLmdldCgnQXV0aFNlcnZpY2UnKTtcbiAgICAgKiAgICAgICBpZiAoIWF1dGhTZXJ2aWNlLmlzQXV0aGVudGljYXRlZCgpKSB7XG4gICAgICogICAgICAgICByZXR1cm4gJHN0YXRlLnRhcmdldCgnbG9naW4nKTtcbiAgICAgKiAgICAgICB9XG4gICAgICogICAgIH1cbiAgICAgKlxuICAgICAqICAgICAkdHJhbnNpdGlvbnMub25TdGFydChhdXRoQ3JpdGVyaWEsIGF1dGhIb29rKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGx1Z2luIG9uZSBvZjpcbiAgICAgKiAgICAgICAgLSBhIHBsdWdpbiBjbGFzcyB3aGljaCBpbXBsZW1lbnRzIFtbVUlSb3V0ZXJQbHVnaW5dXVxuICAgICAqICAgICAgICAtIGEgY29uc3RydWN0b3IgZnVuY3Rpb24gZm9yIGEgW1tVSVJvdXRlclBsdWdpbl1dIHdoaWNoIGFjY2VwdHMgYSBbW1VJUm91dGVyXV0gaW5zdGFuY2VcbiAgICAgKiAgICAgICAgLSBhIGZhY3RvcnkgZnVuY3Rpb24gd2hpY2ggYWNjZXB0cyBhIFtbVUlSb3V0ZXJdXSBpbnN0YW5jZSBhbmQgcmV0dXJucyBhIFtbVUlSb3V0ZXJQbHVnaW5dXSBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSBvcHRpb25zIG9wdGlvbnMgdG8gcGFzcyB0byB0aGUgcGx1Z2luIGNsYXNzL2ZhY3RvcnlcbiAgICAgKiBAcmV0dXJucyB0aGUgcmVnaXN0ZXJlZCBwbHVnaW4gaW5zdGFuY2VcbiAgICAgKi9cbiAgICBVSVJvdXRlci5wcm90b3R5cGUucGx1Z2luID0gZnVuY3Rpb24gKHBsdWdpbiwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB2YXIgcGx1Z2luSW5zdGFuY2UgPSBuZXcgcGx1Z2luKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoIXBsdWdpbkluc3RhbmNlLm5hbWUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlcXVpcmVkIHByb3BlcnR5IGBuYW1lYCBtaXNzaW5nIG9uIHBsdWdpbjogJyArIHBsdWdpbkluc3RhbmNlKTtcbiAgICAgICAgdGhpcy5fZGlzcG9zYWJsZXMucHVzaChwbHVnaW5JbnN0YW5jZSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9wbHVnaW5zW3BsdWdpbkluc3RhbmNlLm5hbWVdID0gcGx1Z2luSW5zdGFuY2U7XG4gICAgfTtcbiAgICBVSVJvdXRlci5wcm90b3R5cGUuZ2V0UGx1Z2luID0gZnVuY3Rpb24gKHBsdWdpbk5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHBsdWdpbk5hbWUgPyB0aGlzLl9wbHVnaW5zW3BsdWdpbk5hbWVdIDogY29tbW9uXzEudmFsdWVzKHRoaXMuX3BsdWdpbnMpO1xuICAgIH07XG4gICAgcmV0dXJuIFVJUm91dGVyO1xufSgpKTtcbmV4cG9ydHMuVUlSb3V0ZXIgPSBVSVJvdXRlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJvdXRlci5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvcm91dGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA3OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///79\n")},function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\n/**\n * @internalapi\n * @module url\n */ /** for typedoc */\nvar common_1 = __webpack_require__(0);\nvar predicates_1 = __webpack_require__(1);\nvar urlMatcher_1 = __webpack_require__(32);\nvar param_1 = __webpack_require__(18);\nvar paramTypes_1 = __webpack_require__(72);\n/**\n * Factory for [[UrlMatcher]] instances.\n *\n * The factory is available to ng1 services as\n * `$urlMatcherFactory` or ng1 providers as `$urlMatcherFactoryProvider`.\n */\nvar UrlMatcherFactory = /** @class */ (function () {\n    function UrlMatcherFactory() {\n        var _this = this;\n        /** @hidden */ this.paramTypes = new paramTypes_1.ParamTypes();\n        /** @hidden */ this._isCaseInsensitive = false;\n        /** @hidden */ this._isStrictMode = true;\n        /** @hidden */ this._defaultSquashPolicy = false;\n        /** @internalapi Creates a new [[Param]] for a given location (DefType) */\n        this.paramFactory = {\n            /** Creates a new [[Param]] from a CONFIG block */\n            fromConfig: function (id, type, config) {\n                return new param_1.Param(id, type, config, param_1.DefType.CONFIG, _this);\n            },\n            /** Creates a new [[Param]] from a url PATH */\n            fromPath: function (id, type, config) {\n                return new param_1.Param(id, type, config, param_1.DefType.PATH, _this);\n            },\n            /** Creates a new [[Param]] from a url SEARCH */\n            fromSearch: function (id, type, config) {\n                return new param_1.Param(id, type, config, param_1.DefType.SEARCH, _this);\n            },\n        };\n        /** @hidden */\n        this._getConfig = function (config) {\n            return common_1.extend({ strict: _this._isStrictMode, caseInsensitive: _this._isCaseInsensitive }, config);\n        };\n        common_1.extend(this, { UrlMatcher: urlMatcher_1.UrlMatcher, Param: param_1.Param });\n    }\n    /** @inheritdoc */\n    UrlMatcherFactory.prototype.caseInsensitive = function (value) {\n        return this._isCaseInsensitive = predicates_1.isDefined(value) ? value : this._isCaseInsensitive;\n    };\n    /** @inheritdoc */\n    UrlMatcherFactory.prototype.strictMode = function (value) {\n        return this._isStrictMode = predicates_1.isDefined(value) ? value : this._isStrictMode;\n    };\n    /** @inheritdoc */\n    UrlMatcherFactory.prototype.defaultSquashPolicy = function (value) {\n        if (predicates_1.isDefined(value) && value !== true && value !== false && !predicates_1.isString(value))\n            throw new Error("Invalid squash policy: " + value + ". Valid policies: false, true, arbitrary-string");\n        return this._defaultSquashPolicy = predicates_1.isDefined(value) ? value : this._defaultSquashPolicy;\n    };\n    /**\n     * Creates a [[UrlMatcher]] for the specified pattern.\n     *\n     * @param pattern  The URL pattern.\n     * @param config  The config object hash.\n     * @returns The UrlMatcher.\n     */\n    UrlMatcherFactory.prototype.compile = function (pattern, config) {\n        return new urlMatcher_1.UrlMatcher(pattern, this.paramTypes, this.paramFactory, this._getConfig(config));\n    };\n    /**\n     * Returns true if the specified object is a [[UrlMatcher]], or false otherwise.\n     *\n     * @param object  The object to perform the type check against.\n     * @returns `true` if the object matches the `UrlMatcher` interface, by\n     *          implementing all the same methods.\n     */\n    UrlMatcherFactory.prototype.isMatcher = function (object) {\n        // TODO: typeof?\n        if (!predicates_1.isObject(object))\n            return false;\n        var result = true;\n        common_1.forEach(urlMatcher_1.UrlMatcher.prototype, function (val, name) {\n            if (predicates_1.isFunction(val))\n                result = result && (predicates_1.isDefined(object[name]) && predicates_1.isFunction(object[name]));\n        });\n        return result;\n    };\n    /**\n     * Creates and registers a custom [[ParamType]] object\n     *\n     * A [[ParamType]] can be used to generate URLs with typed parameters.\n     *\n     * @param name  The type name.\n     * @param definition The type definition. See [[ParamTypeDefinition]] for information on the values accepted.\n     * @param definitionFn A function that is injected before the app runtime starts.\n     *        The result of this function should be a [[ParamTypeDefinition]].\n     *        The result is merged into the existing `definition`.\n     *        See [[ParamType]] for information on the values accepted.\n     *\n     * @returns - if a type was registered: the [[UrlMatcherFactory]]\n     *   - if only the `name` parameter was specified: the currently registered [[ParamType]] object, or undefined\n     *\n     * Note: Register custom types *before using them* in a state definition.\n     *\n     * See [[ParamTypeDefinition]] for examples\n     */\n    UrlMatcherFactory.prototype.type = function (name, definition, definitionFn) {\n        var type = this.paramTypes.type(name, definition, definitionFn);\n        return !predicates_1.isDefined(definition) ? type : this;\n    };\n    /** @hidden */\n    UrlMatcherFactory.prototype.$get = function () {\n        this.paramTypes.enqueue = false;\n        this.paramTypes._flushTypeQueue();\n        return this;\n    };\n    /** @internalapi */\n    UrlMatcherFactory.prototype.dispose = function () {\n        this.paramTypes.dispose();\n    };\n    return UrlMatcherFactory;\n}());\nexports.UrlMatcherFactory = UrlMatcherFactory;\n//# sourceMappingURL=urlMatcherFactory.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3VybC91cmxNYXRjaGVyRmFjdG9yeS5qcz85NDBlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAaW50ZXJuYWxhcGlcbiAqIEBtb2R1bGUgdXJsXG4gKi8gLyoqIGZvciB0eXBlZG9jICovXG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcbnZhciBwcmVkaWNhdGVzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3ByZWRpY2F0ZXNcIik7XG52YXIgdXJsTWF0Y2hlcl8xID0gcmVxdWlyZShcIi4vdXJsTWF0Y2hlclwiKTtcbnZhciBwYXJhbV8xID0gcmVxdWlyZShcIi4uL3BhcmFtcy9wYXJhbVwiKTtcbnZhciBwYXJhbVR5cGVzXzEgPSByZXF1aXJlKFwiLi4vcGFyYW1zL3BhcmFtVHlwZXNcIik7XG4vKipcbiAqIEZhY3RvcnkgZm9yIFtbVXJsTWF0Y2hlcl1dIGluc3RhbmNlcy5cbiAqXG4gKiBUaGUgZmFjdG9yeSBpcyBhdmFpbGFibGUgdG8gbmcxIHNlcnZpY2VzIGFzXG4gKiBgJHVybE1hdGNoZXJGYWN0b3J5YCBvciBuZzEgcHJvdmlkZXJzIGFzIGAkdXJsTWF0Y2hlckZhY3RvcnlQcm92aWRlcmAuXG4gKi9cbnZhciBVcmxNYXRjaGVyRmFjdG9yeSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBVcmxNYXRjaGVyRmFjdG9yeSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLyoqIEBoaWRkZW4gKi8gdGhpcy5wYXJhbVR5cGVzID0gbmV3IHBhcmFtVHlwZXNfMS5QYXJhbVR5cGVzKCk7XG4gICAgICAgIC8qKiBAaGlkZGVuICovIHRoaXMuX2lzQ2FzZUluc2Vuc2l0aXZlID0gZmFsc2U7XG4gICAgICAgIC8qKiBAaGlkZGVuICovIHRoaXMuX2lzU3RyaWN0TW9kZSA9IHRydWU7XG4gICAgICAgIC8qKiBAaGlkZGVuICovIHRoaXMuX2RlZmF1bHRTcXVhc2hQb2xpY3kgPSBmYWxzZTtcbiAgICAgICAgLyoqIEBpbnRlcm5hbGFwaSBDcmVhdGVzIGEgbmV3IFtbUGFyYW1dXSBmb3IgYSBnaXZlbiBsb2NhdGlvbiAoRGVmVHlwZSkgKi9cbiAgICAgICAgdGhpcy5wYXJhbUZhY3RvcnkgPSB7XG4gICAgICAgICAgICAvKiogQ3JlYXRlcyBhIG5ldyBbW1BhcmFtXV0gZnJvbSBhIENPTkZJRyBibG9jayAqL1xuICAgICAgICAgICAgZnJvbUNvbmZpZzogZnVuY3Rpb24gKGlkLCB0eXBlLCBjb25maWcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHBhcmFtXzEuUGFyYW0oaWQsIHR5cGUsIGNvbmZpZywgcGFyYW1fMS5EZWZUeXBlLkNPTkZJRywgX3RoaXMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8qKiBDcmVhdGVzIGEgbmV3IFtbUGFyYW1dXSBmcm9tIGEgdXJsIFBBVEggKi9cbiAgICAgICAgICAgIGZyb21QYXRoOiBmdW5jdGlvbiAoaWQsIHR5cGUsIGNvbmZpZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgcGFyYW1fMS5QYXJhbShpZCwgdHlwZSwgY29uZmlnLCBwYXJhbV8xLkRlZlR5cGUuUEFUSCwgX3RoaXMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8qKiBDcmVhdGVzIGEgbmV3IFtbUGFyYW1dXSBmcm9tIGEgdXJsIFNFQVJDSCAqL1xuICAgICAgICAgICAgZnJvbVNlYXJjaDogZnVuY3Rpb24gKGlkLCB0eXBlLCBjb25maWcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHBhcmFtXzEuUGFyYW0oaWQsIHR5cGUsIGNvbmZpZywgcGFyYW1fMS5EZWZUeXBlLlNFQVJDSCwgX3RoaXMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEBoaWRkZW4gKi9cbiAgICAgICAgdGhpcy5fZ2V0Q29uZmlnID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICAgICAgcmV0dXJuIGNvbW1vbl8xLmV4dGVuZCh7IHN0cmljdDogX3RoaXMuX2lzU3RyaWN0TW9kZSwgY2FzZUluc2Vuc2l0aXZlOiBfdGhpcy5faXNDYXNlSW5zZW5zaXRpdmUgfSwgY29uZmlnKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29tbW9uXzEuZXh0ZW5kKHRoaXMsIHsgVXJsTWF0Y2hlcjogdXJsTWF0Y2hlcl8xLlVybE1hdGNoZXIsIFBhcmFtOiBwYXJhbV8xLlBhcmFtIH0pO1xuICAgIH1cbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBVcmxNYXRjaGVyRmFjdG9yeS5wcm90b3R5cGUuY2FzZUluc2Vuc2l0aXZlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0Nhc2VJbnNlbnNpdGl2ZSA9IHByZWRpY2F0ZXNfMS5pc0RlZmluZWQodmFsdWUpID8gdmFsdWUgOiB0aGlzLl9pc0Nhc2VJbnNlbnNpdGl2ZTtcbiAgICB9O1xuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgIFVybE1hdGNoZXJGYWN0b3J5LnByb3RvdHlwZS5zdHJpY3RNb2RlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc1N0cmljdE1vZGUgPSBwcmVkaWNhdGVzXzEuaXNEZWZpbmVkKHZhbHVlKSA/IHZhbHVlIDogdGhpcy5faXNTdHJpY3RNb2RlO1xuICAgIH07XG4gICAgLyoqIEBpbmhlcml0ZG9jICovXG4gICAgVXJsTWF0Y2hlckZhY3RvcnkucHJvdG90eXBlLmRlZmF1bHRTcXVhc2hQb2xpY3kgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZXNfMS5pc0RlZmluZWQodmFsdWUpICYmIHZhbHVlICE9PSB0cnVlICYmIHZhbHVlICE9PSBmYWxzZSAmJiAhcHJlZGljYXRlc18xLmlzU3RyaW5nKHZhbHVlKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3F1YXNoIHBvbGljeTogXCIgKyB2YWx1ZSArIFwiLiBWYWxpZCBwb2xpY2llczogZmFsc2UsIHRydWUsIGFyYml0cmFyeS1zdHJpbmdcIik7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWZhdWx0U3F1YXNoUG9saWN5ID0gcHJlZGljYXRlc18xLmlzRGVmaW5lZCh2YWx1ZSkgPyB2YWx1ZSA6IHRoaXMuX2RlZmF1bHRTcXVhc2hQb2xpY3k7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgW1tVcmxNYXRjaGVyXV0gZm9yIHRoZSBzcGVjaWZpZWQgcGF0dGVybi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXR0ZXJuICBUaGUgVVJMIHBhdHRlcm4uXG4gICAgICogQHBhcmFtIGNvbmZpZyAgVGhlIGNvbmZpZyBvYmplY3QgaGFzaC5cbiAgICAgKiBAcmV0dXJucyBUaGUgVXJsTWF0Y2hlci5cbiAgICAgKi9cbiAgICBVcmxNYXRjaGVyRmFjdG9yeS5wcm90b3R5cGUuY29tcGlsZSA9IGZ1bmN0aW9uIChwYXR0ZXJuLCBjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB1cmxNYXRjaGVyXzEuVXJsTWF0Y2hlcihwYXR0ZXJuLCB0aGlzLnBhcmFtVHlwZXMsIHRoaXMucGFyYW1GYWN0b3J5LCB0aGlzLl9nZXRDb25maWcoY29uZmlnKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCBvYmplY3QgaXMgYSBbW1VybE1hdGNoZXJdXSwgb3IgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9iamVjdCAgVGhlIG9iamVjdCB0byBwZXJmb3JtIHRoZSB0eXBlIGNoZWNrIGFnYWluc3QuXG4gICAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3QgbWF0Y2hlcyB0aGUgYFVybE1hdGNoZXJgIGludGVyZmFjZSwgYnlcbiAgICAgKiAgICAgICAgICBpbXBsZW1lbnRpbmcgYWxsIHRoZSBzYW1lIG1ldGhvZHMuXG4gICAgICovXG4gICAgVXJsTWF0Y2hlckZhY3RvcnkucHJvdG90eXBlLmlzTWF0Y2hlciA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgICAgLy8gVE9ETzogdHlwZW9mP1xuICAgICAgICBpZiAoIXByZWRpY2F0ZXNfMS5pc09iamVjdChvYmplY3QpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgY29tbW9uXzEuZm9yRWFjaCh1cmxNYXRjaGVyXzEuVXJsTWF0Y2hlci5wcm90b3R5cGUsIGZ1bmN0aW9uICh2YWwsIG5hbWUpIHtcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGVzXzEuaXNGdW5jdGlvbih2YWwpKVxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdCAmJiAocHJlZGljYXRlc18xLmlzRGVmaW5lZChvYmplY3RbbmFtZV0pICYmIHByZWRpY2F0ZXNfMS5pc0Z1bmN0aW9uKG9iamVjdFtuYW1lXSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW5kIHJlZ2lzdGVycyBhIGN1c3RvbSBbW1BhcmFtVHlwZV1dIG9iamVjdFxuICAgICAqXG4gICAgICogQSBbW1BhcmFtVHlwZV1dIGNhbiBiZSB1c2VkIHRvIGdlbmVyYXRlIFVSTHMgd2l0aCB0eXBlZCBwYXJhbWV0ZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWUgIFRoZSB0eXBlIG5hbWUuXG4gICAgICogQHBhcmFtIGRlZmluaXRpb24gVGhlIHR5cGUgZGVmaW5pdGlvbi4gU2VlIFtbUGFyYW1UeXBlRGVmaW5pdGlvbl1dIGZvciBpbmZvcm1hdGlvbiBvbiB0aGUgdmFsdWVzIGFjY2VwdGVkLlxuICAgICAqIEBwYXJhbSBkZWZpbml0aW9uRm4gQSBmdW5jdGlvbiB0aGF0IGlzIGluamVjdGVkIGJlZm9yZSB0aGUgYXBwIHJ1bnRpbWUgc3RhcnRzLlxuICAgICAqICAgICAgICBUaGUgcmVzdWx0IG9mIHRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIGEgW1tQYXJhbVR5cGVEZWZpbml0aW9uXV0uXG4gICAgICogICAgICAgIFRoZSByZXN1bHQgaXMgbWVyZ2VkIGludG8gdGhlIGV4aXN0aW5nIGBkZWZpbml0aW9uYC5cbiAgICAgKiAgICAgICAgU2VlIFtbUGFyYW1UeXBlXV0gZm9yIGluZm9ybWF0aW9uIG9uIHRoZSB2YWx1ZXMgYWNjZXB0ZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyAtIGlmIGEgdHlwZSB3YXMgcmVnaXN0ZXJlZDogdGhlIFtbVXJsTWF0Y2hlckZhY3RvcnldXVxuICAgICAqICAgLSBpZiBvbmx5IHRoZSBgbmFtZWAgcGFyYW1ldGVyIHdhcyBzcGVjaWZpZWQ6IHRoZSBjdXJyZW50bHkgcmVnaXN0ZXJlZCBbW1BhcmFtVHlwZV1dIG9iamVjdCwgb3IgdW5kZWZpbmVkXG4gICAgICpcbiAgICAgKiBOb3RlOiBSZWdpc3RlciBjdXN0b20gdHlwZXMgKmJlZm9yZSB1c2luZyB0aGVtKiBpbiBhIHN0YXRlIGRlZmluaXRpb24uXG4gICAgICpcbiAgICAgKiBTZWUgW1tQYXJhbVR5cGVEZWZpbml0aW9uXV0gZm9yIGV4YW1wbGVzXG4gICAgICovXG4gICAgVXJsTWF0Y2hlckZhY3RvcnkucHJvdG90eXBlLnR5cGUgPSBmdW5jdGlvbiAobmFtZSwgZGVmaW5pdGlvbiwgZGVmaW5pdGlvbkZuKSB7XG4gICAgICAgIHZhciB0eXBlID0gdGhpcy5wYXJhbVR5cGVzLnR5cGUobmFtZSwgZGVmaW5pdGlvbiwgZGVmaW5pdGlvbkZuKTtcbiAgICAgICAgcmV0dXJuICFwcmVkaWNhdGVzXzEuaXNEZWZpbmVkKGRlZmluaXRpb24pID8gdHlwZSA6IHRoaXM7XG4gICAgfTtcbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIFVybE1hdGNoZXJGYWN0b3J5LnByb3RvdHlwZS4kZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnBhcmFtVHlwZXMuZW5xdWV1ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBhcmFtVHlwZXMuX2ZsdXNoVHlwZVF1ZXVlKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqIEBpbnRlcm5hbGFwaSAqL1xuICAgIFVybE1hdGNoZXJGYWN0b3J5LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnBhcmFtVHlwZXMuZGlzcG9zZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIFVybE1hdGNoZXJGYWN0b3J5O1xufSgpKTtcbmV4cG9ydHMuVXJsTWF0Y2hlckZhY3RvcnkgPSBVcmxNYXRjaGVyRmFjdG9yeTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVybE1hdGNoZXJGYWN0b3J5LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi91cmwvdXJsTWF0Y2hlckZhY3RvcnkuanNcbi8vIG1vZHVsZSBpZCA9IDgwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///80\n')},function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @internalapi\n * @module url\n */\n/** for typedoc */\nvar common_1 = __webpack_require__(0);\nvar predicates_1 = __webpack_require__(1);\nvar urlMatcher_1 = __webpack_require__(32);\nvar hof_1 = __webpack_require__(2);\nvar urlRule_1 = __webpack_require__(82);\nvar targetState_1 = __webpack_require__(17);\nvar common_2 = __webpack_require__(5);\n/** @hidden */\nfunction appendBasePath(url, isHtml5, absolute, baseHref) {\n    if (baseHref === '/')\n        return url;\n    if (isHtml5)\n        return common_2.stripLastPathElement(baseHref) + url;\n    if (absolute)\n        return baseHref.slice(1) + url;\n    return url;\n}\n/** @hidden */\nvar prioritySort = function (a, b) {\n    return (b.priority || 0) - (a.priority || 0);\n};\n/** @hidden */\nvar typeSort = function (a, b) {\n    var weights = { 'STATE': 4, 'URLMATCHER': 4, 'REGEXP': 3, 'RAW': 2, 'OTHER': 1 };\n    return (weights[a.type] || 0) - (weights[b.type] || 0);\n};\n/** @hidden */\nvar urlMatcherSort = function (a, b) {\n    return !a.urlMatcher || !b.urlMatcher ? 0 : urlMatcher_1.UrlMatcher.compare(a.urlMatcher, b.urlMatcher);\n};\n/** @hidden */\nvar idSort = function (a, b) {\n    // Identically sorted STATE and URLMATCHER best rule will be chosen by `matchPriority` after each rule matches the URL\n    var useMatchPriority = { STATE: true, URLMATCHER: true };\n    var equal = useMatchPriority[a.type] && useMatchPriority[b.type];\n    return equal ? 0 : (a.$id || 0) - (b.$id || 0);\n};\n/**\n * Default rule priority sorting function.\n *\n * Sorts rules by:\n *\n * - Explicit priority (set rule priority using [[UrlRulesApi.when]])\n * - Rule type (STATE: 4, URLMATCHER: 4, REGEXP: 3, RAW: 2, OTHER: 1)\n * - `UrlMatcher` specificity ([[UrlMatcher.compare]]): works for STATE and URLMATCHER types to pick the most specific rule.\n * - Rule registration order (for rule types other than STATE and URLMATCHER)\n *   - Equally sorted State and UrlMatcher rules will each match the URL.\n *     Then, the *best* match is chosen based on how many parameter values were matched.\n *\n * @coreapi\n */\nvar defaultRuleSortFn;\ndefaultRuleSortFn = function (a, b) {\n    var cmp = prioritySort(a, b);\n    if (cmp !== 0)\n        return cmp;\n    cmp = typeSort(a, b);\n    if (cmp !== 0)\n        return cmp;\n    cmp = urlMatcherSort(a, b);\n    if (cmp !== 0)\n        return cmp;\n    return idSort(a, b);\n};\n/**\n * Updates URL and responds to URL changes\n *\n * ### Deprecation warning:\n * This class is now considered to be an internal API\n * Use the [[UrlService]] instead.\n * For configuring URL rules, use the [[UrlRulesApi]] which can be found as [[UrlService.rules]].\n *\n * This class updates the URL when the state changes.\n * It also responds to changes in the URL.\n */\nvar UrlRouter = /** @class */ (function () {\n    /** @hidden */\n    function UrlRouter(router) {\n        /** @hidden */ this._sortFn = defaultRuleSortFn;\n        /** @hidden */ this._rules = [];\n        /** @hidden */ this.interceptDeferred = false;\n        /** @hidden */ this._id = 0;\n        /** @hidden */ this._sorted = false;\n        this._router = router;\n        this.urlRuleFactory = new urlRule_1.UrlRuleFactory(router);\n        common_1.createProxyFunctions(hof_1.val(UrlRouter.prototype), this, hof_1.val(this));\n    }\n    /** @internalapi */\n    UrlRouter.prototype.dispose = function () {\n        this.listen(false);\n        this._rules = [];\n        delete this._otherwiseFn;\n    };\n    /** @inheritdoc */\n    UrlRouter.prototype.sort = function (compareFn) {\n        this._rules = this.stableSort(this._rules, this._sortFn = compareFn || this._sortFn);\n        this._sorted = true;\n    };\n    UrlRouter.prototype.ensureSorted = function () {\n        this._sorted || this.sort();\n    };\n    UrlRouter.prototype.stableSort = function (arr, compareFn) {\n        var arrOfWrapper = arr.map(function (elem, idx) { return ({ elem: elem, idx: idx }); });\n        arrOfWrapper.sort(function (wrapperA, wrapperB) {\n            var cmpDiff = compareFn(wrapperA.elem, wrapperB.elem);\n            return cmpDiff === 0\n                ? wrapperA.idx - wrapperB.idx\n                : cmpDiff;\n        });\n        return arrOfWrapper.map(function (wrapper) { return wrapper.elem; });\n    };\n    /**\n     * Given a URL, check all rules and return the best [[MatchResult]]\n     * @param url\n     * @returns {MatchResult}\n     */\n    UrlRouter.prototype.match = function (url) {\n        var _this = this;\n        this.ensureSorted();\n        url = common_1.extend({ path: '', search: {}, hash: '' }, url);\n        var rules = this.rules();\n        if (this._otherwiseFn)\n            rules.push(this._otherwiseFn);\n        // Checks a single rule. Returns { rule: rule, match: match, weight: weight } if it matched, or undefined\n        var checkRule = function (rule) {\n            var match = rule.match(url, _this._router);\n            return match && { match: match, rule: rule, weight: rule.matchPriority(match) };\n        };\n        // The rules are pre-sorted.\n        // - Find the first matching rule.\n        // - Find any other matching rule that sorted *exactly the same*, according to `.sort()`.\n        // - Choose the rule with the highest match weight.\n        var best;\n        for (var i = 0; i < rules.length; i++) {\n            // Stop when there is a 'best' rule and the next rule sorts differently than it.\n            if (best && this._sortFn(rules[i], best.rule) !== 0)\n                break;\n            var current = checkRule(rules[i]);\n            // Pick the best MatchResult\n            best = (!best || current && current.weight > best.weight) ? current : best;\n        }\n        return best;\n    };\n    /** @inheritdoc */\n    UrlRouter.prototype.sync = function (evt) {\n        if (evt && evt.defaultPrevented)\n            return;\n        var router = this._router, $url = router.urlService, $state = router.stateService;\n        var url = {\n            path: $url.path(), search: $url.search(), hash: $url.hash(),\n        };\n        var best = this.match(url);\n        var applyResult = hof_1.pattern([\n            [predicates_1.isString, function (newurl) { return $url.url(newurl, true); }],\n            [targetState_1.TargetState.isDef, function (def) { return $state.go(def.state, def.params, def.options); }],\n            [hof_1.is(targetState_1.TargetState), function (target) { return $state.go(target.state(), target.params(), target.options()); }],\n        ]);\n        applyResult(best && best.rule.handler(best.match, url, router));\n    };\n    /** @inheritdoc */\n    UrlRouter.prototype.listen = function (enabled) {\n        var _this = this;\n        if (enabled === false) {\n            this._stopFn && this._stopFn();\n            delete this._stopFn;\n        }\n        else {\n            return this._stopFn = this._stopFn || this._router.urlService.onChange(function (evt) { return _this.sync(evt); });\n        }\n    };\n    /**\n     * Internal API.\n     * @internalapi\n     */\n    UrlRouter.prototype.update = function (read) {\n        var $url = this._router.locationService;\n        if (read) {\n            this.location = $url.url();\n            return;\n        }\n        if ($url.url() === this.location)\n            return;\n        $url.url(this.location, true);\n    };\n    /**\n     * Internal API.\n     *\n     * Pushes a new location to the browser history.\n     *\n     * @internalapi\n     * @param urlMatcher\n     * @param params\n     * @param options\n     */\n    UrlRouter.prototype.push = function (urlMatcher, params, options) {\n        var replace = options && !!options.replace;\n        this._router.urlService.url(urlMatcher.format(params || {}), replace);\n    };\n    /**\n     * Builds and returns a URL with interpolated parameters\n     *\n     * #### Example:\n     * ```js\n     * matcher = $umf.compile(\"/about/:person\");\n     * params = { person: \"bob\" };\n     * $bob = $urlRouter.href(matcher, params);\n     * // $bob == \"/about/bob\";\n     * ```\n     *\n     * @param urlMatcher The [[UrlMatcher]] object which is used as the template of the URL to generate.\n     * @param params An object of parameter values to fill the matcher's required parameters.\n     * @param options Options object. The options are:\n     *\n     * - **`absolute`** - {boolean=false},  If true will generate an absolute url, e.g. \"http://www.example.com/fullurl\".\n     *\n     * @returns Returns the fully compiled URL, or `null` if `params` fail validation against `urlMatcher`\n     */\n    UrlRouter.prototype.href = function (urlMatcher, params, options) {\n        var url = urlMatcher.format(params);\n        if (url == null)\n            return null;\n        options = options || { absolute: false };\n        var cfg = this._router.urlService.config;\n        var isHtml5 = cfg.html5Mode();\n        if (!isHtml5 && url !== null) {\n            url = '#' + cfg.hashPrefix() + url;\n        }\n        url = appendBasePath(url, isHtml5, options.absolute, cfg.baseHref());\n        if (!options.absolute || !url) {\n            return url;\n        }\n        var slash = (!isHtml5 && url ? '/' : '');\n        var cfgPort = cfg.port();\n        var port = (cfgPort === 80 || cfgPort === 443 ? '' : ':' + cfgPort);\n        return [cfg.protocol(), '://', cfg.host(), port, slash, url].join('');\n    };\n    /**\n     * Manually adds a URL Rule.\n     *\n     * Usually, a url rule is added using [[StateDeclaration.url]] or [[when]].\n     * This api can be used directly for more control (to register a [[BaseUrlRule]], for example).\n     * Rules can be created using [[UrlRouter.urlRuleFactory]], or create manually as simple objects.\n     *\n     * A rule should have a `match` function which returns truthy if the rule matched.\n     * It should also have a `handler` function which is invoked if the rule is the best match.\n     *\n     * @return a function that deregisters the rule\n     */\n    UrlRouter.prototype.rule = function (rule) {\n        var _this = this;\n        if (!urlRule_1.UrlRuleFactory.isUrlRule(rule))\n            throw new Error('invalid rule');\n        rule.$id = this._id++;\n        rule.priority = rule.priority || 0;\n        this._rules.push(rule);\n        this._sorted = false;\n        return function () { return _this.removeRule(rule); };\n    };\n    /** @inheritdoc */\n    UrlRouter.prototype.removeRule = function (rule) {\n        common_1.removeFrom(this._rules, rule);\n    };\n    /** @inheritdoc */\n    UrlRouter.prototype.rules = function () {\n        this.ensureSorted();\n        return this._rules.slice();\n    };\n    /** @inheritdoc */\n    UrlRouter.prototype.otherwise = function (handler) {\n        var handlerFn = getHandlerFn(handler);\n        this._otherwiseFn = this.urlRuleFactory.create(hof_1.val(true), handlerFn);\n        this._sorted = false;\n    };\n    /** @inheritdoc */\n    UrlRouter.prototype.initial = function (handler) {\n        var handlerFn = getHandlerFn(handler);\n        var matchFn = function (urlParts, router) {\n            return router.globals.transitionHistory.size() === 0 && !!/^\\/?$/.exec(urlParts.path);\n        };\n        this.rule(this.urlRuleFactory.create(matchFn, handlerFn));\n    };\n    /** @inheritdoc */\n    UrlRouter.prototype.when = function (matcher, handler, options) {\n        var rule = this.urlRuleFactory.create(matcher, handler);\n        if (predicates_1.isDefined(options && options.priority))\n            rule.priority = options.priority;\n        this.rule(rule);\n        return rule;\n    };\n    /** @inheritdoc */\n    UrlRouter.prototype.deferIntercept = function (defer) {\n        if (defer === undefined)\n            defer = true;\n        this.interceptDeferred = defer;\n    };\n    return UrlRouter;\n}());\nexports.UrlRouter = UrlRouter;\nfunction getHandlerFn(handler) {\n    if (!predicates_1.isFunction(handler) && !predicates_1.isString(handler) && !hof_1.is(targetState_1.TargetState)(handler) && !targetState_1.TargetState.isDef(handler)) {\n        throw new Error(\"'handler' must be a string, function, TargetState, or have a state: 'newtarget' property\");\n    }\n    return predicates_1.isFunction(handler) ? handler : hof_1.val(handler);\n}\n//# sourceMappingURL=urlRouter.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3VybC91cmxSb3V0ZXIuanM/YjA1NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGludGVybmFsYXBpXG4gKiBAbW9kdWxlIHVybFxuICovXG4vKiogZm9yIHR5cGVkb2MgKi9cbnZhciBjb21tb25fMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29tbW9uXCIpO1xudmFyIHByZWRpY2F0ZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vcHJlZGljYXRlc1wiKTtcbnZhciB1cmxNYXRjaGVyXzEgPSByZXF1aXJlKFwiLi91cmxNYXRjaGVyXCIpO1xudmFyIGhvZl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9ob2ZcIik7XG52YXIgdXJsUnVsZV8xID0gcmVxdWlyZShcIi4vdXJsUnVsZVwiKTtcbnZhciB0YXJnZXRTdGF0ZV8xID0gcmVxdWlyZShcIi4uL3N0YXRlL3RhcmdldFN0YXRlXCIpO1xudmFyIGNvbW1vbl8yID0gcmVxdWlyZShcIi4uL2NvbW1vblwiKTtcbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiBhcHBlbmRCYXNlUGF0aCh1cmwsIGlzSHRtbDUsIGFic29sdXRlLCBiYXNlSHJlZikge1xuICAgIGlmIChiYXNlSHJlZiA9PT0gJy8nKVxuICAgICAgICByZXR1cm4gdXJsO1xuICAgIGlmIChpc0h0bWw1KVxuICAgICAgICByZXR1cm4gY29tbW9uXzIuc3RyaXBMYXN0UGF0aEVsZW1lbnQoYmFzZUhyZWYpICsgdXJsO1xuICAgIGlmIChhYnNvbHV0ZSlcbiAgICAgICAgcmV0dXJuIGJhc2VIcmVmLnNsaWNlKDEpICsgdXJsO1xuICAgIHJldHVybiB1cmw7XG59XG4vKiogQGhpZGRlbiAqL1xudmFyIHByaW9yaXR5U29ydCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIChiLnByaW9yaXR5IHx8IDApIC0gKGEucHJpb3JpdHkgfHwgMCk7XG59O1xuLyoqIEBoaWRkZW4gKi9cbnZhciB0eXBlU29ydCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgdmFyIHdlaWdodHMgPSB7ICdTVEFURSc6IDQsICdVUkxNQVRDSEVSJzogNCwgJ1JFR0VYUCc6IDMsICdSQVcnOiAyLCAnT1RIRVInOiAxIH07XG4gICAgcmV0dXJuICh3ZWlnaHRzW2EudHlwZV0gfHwgMCkgLSAod2VpZ2h0c1tiLnR5cGVdIHx8IDApO1xufTtcbi8qKiBAaGlkZGVuICovXG52YXIgdXJsTWF0Y2hlclNvcnQgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiAhYS51cmxNYXRjaGVyIHx8ICFiLnVybE1hdGNoZXIgPyAwIDogdXJsTWF0Y2hlcl8xLlVybE1hdGNoZXIuY29tcGFyZShhLnVybE1hdGNoZXIsIGIudXJsTWF0Y2hlcik7XG59O1xuLyoqIEBoaWRkZW4gKi9cbnZhciBpZFNvcnQgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIC8vIElkZW50aWNhbGx5IHNvcnRlZCBTVEFURSBhbmQgVVJMTUFUQ0hFUiBiZXN0IHJ1bGUgd2lsbCBiZSBjaG9zZW4gYnkgYG1hdGNoUHJpb3JpdHlgIGFmdGVyIGVhY2ggcnVsZSBtYXRjaGVzIHRoZSBVUkxcbiAgICB2YXIgdXNlTWF0Y2hQcmlvcml0eSA9IHsgU1RBVEU6IHRydWUsIFVSTE1BVENIRVI6IHRydWUgfTtcbiAgICB2YXIgZXF1YWwgPSB1c2VNYXRjaFByaW9yaXR5W2EudHlwZV0gJiYgdXNlTWF0Y2hQcmlvcml0eVtiLnR5cGVdO1xuICAgIHJldHVybiBlcXVhbCA/IDAgOiAoYS4kaWQgfHwgMCkgLSAoYi4kaWQgfHwgMCk7XG59O1xuLyoqXG4gKiBEZWZhdWx0IHJ1bGUgcHJpb3JpdHkgc29ydGluZyBmdW5jdGlvbi5cbiAqXG4gKiBTb3J0cyBydWxlcyBieTpcbiAqXG4gKiAtIEV4cGxpY2l0IHByaW9yaXR5IChzZXQgcnVsZSBwcmlvcml0eSB1c2luZyBbW1VybFJ1bGVzQXBpLndoZW5dXSlcbiAqIC0gUnVsZSB0eXBlIChTVEFURTogNCwgVVJMTUFUQ0hFUjogNCwgUkVHRVhQOiAzLCBSQVc6IDIsIE9USEVSOiAxKVxuICogLSBgVXJsTWF0Y2hlcmAgc3BlY2lmaWNpdHkgKFtbVXJsTWF0Y2hlci5jb21wYXJlXV0pOiB3b3JrcyBmb3IgU1RBVEUgYW5kIFVSTE1BVENIRVIgdHlwZXMgdG8gcGljayB0aGUgbW9zdCBzcGVjaWZpYyBydWxlLlxuICogLSBSdWxlIHJlZ2lzdHJhdGlvbiBvcmRlciAoZm9yIHJ1bGUgdHlwZXMgb3RoZXIgdGhhbiBTVEFURSBhbmQgVVJMTUFUQ0hFUilcbiAqICAgLSBFcXVhbGx5IHNvcnRlZCBTdGF0ZSBhbmQgVXJsTWF0Y2hlciBydWxlcyB3aWxsIGVhY2ggbWF0Y2ggdGhlIFVSTC5cbiAqICAgICBUaGVuLCB0aGUgKmJlc3QqIG1hdGNoIGlzIGNob3NlbiBiYXNlZCBvbiBob3cgbWFueSBwYXJhbWV0ZXIgdmFsdWVzIHdlcmUgbWF0Y2hlZC5cbiAqXG4gKiBAY29yZWFwaVxuICovXG52YXIgZGVmYXVsdFJ1bGVTb3J0Rm47XG5kZWZhdWx0UnVsZVNvcnRGbiA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgdmFyIGNtcCA9IHByaW9yaXR5U29ydChhLCBiKTtcbiAgICBpZiAoY21wICE9PSAwKVxuICAgICAgICByZXR1cm4gY21wO1xuICAgIGNtcCA9IHR5cGVTb3J0KGEsIGIpO1xuICAgIGlmIChjbXAgIT09IDApXG4gICAgICAgIHJldHVybiBjbXA7XG4gICAgY21wID0gdXJsTWF0Y2hlclNvcnQoYSwgYik7XG4gICAgaWYgKGNtcCAhPT0gMClcbiAgICAgICAgcmV0dXJuIGNtcDtcbiAgICByZXR1cm4gaWRTb3J0KGEsIGIpO1xufTtcbi8qKlxuICogVXBkYXRlcyBVUkwgYW5kIHJlc3BvbmRzIHRvIFVSTCBjaGFuZ2VzXG4gKlxuICogIyMjIERlcHJlY2F0aW9uIHdhcm5pbmc6XG4gKiBUaGlzIGNsYXNzIGlzIG5vdyBjb25zaWRlcmVkIHRvIGJlIGFuIGludGVybmFsIEFQSVxuICogVXNlIHRoZSBbW1VybFNlcnZpY2VdXSBpbnN0ZWFkLlxuICogRm9yIGNvbmZpZ3VyaW5nIFVSTCBydWxlcywgdXNlIHRoZSBbW1VybFJ1bGVzQXBpXV0gd2hpY2ggY2FuIGJlIGZvdW5kIGFzIFtbVXJsU2VydmljZS5ydWxlc11dLlxuICpcbiAqIFRoaXMgY2xhc3MgdXBkYXRlcyB0aGUgVVJMIHdoZW4gdGhlIHN0YXRlIGNoYW5nZXMuXG4gKiBJdCBhbHNvIHJlc3BvbmRzIHRvIGNoYW5nZXMgaW4gdGhlIFVSTC5cbiAqL1xudmFyIFVybFJvdXRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIGZ1bmN0aW9uIFVybFJvdXRlcihyb3V0ZXIpIHtcbiAgICAgICAgLyoqIEBoaWRkZW4gKi8gdGhpcy5fc29ydEZuID0gZGVmYXVsdFJ1bGVTb3J0Rm47XG4gICAgICAgIC8qKiBAaGlkZGVuICovIHRoaXMuX3J1bGVzID0gW107XG4gICAgICAgIC8qKiBAaGlkZGVuICovIHRoaXMuaW50ZXJjZXB0RGVmZXJyZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqIEBoaWRkZW4gKi8gdGhpcy5faWQgPSAwO1xuICAgICAgICAvKiogQGhpZGRlbiAqLyB0aGlzLl9zb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcm91dGVyID0gcm91dGVyO1xuICAgICAgICB0aGlzLnVybFJ1bGVGYWN0b3J5ID0gbmV3IHVybFJ1bGVfMS5VcmxSdWxlRmFjdG9yeShyb3V0ZXIpO1xuICAgICAgICBjb21tb25fMS5jcmVhdGVQcm94eUZ1bmN0aW9ucyhob2ZfMS52YWwoVXJsUm91dGVyLnByb3RvdHlwZSksIHRoaXMsIGhvZl8xLnZhbCh0aGlzKSk7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWxhcGkgKi9cbiAgICBVcmxSb3V0ZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubGlzdGVuKGZhbHNlKTtcbiAgICAgICAgdGhpcy5fcnVsZXMgPSBbXTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX290aGVyd2lzZUZuO1xuICAgIH07XG4gICAgLyoqIEBpbmhlcml0ZG9jICovXG4gICAgVXJsUm91dGVyLnByb3RvdHlwZS5zb3J0ID0gZnVuY3Rpb24gKGNvbXBhcmVGbikge1xuICAgICAgICB0aGlzLl9ydWxlcyA9IHRoaXMuc3RhYmxlU29ydCh0aGlzLl9ydWxlcywgdGhpcy5fc29ydEZuID0gY29tcGFyZUZuIHx8IHRoaXMuX3NvcnRGbik7XG4gICAgICAgIHRoaXMuX3NvcnRlZCA9IHRydWU7XG4gICAgfTtcbiAgICBVcmxSb3V0ZXIucHJvdG90eXBlLmVuc3VyZVNvcnRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fc29ydGVkIHx8IHRoaXMuc29ydCgpO1xuICAgIH07XG4gICAgVXJsUm91dGVyLnByb3RvdHlwZS5zdGFibGVTb3J0ID0gZnVuY3Rpb24gKGFyciwgY29tcGFyZUZuKSB7XG4gICAgICAgIHZhciBhcnJPZldyYXBwZXIgPSBhcnIubWFwKGZ1bmN0aW9uIChlbGVtLCBpZHgpIHsgcmV0dXJuICh7IGVsZW06IGVsZW0sIGlkeDogaWR4IH0pOyB9KTtcbiAgICAgICAgYXJyT2ZXcmFwcGVyLnNvcnQoZnVuY3Rpb24gKHdyYXBwZXJBLCB3cmFwcGVyQikge1xuICAgICAgICAgICAgdmFyIGNtcERpZmYgPSBjb21wYXJlRm4od3JhcHBlckEuZWxlbSwgd3JhcHBlckIuZWxlbSk7XG4gICAgICAgICAgICByZXR1cm4gY21wRGlmZiA9PT0gMFxuICAgICAgICAgICAgICAgID8gd3JhcHBlckEuaWR4IC0gd3JhcHBlckIuaWR4XG4gICAgICAgICAgICAgICAgOiBjbXBEaWZmO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGFyck9mV3JhcHBlci5tYXAoZnVuY3Rpb24gKHdyYXBwZXIpIHsgcmV0dXJuIHdyYXBwZXIuZWxlbTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIFVSTCwgY2hlY2sgYWxsIHJ1bGVzIGFuZCByZXR1cm4gdGhlIGJlc3QgW1tNYXRjaFJlc3VsdF1dXG4gICAgICogQHBhcmFtIHVybFxuICAgICAqIEByZXR1cm5zIHtNYXRjaFJlc3VsdH1cbiAgICAgKi9cbiAgICBVcmxSb3V0ZXIucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24gKHVybCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmVuc3VyZVNvcnRlZCgpO1xuICAgICAgICB1cmwgPSBjb21tb25fMS5leHRlbmQoeyBwYXRoOiAnJywgc2VhcmNoOiB7fSwgaGFzaDogJycgfSwgdXJsKTtcbiAgICAgICAgdmFyIHJ1bGVzID0gdGhpcy5ydWxlcygpO1xuICAgICAgICBpZiAodGhpcy5fb3RoZXJ3aXNlRm4pXG4gICAgICAgICAgICBydWxlcy5wdXNoKHRoaXMuX290aGVyd2lzZUZuKTtcbiAgICAgICAgLy8gQ2hlY2tzIGEgc2luZ2xlIHJ1bGUuIFJldHVybnMgeyBydWxlOiBydWxlLCBtYXRjaDogbWF0Y2gsIHdlaWdodDogd2VpZ2h0IH0gaWYgaXQgbWF0Y2hlZCwgb3IgdW5kZWZpbmVkXG4gICAgICAgIHZhciBjaGVja1J1bGUgPSBmdW5jdGlvbiAocnVsZSkge1xuICAgICAgICAgICAgdmFyIG1hdGNoID0gcnVsZS5tYXRjaCh1cmwsIF90aGlzLl9yb3V0ZXIpO1xuICAgICAgICAgICAgcmV0dXJuIG1hdGNoICYmIHsgbWF0Y2g6IG1hdGNoLCBydWxlOiBydWxlLCB3ZWlnaHQ6IHJ1bGUubWF0Y2hQcmlvcml0eShtYXRjaCkgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gVGhlIHJ1bGVzIGFyZSBwcmUtc29ydGVkLlxuICAgICAgICAvLyAtIEZpbmQgdGhlIGZpcnN0IG1hdGNoaW5nIHJ1bGUuXG4gICAgICAgIC8vIC0gRmluZCBhbnkgb3RoZXIgbWF0Y2hpbmcgcnVsZSB0aGF0IHNvcnRlZCAqZXhhY3RseSB0aGUgc2FtZSosIGFjY29yZGluZyB0byBgLnNvcnQoKWAuXG4gICAgICAgIC8vIC0gQ2hvb3NlIHRoZSBydWxlIHdpdGggdGhlIGhpZ2hlc3QgbWF0Y2ggd2VpZ2h0LlxuICAgICAgICB2YXIgYmVzdDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgLy8gU3RvcCB3aGVuIHRoZXJlIGlzIGEgJ2Jlc3QnIHJ1bGUgYW5kIHRoZSBuZXh0IHJ1bGUgc29ydHMgZGlmZmVyZW50bHkgdGhhbiBpdC5cbiAgICAgICAgICAgIGlmIChiZXN0ICYmIHRoaXMuX3NvcnRGbihydWxlc1tpXSwgYmVzdC5ydWxlKSAhPT0gMClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHZhciBjdXJyZW50ID0gY2hlY2tSdWxlKHJ1bGVzW2ldKTtcbiAgICAgICAgICAgIC8vIFBpY2sgdGhlIGJlc3QgTWF0Y2hSZXN1bHRcbiAgICAgICAgICAgIGJlc3QgPSAoIWJlc3QgfHwgY3VycmVudCAmJiBjdXJyZW50LndlaWdodCA+IGJlc3Qud2VpZ2h0KSA/IGN1cnJlbnQgOiBiZXN0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiZXN0O1xuICAgIH07XG4gICAgLyoqIEBpbmhlcml0ZG9jICovXG4gICAgVXJsUm91dGVyLnByb3RvdHlwZS5zeW5jID0gZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICBpZiAoZXZ0ICYmIGV2dC5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgcm91dGVyID0gdGhpcy5fcm91dGVyLCAkdXJsID0gcm91dGVyLnVybFNlcnZpY2UsICRzdGF0ZSA9IHJvdXRlci5zdGF0ZVNlcnZpY2U7XG4gICAgICAgIHZhciB1cmwgPSB7XG4gICAgICAgICAgICBwYXRoOiAkdXJsLnBhdGgoKSwgc2VhcmNoOiAkdXJsLnNlYXJjaCgpLCBoYXNoOiAkdXJsLmhhc2goKSxcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGJlc3QgPSB0aGlzLm1hdGNoKHVybCk7XG4gICAgICAgIHZhciBhcHBseVJlc3VsdCA9IGhvZl8xLnBhdHRlcm4oW1xuICAgICAgICAgICAgW3ByZWRpY2F0ZXNfMS5pc1N0cmluZywgZnVuY3Rpb24gKG5ld3VybCkgeyByZXR1cm4gJHVybC51cmwobmV3dXJsLCB0cnVlKTsgfV0sXG4gICAgICAgICAgICBbdGFyZ2V0U3RhdGVfMS5UYXJnZXRTdGF0ZS5pc0RlZiwgZnVuY3Rpb24gKGRlZikgeyByZXR1cm4gJHN0YXRlLmdvKGRlZi5zdGF0ZSwgZGVmLnBhcmFtcywgZGVmLm9wdGlvbnMpOyB9XSxcbiAgICAgICAgICAgIFtob2ZfMS5pcyh0YXJnZXRTdGF0ZV8xLlRhcmdldFN0YXRlKSwgZnVuY3Rpb24gKHRhcmdldCkgeyByZXR1cm4gJHN0YXRlLmdvKHRhcmdldC5zdGF0ZSgpLCB0YXJnZXQucGFyYW1zKCksIHRhcmdldC5vcHRpb25zKCkpOyB9XSxcbiAgICAgICAgXSk7XG4gICAgICAgIGFwcGx5UmVzdWx0KGJlc3QgJiYgYmVzdC5ydWxlLmhhbmRsZXIoYmVzdC5tYXRjaCwgdXJsLCByb3V0ZXIpKTtcbiAgICB9O1xuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgIFVybFJvdXRlci5wcm90b3R5cGUubGlzdGVuID0gZnVuY3Rpb24gKGVuYWJsZWQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGVuYWJsZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLl9zdG9wRm4gJiYgdGhpcy5fc3RvcEZuKCk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fc3RvcEZuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3BGbiA9IHRoaXMuX3N0b3BGbiB8fCB0aGlzLl9yb3V0ZXIudXJsU2VydmljZS5vbkNoYW5nZShmdW5jdGlvbiAoZXZ0KSB7IHJldHVybiBfdGhpcy5zeW5jKGV2dCk7IH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBBUEkuXG4gICAgICogQGludGVybmFsYXBpXG4gICAgICovXG4gICAgVXJsUm91dGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAocmVhZCkge1xuICAgICAgICB2YXIgJHVybCA9IHRoaXMuX3JvdXRlci5sb2NhdGlvblNlcnZpY2U7XG4gICAgICAgIGlmIChyZWFkKSB7XG4gICAgICAgICAgICB0aGlzLmxvY2F0aW9uID0gJHVybC51cmwoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJHVybC51cmwoKSA9PT0gdGhpcy5sb2NhdGlvbilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgJHVybC51cmwodGhpcy5sb2NhdGlvbiwgdHJ1ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBBUEkuXG4gICAgICpcbiAgICAgKiBQdXNoZXMgYSBuZXcgbG9jYXRpb24gdG8gdGhlIGJyb3dzZXIgaGlzdG9yeS5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbGFwaVxuICAgICAqIEBwYXJhbSB1cmxNYXRjaGVyXG4gICAgICogQHBhcmFtIHBhcmFtc1xuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICovXG4gICAgVXJsUm91dGVyLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKHVybE1hdGNoZXIsIHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICB2YXIgcmVwbGFjZSA9IG9wdGlvbnMgJiYgISFvcHRpb25zLnJlcGxhY2U7XG4gICAgICAgIHRoaXMuX3JvdXRlci51cmxTZXJ2aWNlLnVybCh1cmxNYXRjaGVyLmZvcm1hdChwYXJhbXMgfHwge30pLCByZXBsYWNlKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEJ1aWxkcyBhbmQgcmV0dXJucyBhIFVSTCB3aXRoIGludGVycG9sYXRlZCBwYXJhbWV0ZXJzXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGU6XG4gICAgICogYGBganNcbiAgICAgKiBtYXRjaGVyID0gJHVtZi5jb21waWxlKFwiL2Fib3V0LzpwZXJzb25cIik7XG4gICAgICogcGFyYW1zID0geyBwZXJzb246IFwiYm9iXCIgfTtcbiAgICAgKiAkYm9iID0gJHVybFJvdXRlci5ocmVmKG1hdGNoZXIsIHBhcmFtcyk7XG4gICAgICogLy8gJGJvYiA9PSBcIi9hYm91dC9ib2JcIjtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB1cmxNYXRjaGVyIFRoZSBbW1VybE1hdGNoZXJdXSBvYmplY3Qgd2hpY2ggaXMgdXNlZCBhcyB0aGUgdGVtcGxhdGUgb2YgdGhlIFVSTCB0byBnZW5lcmF0ZS5cbiAgICAgKiBAcGFyYW0gcGFyYW1zIEFuIG9iamVjdCBvZiBwYXJhbWV0ZXIgdmFsdWVzIHRvIGZpbGwgdGhlIG1hdGNoZXIncyByZXF1aXJlZCBwYXJhbWV0ZXJzLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0LiBUaGUgb3B0aW9ucyBhcmU6XG4gICAgICpcbiAgICAgKiAtICoqYGFic29sdXRlYCoqIC0ge2Jvb2xlYW49ZmFsc2V9LCAgSWYgdHJ1ZSB3aWxsIGdlbmVyYXRlIGFuIGFic29sdXRlIHVybCwgZS5nLiBcImh0dHA6Ly93d3cuZXhhbXBsZS5jb20vZnVsbHVybFwiLlxuICAgICAqXG4gICAgICogQHJldHVybnMgUmV0dXJucyB0aGUgZnVsbHkgY29tcGlsZWQgVVJMLCBvciBgbnVsbGAgaWYgYHBhcmFtc2AgZmFpbCB2YWxpZGF0aW9uIGFnYWluc3QgYHVybE1hdGNoZXJgXG4gICAgICovXG4gICAgVXJsUm91dGVyLnByb3RvdHlwZS5ocmVmID0gZnVuY3Rpb24gKHVybE1hdGNoZXIsIHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICB2YXIgdXJsID0gdXJsTWF0Y2hlci5mb3JtYXQocGFyYW1zKTtcbiAgICAgICAgaWYgKHVybCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHsgYWJzb2x1dGU6IGZhbHNlIH07XG4gICAgICAgIHZhciBjZmcgPSB0aGlzLl9yb3V0ZXIudXJsU2VydmljZS5jb25maWc7XG4gICAgICAgIHZhciBpc0h0bWw1ID0gY2ZnLmh0bWw1TW9kZSgpO1xuICAgICAgICBpZiAoIWlzSHRtbDUgJiYgdXJsICE9PSBudWxsKSB7XG4gICAgICAgICAgICB1cmwgPSAnIycgKyBjZmcuaGFzaFByZWZpeCgpICsgdXJsO1xuICAgICAgICB9XG4gICAgICAgIHVybCA9IGFwcGVuZEJhc2VQYXRoKHVybCwgaXNIdG1sNSwgb3B0aW9ucy5hYnNvbHV0ZSwgY2ZnLmJhc2VIcmVmKCkpO1xuICAgICAgICBpZiAoIW9wdGlvbnMuYWJzb2x1dGUgfHwgIXVybCkge1xuICAgICAgICAgICAgcmV0dXJuIHVybDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2xhc2ggPSAoIWlzSHRtbDUgJiYgdXJsID8gJy8nIDogJycpO1xuICAgICAgICB2YXIgY2ZnUG9ydCA9IGNmZy5wb3J0KCk7XG4gICAgICAgIHZhciBwb3J0ID0gKGNmZ1BvcnQgPT09IDgwIHx8IGNmZ1BvcnQgPT09IDQ0MyA/ICcnIDogJzonICsgY2ZnUG9ydCk7XG4gICAgICAgIHJldHVybiBbY2ZnLnByb3RvY29sKCksICc6Ly8nLCBjZmcuaG9zdCgpLCBwb3J0LCBzbGFzaCwgdXJsXS5qb2luKCcnKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE1hbnVhbGx5IGFkZHMgYSBVUkwgUnVsZS5cbiAgICAgKlxuICAgICAqIFVzdWFsbHksIGEgdXJsIHJ1bGUgaXMgYWRkZWQgdXNpbmcgW1tTdGF0ZURlY2xhcmF0aW9uLnVybF1dIG9yIFtbd2hlbl1dLlxuICAgICAqIFRoaXMgYXBpIGNhbiBiZSB1c2VkIGRpcmVjdGx5IGZvciBtb3JlIGNvbnRyb2wgKHRvIHJlZ2lzdGVyIGEgW1tCYXNlVXJsUnVsZV1dLCBmb3IgZXhhbXBsZSkuXG4gICAgICogUnVsZXMgY2FuIGJlIGNyZWF0ZWQgdXNpbmcgW1tVcmxSb3V0ZXIudXJsUnVsZUZhY3RvcnldXSwgb3IgY3JlYXRlIG1hbnVhbGx5IGFzIHNpbXBsZSBvYmplY3RzLlxuICAgICAqXG4gICAgICogQSBydWxlIHNob3VsZCBoYXZlIGEgYG1hdGNoYCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIHRydXRoeSBpZiB0aGUgcnVsZSBtYXRjaGVkLlxuICAgICAqIEl0IHNob3VsZCBhbHNvIGhhdmUgYSBgaGFuZGxlcmAgZnVuY3Rpb24gd2hpY2ggaXMgaW52b2tlZCBpZiB0aGUgcnVsZSBpcyB0aGUgYmVzdCBtYXRjaC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gYSBmdW5jdGlvbiB0aGF0IGRlcmVnaXN0ZXJzIHRoZSBydWxlXG4gICAgICovXG4gICAgVXJsUm91dGVyLnByb3RvdHlwZS5ydWxlID0gZnVuY3Rpb24gKHJ1bGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF1cmxSdWxlXzEuVXJsUnVsZUZhY3RvcnkuaXNVcmxSdWxlKHJ1bGUpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHJ1bGUnKTtcbiAgICAgICAgcnVsZS4kaWQgPSB0aGlzLl9pZCsrO1xuICAgICAgICBydWxlLnByaW9yaXR5ID0gcnVsZS5wcmlvcml0eSB8fCAwO1xuICAgICAgICB0aGlzLl9ydWxlcy5wdXNoKHJ1bGUpO1xuICAgICAgICB0aGlzLl9zb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnJlbW92ZVJ1bGUocnVsZSk7IH07XG4gICAgfTtcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBVcmxSb3V0ZXIucHJvdG90eXBlLnJlbW92ZVJ1bGUgPSBmdW5jdGlvbiAocnVsZSkge1xuICAgICAgICBjb21tb25fMS5yZW1vdmVGcm9tKHRoaXMuX3J1bGVzLCBydWxlKTtcbiAgICB9O1xuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgIFVybFJvdXRlci5wcm90b3R5cGUucnVsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZW5zdXJlU29ydGVkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9ydWxlcy5zbGljZSgpO1xuICAgIH07XG4gICAgLyoqIEBpbmhlcml0ZG9jICovXG4gICAgVXJsUm91dGVyLnByb3RvdHlwZS5vdGhlcndpc2UgPSBmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgICAgICB2YXIgaGFuZGxlckZuID0gZ2V0SGFuZGxlckZuKGhhbmRsZXIpO1xuICAgICAgICB0aGlzLl9vdGhlcndpc2VGbiA9IHRoaXMudXJsUnVsZUZhY3RvcnkuY3JlYXRlKGhvZl8xLnZhbCh0cnVlKSwgaGFuZGxlckZuKTtcbiAgICAgICAgdGhpcy5fc29ydGVkID0gZmFsc2U7XG4gICAgfTtcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBVcmxSb3V0ZXIucHJvdG90eXBlLmluaXRpYWwgPSBmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgICAgICB2YXIgaGFuZGxlckZuID0gZ2V0SGFuZGxlckZuKGhhbmRsZXIpO1xuICAgICAgICB2YXIgbWF0Y2hGbiA9IGZ1bmN0aW9uICh1cmxQYXJ0cywgcm91dGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gcm91dGVyLmdsb2JhbHMudHJhbnNpdGlvbkhpc3Rvcnkuc2l6ZSgpID09PSAwICYmICEhL15cXC8/JC8uZXhlYyh1cmxQYXJ0cy5wYXRoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ydWxlKHRoaXMudXJsUnVsZUZhY3RvcnkuY3JlYXRlKG1hdGNoRm4sIGhhbmRsZXJGbikpO1xuICAgIH07XG4gICAgLyoqIEBpbmhlcml0ZG9jICovXG4gICAgVXJsUm91dGVyLnByb3RvdHlwZS53aGVuID0gZnVuY3Rpb24gKG1hdGNoZXIsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHJ1bGUgPSB0aGlzLnVybFJ1bGVGYWN0b3J5LmNyZWF0ZShtYXRjaGVyLCBoYW5kbGVyKTtcbiAgICAgICAgaWYgKHByZWRpY2F0ZXNfMS5pc0RlZmluZWQob3B0aW9ucyAmJiBvcHRpb25zLnByaW9yaXR5KSlcbiAgICAgICAgICAgIHJ1bGUucHJpb3JpdHkgPSBvcHRpb25zLnByaW9yaXR5O1xuICAgICAgICB0aGlzLnJ1bGUocnVsZSk7XG4gICAgICAgIHJldHVybiBydWxlO1xuICAgIH07XG4gICAgLyoqIEBpbmhlcml0ZG9jICovXG4gICAgVXJsUm91dGVyLnByb3RvdHlwZS5kZWZlckludGVyY2VwdCA9IGZ1bmN0aW9uIChkZWZlcikge1xuICAgICAgICBpZiAoZGVmZXIgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIGRlZmVyID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pbnRlcmNlcHREZWZlcnJlZCA9IGRlZmVyO1xuICAgIH07XG4gICAgcmV0dXJuIFVybFJvdXRlcjtcbn0oKSk7XG5leHBvcnRzLlVybFJvdXRlciA9IFVybFJvdXRlcjtcbmZ1bmN0aW9uIGdldEhhbmRsZXJGbihoYW5kbGVyKSB7XG4gICAgaWYgKCFwcmVkaWNhdGVzXzEuaXNGdW5jdGlvbihoYW5kbGVyKSAmJiAhcHJlZGljYXRlc18xLmlzU3RyaW5nKGhhbmRsZXIpICYmICFob2ZfMS5pcyh0YXJnZXRTdGF0ZV8xLlRhcmdldFN0YXRlKShoYW5kbGVyKSAmJiAhdGFyZ2V0U3RhdGVfMS5UYXJnZXRTdGF0ZS5pc0RlZihoYW5kbGVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCInaGFuZGxlcicgbXVzdCBiZSBhIHN0cmluZywgZnVuY3Rpb24sIFRhcmdldFN0YXRlLCBvciBoYXZlIGEgc3RhdGU6ICduZXd0YXJnZXQnIHByb3BlcnR5XCIpO1xuICAgIH1cbiAgICByZXR1cm4gcHJlZGljYXRlc18xLmlzRnVuY3Rpb24oaGFuZGxlcikgPyBoYW5kbGVyIDogaG9mXzEudmFsKGhhbmRsZXIpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXJsUm91dGVyLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi91cmwvdXJsUm91dGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA4MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///81\n")},function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @coreapi\n * @module url\n */ /** */\nvar urlMatcher_1 = __webpack_require__(32);\nvar predicates_1 = __webpack_require__(1);\nvar common_1 = __webpack_require__(0);\nvar hof_1 = __webpack_require__(2);\n/**\n * Creates a [[UrlRule]]\n *\n * Creates a [[UrlRule]] from a:\n *\n * - `string`\n * - [[UrlMatcher]]\n * - `RegExp`\n * - [[StateObject]]\n * @internalapi\n */\nvar UrlRuleFactory = /** @class */ (function () {\n    function UrlRuleFactory(router) {\n        this.router = router;\n    }\n    UrlRuleFactory.prototype.compile = function (str) {\n        return this.router.urlMatcherFactory.compile(str);\n    };\n    UrlRuleFactory.prototype.create = function (what, handler) {\n        var _this = this;\n        var makeRule = hof_1.pattern([\n            [predicates_1.isString, function (_what) { return makeRule(_this.compile(_what)); }],\n            [hof_1.is(urlMatcher_1.UrlMatcher), function (_what) { return _this.fromUrlMatcher(_what, handler); }],\n            [predicates_1.isState, function (_what) { return _this.fromState(_what, _this.router); }],\n            [hof_1.is(RegExp), function (_what) { return _this.fromRegExp(_what, handler); }],\n            [predicates_1.isFunction, function (_what) { return new BaseUrlRule(_what, handler); }],\n        ]);\n        var rule = makeRule(what);\n        if (!rule)\n            throw new Error(\"invalid 'what' in when()\");\n        return rule;\n    };\n    /**\n     * A UrlRule which matches based on a UrlMatcher\n     *\n     * The `handler` may be either a `string`, a [[UrlRuleHandlerFn]] or another [[UrlMatcher]]\n     *\n     * ## Handler as a function\n     *\n     * If `handler` is a function, the function is invoked with:\n     *\n     * - matched parameter values ([[RawParams]] from [[UrlMatcher.exec]])\n     * - url: the current Url ([[UrlParts]])\n     * - router: the router object ([[UIRouter]])\n     *\n     * #### Example:\n     * ```js\n     * var urlMatcher = $umf.compile(\"/foo/:fooId/:barId\");\n     * var rule = factory.fromUrlMatcher(urlMatcher, match => \"/home/\" + match.fooId + \"/\" + match.barId);\n     * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }\n     * var result = rule.handler(match); // '/home/123/456'\n     * ```\n     *\n     * ## Handler as UrlMatcher\n     *\n     * If `handler` is a UrlMatcher, the handler matcher is used to create the new url.\n     * The `handler` UrlMatcher is formatted using the matched param from the first matcher.\n     * The url is replaced with the result.\n     *\n     * #### Example:\n     * ```js\n     * var urlMatcher = $umf.compile(\"/foo/:fooId/:barId\");\n     * var handler = $umf.compile(\"/home/:fooId/:barId\");\n     * var rule = factory.fromUrlMatcher(urlMatcher, handler);\n     * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }\n     * var result = rule.handler(match); // '/home/123/456'\n     * ```\n     */\n    UrlRuleFactory.prototype.fromUrlMatcher = function (urlMatcher, handler) {\n        var _handler = handler;\n        if (predicates_1.isString(handler))\n            handler = this.router.urlMatcherFactory.compile(handler);\n        if (hof_1.is(urlMatcher_1.UrlMatcher)(handler))\n            _handler = function (match) { return handler.format(match); };\n        function matchUrlParamters(url) {\n            var params = urlMatcher.exec(url.path, url.search, url.hash);\n            return urlMatcher.validates(params) && params;\n        }\n        // Prioritize URLs, lowest to highest:\n        // - Some optional URL parameters, but none matched\n        // - No optional parameters in URL\n        // - Some optional parameters, some matched\n        // - Some optional parameters, all matched\n        function matchPriority(params) {\n            var optional = urlMatcher.parameters().filter(function (param) { return param.isOptional; });\n            if (!optional.length)\n                return 0.000001;\n            var matched = optional.filter(function (param) { return params[param.id]; });\n            return matched.length / optional.length;\n        }\n        var details = { urlMatcher: urlMatcher, matchPriority: matchPriority, type: 'URLMATCHER' };\n        return common_1.extend(new BaseUrlRule(matchUrlParamters, _handler), details);\n    };\n    /**\n     * A UrlRule which matches a state by its url\n     *\n     * #### Example:\n     * ```js\n     * var rule = factory.fromState($state.get('foo'), router);\n     * var match = rule.match('/foo/123/456'); // results in { fooId: '123', barId: '456' }\n     * var result = rule.handler(match);\n     * // Starts a transition to 'foo' with params: { fooId: '123', barId: '456' }\n     * ```\n     */\n    UrlRuleFactory.prototype.fromState = function (state, router) {\n        /**\n         * Handles match by transitioning to matched state\n         *\n         * First checks if the router should start a new transition.\n         * A new transition is not required if the current state's URL\n         * and the new URL are already identical\n         */\n        var handler = function (match) {\n            var $state = router.stateService;\n            var globals = router.globals;\n            if ($state.href(state, match) !== $state.href(globals.current, globals.params)) {\n                $state.transitionTo(state, match, { inherit: true, source: 'url' });\n            }\n        };\n        var details = { state: state, type: 'STATE' };\n        return common_1.extend(this.fromUrlMatcher(state.url, handler), details);\n    };\n    /**\n     * A UrlRule which matches based on a regular expression\n     *\n     * The `handler` may be either a [[UrlRuleHandlerFn]] or a string.\n     *\n     * ## Handler as a function\n     *\n     * If `handler` is a function, the function is invoked with:\n     *\n     * - regexp match array (from `regexp`)\n     * - url: the current Url ([[UrlParts]])\n     * - router: the router object ([[UIRouter]])\n     *\n     * #### Example:\n     * ```js\n     * var rule = factory.fromRegExp(/^\\/foo\\/(bar|baz)$/, match => \"/home/\" + match[1])\n     * var match = rule.match('/foo/bar'); // results in [ '/foo/bar', 'bar' ]\n     * var result = rule.handler(match); // '/home/bar'\n     * ```\n     *\n     * ## Handler as string\n     *\n     * If `handler` is a string, the url is *replaced by the string* when the Rule is invoked.\n     * The string is first interpolated using `string.replace()` style pattern.\n     *\n     * #### Example:\n     * ```js\n     * var rule = factory.fromRegExp(/^\\/foo\\/(bar|baz)$/, \"/home/$1\")\n     * var match = rule.match('/foo/bar'); // results in [ '/foo/bar', 'bar' ]\n     * var result = rule.handler(match); // '/home/bar'\n     * ```\n     */\n    UrlRuleFactory.prototype.fromRegExp = function (regexp, handler) {\n        if (regexp.global || regexp.sticky)\n            throw new Error('Rule RegExp must not be global or sticky');\n        /**\n         * If handler is a string, the url will be replaced by the string.\n         * If the string has any String.replace() style variables in it (like `$2`),\n         * they will be replaced by the captures from [[match]]\n         */\n        var redirectUrlTo = function (match) {\n            // Interpolates matched values into $1 $2, etc using a String.replace()-style pattern\n            return handler.replace(/\\$(\\$|\\d{1,2})/, function (m, what) {\n                return match[what === '$' ? 0 : Number(what)];\n            });\n        };\n        var _handler = predicates_1.isString(handler) ? redirectUrlTo : handler;\n        var matchParamsFromRegexp = function (url) {\n            return regexp.exec(url.path);\n        };\n        var details = { regexp: regexp, type: 'REGEXP' };\n        return common_1.extend(new BaseUrlRule(matchParamsFromRegexp, _handler), details);\n    };\n    UrlRuleFactory.isUrlRule = function (obj) {\n        return obj && ['type', 'match', 'handler'].every(function (key) { return predicates_1.isDefined(obj[key]); });\n    };\n    return UrlRuleFactory;\n}());\nexports.UrlRuleFactory = UrlRuleFactory;\n/**\n * A base rule which calls `match`\n *\n * The value from the `match` function is passed through to the `handler`.\n * @internalapi\n */\nvar BaseUrlRule = /** @class */ (function () {\n    function BaseUrlRule(match, handler) {\n        var _this = this;\n        this.match = match;\n        this.type = 'RAW';\n        this.matchPriority = function (match) { return 0 - _this.$id; };\n        this.handler = handler || common_1.identity;\n    }\n    return BaseUrlRule;\n}());\nexports.BaseUrlRule = BaseUrlRule;\n//# sourceMappingURL=urlRule.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3VybC91cmxSdWxlLmpzP2QxYWUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEBjb3JlYXBpXG4gKiBAbW9kdWxlIHVybFxuICovIC8qKiAqL1xudmFyIHVybE1hdGNoZXJfMSA9IHJlcXVpcmUoXCIuL3VybE1hdGNoZXJcIik7XG52YXIgcHJlZGljYXRlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9wcmVkaWNhdGVzXCIpO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb21tb25cIik7XG52YXIgaG9mXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2hvZlwiKTtcbi8qKlxuICogQ3JlYXRlcyBhIFtbVXJsUnVsZV1dXG4gKlxuICogQ3JlYXRlcyBhIFtbVXJsUnVsZV1dIGZyb20gYTpcbiAqXG4gKiAtIGBzdHJpbmdgXG4gKiAtIFtbVXJsTWF0Y2hlcl1dXG4gKiAtIGBSZWdFeHBgXG4gKiAtIFtbU3RhdGVPYmplY3RdXVxuICogQGludGVybmFsYXBpXG4gKi9cbnZhciBVcmxSdWxlRmFjdG9yeSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBVcmxSdWxlRmFjdG9yeShyb3V0ZXIpIHtcbiAgICAgICAgdGhpcy5yb3V0ZXIgPSByb3V0ZXI7XG4gICAgfVxuICAgIFVybFJ1bGVGYWN0b3J5LnByb3RvdHlwZS5jb21waWxlID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgICByZXR1cm4gdGhpcy5yb3V0ZXIudXJsTWF0Y2hlckZhY3RvcnkuY29tcGlsZShzdHIpO1xuICAgIH07XG4gICAgVXJsUnVsZUZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uICh3aGF0LCBoYW5kbGVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBtYWtlUnVsZSA9IGhvZl8xLnBhdHRlcm4oW1xuICAgICAgICAgICAgW3ByZWRpY2F0ZXNfMS5pc1N0cmluZywgZnVuY3Rpb24gKF93aGF0KSB7IHJldHVybiBtYWtlUnVsZShfdGhpcy5jb21waWxlKF93aGF0KSk7IH1dLFxuICAgICAgICAgICAgW2hvZl8xLmlzKHVybE1hdGNoZXJfMS5VcmxNYXRjaGVyKSwgZnVuY3Rpb24gKF93aGF0KSB7IHJldHVybiBfdGhpcy5mcm9tVXJsTWF0Y2hlcihfd2hhdCwgaGFuZGxlcik7IH1dLFxuICAgICAgICAgICAgW3ByZWRpY2F0ZXNfMS5pc1N0YXRlLCBmdW5jdGlvbiAoX3doYXQpIHsgcmV0dXJuIF90aGlzLmZyb21TdGF0ZShfd2hhdCwgX3RoaXMucm91dGVyKTsgfV0sXG4gICAgICAgICAgICBbaG9mXzEuaXMoUmVnRXhwKSwgZnVuY3Rpb24gKF93aGF0KSB7IHJldHVybiBfdGhpcy5mcm9tUmVnRXhwKF93aGF0LCBoYW5kbGVyKTsgfV0sXG4gICAgICAgICAgICBbcHJlZGljYXRlc18xLmlzRnVuY3Rpb24sIGZ1bmN0aW9uIChfd2hhdCkgeyByZXR1cm4gbmV3IEJhc2VVcmxSdWxlKF93aGF0LCBoYW5kbGVyKTsgfV0sXG4gICAgICAgIF0pO1xuICAgICAgICB2YXIgcnVsZSA9IG1ha2VSdWxlKHdoYXQpO1xuICAgICAgICBpZiAoIXJ1bGUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkICd3aGF0JyBpbiB3aGVuKClcIik7XG4gICAgICAgIHJldHVybiBydWxlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBVcmxSdWxlIHdoaWNoIG1hdGNoZXMgYmFzZWQgb24gYSBVcmxNYXRjaGVyXG4gICAgICpcbiAgICAgKiBUaGUgYGhhbmRsZXJgIG1heSBiZSBlaXRoZXIgYSBgc3RyaW5nYCwgYSBbW1VybFJ1bGVIYW5kbGVyRm5dXSBvciBhbm90aGVyIFtbVXJsTWF0Y2hlcl1dXG4gICAgICpcbiAgICAgKiAjIyBIYW5kbGVyIGFzIGEgZnVuY3Rpb25cbiAgICAgKlxuICAgICAqIElmIGBoYW5kbGVyYCBpcyBhIGZ1bmN0aW9uLCB0aGUgZnVuY3Rpb24gaXMgaW52b2tlZCB3aXRoOlxuICAgICAqXG4gICAgICogLSBtYXRjaGVkIHBhcmFtZXRlciB2YWx1ZXMgKFtbUmF3UGFyYW1zXV0gZnJvbSBbW1VybE1hdGNoZXIuZXhlY11dKVxuICAgICAqIC0gdXJsOiB0aGUgY3VycmVudCBVcmwgKFtbVXJsUGFydHNdXSlcbiAgICAgKiAtIHJvdXRlcjogdGhlIHJvdXRlciBvYmplY3QgKFtbVUlSb3V0ZXJdXSlcbiAgICAgKlxuICAgICAqICMjIyMgRXhhbXBsZTpcbiAgICAgKiBgYGBqc1xuICAgICAqIHZhciB1cmxNYXRjaGVyID0gJHVtZi5jb21waWxlKFwiL2Zvby86Zm9vSWQvOmJhcklkXCIpO1xuICAgICAqIHZhciBydWxlID0gZmFjdG9yeS5mcm9tVXJsTWF0Y2hlcih1cmxNYXRjaGVyLCBtYXRjaCA9PiBcIi9ob21lL1wiICsgbWF0Y2guZm9vSWQgKyBcIi9cIiArIG1hdGNoLmJhcklkKTtcbiAgICAgKiB2YXIgbWF0Y2ggPSBydWxlLm1hdGNoKCcvZm9vLzEyMy80NTYnKTsgLy8gcmVzdWx0cyBpbiB7IGZvb0lkOiAnMTIzJywgYmFySWQ6ICc0NTYnIH1cbiAgICAgKiB2YXIgcmVzdWx0ID0gcnVsZS5oYW5kbGVyKG1hdGNoKTsgLy8gJy9ob21lLzEyMy80NTYnXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiAjIyBIYW5kbGVyIGFzIFVybE1hdGNoZXJcbiAgICAgKlxuICAgICAqIElmIGBoYW5kbGVyYCBpcyBhIFVybE1hdGNoZXIsIHRoZSBoYW5kbGVyIG1hdGNoZXIgaXMgdXNlZCB0byBjcmVhdGUgdGhlIG5ldyB1cmwuXG4gICAgICogVGhlIGBoYW5kbGVyYCBVcmxNYXRjaGVyIGlzIGZvcm1hdHRlZCB1c2luZyB0aGUgbWF0Y2hlZCBwYXJhbSBmcm9tIHRoZSBmaXJzdCBtYXRjaGVyLlxuICAgICAqIFRoZSB1cmwgaXMgcmVwbGFjZWQgd2l0aCB0aGUgcmVzdWx0LlxuICAgICAqXG4gICAgICogIyMjIyBFeGFtcGxlOlxuICAgICAqIGBgYGpzXG4gICAgICogdmFyIHVybE1hdGNoZXIgPSAkdW1mLmNvbXBpbGUoXCIvZm9vLzpmb29JZC86YmFySWRcIik7XG4gICAgICogdmFyIGhhbmRsZXIgPSAkdW1mLmNvbXBpbGUoXCIvaG9tZS86Zm9vSWQvOmJhcklkXCIpO1xuICAgICAqIHZhciBydWxlID0gZmFjdG9yeS5mcm9tVXJsTWF0Y2hlcih1cmxNYXRjaGVyLCBoYW5kbGVyKTtcbiAgICAgKiB2YXIgbWF0Y2ggPSBydWxlLm1hdGNoKCcvZm9vLzEyMy80NTYnKTsgLy8gcmVzdWx0cyBpbiB7IGZvb0lkOiAnMTIzJywgYmFySWQ6ICc0NTYnIH1cbiAgICAgKiB2YXIgcmVzdWx0ID0gcnVsZS5oYW5kbGVyKG1hdGNoKTsgLy8gJy9ob21lLzEyMy80NTYnXG4gICAgICogYGBgXG4gICAgICovXG4gICAgVXJsUnVsZUZhY3RvcnkucHJvdG90eXBlLmZyb21VcmxNYXRjaGVyID0gZnVuY3Rpb24gKHVybE1hdGNoZXIsIGhhbmRsZXIpIHtcbiAgICAgICAgdmFyIF9oYW5kbGVyID0gaGFuZGxlcjtcbiAgICAgICAgaWYgKHByZWRpY2F0ZXNfMS5pc1N0cmluZyhoYW5kbGVyKSlcbiAgICAgICAgICAgIGhhbmRsZXIgPSB0aGlzLnJvdXRlci51cmxNYXRjaGVyRmFjdG9yeS5jb21waWxlKGhhbmRsZXIpO1xuICAgICAgICBpZiAoaG9mXzEuaXModXJsTWF0Y2hlcl8xLlVybE1hdGNoZXIpKGhhbmRsZXIpKVxuICAgICAgICAgICAgX2hhbmRsZXIgPSBmdW5jdGlvbiAobWF0Y2gpIHsgcmV0dXJuIGhhbmRsZXIuZm9ybWF0KG1hdGNoKTsgfTtcbiAgICAgICAgZnVuY3Rpb24gbWF0Y2hVcmxQYXJhbXRlcnModXJsKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1zID0gdXJsTWF0Y2hlci5leGVjKHVybC5wYXRoLCB1cmwuc2VhcmNoLCB1cmwuaGFzaCk7XG4gICAgICAgICAgICByZXR1cm4gdXJsTWF0Y2hlci52YWxpZGF0ZXMocGFyYW1zKSAmJiBwYXJhbXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJpb3JpdGl6ZSBVUkxzLCBsb3dlc3QgdG8gaGlnaGVzdDpcbiAgICAgICAgLy8gLSBTb21lIG9wdGlvbmFsIFVSTCBwYXJhbWV0ZXJzLCBidXQgbm9uZSBtYXRjaGVkXG4gICAgICAgIC8vIC0gTm8gb3B0aW9uYWwgcGFyYW1ldGVycyBpbiBVUkxcbiAgICAgICAgLy8gLSBTb21lIG9wdGlvbmFsIHBhcmFtZXRlcnMsIHNvbWUgbWF0Y2hlZFxuICAgICAgICAvLyAtIFNvbWUgb3B0aW9uYWwgcGFyYW1ldGVycywgYWxsIG1hdGNoZWRcbiAgICAgICAgZnVuY3Rpb24gbWF0Y2hQcmlvcml0eShwYXJhbXMpIHtcbiAgICAgICAgICAgIHZhciBvcHRpb25hbCA9IHVybE1hdGNoZXIucGFyYW1ldGVycygpLmZpbHRlcihmdW5jdGlvbiAocGFyYW0pIHsgcmV0dXJuIHBhcmFtLmlzT3B0aW9uYWw7IH0pO1xuICAgICAgICAgICAgaWYgKCFvcHRpb25hbC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuIDAuMDAwMDAxO1xuICAgICAgICAgICAgdmFyIG1hdGNoZWQgPSBvcHRpb25hbC5maWx0ZXIoZnVuY3Rpb24gKHBhcmFtKSB7IHJldHVybiBwYXJhbXNbcGFyYW0uaWRdOyB9KTtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaGVkLmxlbmd0aCAvIG9wdGlvbmFsLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGV0YWlscyA9IHsgdXJsTWF0Y2hlcjogdXJsTWF0Y2hlciwgbWF0Y2hQcmlvcml0eTogbWF0Y2hQcmlvcml0eSwgdHlwZTogJ1VSTE1BVENIRVInIH07XG4gICAgICAgIHJldHVybiBjb21tb25fMS5leHRlbmQobmV3IEJhc2VVcmxSdWxlKG1hdGNoVXJsUGFyYW10ZXJzLCBfaGFuZGxlciksIGRldGFpbHMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQSBVcmxSdWxlIHdoaWNoIG1hdGNoZXMgYSBzdGF0ZSBieSBpdHMgdXJsXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGU6XG4gICAgICogYGBganNcbiAgICAgKiB2YXIgcnVsZSA9IGZhY3RvcnkuZnJvbVN0YXRlKCRzdGF0ZS5nZXQoJ2ZvbycpLCByb3V0ZXIpO1xuICAgICAqIHZhciBtYXRjaCA9IHJ1bGUubWF0Y2goJy9mb28vMTIzLzQ1NicpOyAvLyByZXN1bHRzIGluIHsgZm9vSWQ6ICcxMjMnLCBiYXJJZDogJzQ1NicgfVxuICAgICAqIHZhciByZXN1bHQgPSBydWxlLmhhbmRsZXIobWF0Y2gpO1xuICAgICAqIC8vIFN0YXJ0cyBhIHRyYW5zaXRpb24gdG8gJ2Zvbycgd2l0aCBwYXJhbXM6IHsgZm9vSWQ6ICcxMjMnLCBiYXJJZDogJzQ1NicgfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIFVybFJ1bGVGYWN0b3J5LnByb3RvdHlwZS5mcm9tU3RhdGUgPSBmdW5jdGlvbiAoc3RhdGUsIHJvdXRlcikge1xuICAgICAgICAvKipcbiAgICAgICAgICogSGFuZGxlcyBtYXRjaCBieSB0cmFuc2l0aW9uaW5nIHRvIG1hdGNoZWQgc3RhdGVcbiAgICAgICAgICpcbiAgICAgICAgICogRmlyc3QgY2hlY2tzIGlmIHRoZSByb3V0ZXIgc2hvdWxkIHN0YXJ0IGEgbmV3IHRyYW5zaXRpb24uXG4gICAgICAgICAqIEEgbmV3IHRyYW5zaXRpb24gaXMgbm90IHJlcXVpcmVkIGlmIHRoZSBjdXJyZW50IHN0YXRlJ3MgVVJMXG4gICAgICAgICAqIGFuZCB0aGUgbmV3IFVSTCBhcmUgYWxyZWFkeSBpZGVudGljYWxcbiAgICAgICAgICovXG4gICAgICAgIHZhciBoYW5kbGVyID0gZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgICB2YXIgJHN0YXRlID0gcm91dGVyLnN0YXRlU2VydmljZTtcbiAgICAgICAgICAgIHZhciBnbG9iYWxzID0gcm91dGVyLmdsb2JhbHM7XG4gICAgICAgICAgICBpZiAoJHN0YXRlLmhyZWYoc3RhdGUsIG1hdGNoKSAhPT0gJHN0YXRlLmhyZWYoZ2xvYmFscy5jdXJyZW50LCBnbG9iYWxzLnBhcmFtcykpIHtcbiAgICAgICAgICAgICAgICAkc3RhdGUudHJhbnNpdGlvblRvKHN0YXRlLCBtYXRjaCwgeyBpbmhlcml0OiB0cnVlLCBzb3VyY2U6ICd1cmwnIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgZGV0YWlscyA9IHsgc3RhdGU6IHN0YXRlLCB0eXBlOiAnU1RBVEUnIH07XG4gICAgICAgIHJldHVybiBjb21tb25fMS5leHRlbmQodGhpcy5mcm9tVXJsTWF0Y2hlcihzdGF0ZS51cmwsIGhhbmRsZXIpLCBkZXRhaWxzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEEgVXJsUnVsZSB3aGljaCBtYXRjaGVzIGJhc2VkIG9uIGEgcmVndWxhciBleHByZXNzaW9uXG4gICAgICpcbiAgICAgKiBUaGUgYGhhbmRsZXJgIG1heSBiZSBlaXRoZXIgYSBbW1VybFJ1bGVIYW5kbGVyRm5dXSBvciBhIHN0cmluZy5cbiAgICAgKlxuICAgICAqICMjIEhhbmRsZXIgYXMgYSBmdW5jdGlvblxuICAgICAqXG4gICAgICogSWYgYGhhbmRsZXJgIGlzIGEgZnVuY3Rpb24sIHRoZSBmdW5jdGlvbiBpcyBpbnZva2VkIHdpdGg6XG4gICAgICpcbiAgICAgKiAtIHJlZ2V4cCBtYXRjaCBhcnJheSAoZnJvbSBgcmVnZXhwYClcbiAgICAgKiAtIHVybDogdGhlIGN1cnJlbnQgVXJsIChbW1VybFBhcnRzXV0pXG4gICAgICogLSByb3V0ZXI6IHRoZSByb3V0ZXIgb2JqZWN0IChbW1VJUm91dGVyXV0pXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGU6XG4gICAgICogYGBganNcbiAgICAgKiB2YXIgcnVsZSA9IGZhY3RvcnkuZnJvbVJlZ0V4cCgvXlxcL2Zvb1xcLyhiYXJ8YmF6KSQvLCBtYXRjaCA9PiBcIi9ob21lL1wiICsgbWF0Y2hbMV0pXG4gICAgICogdmFyIG1hdGNoID0gcnVsZS5tYXRjaCgnL2Zvby9iYXInKTsgLy8gcmVzdWx0cyBpbiBbICcvZm9vL2JhcicsICdiYXInIF1cbiAgICAgKiB2YXIgcmVzdWx0ID0gcnVsZS5oYW5kbGVyKG1hdGNoKTsgLy8gJy9ob21lL2JhcidcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqICMjIEhhbmRsZXIgYXMgc3RyaW5nXG4gICAgICpcbiAgICAgKiBJZiBgaGFuZGxlcmAgaXMgYSBzdHJpbmcsIHRoZSB1cmwgaXMgKnJlcGxhY2VkIGJ5IHRoZSBzdHJpbmcqIHdoZW4gdGhlIFJ1bGUgaXMgaW52b2tlZC5cbiAgICAgKiBUaGUgc3RyaW5nIGlzIGZpcnN0IGludGVycG9sYXRlZCB1c2luZyBgc3RyaW5nLnJlcGxhY2UoKWAgc3R5bGUgcGF0dGVybi5cbiAgICAgKlxuICAgICAqICMjIyMgRXhhbXBsZTpcbiAgICAgKiBgYGBqc1xuICAgICAqIHZhciBydWxlID0gZmFjdG9yeS5mcm9tUmVnRXhwKC9eXFwvZm9vXFwvKGJhcnxiYXopJC8sIFwiL2hvbWUvJDFcIilcbiAgICAgKiB2YXIgbWF0Y2ggPSBydWxlLm1hdGNoKCcvZm9vL2JhcicpOyAvLyByZXN1bHRzIGluIFsgJy9mb28vYmFyJywgJ2JhcicgXVxuICAgICAqIHZhciByZXN1bHQgPSBydWxlLmhhbmRsZXIobWF0Y2gpOyAvLyAnL2hvbWUvYmFyJ1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIFVybFJ1bGVGYWN0b3J5LnByb3RvdHlwZS5mcm9tUmVnRXhwID0gZnVuY3Rpb24gKHJlZ2V4cCwgaGFuZGxlcikge1xuICAgICAgICBpZiAocmVnZXhwLmdsb2JhbCB8fCByZWdleHAuc3RpY2t5KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSdWxlIFJlZ0V4cCBtdXN0IG5vdCBiZSBnbG9iYWwgb3Igc3RpY2t5Jyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBoYW5kbGVyIGlzIGEgc3RyaW5nLCB0aGUgdXJsIHdpbGwgYmUgcmVwbGFjZWQgYnkgdGhlIHN0cmluZy5cbiAgICAgICAgICogSWYgdGhlIHN0cmluZyBoYXMgYW55IFN0cmluZy5yZXBsYWNlKCkgc3R5bGUgdmFyaWFibGVzIGluIGl0IChsaWtlIGAkMmApLFxuICAgICAgICAgKiB0aGV5IHdpbGwgYmUgcmVwbGFjZWQgYnkgdGhlIGNhcHR1cmVzIGZyb20gW1ttYXRjaF1dXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgcmVkaXJlY3RVcmxUbyA9IGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICAgICAgLy8gSW50ZXJwb2xhdGVzIG1hdGNoZWQgdmFsdWVzIGludG8gJDEgJDIsIGV0YyB1c2luZyBhIFN0cmluZy5yZXBsYWNlKCktc3R5bGUgcGF0dGVyblxuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXIucmVwbGFjZSgvXFwkKFxcJHxcXGR7MSwyfSkvLCBmdW5jdGlvbiAobSwgd2hhdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaFt3aGF0ID09PSAnJCcgPyAwIDogTnVtYmVyKHdoYXQpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgX2hhbmRsZXIgPSBwcmVkaWNhdGVzXzEuaXNTdHJpbmcoaGFuZGxlcikgPyByZWRpcmVjdFVybFRvIDogaGFuZGxlcjtcbiAgICAgICAgdmFyIG1hdGNoUGFyYW1zRnJvbVJlZ2V4cCA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICAgICAgICAgIHJldHVybiByZWdleHAuZXhlYyh1cmwucGF0aCk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBkZXRhaWxzID0geyByZWdleHA6IHJlZ2V4cCwgdHlwZTogJ1JFR0VYUCcgfTtcbiAgICAgICAgcmV0dXJuIGNvbW1vbl8xLmV4dGVuZChuZXcgQmFzZVVybFJ1bGUobWF0Y2hQYXJhbXNGcm9tUmVnZXhwLCBfaGFuZGxlciksIGRldGFpbHMpO1xuICAgIH07XG4gICAgVXJsUnVsZUZhY3RvcnkuaXNVcmxSdWxlID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICByZXR1cm4gb2JqICYmIFsndHlwZScsICdtYXRjaCcsICdoYW5kbGVyJ10uZXZlcnkoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gcHJlZGljYXRlc18xLmlzRGVmaW5lZChvYmpba2V5XSk7IH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFVybFJ1bGVGYWN0b3J5O1xufSgpKTtcbmV4cG9ydHMuVXJsUnVsZUZhY3RvcnkgPSBVcmxSdWxlRmFjdG9yeTtcbi8qKlxuICogQSBiYXNlIHJ1bGUgd2hpY2ggY2FsbHMgYG1hdGNoYFxuICpcbiAqIFRoZSB2YWx1ZSBmcm9tIHRoZSBgbWF0Y2hgIGZ1bmN0aW9uIGlzIHBhc3NlZCB0aHJvdWdoIHRvIHRoZSBgaGFuZGxlcmAuXG4gKiBAaW50ZXJuYWxhcGlcbiAqL1xudmFyIEJhc2VVcmxSdWxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJhc2VVcmxSdWxlKG1hdGNoLCBoYW5kbGVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMubWF0Y2ggPSBtYXRjaDtcbiAgICAgICAgdGhpcy50eXBlID0gJ1JBVyc7XG4gICAgICAgIHRoaXMubWF0Y2hQcmlvcml0eSA9IGZ1bmN0aW9uIChtYXRjaCkgeyByZXR1cm4gMCAtIF90aGlzLiRpZDsgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlciB8fCBjb21tb25fMS5pZGVudGl0eTtcbiAgICB9XG4gICAgcmV0dXJuIEJhc2VVcmxSdWxlO1xufSgpKTtcbmV4cG9ydHMuQmFzZVVybFJ1bGUgPSBCYXNlVXJsUnVsZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVybFJ1bGUuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3VybC91cmxSdWxlLmpzXG4vLyBtb2R1bGUgaWQgPSA4MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///82\n")},function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\n/**\n * @coreapi\n * @module view\n */ /** for typedoc */\nvar common_1 = __webpack_require__(0);\nvar hof_1 = __webpack_require__(2);\nvar predicates_1 = __webpack_require__(1);\nvar trace_1 = __webpack_require__(8);\n/**\n * The View service\n *\n * This service pairs existing `ui-view` components (which live in the DOM)\n * with view configs (from the state declaration objects: [[StateDeclaration.views]]).\n *\n * - After a successful Transition, the views from the newly entered states are activated via [[activateViewConfig]].\n *   The views from exited states are deactivated via [[deactivateViewConfig]].\n *   (See: the [[registerActivateViews]] Transition Hook)\n *\n * - As `ui-view` components pop in and out of existence, they register themselves using [[registerUIView]].\n *\n * - When the [[sync]] function is called, the registered `ui-view`(s) ([[ActiveUIView]])\n * are configured with the matching [[ViewConfig]](s)\n *\n */\nvar ViewService = /** @class */ (function () {\n    function ViewService() {\n        var _this = this;\n        this._uiViews = [];\n        this._viewConfigs = [];\n        this._viewConfigFactories = {};\n        this._listeners = [];\n        this._pluginapi = {\n            _rootViewContext: this._rootViewContext.bind(this),\n            _viewConfigFactory: this._viewConfigFactory.bind(this),\n            _registeredUIViews: function () { return _this._uiViews; },\n            _activeViewConfigs: function () { return _this._viewConfigs; },\n            _onSync: function (listener) {\n                _this._listeners.push(listener);\n                return function () { return common_1.removeFrom(_this._listeners, listener); };\n            },\n        };\n    }\n    /**\n     * Normalizes a view\'s name from a state.views configuration block.\n     *\n     * This should be used by a framework implementation to calculate the values for\n     * [[_ViewDeclaration.$uiViewName]] and [[_ViewDeclaration.$uiViewContextAnchor]].\n     *\n     * @param context the context object (state declaration) that the view belongs to\n     * @param rawViewName the name of the view, as declared in the [[StateDeclaration.views]]\n     *\n     * @returns the normalized uiViewName and uiViewContextAnchor that the view targets\n     */\n    ViewService.normalizeUIViewTarget = function (context, rawViewName) {\n        if (rawViewName === void 0) { rawViewName = \'\'; }\n        // TODO: Validate incoming view name with a regexp to allow:\n        // ex: "view.name@foo.bar" , "^.^.view.name" , "view.name@^.^" , "" ,\n        // "@" , "$default@^" , "!$default.$default" , "!foo.bar"\n        var viewAtContext = rawViewName.split(\'@\');\n        var uiViewName = viewAtContext[0] || \'$default\'; // default to unnamed view\n        var uiViewContextAnchor = predicates_1.isString(viewAtContext[1]) ? viewAtContext[1] : \'^\'; // default to parent context\n        // Handle relative view-name sugar syntax.\n        // Matches rawViewName "^.^.^.foo.bar" into array: ["^.^.^.foo.bar", "^.^.^", "foo.bar"],\n        var relativeViewNameSugar = /^(\\^(?:\\.\\^)*)\\.(.*$)/.exec(uiViewName);\n        if (relativeViewNameSugar) {\n            // Clobbers existing contextAnchor (rawViewName validation will fix this)\n            uiViewContextAnchor = relativeViewNameSugar[1]; // set anchor to "^.^.^"\n            uiViewName = relativeViewNameSugar[2]; // set view-name to "foo.bar"\n        }\n        if (uiViewName.charAt(0) === \'!\') {\n            uiViewName = uiViewName.substr(1);\n            uiViewContextAnchor = \'\'; // target absolutely from root\n        }\n        // handle parent relative targeting "^.^.^"\n        var relativeMatch = /^(\\^(?:\\.\\^)*)$/;\n        if (relativeMatch.exec(uiViewContextAnchor)) {\n            var anchorState = uiViewContextAnchor.split(\'.\')\n                .reduce((function (anchor, x) { return anchor.parent; }), context);\n            uiViewContextAnchor = anchorState.name;\n        }\n        else if (uiViewContextAnchor === \'.\') {\n            uiViewContextAnchor = context.name;\n        }\n        return { uiViewName: uiViewName, uiViewContextAnchor: uiViewContextAnchor };\n    };\n    ViewService.prototype._rootViewContext = function (context) {\n        return this._rootContext = context || this._rootContext;\n    };\n    ViewService.prototype._viewConfigFactory = function (viewType, factory) {\n        this._viewConfigFactories[viewType] = factory;\n    };\n    ViewService.prototype.createViewConfig = function (path, decl) {\n        var cfgFactory = this._viewConfigFactories[decl.$type];\n        if (!cfgFactory)\n            throw new Error(\'ViewService: No view config factory registered for type \' + decl.$type);\n        var cfgs = cfgFactory(path, decl);\n        return predicates_1.isArray(cfgs) ? cfgs : [cfgs];\n    };\n    /**\n     * Deactivates a ViewConfig.\n     *\n     * This function deactivates a `ViewConfig`.\n     * After calling [[sync]], it will un-pair from any `ui-view` with which it is currently paired.\n     *\n     * @param viewConfig The ViewConfig view to deregister.\n     */\n    ViewService.prototype.deactivateViewConfig = function (viewConfig) {\n        trace_1.trace.traceViewServiceEvent(\'<- Removing\', viewConfig);\n        common_1.removeFrom(this._viewConfigs, viewConfig);\n    };\n    ViewService.prototype.activateViewConfig = function (viewConfig) {\n        trace_1.trace.traceViewServiceEvent(\'-> Registering\', viewConfig);\n        this._viewConfigs.push(viewConfig);\n    };\n    ViewService.prototype.sync = function () {\n        var _this = this;\n        var uiViewsByFqn = this._uiViews.map(function (uiv) { return [uiv.fqn, uiv]; }).reduce(common_1.applyPairs, {});\n        // Return a weighted depth value for a uiView.\n        // The depth is the nesting depth of ui-views (based on FQN; times 10,000)\n        // plus the depth of the state that is populating the uiView\n        function uiViewDepth(uiView) {\n            var stateDepth = function (context) {\n                return context && context.parent ? stateDepth(context.parent) + 1 : 1;\n            };\n            return (uiView.fqn.split(\'.\').length * 10000) + stateDepth(uiView.creationContext);\n        }\n        // Return the ViewConfig\'s context\'s depth in the context tree.\n        function viewConfigDepth(config) {\n            var context = config.viewDecl.$context, count = 0;\n            while (++count && context.parent)\n                context = context.parent;\n            return count;\n        }\n        // Given a depth function, returns a compare function which can return either ascending or descending order\n        var depthCompare = hof_1.curry(function (depthFn, posNeg, left, right) { return posNeg * (depthFn(left) - depthFn(right)); });\n        var matchingConfigPair = function (uiView) {\n            var matchingConfigs = _this._viewConfigs.filter(ViewService.matches(uiViewsByFqn, uiView));\n            if (matchingConfigs.length > 1) {\n                // This is OK.  Child states can target a ui-view that the parent state also targets (the child wins)\n                // Sort by depth and return the match from the deepest child\n                // console.log(`Multiple matching view configs for ${uiView.fqn}`, matchingConfigs);\n                matchingConfigs.sort(depthCompare(viewConfigDepth, -1)); // descending\n            }\n            return { uiView: uiView, viewConfig: matchingConfigs[0] };\n        };\n        var configureUIView = function (tuple) {\n            // If a parent ui-view is reconfigured, it could destroy child ui-views.\n            // Before configuring a child ui-view, make sure it\'s still in the active uiViews array.\n            if (_this._uiViews.indexOf(tuple.uiView) !== -1)\n                tuple.uiView.configUpdated(tuple.viewConfig);\n        };\n        // Sort views by FQN and state depth. Process uiviews nearest the root first.\n        var uiViewTuples = this._uiViews.sort(depthCompare(uiViewDepth, 1)).map(matchingConfigPair);\n        var matchedViewConfigs = uiViewTuples.map(function (tuple) { return tuple.viewConfig; });\n        var unmatchedConfigTuples = this._viewConfigs\n            .filter(function (config) { return !common_1.inArray(matchedViewConfigs, config); })\n            .map(function (viewConfig) { return ({ uiView: undefined, viewConfig: viewConfig }); });\n        uiViewTuples.forEach(configureUIView);\n        var allTuples = uiViewTuples.concat(unmatchedConfigTuples);\n        this._listeners.forEach(function (cb) { return cb(allTuples); });\n        trace_1.trace.traceViewSync(allTuples);\n    };\n    /**\n     * Registers a `ui-view` component\n     *\n     * When a `ui-view` component is created, it uses this method to register itself.\n     * After registration the [[sync]] method is used to ensure all `ui-view` are configured with the proper [[ViewConfig]].\n     *\n     * Note: the `ui-view` component uses the `ViewConfig` to determine what view should be loaded inside the `ui-view`,\n     * and what the view\'s state context is.\n     *\n     * Note: There is no corresponding `deregisterUIView`.\n     *       A `ui-view` should hang on to the return value of `registerUIView` and invoke it to deregister itself.\n     *\n     * @param uiView The metadata for a UIView\n     * @return a de-registration function used when the view is destroyed.\n     */\n    ViewService.prototype.registerUIView = function (uiView) {\n        trace_1.trace.traceViewServiceUIViewEvent(\'-> Registering\', uiView);\n        var uiViews = this._uiViews;\n        var fqnAndTypeMatches = function (uiv) { return uiv.fqn === uiView.fqn && uiv.$type === uiView.$type; };\n        if (uiViews.filter(fqnAndTypeMatches).length)\n            trace_1.trace.traceViewServiceUIViewEvent(\'!!!! duplicate uiView named:\', uiView);\n        uiViews.push(uiView);\n        this.sync();\n        return function () {\n            var idx = uiViews.indexOf(uiView);\n            if (idx === -1) {\n                trace_1.trace.traceViewServiceUIViewEvent(\'Tried removing non-registered uiView\', uiView);\n                return;\n            }\n            trace_1.trace.traceViewServiceUIViewEvent(\'<- Deregistering\', uiView);\n            common_1.removeFrom(uiViews)(uiView);\n        };\n    };\n    /**\n     * Returns the list of views currently available on the page, by fully-qualified name.\n     *\n     * @return {Array} Returns an array of fully-qualified view names.\n     */\n    ViewService.prototype.available = function () {\n        return this._uiViews.map(hof_1.prop(\'fqn\'));\n    };\n    /**\n     * Returns the list of views on the page containing loaded content.\n     *\n     * @return {Array} Returns an array of fully-qualified view names.\n     */\n    ViewService.prototype.active = function () {\n        return this._uiViews.filter(hof_1.prop(\'$config\')).map(hof_1.prop(\'name\'));\n    };\n    /**\n     * Given a ui-view and a ViewConfig, determines if they "match".\n     *\n     * A ui-view has a fully qualified name (fqn) and a context object.  The fqn is built from its overall location in\n     * the DOM, describing its nesting relationship to any parent ui-view tags it is nested inside of.\n     *\n     * A ViewConfig has a target ui-view name and a context anchor.  The ui-view name can be a simple name, or\n     * can be a segmented ui-view path, describing a portion of a ui-view fqn.\n     *\n     * In order for a ui-view to match ViewConfig, ui-view\'s $type must match the ViewConfig\'s $type\n     *\n     * If the ViewConfig\'s target ui-view name is a simple name (no dots), then a ui-view matches if:\n     * - the ui-view\'s name matches the ViewConfig\'s target name\n     * - the ui-view\'s context matches the ViewConfig\'s anchor\n     *\n     * If the ViewConfig\'s target ui-view name is a segmented name (with dots), then a ui-view matches if:\n     * - There exists a parent ui-view where:\n     *    - the parent ui-view\'s name matches the first segment (index 0) of the ViewConfig\'s target name\n     *    - the parent ui-view\'s context matches the ViewConfig\'s anchor\n     * - And the remaining segments (index 1..n) of the ViewConfig\'s target name match the tail of the ui-view\'s fqn\n     *\n     * Example:\n     *\n     * DOM:\n     * <ui-view>                        \x3c!-- created in the root context (name: "") --\x3e\n     *   <ui-view name="foo">                \x3c!-- created in the context named: "A"      --\x3e\n     *     <ui-view>                    \x3c!-- created in the context named: "A.B"    --\x3e\n     *       <ui-view name="bar">            \x3c!-- created in the context named: "A.B.C"  --\x3e\n     *       </ui-view>\n     *     </ui-view>\n     *   </ui-view>\n     * </ui-view>\n     *\n     * uiViews: [\n     *  { fqn: "$default",                  creationContext: { name: "" } },\n     *  { fqn: "$default.foo",              creationContext: { name: "A" } },\n     *  { fqn: "$default.foo.$default",     creationContext: { name: "A.B" } }\n     *  { fqn: "$default.foo.$default.bar", creationContext: { name: "A.B.C" } }\n     * ]\n     *\n     * These four view configs all match the ui-view with the fqn: "$default.foo.$default.bar":\n     *\n     * - ViewConfig1: { uiViewName: "bar",                       uiViewContextAnchor: "A.B.C" }\n     * - ViewConfig2: { uiViewName: "$default.bar",              uiViewContextAnchor: "A.B" }\n     * - ViewConfig3: { uiViewName: "foo.$default.bar",          uiViewContextAnchor: "A" }\n     * - ViewConfig4: { uiViewName: "$default.foo.$default.bar", uiViewContextAnchor: "" }\n     *\n     * Using ViewConfig3 as an example, it matches the ui-view with fqn "$default.foo.$default.bar" because:\n     * - The ViewConfig\'s segmented target name is: [ "foo", "$default", "bar" ]\n     * - There exists a parent ui-view (which has fqn: "$default.foo") where:\n     *    - the parent ui-view\'s name "foo" matches the first segment "foo" of the ViewConfig\'s target name\n     *    - the parent ui-view\'s context "A" matches the ViewConfig\'s anchor context "A"\n     * - And the remaining segments [ "$default", "bar" ].join("."_ of the ViewConfig\'s target name match\n     *   the tail of the ui-view\'s fqn "default.bar"\n     *\n     * @internalapi\n     */\n    ViewService.matches = function (uiViewsByFqn, uiView) { return function (viewConfig) {\n        // Don\'t supply an ng1 ui-view with an ng2 ViewConfig, etc\n        if (uiView.$type !== viewConfig.viewDecl.$type)\n            return false;\n        // Split names apart from both viewConfig and uiView into segments\n        var vc = viewConfig.viewDecl;\n        var vcSegments = vc.$uiViewName.split(\'.\');\n        var uivSegments = uiView.fqn.split(\'.\');\n        // Check if the tails of the segment arrays match. ex, these arrays\' tails match:\n        // vc: ["foo", "bar"], uiv fqn: ["$default", "foo", "bar"]\n        if (!common_1.equals(vcSegments, uivSegments.slice(0 - vcSegments.length)))\n            return false;\n        // Now check if the fqn ending at the first segment of the viewConfig matches the context:\n        // ["$default", "foo"].join(".") == "$default.foo", does the ui-view $default.foo context match?\n        var negOffset = (1 - vcSegments.length) || undefined;\n        var fqnToFirstSegment = uivSegments.slice(0, negOffset).join(\'.\');\n        var uiViewContext = uiViewsByFqn[fqnToFirstSegment].creationContext;\n        return vc.$uiViewContextAnchor === (uiViewContext && uiViewContext.name);\n    }; };\n    return ViewService;\n}());\nexports.ViewService = ViewService;\n//# sourceMappingURL=view.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3ZpZXcvdmlldy5qcz9lMzkzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAY29yZWFwaVxuICogQG1vZHVsZSB2aWV3XG4gKi8gLyoqIGZvciB0eXBlZG9jICovXG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcbnZhciBob2ZfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vaG9mXCIpO1xudmFyIHByZWRpY2F0ZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vcHJlZGljYXRlc1wiKTtcbnZhciB0cmFjZV8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi90cmFjZVwiKTtcbi8qKlxuICogVGhlIFZpZXcgc2VydmljZVxuICpcbiAqIFRoaXMgc2VydmljZSBwYWlycyBleGlzdGluZyBgdWktdmlld2AgY29tcG9uZW50cyAod2hpY2ggbGl2ZSBpbiB0aGUgRE9NKVxuICogd2l0aCB2aWV3IGNvbmZpZ3MgKGZyb20gdGhlIHN0YXRlIGRlY2xhcmF0aW9uIG9iamVjdHM6IFtbU3RhdGVEZWNsYXJhdGlvbi52aWV3c11dKS5cbiAqXG4gKiAtIEFmdGVyIGEgc3VjY2Vzc2Z1bCBUcmFuc2l0aW9uLCB0aGUgdmlld3MgZnJvbSB0aGUgbmV3bHkgZW50ZXJlZCBzdGF0ZXMgYXJlIGFjdGl2YXRlZCB2aWEgW1thY3RpdmF0ZVZpZXdDb25maWddXS5cbiAqICAgVGhlIHZpZXdzIGZyb20gZXhpdGVkIHN0YXRlcyBhcmUgZGVhY3RpdmF0ZWQgdmlhIFtbZGVhY3RpdmF0ZVZpZXdDb25maWddXS5cbiAqICAgKFNlZTogdGhlIFtbcmVnaXN0ZXJBY3RpdmF0ZVZpZXdzXV0gVHJhbnNpdGlvbiBIb29rKVxuICpcbiAqIC0gQXMgYHVpLXZpZXdgIGNvbXBvbmVudHMgcG9wIGluIGFuZCBvdXQgb2YgZXhpc3RlbmNlLCB0aGV5IHJlZ2lzdGVyIHRoZW1zZWx2ZXMgdXNpbmcgW1tyZWdpc3RlclVJVmlld11dLlxuICpcbiAqIC0gV2hlbiB0aGUgW1tzeW5jXV0gZnVuY3Rpb24gaXMgY2FsbGVkLCB0aGUgcmVnaXN0ZXJlZCBgdWktdmlld2AocykgKFtbQWN0aXZlVUlWaWV3XV0pXG4gKiBhcmUgY29uZmlndXJlZCB3aXRoIHRoZSBtYXRjaGluZyBbW1ZpZXdDb25maWddXShzKVxuICpcbiAqL1xudmFyIFZpZXdTZXJ2aWNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFZpZXdTZXJ2aWNlKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLl91aVZpZXdzID0gW107XG4gICAgICAgIHRoaXMuX3ZpZXdDb25maWdzID0gW107XG4gICAgICAgIHRoaXMuX3ZpZXdDb25maWdGYWN0b3JpZXMgPSB7fTtcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0gW107XG4gICAgICAgIHRoaXMuX3BsdWdpbmFwaSA9IHtcbiAgICAgICAgICAgIF9yb290Vmlld0NvbnRleHQ6IHRoaXMuX3Jvb3RWaWV3Q29udGV4dC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgX3ZpZXdDb25maWdGYWN0b3J5OiB0aGlzLl92aWV3Q29uZmlnRmFjdG9yeS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgX3JlZ2lzdGVyZWRVSVZpZXdzOiBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fdWlWaWV3czsgfSxcbiAgICAgICAgICAgIF9hY3RpdmVWaWV3Q29uZmlnczogZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX3ZpZXdDb25maWdzOyB9LFxuICAgICAgICAgICAgX29uU3luYzogZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX2xpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29tbW9uXzEucmVtb3ZlRnJvbShfdGhpcy5fbGlzdGVuZXJzLCBsaXN0ZW5lcik7IH07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBOb3JtYWxpemVzIGEgdmlldydzIG5hbWUgZnJvbSBhIHN0YXRlLnZpZXdzIGNvbmZpZ3VyYXRpb24gYmxvY2suXG4gICAgICpcbiAgICAgKiBUaGlzIHNob3VsZCBiZSB1c2VkIGJ5IGEgZnJhbWV3b3JrIGltcGxlbWVudGF0aW9uIHRvIGNhbGN1bGF0ZSB0aGUgdmFsdWVzIGZvclxuICAgICAqIFtbX1ZpZXdEZWNsYXJhdGlvbi4kdWlWaWV3TmFtZV1dIGFuZCBbW19WaWV3RGVjbGFyYXRpb24uJHVpVmlld0NvbnRleHRBbmNob3JdXS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb250ZXh0IHRoZSBjb250ZXh0IG9iamVjdCAoc3RhdGUgZGVjbGFyYXRpb24pIHRoYXQgdGhlIHZpZXcgYmVsb25ncyB0b1xuICAgICAqIEBwYXJhbSByYXdWaWV3TmFtZSB0aGUgbmFtZSBvZiB0aGUgdmlldywgYXMgZGVjbGFyZWQgaW4gdGhlIFtbU3RhdGVEZWNsYXJhdGlvbi52aWV3c11dXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB0aGUgbm9ybWFsaXplZCB1aVZpZXdOYW1lIGFuZCB1aVZpZXdDb250ZXh0QW5jaG9yIHRoYXQgdGhlIHZpZXcgdGFyZ2V0c1xuICAgICAqL1xuICAgIFZpZXdTZXJ2aWNlLm5vcm1hbGl6ZVVJVmlld1RhcmdldCA9IGZ1bmN0aW9uIChjb250ZXh0LCByYXdWaWV3TmFtZSkge1xuICAgICAgICBpZiAocmF3Vmlld05hbWUgPT09IHZvaWQgMCkgeyByYXdWaWV3TmFtZSA9ICcnOyB9XG4gICAgICAgIC8vIFRPRE86IFZhbGlkYXRlIGluY29taW5nIHZpZXcgbmFtZSB3aXRoIGEgcmVnZXhwIHRvIGFsbG93OlxuICAgICAgICAvLyBleDogXCJ2aWV3Lm5hbWVAZm9vLmJhclwiICwgXCJeLl4udmlldy5uYW1lXCIgLCBcInZpZXcubmFtZUBeLl5cIiAsIFwiXCIgLFxuICAgICAgICAvLyBcIkBcIiAsIFwiJGRlZmF1bHRAXlwiICwgXCIhJGRlZmF1bHQuJGRlZmF1bHRcIiAsIFwiIWZvby5iYXJcIlxuICAgICAgICB2YXIgdmlld0F0Q29udGV4dCA9IHJhd1ZpZXdOYW1lLnNwbGl0KCdAJyk7XG4gICAgICAgIHZhciB1aVZpZXdOYW1lID0gdmlld0F0Q29udGV4dFswXSB8fCAnJGRlZmF1bHQnOyAvLyBkZWZhdWx0IHRvIHVubmFtZWQgdmlld1xuICAgICAgICB2YXIgdWlWaWV3Q29udGV4dEFuY2hvciA9IHByZWRpY2F0ZXNfMS5pc1N0cmluZyh2aWV3QXRDb250ZXh0WzFdKSA/IHZpZXdBdENvbnRleHRbMV0gOiAnXic7IC8vIGRlZmF1bHQgdG8gcGFyZW50IGNvbnRleHRcbiAgICAgICAgLy8gSGFuZGxlIHJlbGF0aXZlIHZpZXctbmFtZSBzdWdhciBzeW50YXguXG4gICAgICAgIC8vIE1hdGNoZXMgcmF3Vmlld05hbWUgXCJeLl4uXi5mb28uYmFyXCIgaW50byBhcnJheTogW1wiXi5eLl4uZm9vLmJhclwiLCBcIl4uXi5eXCIsIFwiZm9vLmJhclwiXSxcbiAgICAgICAgdmFyIHJlbGF0aXZlVmlld05hbWVTdWdhciA9IC9eKFxcXig/OlxcLlxcXikqKVxcLiguKiQpLy5leGVjKHVpVmlld05hbWUpO1xuICAgICAgICBpZiAocmVsYXRpdmVWaWV3TmFtZVN1Z2FyKSB7XG4gICAgICAgICAgICAvLyBDbG9iYmVycyBleGlzdGluZyBjb250ZXh0QW5jaG9yIChyYXdWaWV3TmFtZSB2YWxpZGF0aW9uIHdpbGwgZml4IHRoaXMpXG4gICAgICAgICAgICB1aVZpZXdDb250ZXh0QW5jaG9yID0gcmVsYXRpdmVWaWV3TmFtZVN1Z2FyWzFdOyAvLyBzZXQgYW5jaG9yIHRvIFwiXi5eLl5cIlxuICAgICAgICAgICAgdWlWaWV3TmFtZSA9IHJlbGF0aXZlVmlld05hbWVTdWdhclsyXTsgLy8gc2V0IHZpZXctbmFtZSB0byBcImZvby5iYXJcIlxuICAgICAgICB9XG4gICAgICAgIGlmICh1aVZpZXdOYW1lLmNoYXJBdCgwKSA9PT0gJyEnKSB7XG4gICAgICAgICAgICB1aVZpZXdOYW1lID0gdWlWaWV3TmFtZS5zdWJzdHIoMSk7XG4gICAgICAgICAgICB1aVZpZXdDb250ZXh0QW5jaG9yID0gJyc7IC8vIHRhcmdldCBhYnNvbHV0ZWx5IGZyb20gcm9vdFxuICAgICAgICB9XG4gICAgICAgIC8vIGhhbmRsZSBwYXJlbnQgcmVsYXRpdmUgdGFyZ2V0aW5nIFwiXi5eLl5cIlxuICAgICAgICB2YXIgcmVsYXRpdmVNYXRjaCA9IC9eKFxcXig/OlxcLlxcXikqKSQvO1xuICAgICAgICBpZiAocmVsYXRpdmVNYXRjaC5leGVjKHVpVmlld0NvbnRleHRBbmNob3IpKSB7XG4gICAgICAgICAgICB2YXIgYW5jaG9yU3RhdGUgPSB1aVZpZXdDb250ZXh0QW5jaG9yLnNwbGl0KCcuJylcbiAgICAgICAgICAgICAgICAucmVkdWNlKChmdW5jdGlvbiAoYW5jaG9yLCB4KSB7IHJldHVybiBhbmNob3IucGFyZW50OyB9KSwgY29udGV4dCk7XG4gICAgICAgICAgICB1aVZpZXdDb250ZXh0QW5jaG9yID0gYW5jaG9yU3RhdGUubmFtZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh1aVZpZXdDb250ZXh0QW5jaG9yID09PSAnLicpIHtcbiAgICAgICAgICAgIHVpVmlld0NvbnRleHRBbmNob3IgPSBjb250ZXh0Lm5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdWlWaWV3TmFtZTogdWlWaWV3TmFtZSwgdWlWaWV3Q29udGV4dEFuY2hvcjogdWlWaWV3Q29udGV4dEFuY2hvciB9O1xuICAgIH07XG4gICAgVmlld1NlcnZpY2UucHJvdG90eXBlLl9yb290Vmlld0NvbnRleHQgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcm9vdENvbnRleHQgPSBjb250ZXh0IHx8IHRoaXMuX3Jvb3RDb250ZXh0O1xuICAgIH07XG4gICAgVmlld1NlcnZpY2UucHJvdG90eXBlLl92aWV3Q29uZmlnRmFjdG9yeSA9IGZ1bmN0aW9uICh2aWV3VHlwZSwgZmFjdG9yeSkge1xuICAgICAgICB0aGlzLl92aWV3Q29uZmlnRmFjdG9yaWVzW3ZpZXdUeXBlXSA9IGZhY3Rvcnk7XG4gICAgfTtcbiAgICBWaWV3U2VydmljZS5wcm90b3R5cGUuY3JlYXRlVmlld0NvbmZpZyA9IGZ1bmN0aW9uIChwYXRoLCBkZWNsKSB7XG4gICAgICAgIHZhciBjZmdGYWN0b3J5ID0gdGhpcy5fdmlld0NvbmZpZ0ZhY3Rvcmllc1tkZWNsLiR0eXBlXTtcbiAgICAgICAgaWYgKCFjZmdGYWN0b3J5KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdWaWV3U2VydmljZTogTm8gdmlldyBjb25maWcgZmFjdG9yeSByZWdpc3RlcmVkIGZvciB0eXBlICcgKyBkZWNsLiR0eXBlKTtcbiAgICAgICAgdmFyIGNmZ3MgPSBjZmdGYWN0b3J5KHBhdGgsIGRlY2wpO1xuICAgICAgICByZXR1cm4gcHJlZGljYXRlc18xLmlzQXJyYXkoY2ZncykgPyBjZmdzIDogW2NmZ3NdO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRGVhY3RpdmF0ZXMgYSBWaWV3Q29uZmlnLlxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBkZWFjdGl2YXRlcyBhIGBWaWV3Q29uZmlnYC5cbiAgICAgKiBBZnRlciBjYWxsaW5nIFtbc3luY11dLCBpdCB3aWxsIHVuLXBhaXIgZnJvbSBhbnkgYHVpLXZpZXdgIHdpdGggd2hpY2ggaXQgaXMgY3VycmVudGx5IHBhaXJlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2aWV3Q29uZmlnIFRoZSBWaWV3Q29uZmlnIHZpZXcgdG8gZGVyZWdpc3Rlci5cbiAgICAgKi9cbiAgICBWaWV3U2VydmljZS5wcm90b3R5cGUuZGVhY3RpdmF0ZVZpZXdDb25maWcgPSBmdW5jdGlvbiAodmlld0NvbmZpZykge1xuICAgICAgICB0cmFjZV8xLnRyYWNlLnRyYWNlVmlld1NlcnZpY2VFdmVudCgnPC0gUmVtb3ZpbmcnLCB2aWV3Q29uZmlnKTtcbiAgICAgICAgY29tbW9uXzEucmVtb3ZlRnJvbSh0aGlzLl92aWV3Q29uZmlncywgdmlld0NvbmZpZyk7XG4gICAgfTtcbiAgICBWaWV3U2VydmljZS5wcm90b3R5cGUuYWN0aXZhdGVWaWV3Q29uZmlnID0gZnVuY3Rpb24gKHZpZXdDb25maWcpIHtcbiAgICAgICAgdHJhY2VfMS50cmFjZS50cmFjZVZpZXdTZXJ2aWNlRXZlbnQoJy0+IFJlZ2lzdGVyaW5nJywgdmlld0NvbmZpZyk7XG4gICAgICAgIHRoaXMuX3ZpZXdDb25maWdzLnB1c2godmlld0NvbmZpZyk7XG4gICAgfTtcbiAgICBWaWV3U2VydmljZS5wcm90b3R5cGUuc3luYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHVpVmlld3NCeUZxbiA9IHRoaXMuX3VpVmlld3MubWFwKGZ1bmN0aW9uICh1aXYpIHsgcmV0dXJuIFt1aXYuZnFuLCB1aXZdOyB9KS5yZWR1Y2UoY29tbW9uXzEuYXBwbHlQYWlycywge30pO1xuICAgICAgICAvLyBSZXR1cm4gYSB3ZWlnaHRlZCBkZXB0aCB2YWx1ZSBmb3IgYSB1aVZpZXcuXG4gICAgICAgIC8vIFRoZSBkZXB0aCBpcyB0aGUgbmVzdGluZyBkZXB0aCBvZiB1aS12aWV3cyAoYmFzZWQgb24gRlFOOyB0aW1lcyAxMCwwMDApXG4gICAgICAgIC8vIHBsdXMgdGhlIGRlcHRoIG9mIHRoZSBzdGF0ZSB0aGF0IGlzIHBvcHVsYXRpbmcgdGhlIHVpVmlld1xuICAgICAgICBmdW5jdGlvbiB1aVZpZXdEZXB0aCh1aVZpZXcpIHtcbiAgICAgICAgICAgIHZhciBzdGF0ZURlcHRoID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dCAmJiBjb250ZXh0LnBhcmVudCA/IHN0YXRlRGVwdGgoY29udGV4dC5wYXJlbnQpICsgMSA6IDE7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuICh1aVZpZXcuZnFuLnNwbGl0KCcuJykubGVuZ3RoICogMTAwMDApICsgc3RhdGVEZXB0aCh1aVZpZXcuY3JlYXRpb25Db250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXR1cm4gdGhlIFZpZXdDb25maWcncyBjb250ZXh0J3MgZGVwdGggaW4gdGhlIGNvbnRleHQgdHJlZS5cbiAgICAgICAgZnVuY3Rpb24gdmlld0NvbmZpZ0RlcHRoKGNvbmZpZykge1xuICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBjb25maWcudmlld0RlY2wuJGNvbnRleHQsIGNvdW50ID0gMDtcbiAgICAgICAgICAgIHdoaWxlICgrK2NvdW50ICYmIGNvbnRleHQucGFyZW50KVxuICAgICAgICAgICAgICAgIGNvbnRleHQgPSBjb250ZXh0LnBhcmVudDtcbiAgICAgICAgICAgIHJldHVybiBjb3VudDtcbiAgICAgICAgfVxuICAgICAgICAvLyBHaXZlbiBhIGRlcHRoIGZ1bmN0aW9uLCByZXR1cm5zIGEgY29tcGFyZSBmdW5jdGlvbiB3aGljaCBjYW4gcmV0dXJuIGVpdGhlciBhc2NlbmRpbmcgb3IgZGVzY2VuZGluZyBvcmRlclxuICAgICAgICB2YXIgZGVwdGhDb21wYXJlID0gaG9mXzEuY3VycnkoZnVuY3Rpb24gKGRlcHRoRm4sIHBvc05lZywgbGVmdCwgcmlnaHQpIHsgcmV0dXJuIHBvc05lZyAqIChkZXB0aEZuKGxlZnQpIC0gZGVwdGhGbihyaWdodCkpOyB9KTtcbiAgICAgICAgdmFyIG1hdGNoaW5nQ29uZmlnUGFpciA9IGZ1bmN0aW9uICh1aVZpZXcpIHtcbiAgICAgICAgICAgIHZhciBtYXRjaGluZ0NvbmZpZ3MgPSBfdGhpcy5fdmlld0NvbmZpZ3MuZmlsdGVyKFZpZXdTZXJ2aWNlLm1hdGNoZXModWlWaWV3c0J5RnFuLCB1aVZpZXcpKTtcbiAgICAgICAgICAgIGlmIChtYXRjaGluZ0NvbmZpZ3MubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgT0suICBDaGlsZCBzdGF0ZXMgY2FuIHRhcmdldCBhIHVpLXZpZXcgdGhhdCB0aGUgcGFyZW50IHN0YXRlIGFsc28gdGFyZ2V0cyAodGhlIGNoaWxkIHdpbnMpXG4gICAgICAgICAgICAgICAgLy8gU29ydCBieSBkZXB0aCBhbmQgcmV0dXJuIHRoZSBtYXRjaCBmcm9tIHRoZSBkZWVwZXN0IGNoaWxkXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coYE11bHRpcGxlIG1hdGNoaW5nIHZpZXcgY29uZmlncyBmb3IgJHt1aVZpZXcuZnFufWAsIG1hdGNoaW5nQ29uZmlncyk7XG4gICAgICAgICAgICAgICAgbWF0Y2hpbmdDb25maWdzLnNvcnQoZGVwdGhDb21wYXJlKHZpZXdDb25maWdEZXB0aCwgLTEpKTsgLy8gZGVzY2VuZGluZ1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgdWlWaWV3OiB1aVZpZXcsIHZpZXdDb25maWc6IG1hdGNoaW5nQ29uZmlnc1swXSB9O1xuICAgICAgICB9O1xuICAgICAgICB2YXIgY29uZmlndXJlVUlWaWV3ID0gZnVuY3Rpb24gKHR1cGxlKSB7XG4gICAgICAgICAgICAvLyBJZiBhIHBhcmVudCB1aS12aWV3IGlzIHJlY29uZmlndXJlZCwgaXQgY291bGQgZGVzdHJveSBjaGlsZCB1aS12aWV3cy5cbiAgICAgICAgICAgIC8vIEJlZm9yZSBjb25maWd1cmluZyBhIGNoaWxkIHVpLXZpZXcsIG1ha2Ugc3VyZSBpdCdzIHN0aWxsIGluIHRoZSBhY3RpdmUgdWlWaWV3cyBhcnJheS5cbiAgICAgICAgICAgIGlmIChfdGhpcy5fdWlWaWV3cy5pbmRleE9mKHR1cGxlLnVpVmlldykgIT09IC0xKVxuICAgICAgICAgICAgICAgIHR1cGxlLnVpVmlldy5jb25maWdVcGRhdGVkKHR1cGxlLnZpZXdDb25maWcpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBTb3J0IHZpZXdzIGJ5IEZRTiBhbmQgc3RhdGUgZGVwdGguIFByb2Nlc3MgdWl2aWV3cyBuZWFyZXN0IHRoZSByb290IGZpcnN0LlxuICAgICAgICB2YXIgdWlWaWV3VHVwbGVzID0gdGhpcy5fdWlWaWV3cy5zb3J0KGRlcHRoQ29tcGFyZSh1aVZpZXdEZXB0aCwgMSkpLm1hcChtYXRjaGluZ0NvbmZpZ1BhaXIpO1xuICAgICAgICB2YXIgbWF0Y2hlZFZpZXdDb25maWdzID0gdWlWaWV3VHVwbGVzLm1hcChmdW5jdGlvbiAodHVwbGUpIHsgcmV0dXJuIHR1cGxlLnZpZXdDb25maWc7IH0pO1xuICAgICAgICB2YXIgdW5tYXRjaGVkQ29uZmlnVHVwbGVzID0gdGhpcy5fdmlld0NvbmZpZ3NcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGNvbmZpZykgeyByZXR1cm4gIWNvbW1vbl8xLmluQXJyYXkobWF0Y2hlZFZpZXdDb25maWdzLCBjb25maWcpOyB9KVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAodmlld0NvbmZpZykgeyByZXR1cm4gKHsgdWlWaWV3OiB1bmRlZmluZWQsIHZpZXdDb25maWc6IHZpZXdDb25maWcgfSk7IH0pO1xuICAgICAgICB1aVZpZXdUdXBsZXMuZm9yRWFjaChjb25maWd1cmVVSVZpZXcpO1xuICAgICAgICB2YXIgYWxsVHVwbGVzID0gdWlWaWV3VHVwbGVzLmNvbmNhdCh1bm1hdGNoZWRDb25maWdUdXBsZXMpO1xuICAgICAgICB0aGlzLl9saXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAoY2IpIHsgcmV0dXJuIGNiKGFsbFR1cGxlcyk7IH0pO1xuICAgICAgICB0cmFjZV8xLnRyYWNlLnRyYWNlVmlld1N5bmMoYWxsVHVwbGVzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIGB1aS12aWV3YCBjb21wb25lbnRcbiAgICAgKlxuICAgICAqIFdoZW4gYSBgdWktdmlld2AgY29tcG9uZW50IGlzIGNyZWF0ZWQsIGl0IHVzZXMgdGhpcyBtZXRob2QgdG8gcmVnaXN0ZXIgaXRzZWxmLlxuICAgICAqIEFmdGVyIHJlZ2lzdHJhdGlvbiB0aGUgW1tzeW5jXV0gbWV0aG9kIGlzIHVzZWQgdG8gZW5zdXJlIGFsbCBgdWktdmlld2AgYXJlIGNvbmZpZ3VyZWQgd2l0aCB0aGUgcHJvcGVyIFtbVmlld0NvbmZpZ11dLlxuICAgICAqXG4gICAgICogTm90ZTogdGhlIGB1aS12aWV3YCBjb21wb25lbnQgdXNlcyB0aGUgYFZpZXdDb25maWdgIHRvIGRldGVybWluZSB3aGF0IHZpZXcgc2hvdWxkIGJlIGxvYWRlZCBpbnNpZGUgdGhlIGB1aS12aWV3YCxcbiAgICAgKiBhbmQgd2hhdCB0aGUgdmlldydzIHN0YXRlIGNvbnRleHQgaXMuXG4gICAgICpcbiAgICAgKiBOb3RlOiBUaGVyZSBpcyBubyBjb3JyZXNwb25kaW5nIGBkZXJlZ2lzdGVyVUlWaWV3YC5cbiAgICAgKiAgICAgICBBIGB1aS12aWV3YCBzaG91bGQgaGFuZyBvbiB0byB0aGUgcmV0dXJuIHZhbHVlIG9mIGByZWdpc3RlclVJVmlld2AgYW5kIGludm9rZSBpdCB0byBkZXJlZ2lzdGVyIGl0c2VsZi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1aVZpZXcgVGhlIG1ldGFkYXRhIGZvciBhIFVJVmlld1xuICAgICAqIEByZXR1cm4gYSBkZS1yZWdpc3RyYXRpb24gZnVuY3Rpb24gdXNlZCB3aGVuIHRoZSB2aWV3IGlzIGRlc3Ryb3llZC5cbiAgICAgKi9cbiAgICBWaWV3U2VydmljZS5wcm90b3R5cGUucmVnaXN0ZXJVSVZpZXcgPSBmdW5jdGlvbiAodWlWaWV3KSB7XG4gICAgICAgIHRyYWNlXzEudHJhY2UudHJhY2VWaWV3U2VydmljZVVJVmlld0V2ZW50KCctPiBSZWdpc3RlcmluZycsIHVpVmlldyk7XG4gICAgICAgIHZhciB1aVZpZXdzID0gdGhpcy5fdWlWaWV3cztcbiAgICAgICAgdmFyIGZxbkFuZFR5cGVNYXRjaGVzID0gZnVuY3Rpb24gKHVpdikgeyByZXR1cm4gdWl2LmZxbiA9PT0gdWlWaWV3LmZxbiAmJiB1aXYuJHR5cGUgPT09IHVpVmlldy4kdHlwZTsgfTtcbiAgICAgICAgaWYgKHVpVmlld3MuZmlsdGVyKGZxbkFuZFR5cGVNYXRjaGVzKS5sZW5ndGgpXG4gICAgICAgICAgICB0cmFjZV8xLnRyYWNlLnRyYWNlVmlld1NlcnZpY2VVSVZpZXdFdmVudCgnISEhISBkdXBsaWNhdGUgdWlWaWV3IG5hbWVkOicsIHVpVmlldyk7XG4gICAgICAgIHVpVmlld3MucHVzaCh1aVZpZXcpO1xuICAgICAgICB0aGlzLnN5bmMoKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpZHggPSB1aVZpZXdzLmluZGV4T2YodWlWaWV3KTtcbiAgICAgICAgICAgIGlmIChpZHggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdHJhY2VfMS50cmFjZS50cmFjZVZpZXdTZXJ2aWNlVUlWaWV3RXZlbnQoJ1RyaWVkIHJlbW92aW5nIG5vbi1yZWdpc3RlcmVkIHVpVmlldycsIHVpVmlldyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhY2VfMS50cmFjZS50cmFjZVZpZXdTZXJ2aWNlVUlWaWV3RXZlbnQoJzwtIERlcmVnaXN0ZXJpbmcnLCB1aVZpZXcpO1xuICAgICAgICAgICAgY29tbW9uXzEucmVtb3ZlRnJvbSh1aVZpZXdzKSh1aVZpZXcpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGlzdCBvZiB2aWV3cyBjdXJyZW50bHkgYXZhaWxhYmxlIG9uIHRoZSBwYWdlLCBieSBmdWxseS1xdWFsaWZpZWQgbmFtZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIGZ1bGx5LXF1YWxpZmllZCB2aWV3IG5hbWVzLlxuICAgICAqL1xuICAgIFZpZXdTZXJ2aWNlLnByb3RvdHlwZS5hdmFpbGFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl91aVZpZXdzLm1hcChob2ZfMS5wcm9wKCdmcW4nKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIHZpZXdzIG9uIHRoZSBwYWdlIGNvbnRhaW5pbmcgbG9hZGVkIGNvbnRlbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBvZiBmdWxseS1xdWFsaWZpZWQgdmlldyBuYW1lcy5cbiAgICAgKi9cbiAgICBWaWV3U2VydmljZS5wcm90b3R5cGUuYWN0aXZlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdWlWaWV3cy5maWx0ZXIoaG9mXzEucHJvcCgnJGNvbmZpZycpKS5tYXAoaG9mXzEucHJvcCgnbmFtZScpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgdWktdmlldyBhbmQgYSBWaWV3Q29uZmlnLCBkZXRlcm1pbmVzIGlmIHRoZXkgXCJtYXRjaFwiLlxuICAgICAqXG4gICAgICogQSB1aS12aWV3IGhhcyBhIGZ1bGx5IHF1YWxpZmllZCBuYW1lIChmcW4pIGFuZCBhIGNvbnRleHQgb2JqZWN0LiAgVGhlIGZxbiBpcyBidWlsdCBmcm9tIGl0cyBvdmVyYWxsIGxvY2F0aW9uIGluXG4gICAgICogdGhlIERPTSwgZGVzY3JpYmluZyBpdHMgbmVzdGluZyByZWxhdGlvbnNoaXAgdG8gYW55IHBhcmVudCB1aS12aWV3IHRhZ3MgaXQgaXMgbmVzdGVkIGluc2lkZSBvZi5cbiAgICAgKlxuICAgICAqIEEgVmlld0NvbmZpZyBoYXMgYSB0YXJnZXQgdWktdmlldyBuYW1lIGFuZCBhIGNvbnRleHQgYW5jaG9yLiAgVGhlIHVpLXZpZXcgbmFtZSBjYW4gYmUgYSBzaW1wbGUgbmFtZSwgb3JcbiAgICAgKiBjYW4gYmUgYSBzZWdtZW50ZWQgdWktdmlldyBwYXRoLCBkZXNjcmliaW5nIGEgcG9ydGlvbiBvZiBhIHVpLXZpZXcgZnFuLlxuICAgICAqXG4gICAgICogSW4gb3JkZXIgZm9yIGEgdWktdmlldyB0byBtYXRjaCBWaWV3Q29uZmlnLCB1aS12aWV3J3MgJHR5cGUgbXVzdCBtYXRjaCB0aGUgVmlld0NvbmZpZydzICR0eXBlXG4gICAgICpcbiAgICAgKiBJZiB0aGUgVmlld0NvbmZpZydzIHRhcmdldCB1aS12aWV3IG5hbWUgaXMgYSBzaW1wbGUgbmFtZSAobm8gZG90cyksIHRoZW4gYSB1aS12aWV3IG1hdGNoZXMgaWY6XG4gICAgICogLSB0aGUgdWktdmlldydzIG5hbWUgbWF0Y2hlcyB0aGUgVmlld0NvbmZpZydzIHRhcmdldCBuYW1lXG4gICAgICogLSB0aGUgdWktdmlldydzIGNvbnRleHQgbWF0Y2hlcyB0aGUgVmlld0NvbmZpZydzIGFuY2hvclxuICAgICAqXG4gICAgICogSWYgdGhlIFZpZXdDb25maWcncyB0YXJnZXQgdWktdmlldyBuYW1lIGlzIGEgc2VnbWVudGVkIG5hbWUgKHdpdGggZG90cyksIHRoZW4gYSB1aS12aWV3IG1hdGNoZXMgaWY6XG4gICAgICogLSBUaGVyZSBleGlzdHMgYSBwYXJlbnQgdWktdmlldyB3aGVyZTpcbiAgICAgKiAgICAtIHRoZSBwYXJlbnQgdWktdmlldydzIG5hbWUgbWF0Y2hlcyB0aGUgZmlyc3Qgc2VnbWVudCAoaW5kZXggMCkgb2YgdGhlIFZpZXdDb25maWcncyB0YXJnZXQgbmFtZVxuICAgICAqICAgIC0gdGhlIHBhcmVudCB1aS12aWV3J3MgY29udGV4dCBtYXRjaGVzIHRoZSBWaWV3Q29uZmlnJ3MgYW5jaG9yXG4gICAgICogLSBBbmQgdGhlIHJlbWFpbmluZyBzZWdtZW50cyAoaW5kZXggMS4ubikgb2YgdGhlIFZpZXdDb25maWcncyB0YXJnZXQgbmFtZSBtYXRjaCB0aGUgdGFpbCBvZiB0aGUgdWktdmlldydzIGZxblxuICAgICAqXG4gICAgICogRXhhbXBsZTpcbiAgICAgKlxuICAgICAqIERPTTpcbiAgICAgKiA8dWktdmlldz4gICAgICAgICAgICAgICAgICAgICAgICA8IS0tIGNyZWF0ZWQgaW4gdGhlIHJvb3QgY29udGV4dCAobmFtZTogXCJcIikgLS0+XG4gICAgICogICA8dWktdmlldyBuYW1lPVwiZm9vXCI+ICAgICAgICAgICAgICAgIDwhLS0gY3JlYXRlZCBpbiB0aGUgY29udGV4dCBuYW1lZDogXCJBXCIgICAgICAtLT5cbiAgICAgKiAgICAgPHVpLXZpZXc+ICAgICAgICAgICAgICAgICAgICA8IS0tIGNyZWF0ZWQgaW4gdGhlIGNvbnRleHQgbmFtZWQ6IFwiQS5CXCIgICAgLS0+XG4gICAgICogICAgICAgPHVpLXZpZXcgbmFtZT1cImJhclwiPiAgICAgICAgICAgIDwhLS0gY3JlYXRlZCBpbiB0aGUgY29udGV4dCBuYW1lZDogXCJBLkIuQ1wiICAtLT5cbiAgICAgKiAgICAgICA8L3VpLXZpZXc+XG4gICAgICogICAgIDwvdWktdmlldz5cbiAgICAgKiAgIDwvdWktdmlldz5cbiAgICAgKiA8L3VpLXZpZXc+XG4gICAgICpcbiAgICAgKiB1aVZpZXdzOiBbXG4gICAgICogIHsgZnFuOiBcIiRkZWZhdWx0XCIsICAgICAgICAgICAgICAgICAgY3JlYXRpb25Db250ZXh0OiB7IG5hbWU6IFwiXCIgfSB9LFxuICAgICAqICB7IGZxbjogXCIkZGVmYXVsdC5mb29cIiwgICAgICAgICAgICAgIGNyZWF0aW9uQ29udGV4dDogeyBuYW1lOiBcIkFcIiB9IH0sXG4gICAgICogIHsgZnFuOiBcIiRkZWZhdWx0LmZvby4kZGVmYXVsdFwiLCAgICAgY3JlYXRpb25Db250ZXh0OiB7IG5hbWU6IFwiQS5CXCIgfSB9XG4gICAgICogIHsgZnFuOiBcIiRkZWZhdWx0LmZvby4kZGVmYXVsdC5iYXJcIiwgY3JlYXRpb25Db250ZXh0OiB7IG5hbWU6IFwiQS5CLkNcIiB9IH1cbiAgICAgKiBdXG4gICAgICpcbiAgICAgKiBUaGVzZSBmb3VyIHZpZXcgY29uZmlncyBhbGwgbWF0Y2ggdGhlIHVpLXZpZXcgd2l0aCB0aGUgZnFuOiBcIiRkZWZhdWx0LmZvby4kZGVmYXVsdC5iYXJcIjpcbiAgICAgKlxuICAgICAqIC0gVmlld0NvbmZpZzE6IHsgdWlWaWV3TmFtZTogXCJiYXJcIiwgICAgICAgICAgICAgICAgICAgICAgIHVpVmlld0NvbnRleHRBbmNob3I6IFwiQS5CLkNcIiB9XG4gICAgICogLSBWaWV3Q29uZmlnMjogeyB1aVZpZXdOYW1lOiBcIiRkZWZhdWx0LmJhclwiLCAgICAgICAgICAgICAgdWlWaWV3Q29udGV4dEFuY2hvcjogXCJBLkJcIiB9XG4gICAgICogLSBWaWV3Q29uZmlnMzogeyB1aVZpZXdOYW1lOiBcImZvby4kZGVmYXVsdC5iYXJcIiwgICAgICAgICAgdWlWaWV3Q29udGV4dEFuY2hvcjogXCJBXCIgfVxuICAgICAqIC0gVmlld0NvbmZpZzQ6IHsgdWlWaWV3TmFtZTogXCIkZGVmYXVsdC5mb28uJGRlZmF1bHQuYmFyXCIsIHVpVmlld0NvbnRleHRBbmNob3I6IFwiXCIgfVxuICAgICAqXG4gICAgICogVXNpbmcgVmlld0NvbmZpZzMgYXMgYW4gZXhhbXBsZSwgaXQgbWF0Y2hlcyB0aGUgdWktdmlldyB3aXRoIGZxbiBcIiRkZWZhdWx0LmZvby4kZGVmYXVsdC5iYXJcIiBiZWNhdXNlOlxuICAgICAqIC0gVGhlIFZpZXdDb25maWcncyBzZWdtZW50ZWQgdGFyZ2V0IG5hbWUgaXM6IFsgXCJmb29cIiwgXCIkZGVmYXVsdFwiLCBcImJhclwiIF1cbiAgICAgKiAtIFRoZXJlIGV4aXN0cyBhIHBhcmVudCB1aS12aWV3ICh3aGljaCBoYXMgZnFuOiBcIiRkZWZhdWx0LmZvb1wiKSB3aGVyZTpcbiAgICAgKiAgICAtIHRoZSBwYXJlbnQgdWktdmlldydzIG5hbWUgXCJmb29cIiBtYXRjaGVzIHRoZSBmaXJzdCBzZWdtZW50IFwiZm9vXCIgb2YgdGhlIFZpZXdDb25maWcncyB0YXJnZXQgbmFtZVxuICAgICAqICAgIC0gdGhlIHBhcmVudCB1aS12aWV3J3MgY29udGV4dCBcIkFcIiBtYXRjaGVzIHRoZSBWaWV3Q29uZmlnJ3MgYW5jaG9yIGNvbnRleHQgXCJBXCJcbiAgICAgKiAtIEFuZCB0aGUgcmVtYWluaW5nIHNlZ21lbnRzIFsgXCIkZGVmYXVsdFwiLCBcImJhclwiIF0uam9pbihcIi5cIl8gb2YgdGhlIFZpZXdDb25maWcncyB0YXJnZXQgbmFtZSBtYXRjaFxuICAgICAqICAgdGhlIHRhaWwgb2YgdGhlIHVpLXZpZXcncyBmcW4gXCJkZWZhdWx0LmJhclwiXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxhcGlcbiAgICAgKi9cbiAgICBWaWV3U2VydmljZS5tYXRjaGVzID0gZnVuY3Rpb24gKHVpVmlld3NCeUZxbiwgdWlWaWV3KSB7IHJldHVybiBmdW5jdGlvbiAodmlld0NvbmZpZykge1xuICAgICAgICAvLyBEb24ndCBzdXBwbHkgYW4gbmcxIHVpLXZpZXcgd2l0aCBhbiBuZzIgVmlld0NvbmZpZywgZXRjXG4gICAgICAgIGlmICh1aVZpZXcuJHR5cGUgIT09IHZpZXdDb25maWcudmlld0RlY2wuJHR5cGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIFNwbGl0IG5hbWVzIGFwYXJ0IGZyb20gYm90aCB2aWV3Q29uZmlnIGFuZCB1aVZpZXcgaW50byBzZWdtZW50c1xuICAgICAgICB2YXIgdmMgPSB2aWV3Q29uZmlnLnZpZXdEZWNsO1xuICAgICAgICB2YXIgdmNTZWdtZW50cyA9IHZjLiR1aVZpZXdOYW1lLnNwbGl0KCcuJyk7XG4gICAgICAgIHZhciB1aXZTZWdtZW50cyA9IHVpVmlldy5mcW4uc3BsaXQoJy4nKTtcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIHRhaWxzIG9mIHRoZSBzZWdtZW50IGFycmF5cyBtYXRjaC4gZXgsIHRoZXNlIGFycmF5cycgdGFpbHMgbWF0Y2g6XG4gICAgICAgIC8vIHZjOiBbXCJmb29cIiwgXCJiYXJcIl0sIHVpdiBmcW46IFtcIiRkZWZhdWx0XCIsIFwiZm9vXCIsIFwiYmFyXCJdXG4gICAgICAgIGlmICghY29tbW9uXzEuZXF1YWxzKHZjU2VnbWVudHMsIHVpdlNlZ21lbnRzLnNsaWNlKDAgLSB2Y1NlZ21lbnRzLmxlbmd0aCkpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAvLyBOb3cgY2hlY2sgaWYgdGhlIGZxbiBlbmRpbmcgYXQgdGhlIGZpcnN0IHNlZ21lbnQgb2YgdGhlIHZpZXdDb25maWcgbWF0Y2hlcyB0aGUgY29udGV4dDpcbiAgICAgICAgLy8gW1wiJGRlZmF1bHRcIiwgXCJmb29cIl0uam9pbihcIi5cIikgPT0gXCIkZGVmYXVsdC5mb29cIiwgZG9lcyB0aGUgdWktdmlldyAkZGVmYXVsdC5mb28gY29udGV4dCBtYXRjaD9cbiAgICAgICAgdmFyIG5lZ09mZnNldCA9ICgxIC0gdmNTZWdtZW50cy5sZW5ndGgpIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIGZxblRvRmlyc3RTZWdtZW50ID0gdWl2U2VnbWVudHMuc2xpY2UoMCwgbmVnT2Zmc2V0KS5qb2luKCcuJyk7XG4gICAgICAgIHZhciB1aVZpZXdDb250ZXh0ID0gdWlWaWV3c0J5RnFuW2ZxblRvRmlyc3RTZWdtZW50XS5jcmVhdGlvbkNvbnRleHQ7XG4gICAgICAgIHJldHVybiB2Yy4kdWlWaWV3Q29udGV4dEFuY2hvciA9PT0gKHVpVmlld0NvbnRleHQgJiYgdWlWaWV3Q29udGV4dC5uYW1lKTtcbiAgICB9OyB9O1xuICAgIHJldHVybiBWaWV3U2VydmljZTtcbn0oKSk7XG5leHBvcnRzLlZpZXdTZXJ2aWNlID0gVmlld1NlcnZpY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12aWV3LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi92aWV3L3ZpZXcuanNcbi8vIG1vZHVsZSBpZCA9IDgzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///83\n')},function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\n/**\n * @coreapi\n * @module core\n */ /** */\nvar stateParams_1 = __webpack_require__(73);\nvar queue_1 = __webpack_require__(43);\n/**\n * Global router state\n *\n * This is where we hold the global mutable state such as current state, current\n * params, current transition, etc.\n */\nvar UIRouterGlobals = /** @class */ (function () {\n    function UIRouterGlobals() {\n        /**\n         * Current parameter values\n         *\n         * The parameter values from the latest successful transition\n         */\n        this.params = new stateParams_1.StateParams();\n        /** @internalapi */\n        this.lastStartedTransitionId = -1;\n        /** @internalapi */\n        this.transitionHistory = new queue_1.Queue([], 1);\n        /** @internalapi */\n        this.successfulTransitions = new queue_1.Queue([], 1);\n    }\n    UIRouterGlobals.prototype.dispose = function () {\n        this.transitionHistory.clear();\n        this.successfulTransitions.clear();\n        this.transition = null;\n    };\n    return UIRouterGlobals;\n}());\nexports.UIRouterGlobals = UIRouterGlobals;\n//# sourceMappingURL=globals.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2dsb2JhbHMuanM/NjEwMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGNvcmVhcGlcbiAqIEBtb2R1bGUgY29yZVxuICovIC8qKiAqL1xudmFyIHN0YXRlUGFyYW1zXzEgPSByZXF1aXJlKFwiLi9wYXJhbXMvc3RhdGVQYXJhbXNcIik7XG52YXIgcXVldWVfMSA9IHJlcXVpcmUoXCIuL2NvbW1vbi9xdWV1ZVwiKTtcbi8qKlxuICogR2xvYmFsIHJvdXRlciBzdGF0ZVxuICpcbiAqIFRoaXMgaXMgd2hlcmUgd2UgaG9sZCB0aGUgZ2xvYmFsIG11dGFibGUgc3RhdGUgc3VjaCBhcyBjdXJyZW50IHN0YXRlLCBjdXJyZW50XG4gKiBwYXJhbXMsIGN1cnJlbnQgdHJhbnNpdGlvbiwgZXRjLlxuICovXG52YXIgVUlSb3V0ZXJHbG9iYWxzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFVJUm91dGVyR2xvYmFscygpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEN1cnJlbnQgcGFyYW1ldGVyIHZhbHVlc1xuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgcGFyYW1ldGVyIHZhbHVlcyBmcm9tIHRoZSBsYXRlc3Qgc3VjY2Vzc2Z1bCB0cmFuc2l0aW9uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBhcmFtcyA9IG5ldyBzdGF0ZVBhcmFtc18xLlN0YXRlUGFyYW1zKCk7XG4gICAgICAgIC8qKiBAaW50ZXJuYWxhcGkgKi9cbiAgICAgICAgdGhpcy5sYXN0U3RhcnRlZFRyYW5zaXRpb25JZCA9IC0xO1xuICAgICAgICAvKiogQGludGVybmFsYXBpICovXG4gICAgICAgIHRoaXMudHJhbnNpdGlvbkhpc3RvcnkgPSBuZXcgcXVldWVfMS5RdWV1ZShbXSwgMSk7XG4gICAgICAgIC8qKiBAaW50ZXJuYWxhcGkgKi9cbiAgICAgICAgdGhpcy5zdWNjZXNzZnVsVHJhbnNpdGlvbnMgPSBuZXcgcXVldWVfMS5RdWV1ZShbXSwgMSk7XG4gICAgfVxuICAgIFVJUm91dGVyR2xvYmFscy5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uSGlzdG9yeS5jbGVhcigpO1xuICAgICAgICB0aGlzLnN1Y2Nlc3NmdWxUcmFuc2l0aW9ucy5jbGVhcigpO1xuICAgICAgICB0aGlzLnRyYW5zaXRpb24gPSBudWxsO1xuICAgIH07XG4gICAgcmV0dXJuIFVJUm91dGVyR2xvYmFscztcbn0oKSk7XG5leHBvcnRzLlVJUm91dGVyR2xvYmFscyA9IFVJUm91dGVyR2xvYmFscztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdsb2JhbHMuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2dsb2JhbHMuanNcbi8vIG1vZHVsZSBpZCA9IDg0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///84\n')},function(module,exports,__webpack_require__){"use strict";eval("\n/**\n * @coreapi\n * @module url\n */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar coreservices_1 = __webpack_require__(3);\nvar common_1 = __webpack_require__(0);\n/** @hidden */\nvar makeStub = function (keys) {\n    return keys.reduce(function (acc, key) { return (acc[key] = coreservices_1.notImplemented(key), acc); }, { dispose: common_1.noop });\n};\n/* tslint:disable:align */\n/** @hidden */ var locationServicesFns = ['url', 'path', 'search', 'hash', 'onChange'];\n/** @hidden */ var locationConfigFns = ['port', 'protocol', 'host', 'baseHref', 'html5Mode', 'hashPrefix'];\n/** @hidden */ var umfFns = ['type', 'caseInsensitive', 'strictMode', 'defaultSquashPolicy'];\n/** @hidden */ var rulesFns = ['sort', 'when', 'initial', 'otherwise', 'rules', 'rule', 'removeRule'];\n/** @hidden */ var syncFns = ['deferIntercept', 'listen', 'sync', 'match'];\n/* tslint:enable:align */\n/**\n * API for URL management\n */\nvar UrlService = /** @class */ (function () {\n    /** @hidden */\n    function UrlService(router, lateBind) {\n        if (lateBind === void 0) { lateBind = true; }\n        this.router = router;\n        this.rules = {};\n        this.config = {};\n        // proxy function calls from UrlService to the LocationService/LocationConfig\n        var locationServices = function () { return router.locationService; };\n        common_1.createProxyFunctions(locationServices, this, locationServices, locationServicesFns, lateBind);\n        var locationConfig = function () { return router.locationConfig; };\n        common_1.createProxyFunctions(locationConfig, this.config, locationConfig, locationConfigFns, lateBind);\n        var umf = function () { return router.urlMatcherFactory; };\n        common_1.createProxyFunctions(umf, this.config, umf, umfFns);\n        var urlRouter = function () { return router.urlRouter; };\n        common_1.createProxyFunctions(urlRouter, this.rules, urlRouter, rulesFns);\n        common_1.createProxyFunctions(urlRouter, this, urlRouter, syncFns);\n    }\n    UrlService.prototype.url = function (newurl, replace, state) { return; };\n    /** @inheritdoc */\n    UrlService.prototype.path = function () { return; };\n    /** @inheritdoc */\n    UrlService.prototype.search = function () { return; };\n    /** @inheritdoc */\n    UrlService.prototype.hash = function () { return; };\n    /** @inheritdoc */\n    UrlService.prototype.onChange = function (callback) { return; };\n    /**\n     * Returns the current URL parts\n     *\n     * This method returns the current URL components as a [[UrlParts]] object.\n     *\n     * @returns the current url parts\n     */\n    UrlService.prototype.parts = function () {\n        return { path: this.path(), search: this.search(), hash: this.hash() };\n    };\n    UrlService.prototype.dispose = function () { };\n    /** @inheritdoc */\n    UrlService.prototype.sync = function (evt) { return; };\n    /** @inheritdoc */\n    UrlService.prototype.listen = function (enabled) { return; };\n    /** @inheritdoc */\n    UrlService.prototype.deferIntercept = function (defer) { return; };\n    /** @inheritdoc */\n    UrlService.prototype.match = function (urlParts) { return; };\n    /** @hidden */\n    UrlService.locationServiceStub = makeStub(locationServicesFns);\n    /** @hidden */\n    UrlService.locationConfigStub = makeStub(locationConfigFns);\n    return UrlService;\n}());\nexports.UrlService = UrlService;\n//# sourceMappingURL=urlService.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3VybC91cmxTZXJ2aWNlLmpzP2I3M2YiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEBjb3JlYXBpXG4gKiBAbW9kdWxlIHVybFxuICovIC8qKiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGNvcmVzZXJ2aWNlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb3Jlc2VydmljZXNcIik7XG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcbi8qKiBAaGlkZGVuICovXG52YXIgbWFrZVN0dWIgPSBmdW5jdGlvbiAoa2V5cykge1xuICAgIHJldHVybiBrZXlzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBrZXkpIHsgcmV0dXJuIChhY2Nba2V5XSA9IGNvcmVzZXJ2aWNlc18xLm5vdEltcGxlbWVudGVkKGtleSksIGFjYyk7IH0sIHsgZGlzcG9zZTogY29tbW9uXzEubm9vcCB9KTtcbn07XG4vKiB0c2xpbnQ6ZGlzYWJsZTphbGlnbiAqL1xuLyoqIEBoaWRkZW4gKi8gdmFyIGxvY2F0aW9uU2VydmljZXNGbnMgPSBbJ3VybCcsICdwYXRoJywgJ3NlYXJjaCcsICdoYXNoJywgJ29uQ2hhbmdlJ107XG4vKiogQGhpZGRlbiAqLyB2YXIgbG9jYXRpb25Db25maWdGbnMgPSBbJ3BvcnQnLCAncHJvdG9jb2wnLCAnaG9zdCcsICdiYXNlSHJlZicsICdodG1sNU1vZGUnLCAnaGFzaFByZWZpeCddO1xuLyoqIEBoaWRkZW4gKi8gdmFyIHVtZkZucyA9IFsndHlwZScsICdjYXNlSW5zZW5zaXRpdmUnLCAnc3RyaWN0TW9kZScsICdkZWZhdWx0U3F1YXNoUG9saWN5J107XG4vKiogQGhpZGRlbiAqLyB2YXIgcnVsZXNGbnMgPSBbJ3NvcnQnLCAnd2hlbicsICdpbml0aWFsJywgJ290aGVyd2lzZScsICdydWxlcycsICdydWxlJywgJ3JlbW92ZVJ1bGUnXTtcbi8qKiBAaGlkZGVuICovIHZhciBzeW5jRm5zID0gWydkZWZlckludGVyY2VwdCcsICdsaXN0ZW4nLCAnc3luYycsICdtYXRjaCddO1xuLyogdHNsaW50OmVuYWJsZTphbGlnbiAqL1xuLyoqXG4gKiBBUEkgZm9yIFVSTCBtYW5hZ2VtZW50XG4gKi9cbnZhciBVcmxTZXJ2aWNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qKiBAaGlkZGVuICovXG4gICAgZnVuY3Rpb24gVXJsU2VydmljZShyb3V0ZXIsIGxhdGVCaW5kKSB7XG4gICAgICAgIGlmIChsYXRlQmluZCA9PT0gdm9pZCAwKSB7IGxhdGVCaW5kID0gdHJ1ZTsgfVxuICAgICAgICB0aGlzLnJvdXRlciA9IHJvdXRlcjtcbiAgICAgICAgdGhpcy5ydWxlcyA9IHt9O1xuICAgICAgICB0aGlzLmNvbmZpZyA9IHt9O1xuICAgICAgICAvLyBwcm94eSBmdW5jdGlvbiBjYWxscyBmcm9tIFVybFNlcnZpY2UgdG8gdGhlIExvY2F0aW9uU2VydmljZS9Mb2NhdGlvbkNvbmZpZ1xuICAgICAgICB2YXIgbG9jYXRpb25TZXJ2aWNlcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJvdXRlci5sb2NhdGlvblNlcnZpY2U7IH07XG4gICAgICAgIGNvbW1vbl8xLmNyZWF0ZVByb3h5RnVuY3Rpb25zKGxvY2F0aW9uU2VydmljZXMsIHRoaXMsIGxvY2F0aW9uU2VydmljZXMsIGxvY2F0aW9uU2VydmljZXNGbnMsIGxhdGVCaW5kKTtcbiAgICAgICAgdmFyIGxvY2F0aW9uQ29uZmlnID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcm91dGVyLmxvY2F0aW9uQ29uZmlnOyB9O1xuICAgICAgICBjb21tb25fMS5jcmVhdGVQcm94eUZ1bmN0aW9ucyhsb2NhdGlvbkNvbmZpZywgdGhpcy5jb25maWcsIGxvY2F0aW9uQ29uZmlnLCBsb2NhdGlvbkNvbmZpZ0ZucywgbGF0ZUJpbmQpO1xuICAgICAgICB2YXIgdW1mID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcm91dGVyLnVybE1hdGNoZXJGYWN0b3J5OyB9O1xuICAgICAgICBjb21tb25fMS5jcmVhdGVQcm94eUZ1bmN0aW9ucyh1bWYsIHRoaXMuY29uZmlnLCB1bWYsIHVtZkZucyk7XG4gICAgICAgIHZhciB1cmxSb3V0ZXIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiByb3V0ZXIudXJsUm91dGVyOyB9O1xuICAgICAgICBjb21tb25fMS5jcmVhdGVQcm94eUZ1bmN0aW9ucyh1cmxSb3V0ZXIsIHRoaXMucnVsZXMsIHVybFJvdXRlciwgcnVsZXNGbnMpO1xuICAgICAgICBjb21tb25fMS5jcmVhdGVQcm94eUZ1bmN0aW9ucyh1cmxSb3V0ZXIsIHRoaXMsIHVybFJvdXRlciwgc3luY0Zucyk7XG4gICAgfVxuICAgIFVybFNlcnZpY2UucHJvdG90eXBlLnVybCA9IGZ1bmN0aW9uIChuZXd1cmwsIHJlcGxhY2UsIHN0YXRlKSB7IHJldHVybjsgfTtcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBVcmxTZXJ2aWNlLnByb3RvdHlwZS5wYXRoID0gZnVuY3Rpb24gKCkgeyByZXR1cm47IH07XG4gICAgLyoqIEBpbmhlcml0ZG9jICovXG4gICAgVXJsU2VydmljZS5wcm90b3R5cGUuc2VhcmNoID0gZnVuY3Rpb24gKCkgeyByZXR1cm47IH07XG4gICAgLyoqIEBpbmhlcml0ZG9jICovXG4gICAgVXJsU2VydmljZS5wcm90b3R5cGUuaGFzaCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuOyB9O1xuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgIFVybFNlcnZpY2UucHJvdG90eXBlLm9uQ2hhbmdlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7IHJldHVybjsgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IFVSTCBwYXJ0c1xuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgY3VycmVudCBVUkwgY29tcG9uZW50cyBhcyBhIFtbVXJsUGFydHNdXSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB0aGUgY3VycmVudCB1cmwgcGFydHNcbiAgICAgKi9cbiAgICBVcmxTZXJ2aWNlLnByb3RvdHlwZS5wYXJ0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHsgcGF0aDogdGhpcy5wYXRoKCksIHNlYXJjaDogdGhpcy5zZWFyY2goKSwgaGFzaDogdGhpcy5oYXNoKCkgfTtcbiAgICB9O1xuICAgIFVybFNlcnZpY2UucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgLyoqIEBpbmhlcml0ZG9jICovXG4gICAgVXJsU2VydmljZS5wcm90b3R5cGUuc3luYyA9IGZ1bmN0aW9uIChldnQpIHsgcmV0dXJuOyB9O1xuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgIFVybFNlcnZpY2UucHJvdG90eXBlLmxpc3RlbiA9IGZ1bmN0aW9uIChlbmFibGVkKSB7IHJldHVybjsgfTtcbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBVcmxTZXJ2aWNlLnByb3RvdHlwZS5kZWZlckludGVyY2VwdCA9IGZ1bmN0aW9uIChkZWZlcikgeyByZXR1cm47IH07XG4gICAgLyoqIEBpbmhlcml0ZG9jICovXG4gICAgVXJsU2VydmljZS5wcm90b3R5cGUubWF0Y2ggPSBmdW5jdGlvbiAodXJsUGFydHMpIHsgcmV0dXJuOyB9O1xuICAgIC8qKiBAaGlkZGVuICovXG4gICAgVXJsU2VydmljZS5sb2NhdGlvblNlcnZpY2VTdHViID0gbWFrZVN0dWIobG9jYXRpb25TZXJ2aWNlc0Zucyk7XG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBVcmxTZXJ2aWNlLmxvY2F0aW9uQ29uZmlnU3R1YiA9IG1ha2VTdHViKGxvY2F0aW9uQ29uZmlnRm5zKTtcbiAgICByZXR1cm4gVXJsU2VydmljZTtcbn0oKSk7XG5leHBvcnRzLlVybFNlcnZpY2UgPSBVcmxTZXJ2aWNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXJsU2VydmljZS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvdXJsL3VybFNlcnZpY2UuanNcbi8vIG1vZHVsZSBpZCA9IDg1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///85\n")},function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar coreservices_1 = __webpack_require__(3);\n/**\n * A [[TransitionHookFn]] that performs lazy loading\n *\n * When entering a state \"abc\" which has a `lazyLoad` function defined:\n * - Invoke the `lazyLoad` function (unless it is already in process)\n *   - Flag the hook function as \"in process\"\n *   - The function should return a promise (that resolves when lazy loading is complete)\n * - Wait for the promise to settle\n *   - If the promise resolves to a [[LazyLoadResult]], then register those states\n *   - Flag the hook function as \"not in process\"\n * - If the hook was successful\n *   - Remove the `lazyLoad` function from the state declaration\n * - If all the hooks were successful\n *   - Retry the transition (by returning a TargetState)\n *\n * ```\n * .state('abc', {\n *   component: 'fooComponent',\n *   lazyLoad: () => System.import('./fooComponent')\n *   });\n * ```\n *\n * See [[StateDeclaration.lazyLoad]]\n */\nvar lazyLoadHook = function (transition) {\n    var router = transition.router;\n    function retryTransition() {\n        if (transition.originalTransition().options().source !== 'url') {\n            // The original transition was not triggered via url sync\n            // The lazy state should be loaded now, so re-try the original transition\n            var orig = transition.targetState();\n            return router.stateService.target(orig.identifier(), orig.params(), orig.options());\n        }\n        // The original transition was triggered via url sync\n        // Run the URL rules and find the best match\n        var $url = router.urlService;\n        var result = $url.match($url.parts());\n        var rule = result && result.rule;\n        // If the best match is a state, redirect the transition (instead\n        // of calling sync() which supersedes the current transition)\n        if (rule && rule.type === 'STATE') {\n            var state = rule.state;\n            var params = result.match;\n            return router.stateService.target(state, params, transition.options());\n        }\n        // No matching state found, so let .sync() choose the best non-state match/otherwise\n        router.urlService.sync();\n    }\n    var promises = transition.entering()\n        .filter(function (state) { return !!state.$$state().lazyLoad; })\n        .map(function (state) { return lazyLoadState(transition, state); });\n    return coreservices_1.services.$q.all(promises).then(retryTransition);\n};\nexports.registerLazyLoadHook = function (transitionService) {\n    return transitionService.onBefore({ entering: function (state) { return !!state.lazyLoad; } }, lazyLoadHook);\n};\n/**\n * Invokes a state's lazy load function\n *\n * @param transition a Transition context\n * @param state the state to lazy load\n * @returns A promise for the lazy load result\n */\nfunction lazyLoadState(transition, state) {\n    var lazyLoadFn = state.$$state().lazyLoad;\n    // Store/get the lazy load promise on/from the hookfn so it doesn't get re-invoked\n    var promise = lazyLoadFn['_promise'];\n    if (!promise) {\n        var success = function (result) {\n            delete state.lazyLoad;\n            delete state.$$state().lazyLoad;\n            delete lazyLoadFn['_promise'];\n            return result;\n        };\n        var error = function (err) {\n            delete lazyLoadFn['_promise'];\n            return coreservices_1.services.$q.reject(err);\n        };\n        promise = lazyLoadFn['_promise'] =\n            coreservices_1.services.$q.when(lazyLoadFn(transition, state))\n                .then(updateStateRegistry)\n                .then(success, error);\n    }\n    /** Register any lazy loaded state definitions */\n    function updateStateRegistry(result) {\n        if (result && Array.isArray(result.states)) {\n            result.states.forEach(function (_state) { return transition.router.stateRegistry.register(_state); });\n        }\n        return result;\n    }\n    return promise;\n}\nexports.lazyLoadState = lazyLoadState;\n//# sourceMappingURL=lazyLoad.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2hvb2tzL2xhenlMb2FkLmpzP2JkZDMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29yZXNlcnZpY2VzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvcmVzZXJ2aWNlc1wiKTtcbi8qKlxuICogQSBbW1RyYW5zaXRpb25Ib29rRm5dXSB0aGF0IHBlcmZvcm1zIGxhenkgbG9hZGluZ1xuICpcbiAqIFdoZW4gZW50ZXJpbmcgYSBzdGF0ZSBcImFiY1wiIHdoaWNoIGhhcyBhIGBsYXp5TG9hZGAgZnVuY3Rpb24gZGVmaW5lZDpcbiAqIC0gSW52b2tlIHRoZSBgbGF6eUxvYWRgIGZ1bmN0aW9uICh1bmxlc3MgaXQgaXMgYWxyZWFkeSBpbiBwcm9jZXNzKVxuICogICAtIEZsYWcgdGhlIGhvb2sgZnVuY3Rpb24gYXMgXCJpbiBwcm9jZXNzXCJcbiAqICAgLSBUaGUgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhIHByb21pc2UgKHRoYXQgcmVzb2x2ZXMgd2hlbiBsYXp5IGxvYWRpbmcgaXMgY29tcGxldGUpXG4gKiAtIFdhaXQgZm9yIHRoZSBwcm9taXNlIHRvIHNldHRsZVxuICogICAtIElmIHRoZSBwcm9taXNlIHJlc29sdmVzIHRvIGEgW1tMYXp5TG9hZFJlc3VsdF1dLCB0aGVuIHJlZ2lzdGVyIHRob3NlIHN0YXRlc1xuICogICAtIEZsYWcgdGhlIGhvb2sgZnVuY3Rpb24gYXMgXCJub3QgaW4gcHJvY2Vzc1wiXG4gKiAtIElmIHRoZSBob29rIHdhcyBzdWNjZXNzZnVsXG4gKiAgIC0gUmVtb3ZlIHRoZSBgbGF6eUxvYWRgIGZ1bmN0aW9uIGZyb20gdGhlIHN0YXRlIGRlY2xhcmF0aW9uXG4gKiAtIElmIGFsbCB0aGUgaG9va3Mgd2VyZSBzdWNjZXNzZnVsXG4gKiAgIC0gUmV0cnkgdGhlIHRyYW5zaXRpb24gKGJ5IHJldHVybmluZyBhIFRhcmdldFN0YXRlKVxuICpcbiAqIGBgYFxuICogLnN0YXRlKCdhYmMnLCB7XG4gKiAgIGNvbXBvbmVudDogJ2Zvb0NvbXBvbmVudCcsXG4gKiAgIGxhenlMb2FkOiAoKSA9PiBTeXN0ZW0uaW1wb3J0KCcuL2Zvb0NvbXBvbmVudCcpXG4gKiAgIH0pO1xuICogYGBgXG4gKlxuICogU2VlIFtbU3RhdGVEZWNsYXJhdGlvbi5sYXp5TG9hZF1dXG4gKi9cbnZhciBsYXp5TG9hZEhvb2sgPSBmdW5jdGlvbiAodHJhbnNpdGlvbikge1xuICAgIHZhciByb3V0ZXIgPSB0cmFuc2l0aW9uLnJvdXRlcjtcbiAgICBmdW5jdGlvbiByZXRyeVRyYW5zaXRpb24oKSB7XG4gICAgICAgIGlmICh0cmFuc2l0aW9uLm9yaWdpbmFsVHJhbnNpdGlvbigpLm9wdGlvbnMoKS5zb3VyY2UgIT09ICd1cmwnKSB7XG4gICAgICAgICAgICAvLyBUaGUgb3JpZ2luYWwgdHJhbnNpdGlvbiB3YXMgbm90IHRyaWdnZXJlZCB2aWEgdXJsIHN5bmNcbiAgICAgICAgICAgIC8vIFRoZSBsYXp5IHN0YXRlIHNob3VsZCBiZSBsb2FkZWQgbm93LCBzbyByZS10cnkgdGhlIG9yaWdpbmFsIHRyYW5zaXRpb25cbiAgICAgICAgICAgIHZhciBvcmlnID0gdHJhbnNpdGlvbi50YXJnZXRTdGF0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHJvdXRlci5zdGF0ZVNlcnZpY2UudGFyZ2V0KG9yaWcuaWRlbnRpZmllcigpLCBvcmlnLnBhcmFtcygpLCBvcmlnLm9wdGlvbnMoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIG9yaWdpbmFsIHRyYW5zaXRpb24gd2FzIHRyaWdnZXJlZCB2aWEgdXJsIHN5bmNcbiAgICAgICAgLy8gUnVuIHRoZSBVUkwgcnVsZXMgYW5kIGZpbmQgdGhlIGJlc3QgbWF0Y2hcbiAgICAgICAgdmFyICR1cmwgPSByb3V0ZXIudXJsU2VydmljZTtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICR1cmwubWF0Y2goJHVybC5wYXJ0cygpKTtcbiAgICAgICAgdmFyIHJ1bGUgPSByZXN1bHQgJiYgcmVzdWx0LnJ1bGU7XG4gICAgICAgIC8vIElmIHRoZSBiZXN0IG1hdGNoIGlzIGEgc3RhdGUsIHJlZGlyZWN0IHRoZSB0cmFuc2l0aW9uIChpbnN0ZWFkXG4gICAgICAgIC8vIG9mIGNhbGxpbmcgc3luYygpIHdoaWNoIHN1cGVyc2VkZXMgdGhlIGN1cnJlbnQgdHJhbnNpdGlvbilcbiAgICAgICAgaWYgKHJ1bGUgJiYgcnVsZS50eXBlID09PSAnU1RBVEUnKSB7XG4gICAgICAgICAgICB2YXIgc3RhdGUgPSBydWxlLnN0YXRlO1xuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IHJlc3VsdC5tYXRjaDtcbiAgICAgICAgICAgIHJldHVybiByb3V0ZXIuc3RhdGVTZXJ2aWNlLnRhcmdldChzdGF0ZSwgcGFyYW1zLCB0cmFuc2l0aW9uLm9wdGlvbnMoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm8gbWF0Y2hpbmcgc3RhdGUgZm91bmQsIHNvIGxldCAuc3luYygpIGNob29zZSB0aGUgYmVzdCBub24tc3RhdGUgbWF0Y2gvb3RoZXJ3aXNlXG4gICAgICAgIHJvdXRlci51cmxTZXJ2aWNlLnN5bmMoKTtcbiAgICB9XG4gICAgdmFyIHByb21pc2VzID0gdHJhbnNpdGlvbi5lbnRlcmluZygpXG4gICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHN0YXRlKSB7IHJldHVybiAhIXN0YXRlLiQkc3RhdGUoKS5sYXp5TG9hZDsgfSlcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoc3RhdGUpIHsgcmV0dXJuIGxhenlMb2FkU3RhdGUodHJhbnNpdGlvbiwgc3RhdGUpOyB9KTtcbiAgICByZXR1cm4gY29yZXNlcnZpY2VzXzEuc2VydmljZXMuJHEuYWxsKHByb21pc2VzKS50aGVuKHJldHJ5VHJhbnNpdGlvbik7XG59O1xuZXhwb3J0cy5yZWdpc3RlckxhenlMb2FkSG9vayA9IGZ1bmN0aW9uICh0cmFuc2l0aW9uU2VydmljZSkge1xuICAgIHJldHVybiB0cmFuc2l0aW9uU2VydmljZS5vbkJlZm9yZSh7IGVudGVyaW5nOiBmdW5jdGlvbiAoc3RhdGUpIHsgcmV0dXJuICEhc3RhdGUubGF6eUxvYWQ7IH0gfSwgbGF6eUxvYWRIb29rKTtcbn07XG4vKipcbiAqIEludm9rZXMgYSBzdGF0ZSdzIGxhenkgbG9hZCBmdW5jdGlvblxuICpcbiAqIEBwYXJhbSB0cmFuc2l0aW9uIGEgVHJhbnNpdGlvbiBjb250ZXh0XG4gKiBAcGFyYW0gc3RhdGUgdGhlIHN0YXRlIHRvIGxhenkgbG9hZFxuICogQHJldHVybnMgQSBwcm9taXNlIGZvciB0aGUgbGF6eSBsb2FkIHJlc3VsdFxuICovXG5mdW5jdGlvbiBsYXp5TG9hZFN0YXRlKHRyYW5zaXRpb24sIHN0YXRlKSB7XG4gICAgdmFyIGxhenlMb2FkRm4gPSBzdGF0ZS4kJHN0YXRlKCkubGF6eUxvYWQ7XG4gICAgLy8gU3RvcmUvZ2V0IHRoZSBsYXp5IGxvYWQgcHJvbWlzZSBvbi9mcm9tIHRoZSBob29rZm4gc28gaXQgZG9lc24ndCBnZXQgcmUtaW52b2tlZFxuICAgIHZhciBwcm9taXNlID0gbGF6eUxvYWRGblsnX3Byb21pc2UnXTtcbiAgICBpZiAoIXByb21pc2UpIHtcbiAgICAgICAgdmFyIHN1Y2Nlc3MgPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICBkZWxldGUgc3RhdGUubGF6eUxvYWQ7XG4gICAgICAgICAgICBkZWxldGUgc3RhdGUuJCRzdGF0ZSgpLmxhenlMb2FkO1xuICAgICAgICAgICAgZGVsZXRlIGxhenlMb2FkRm5bJ19wcm9taXNlJ107XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgICB2YXIgZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBkZWxldGUgbGF6eUxvYWRGblsnX3Byb21pc2UnXTtcbiAgICAgICAgICAgIHJldHVybiBjb3Jlc2VydmljZXNfMS5zZXJ2aWNlcy4kcS5yZWplY3QoZXJyKTtcbiAgICAgICAgfTtcbiAgICAgICAgcHJvbWlzZSA9IGxhenlMb2FkRm5bJ19wcm9taXNlJ10gPVxuICAgICAgICAgICAgY29yZXNlcnZpY2VzXzEuc2VydmljZXMuJHEud2hlbihsYXp5TG9hZEZuKHRyYW5zaXRpb24sIHN0YXRlKSlcbiAgICAgICAgICAgICAgICAudGhlbih1cGRhdGVTdGF0ZVJlZ2lzdHJ5KVxuICAgICAgICAgICAgICAgIC50aGVuKHN1Y2Nlc3MsIGVycm9yKTtcbiAgICB9XG4gICAgLyoqIFJlZ2lzdGVyIGFueSBsYXp5IGxvYWRlZCBzdGF0ZSBkZWZpbml0aW9ucyAqL1xuICAgIGZ1bmN0aW9uIHVwZGF0ZVN0YXRlUmVnaXN0cnkocmVzdWx0KSB7XG4gICAgICAgIGlmIChyZXN1bHQgJiYgQXJyYXkuaXNBcnJheShyZXN1bHQuc3RhdGVzKSkge1xuICAgICAgICAgICAgcmVzdWx0LnN0YXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChfc3RhdGUpIHsgcmV0dXJuIHRyYW5zaXRpb24ucm91dGVyLnN0YXRlUmVnaXN0cnkucmVnaXN0ZXIoX3N0YXRlKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIHByb21pc2U7XG59XG5leHBvcnRzLmxhenlMb2FkU3RhdGUgPSBsYXp5TG9hZFN0YXRlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGF6eUxvYWQuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2hvb2tzL2xhenlMb2FkLmpzXG4vLyBtb2R1bGUgaWQgPSA4NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///86\n")},function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\nvar transitionHook_1 = __webpack_require__(25);\n/**\n * This class defines a type of hook, such as `onBefore` or `onEnter`.\n * Plugins can define custom hook types, such as sticky states does for `onInactive`.\n *\n * @interalapi\n */\nvar TransitionEventType = /** @class */ (function () {\n    /* tslint:disable:no-inferrable-types */\n    function TransitionEventType(name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, synchronous) {\n        if (reverseSort === void 0) { reverseSort = false; }\n        if (getResultHandler === void 0) { getResultHandler = transitionHook_1.TransitionHook.HANDLE_RESULT; }\n        if (getErrorHandler === void 0) { getErrorHandler = transitionHook_1.TransitionHook.REJECT_ERROR; }\n        if (synchronous === void 0) { synchronous = false; }\n        this.name = name;\n        this.hookPhase = hookPhase;\n        this.hookOrder = hookOrder;\n        this.criteriaMatchPath = criteriaMatchPath;\n        this.reverseSort = reverseSort;\n        this.getResultHandler = getResultHandler;\n        this.getErrorHandler = getErrorHandler;\n        this.synchronous = synchronous;\n    }\n    return TransitionEventType;\n}());\nexports.TransitionEventType = TransitionEventType;\n//# sourceMappingURL=transitionEventType.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3RyYW5zaXRpb24vdHJhbnNpdGlvbkV2ZW50VHlwZS5qcz83NGFhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRyYW5zaXRpb25Ib29rXzEgPSByZXF1aXJlKFwiLi90cmFuc2l0aW9uSG9va1wiKTtcbi8qKlxuICogVGhpcyBjbGFzcyBkZWZpbmVzIGEgdHlwZSBvZiBob29rLCBzdWNoIGFzIGBvbkJlZm9yZWAgb3IgYG9uRW50ZXJgLlxuICogUGx1Z2lucyBjYW4gZGVmaW5lIGN1c3RvbSBob29rIHR5cGVzLCBzdWNoIGFzIHN0aWNreSBzdGF0ZXMgZG9lcyBmb3IgYG9uSW5hY3RpdmVgLlxuICpcbiAqIEBpbnRlcmFsYXBpXG4gKi9cbnZhciBUcmFuc2l0aW9uRXZlbnRUeXBlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8qIHRzbGludDpkaXNhYmxlOm5vLWluZmVycmFibGUtdHlwZXMgKi9cbiAgICBmdW5jdGlvbiBUcmFuc2l0aW9uRXZlbnRUeXBlKG5hbWUsIGhvb2tQaGFzZSwgaG9va09yZGVyLCBjcml0ZXJpYU1hdGNoUGF0aCwgcmV2ZXJzZVNvcnQsIGdldFJlc3VsdEhhbmRsZXIsIGdldEVycm9ySGFuZGxlciwgc3luY2hyb25vdXMpIHtcbiAgICAgICAgaWYgKHJldmVyc2VTb3J0ID09PSB2b2lkIDApIHsgcmV2ZXJzZVNvcnQgPSBmYWxzZTsgfVxuICAgICAgICBpZiAoZ2V0UmVzdWx0SGFuZGxlciA9PT0gdm9pZCAwKSB7IGdldFJlc3VsdEhhbmRsZXIgPSB0cmFuc2l0aW9uSG9va18xLlRyYW5zaXRpb25Ib29rLkhBTkRMRV9SRVNVTFQ7IH1cbiAgICAgICAgaWYgKGdldEVycm9ySGFuZGxlciA9PT0gdm9pZCAwKSB7IGdldEVycm9ySGFuZGxlciA9IHRyYW5zaXRpb25Ib29rXzEuVHJhbnNpdGlvbkhvb2suUkVKRUNUX0VSUk9SOyB9XG4gICAgICAgIGlmIChzeW5jaHJvbm91cyA9PT0gdm9pZCAwKSB7IHN5bmNocm9ub3VzID0gZmFsc2U7IH1cbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5ob29rUGhhc2UgPSBob29rUGhhc2U7XG4gICAgICAgIHRoaXMuaG9va09yZGVyID0gaG9va09yZGVyO1xuICAgICAgICB0aGlzLmNyaXRlcmlhTWF0Y2hQYXRoID0gY3JpdGVyaWFNYXRjaFBhdGg7XG4gICAgICAgIHRoaXMucmV2ZXJzZVNvcnQgPSByZXZlcnNlU29ydDtcbiAgICAgICAgdGhpcy5nZXRSZXN1bHRIYW5kbGVyID0gZ2V0UmVzdWx0SGFuZGxlcjtcbiAgICAgICAgdGhpcy5nZXRFcnJvckhhbmRsZXIgPSBnZXRFcnJvckhhbmRsZXI7XG4gICAgICAgIHRoaXMuc3luY2hyb25vdXMgPSBzeW5jaHJvbm91cztcbiAgICB9XG4gICAgcmV0dXJuIFRyYW5zaXRpb25FdmVudFR5cGU7XG59KCkpO1xuZXhwb3J0cy5UcmFuc2l0aW9uRXZlbnRUeXBlID0gVHJhbnNpdGlvbkV2ZW50VHlwZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRyYW5zaXRpb25FdmVudFR5cGUuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3RyYW5zaXRpb24vdHJhbnNpdGlvbkV2ZW50VHlwZS5qc1xuLy8gbW9kdWxlIGlkID0gODdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///87\n')},function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\nvar index_1 = __webpack_require__(5);\n/**\n * An angular1-like promise api\n *\n * This object implements four methods similar to the\n * [angular 1 promise api](https://docs.angularjs.org/api/ng/service/$q)\n *\n * UI-Router evolved from an angular 1 library to a framework agnostic library.\n * However, some of the `@uirouter/core` code uses these ng1 style APIs to support ng1 style dependency injection.\n *\n * This API provides native ES6 promise support wrapped as a $q-like API.\n * Internally, UI-Router uses this $q object to perform promise operations.\n * The `angular-ui-router` (ui-router for angular 1) uses the $q API provided by angular.\n *\n * $q-like promise api\n */\nexports.$q = {\n    /** Normalizes a value as a promise */\n    when: function (val) { return new Promise(function (resolve, reject) { return resolve(val); }); },\n    /** Normalizes a value as a promise rejection */\n    reject: function (val) { return new Promise(function (resolve, reject) { reject(val); }); },\n    /** @returns a deferred object, which has `resolve` and `reject` functions */\n    defer: function () {\n        var deferred = {};\n        deferred.promise = new Promise(function (resolve, reject) {\n            deferred.resolve = resolve;\n            deferred.reject = reject;\n        });\n        return deferred;\n    },\n    /** Like Promise.all(), but also supports object key/promise notation like $q */\n    all: function (promises) {\n        if (index_1.isArray(promises)) {\n            return Promise.all(promises);\n        }\n        if (index_1.isObject(promises)) {\n            // Convert promises map to promises array.\n            // When each promise resolves, map it to a tuple { key: key, val: val }\n            var chain = Object.keys(promises)\n                .map(function (key) { return promises[key].then(function (val) { return ({ key: key, val: val }); }); });\n            // Then wait for all promises to resolve, and convert them back to an object\n            return exports.$q.all(chain).then(function (values) {\n                return values.reduce(function (acc, tuple) { acc[tuple.key] = tuple.val; return acc; }, {});\n            });\n        }\n    },\n};\n//# sourceMappingURL=q.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3ZhbmlsbGEvcS5qcz8yOTUxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAaW50ZXJuYWxhcGlcbiAqIEBtb2R1bGUgdmFuaWxsYVxuICovXG4vKiogKi9cbnZhciBpbmRleF8xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9pbmRleFwiKTtcbi8qKlxuICogQW4gYW5ndWxhcjEtbGlrZSBwcm9taXNlIGFwaVxuICpcbiAqIFRoaXMgb2JqZWN0IGltcGxlbWVudHMgZm91ciBtZXRob2RzIHNpbWlsYXIgdG8gdGhlXG4gKiBbYW5ndWxhciAxIHByb21pc2UgYXBpXShodHRwczovL2RvY3MuYW5ndWxhcmpzLm9yZy9hcGkvbmcvc2VydmljZS8kcSlcbiAqXG4gKiBVSS1Sb3V0ZXIgZXZvbHZlZCBmcm9tIGFuIGFuZ3VsYXIgMSBsaWJyYXJ5IHRvIGEgZnJhbWV3b3JrIGFnbm9zdGljIGxpYnJhcnkuXG4gKiBIb3dldmVyLCBzb21lIG9mIHRoZSBgQHVpcm91dGVyL2NvcmVgIGNvZGUgdXNlcyB0aGVzZSBuZzEgc3R5bGUgQVBJcyB0byBzdXBwb3J0IG5nMSBzdHlsZSBkZXBlbmRlbmN5IGluamVjdGlvbi5cbiAqXG4gKiBUaGlzIEFQSSBwcm92aWRlcyBuYXRpdmUgRVM2IHByb21pc2Ugc3VwcG9ydCB3cmFwcGVkIGFzIGEgJHEtbGlrZSBBUEkuXG4gKiBJbnRlcm5hbGx5LCBVSS1Sb3V0ZXIgdXNlcyB0aGlzICRxIG9iamVjdCB0byBwZXJmb3JtIHByb21pc2Ugb3BlcmF0aW9ucy5cbiAqIFRoZSBgYW5ndWxhci11aS1yb3V0ZXJgICh1aS1yb3V0ZXIgZm9yIGFuZ3VsYXIgMSkgdXNlcyB0aGUgJHEgQVBJIHByb3ZpZGVkIGJ5IGFuZ3VsYXIuXG4gKlxuICogJHEtbGlrZSBwcm9taXNlIGFwaVxuICovXG5leHBvcnRzLiRxID0ge1xuICAgIC8qKiBOb3JtYWxpemVzIGEgdmFsdWUgYXMgYSBwcm9taXNlICovXG4gICAgd2hlbjogZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyByZXR1cm4gcmVzb2x2ZSh2YWwpOyB9KTsgfSxcbiAgICAvKiogTm9ybWFsaXplcyBhIHZhbHVlIGFzIGEgcHJvbWlzZSByZWplY3Rpb24gKi9cbiAgICByZWplY3Q6IGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgcmVqZWN0KHZhbCk7IH0pOyB9LFxuICAgIC8qKiBAcmV0dXJucyBhIGRlZmVycmVkIG9iamVjdCwgd2hpY2ggaGFzIGByZXNvbHZlYCBhbmQgYHJlamVjdGAgZnVuY3Rpb25zICovXG4gICAgZGVmZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRlZmVycmVkID0ge307XG4gICAgICAgIGRlZmVycmVkLnByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgICAgIGRlZmVycmVkLnJlamVjdCA9IHJlamVjdDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkZWZlcnJlZDtcbiAgICB9LFxuICAgIC8qKiBMaWtlIFByb21pc2UuYWxsKCksIGJ1dCBhbHNvIHN1cHBvcnRzIG9iamVjdCBrZXkvcHJvbWlzZSBub3RhdGlvbiBsaWtlICRxICovXG4gICAgYWxsOiBmdW5jdGlvbiAocHJvbWlzZXMpIHtcbiAgICAgICAgaWYgKGluZGV4XzEuaXNBcnJheShwcm9taXNlcykpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZGV4XzEuaXNPYmplY3QocHJvbWlzZXMpKSB7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHByb21pc2VzIG1hcCB0byBwcm9taXNlcyBhcnJheS5cbiAgICAgICAgICAgIC8vIFdoZW4gZWFjaCBwcm9taXNlIHJlc29sdmVzLCBtYXAgaXQgdG8gYSB0dXBsZSB7IGtleToga2V5LCB2YWw6IHZhbCB9XG4gICAgICAgICAgICB2YXIgY2hhaW4gPSBPYmplY3Qua2V5cyhwcm9taXNlcylcbiAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIHByb21pc2VzW2tleV0udGhlbihmdW5jdGlvbiAodmFsKSB7IHJldHVybiAoeyBrZXk6IGtleSwgdmFsOiB2YWwgfSk7IH0pOyB9KTtcbiAgICAgICAgICAgIC8vIFRoZW4gd2FpdCBmb3IgYWxsIHByb21pc2VzIHRvIHJlc29sdmUsIGFuZCBjb252ZXJ0IHRoZW0gYmFjayB0byBhbiBvYmplY3RcbiAgICAgICAgICAgIHJldHVybiBleHBvcnRzLiRxLmFsbChjaGFpbikudGhlbihmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgdHVwbGUpIHsgYWNjW3R1cGxlLmtleV0gPSB0dXBsZS52YWw7IHJldHVybiBhY2M7IH0sIHt9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1xLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi92YW5pbGxhL3EuanNcbi8vIG1vZHVsZSBpZCA9IDg4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///88\n')},function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\nvar index_1 = __webpack_require__(5);\n// globally available injectables\nvar globals = {};\nvar STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\nvar ARGUMENT_NAMES = /([^\\s,]+)/g;\n/**\n * A basic angular1-like injector api\n *\n * This object implements four methods similar to the\n * [angular 1 dependency injector](https://docs.angularjs.org/api/auto/service/$injector)\n *\n * UI-Router evolved from an angular 1 library to a framework agnostic library.\n * However, some of the `@uirouter/core` code uses these ng1 style APIs to support ng1 style dependency injection.\n *\n * This object provides a naive implementation of a globally scoped dependency injection system.\n * It supports the following DI approaches:\n *\n * ### Function parameter names\n *\n * A function's `.toString()` is called, and the parameter names are parsed.\n * This only works when the parameter names aren't \"mangled\" by a minifier such as UglifyJS.\n *\n * ```js\n * function injectedFunction(FooService, BarService) {\n *   // FooService and BarService are injected\n * }\n * ```\n *\n * ### Function annotation\n *\n * A function may be annotated with an array of dependency names as the `$inject` property.\n *\n * ```js\n * injectedFunction.$inject = [ 'FooService', 'BarService' ];\n * function injectedFunction(fs, bs) {\n *   // FooService and BarService are injected as fs and bs parameters\n * }\n * ```\n *\n * ### Array notation\n *\n * An array provides the names of the dependencies to inject (as strings).\n * The function is the last element of the array.\n *\n * ```js\n * [ 'FooService', 'BarService', function (fs, bs) {\n *   // FooService and BarService are injected as fs and bs parameters\n * }]\n * ```\n *\n * @type {$InjectorLike}\n */\nexports.$injector = {\n    /** Gets an object from DI based on a string token */\n    get: function (name) { return globals[name]; },\n    /** Returns true if an object named `name` exists in global DI */\n    has: function (name) { return exports.$injector.get(name) != null; },\n    /**\n     * Injects a function\n     *\n     * @param fn the function to inject\n     * @param context the function's `this` binding\n     * @param locals An object with additional DI tokens and values, such as `{ someToken: { foo: 1 } }`\n     */\n    invoke: function (fn, context, locals) {\n        var all = index_1.extend({}, globals, locals || {});\n        var params = exports.$injector.annotate(fn);\n        var ensureExist = index_1.assertPredicate(function (key) { return all.hasOwnProperty(key); }, function (key) { return \"DI can't find injectable: '\" + key + \"'\"; });\n        var args = params.filter(ensureExist).map(function (x) { return all[x]; });\n        if (index_1.isFunction(fn))\n            return fn.apply(context, args);\n        else\n            return fn.slice(-1)[0].apply(context, args);\n    },\n    /**\n     * Returns a function's dependencies\n     *\n     * Analyzes a function (or array) and returns an array of DI tokens that the function requires.\n     * @return an array of `string`s\n     */\n    annotate: function (fn) {\n        if (!index_1.isInjectable(fn))\n            throw new Error(\"Not an injectable function: \" + fn);\n        if (fn && fn.$inject)\n            return fn.$inject;\n        if (index_1.isArray(fn))\n            return fn.slice(0, -1);\n        var fnStr = fn.toString().replace(STRIP_COMMENTS, '');\n        var result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(ARGUMENT_NAMES);\n        return result || [];\n    },\n};\n//# sourceMappingURL=injector.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiODkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3ZhbmlsbGEvaW5qZWN0b3IuanM/YTA1NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGludGVybmFsYXBpXG4gKiBAbW9kdWxlIHZhbmlsbGFcbiAqL1xuLyoqICovXG52YXIgaW5kZXhfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vaW5kZXhcIik7XG4vLyBnbG9iYWxseSBhdmFpbGFibGUgaW5qZWN0YWJsZXNcbnZhciBnbG9iYWxzID0ge307XG52YXIgU1RSSVBfQ09NTUVOVFMgPSAvKChcXC9cXC8uKiQpfChcXC9cXCpbXFxzXFxTXSo/XFwqXFwvKSkvbWc7XG52YXIgQVJHVU1FTlRfTkFNRVMgPSAvKFteXFxzLF0rKS9nO1xuLyoqXG4gKiBBIGJhc2ljIGFuZ3VsYXIxLWxpa2UgaW5qZWN0b3IgYXBpXG4gKlxuICogVGhpcyBvYmplY3QgaW1wbGVtZW50cyBmb3VyIG1ldGhvZHMgc2ltaWxhciB0byB0aGVcbiAqIFthbmd1bGFyIDEgZGVwZW5kZW5jeSBpbmplY3Rvcl0oaHR0cHM6Ly9kb2NzLmFuZ3VsYXJqcy5vcmcvYXBpL2F1dG8vc2VydmljZS8kaW5qZWN0b3IpXG4gKlxuICogVUktUm91dGVyIGV2b2x2ZWQgZnJvbSBhbiBhbmd1bGFyIDEgbGlicmFyeSB0byBhIGZyYW1ld29yayBhZ25vc3RpYyBsaWJyYXJ5LlxuICogSG93ZXZlciwgc29tZSBvZiB0aGUgYEB1aXJvdXRlci9jb3JlYCBjb2RlIHVzZXMgdGhlc2UgbmcxIHN0eWxlIEFQSXMgdG8gc3VwcG9ydCBuZzEgc3R5bGUgZGVwZW5kZW5jeSBpbmplY3Rpb24uXG4gKlxuICogVGhpcyBvYmplY3QgcHJvdmlkZXMgYSBuYWl2ZSBpbXBsZW1lbnRhdGlvbiBvZiBhIGdsb2JhbGx5IHNjb3BlZCBkZXBlbmRlbmN5IGluamVjdGlvbiBzeXN0ZW0uXG4gKiBJdCBzdXBwb3J0cyB0aGUgZm9sbG93aW5nIERJIGFwcHJvYWNoZXM6XG4gKlxuICogIyMjIEZ1bmN0aW9uIHBhcmFtZXRlciBuYW1lc1xuICpcbiAqIEEgZnVuY3Rpb24ncyBgLnRvU3RyaW5nKClgIGlzIGNhbGxlZCwgYW5kIHRoZSBwYXJhbWV0ZXIgbmFtZXMgYXJlIHBhcnNlZC5cbiAqIFRoaXMgb25seSB3b3JrcyB3aGVuIHRoZSBwYXJhbWV0ZXIgbmFtZXMgYXJlbid0IFwibWFuZ2xlZFwiIGJ5IGEgbWluaWZpZXIgc3VjaCBhcyBVZ2xpZnlKUy5cbiAqXG4gKiBgYGBqc1xuICogZnVuY3Rpb24gaW5qZWN0ZWRGdW5jdGlvbihGb29TZXJ2aWNlLCBCYXJTZXJ2aWNlKSB7XG4gKiAgIC8vIEZvb1NlcnZpY2UgYW5kIEJhclNlcnZpY2UgYXJlIGluamVjdGVkXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiAjIyMgRnVuY3Rpb24gYW5ub3RhdGlvblxuICpcbiAqIEEgZnVuY3Rpb24gbWF5IGJlIGFubm90YXRlZCB3aXRoIGFuIGFycmF5IG9mIGRlcGVuZGVuY3kgbmFtZXMgYXMgdGhlIGAkaW5qZWN0YCBwcm9wZXJ0eS5cbiAqXG4gKiBgYGBqc1xuICogaW5qZWN0ZWRGdW5jdGlvbi4kaW5qZWN0ID0gWyAnRm9vU2VydmljZScsICdCYXJTZXJ2aWNlJyBdO1xuICogZnVuY3Rpb24gaW5qZWN0ZWRGdW5jdGlvbihmcywgYnMpIHtcbiAqICAgLy8gRm9vU2VydmljZSBhbmQgQmFyU2VydmljZSBhcmUgaW5qZWN0ZWQgYXMgZnMgYW5kIGJzIHBhcmFtZXRlcnNcbiAqIH1cbiAqIGBgYFxuICpcbiAqICMjIyBBcnJheSBub3RhdGlvblxuICpcbiAqIEFuIGFycmF5IHByb3ZpZGVzIHRoZSBuYW1lcyBvZiB0aGUgZGVwZW5kZW5jaWVzIHRvIGluamVjdCAoYXMgc3RyaW5ncykuXG4gKiBUaGUgZnVuY3Rpb24gaXMgdGhlIGxhc3QgZWxlbWVudCBvZiB0aGUgYXJyYXkuXG4gKlxuICogYGBganNcbiAqIFsgJ0Zvb1NlcnZpY2UnLCAnQmFyU2VydmljZScsIGZ1bmN0aW9uIChmcywgYnMpIHtcbiAqICAgLy8gRm9vU2VydmljZSBhbmQgQmFyU2VydmljZSBhcmUgaW5qZWN0ZWQgYXMgZnMgYW5kIGJzIHBhcmFtZXRlcnNcbiAqIH1dXG4gKiBgYGBcbiAqXG4gKiBAdHlwZSB7JEluamVjdG9yTGlrZX1cbiAqL1xuZXhwb3J0cy4kaW5qZWN0b3IgPSB7XG4gICAgLyoqIEdldHMgYW4gb2JqZWN0IGZyb20gREkgYmFzZWQgb24gYSBzdHJpbmcgdG9rZW4gKi9cbiAgICBnZXQ6IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBnbG9iYWxzW25hbWVdOyB9LFxuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgYW4gb2JqZWN0IG5hbWVkIGBuYW1lYCBleGlzdHMgaW4gZ2xvYmFsIERJICovXG4gICAgaGFzOiBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gZXhwb3J0cy4kaW5qZWN0b3IuZ2V0KG5hbWUpICE9IG51bGw7IH0sXG4gICAgLyoqXG4gICAgICogSW5qZWN0cyBhIGZ1bmN0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZm4gdGhlIGZ1bmN0aW9uIHRvIGluamVjdFxuICAgICAqIEBwYXJhbSBjb250ZXh0IHRoZSBmdW5jdGlvbidzIGB0aGlzYCBiaW5kaW5nXG4gICAgICogQHBhcmFtIGxvY2FscyBBbiBvYmplY3Qgd2l0aCBhZGRpdGlvbmFsIERJIHRva2VucyBhbmQgdmFsdWVzLCBzdWNoIGFzIGB7IHNvbWVUb2tlbjogeyBmb286IDEgfSB9YFxuICAgICAqL1xuICAgIGludm9rZTogZnVuY3Rpb24gKGZuLCBjb250ZXh0LCBsb2NhbHMpIHtcbiAgICAgICAgdmFyIGFsbCA9IGluZGV4XzEuZXh0ZW5kKHt9LCBnbG9iYWxzLCBsb2NhbHMgfHwge30pO1xuICAgICAgICB2YXIgcGFyYW1zID0gZXhwb3J0cy4kaW5qZWN0b3IuYW5ub3RhdGUoZm4pO1xuICAgICAgICB2YXIgZW5zdXJlRXhpc3QgPSBpbmRleF8xLmFzc2VydFByZWRpY2F0ZShmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBhbGwuaGFzT3duUHJvcGVydHkoa2V5KTsgfSwgZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gXCJESSBjYW4ndCBmaW5kIGluamVjdGFibGU6ICdcIiArIGtleSArIFwiJ1wiOyB9KTtcbiAgICAgICAgdmFyIGFyZ3MgPSBwYXJhbXMuZmlsdGVyKGVuc3VyZUV4aXN0KS5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIGFsbFt4XTsgfSk7XG4gICAgICAgIGlmIChpbmRleF8xLmlzRnVuY3Rpb24oZm4pKVxuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gZm4uc2xpY2UoLTEpWzBdLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGZ1bmN0aW9uJ3MgZGVwZW5kZW5jaWVzXG4gICAgICpcbiAgICAgKiBBbmFseXplcyBhIGZ1bmN0aW9uIChvciBhcnJheSkgYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgREkgdG9rZW5zIHRoYXQgdGhlIGZ1bmN0aW9uIHJlcXVpcmVzLlxuICAgICAqIEByZXR1cm4gYW4gYXJyYXkgb2YgYHN0cmluZ2BzXG4gICAgICovXG4gICAgYW5ub3RhdGU6IGZ1bmN0aW9uIChmbikge1xuICAgICAgICBpZiAoIWluZGV4XzEuaXNJbmplY3RhYmxlKGZuKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBhbiBpbmplY3RhYmxlIGZ1bmN0aW9uOiBcIiArIGZuKTtcbiAgICAgICAgaWYgKGZuICYmIGZuLiRpbmplY3QpXG4gICAgICAgICAgICByZXR1cm4gZm4uJGluamVjdDtcbiAgICAgICAgaWYgKGluZGV4XzEuaXNBcnJheShmbikpXG4gICAgICAgICAgICByZXR1cm4gZm4uc2xpY2UoMCwgLTEpO1xuICAgICAgICB2YXIgZm5TdHIgPSBmbi50b1N0cmluZygpLnJlcGxhY2UoU1RSSVBfQ09NTUVOVFMsICcnKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGZuU3RyLnNsaWNlKGZuU3RyLmluZGV4T2YoJygnKSArIDEsIGZuU3RyLmluZGV4T2YoJyknKSkubWF0Y2goQVJHVU1FTlRfTkFNRVMpO1xuICAgICAgICByZXR1cm4gcmVzdWx0IHx8IFtdO1xuICAgIH0sXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5qZWN0b3IuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3ZhbmlsbGEvaW5qZWN0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDg5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///89\n")},function(module,exports,__webpack_require__){"use strict";eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\nvar common_1 = __webpack_require__(5);\nvar baseLocationService_1 = __webpack_require__(33);\n/** A `LocationServices` that uses the browser hash \"#\" to get/set the current location */\nvar HashLocationService = /** @class */ (function (_super) {\n    __extends(HashLocationService, _super);\n    function HashLocationService(router) {\n        var _this = _super.call(this, router, false) || this;\n        common_1.root.addEventListener('hashchange', _this._listener, false);\n        return _this;\n    }\n    HashLocationService.prototype._get = function () {\n        return common_1.trimHashVal(this._location.hash);\n    };\n    HashLocationService.prototype._set = function (state, title, url, replace) {\n        this._location.hash = url;\n    };\n    HashLocationService.prototype.dispose = function (router) {\n        _super.prototype.dispose.call(this, router);\n        common_1.root.removeEventListener('hashchange', this._listener);\n    };\n    return HashLocationService;\n}(baseLocationService_1.BaseLocationServices));\nexports.HashLocationService = HashLocationService;\n//# sourceMappingURL=hashLocationService.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3ZhbmlsbGEvaGFzaExvY2F0aW9uU2VydmljZS5qcz9mOTMxIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEBpbnRlcm5hbGFwaVxuICogQG1vZHVsZSB2YW5pbGxhXG4gKi9cbi8qKiAqL1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vblwiKTtcbnZhciBiYXNlTG9jYXRpb25TZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi9iYXNlTG9jYXRpb25TZXJ2aWNlXCIpO1xuLyoqIEEgYExvY2F0aW9uU2VydmljZXNgIHRoYXQgdXNlcyB0aGUgYnJvd3NlciBoYXNoIFwiI1wiIHRvIGdldC9zZXQgdGhlIGN1cnJlbnQgbG9jYXRpb24gKi9cbnZhciBIYXNoTG9jYXRpb25TZXJ2aWNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhIYXNoTG9jYXRpb25TZXJ2aWNlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEhhc2hMb2NhdGlvblNlcnZpY2Uocm91dGVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHJvdXRlciwgZmFsc2UpIHx8IHRoaXM7XG4gICAgICAgIGNvbW1vbl8xLnJvb3QuYWRkRXZlbnRMaXN0ZW5lcignaGFzaGNoYW5nZScsIF90aGlzLl9saXN0ZW5lciwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEhhc2hMb2NhdGlvblNlcnZpY2UucHJvdG90eXBlLl9nZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjb21tb25fMS50cmltSGFzaFZhbCh0aGlzLl9sb2NhdGlvbi5oYXNoKTtcbiAgICB9O1xuICAgIEhhc2hMb2NhdGlvblNlcnZpY2UucHJvdG90eXBlLl9zZXQgPSBmdW5jdGlvbiAoc3RhdGUsIHRpdGxlLCB1cmwsIHJlcGxhY2UpIHtcbiAgICAgICAgdGhpcy5fbG9jYXRpb24uaGFzaCA9IHVybDtcbiAgICB9O1xuICAgIEhhc2hMb2NhdGlvblNlcnZpY2UucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAocm91dGVyKSB7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMsIHJvdXRlcik7XG4gICAgICAgIGNvbW1vbl8xLnJvb3QucmVtb3ZlRXZlbnRMaXN0ZW5lcignaGFzaGNoYW5nZScsIHRoaXMuX2xpc3RlbmVyKTtcbiAgICB9O1xuICAgIHJldHVybiBIYXNoTG9jYXRpb25TZXJ2aWNlO1xufShiYXNlTG9jYXRpb25TZXJ2aWNlXzEuQmFzZUxvY2F0aW9uU2VydmljZXMpKTtcbmV4cG9ydHMuSGFzaExvY2F0aW9uU2VydmljZSA9IEhhc2hMb2NhdGlvblNlcnZpY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYXNoTG9jYXRpb25TZXJ2aWNlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi92YW5pbGxhL2hhc2hMb2NhdGlvblNlcnZpY2UuanNcbi8vIG1vZHVsZSBpZCA9IDkwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///90\n")},function(module,exports,__webpack_require__){"use strict";eval('\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, "__esModule", { value: true });\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\nvar baseLocationService_1 = __webpack_require__(33);\n/** A `LocationServices` that gets/sets the current location from an in-memory object */\nvar MemoryLocationService = /** @class */ (function (_super) {\n    __extends(MemoryLocationService, _super);\n    function MemoryLocationService(router) {\n        return _super.call(this, router, true) || this;\n    }\n    MemoryLocationService.prototype._get = function () {\n        return this._url;\n    };\n    MemoryLocationService.prototype._set = function (state, title, url, replace) {\n        this._url = url;\n    };\n    return MemoryLocationService;\n}(baseLocationService_1.BaseLocationServices));\nexports.MemoryLocationService = MemoryLocationService;\n//# sourceMappingURL=memoryLocationService.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3ZhbmlsbGEvbWVtb3J5TG9jYXRpb25TZXJ2aWNlLmpzPzE2OTgiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGludGVybmFsYXBpXG4gKiBAbW9kdWxlIHZhbmlsbGFcbiAqL1xuLyoqICovXG52YXIgYmFzZUxvY2F0aW9uU2VydmljZV8xID0gcmVxdWlyZShcIi4vYmFzZUxvY2F0aW9uU2VydmljZVwiKTtcbi8qKiBBIGBMb2NhdGlvblNlcnZpY2VzYCB0aGF0IGdldHMvc2V0cyB0aGUgY3VycmVudCBsb2NhdGlvbiBmcm9tIGFuIGluLW1lbW9yeSBvYmplY3QgKi9cbnZhciBNZW1vcnlMb2NhdGlvblNlcnZpY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1lbW9yeUxvY2F0aW9uU2VydmljZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZW1vcnlMb2NhdGlvblNlcnZpY2Uocm91dGVyKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCByb3V0ZXIsIHRydWUpIHx8IHRoaXM7XG4gICAgfVxuICAgIE1lbW9yeUxvY2F0aW9uU2VydmljZS5wcm90b3R5cGUuX2dldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3VybDtcbiAgICB9O1xuICAgIE1lbW9yeUxvY2F0aW9uU2VydmljZS5wcm90b3R5cGUuX3NldCA9IGZ1bmN0aW9uIChzdGF0ZSwgdGl0bGUsIHVybCwgcmVwbGFjZSkge1xuICAgICAgICB0aGlzLl91cmwgPSB1cmw7XG4gICAgfTtcbiAgICByZXR1cm4gTWVtb3J5TG9jYXRpb25TZXJ2aWNlO1xufShiYXNlTG9jYXRpb25TZXJ2aWNlXzEuQmFzZUxvY2F0aW9uU2VydmljZXMpKTtcbmV4cG9ydHMuTWVtb3J5TG9jYXRpb25TZXJ2aWNlID0gTWVtb3J5TG9jYXRpb25TZXJ2aWNlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVtb3J5TG9jYXRpb25TZXJ2aWNlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi92YW5pbGxhL21lbW9yeUxvY2F0aW9uU2VydmljZS5qc1xuLy8gbW9kdWxlIGlkID0gOTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///91\n')},function(module,exports,__webpack_require__){"use strict";eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar baseLocationService_1 = __webpack_require__(33);\nvar common_1 = __webpack_require__(5);\n/**\n * A `LocationServices` that gets/sets the current location using the browser's `location` and `history` apis\n *\n * Uses `history.pushState` and `history.replaceState`\n */\nvar PushStateLocationService = /** @class */ (function (_super) {\n    __extends(PushStateLocationService, _super);\n    function PushStateLocationService(router) {\n        var _this = _super.call(this, router, true) || this;\n        _this._config = router.urlService.config;\n        common_1.root.addEventListener('popstate', _this._listener, false);\n        return _this;\n    }\n    /**\n     * Gets the base prefix without:\n     * - trailing slash\n     * - trailing filename\n     * - protocol and hostname\n     *\n     * If <base href='/base/'>, this returns '/base'.\n     * If <base href='/foo/base/'>, this returns '/foo/base'.\n     * If <base href='/base/index.html'>, this returns '/base'.\n     * If <base href='http://localhost:8080/base/index.html'>, this returns '/base'.\n     * If <base href='/base'>, this returns ''.\n     * If <base href='http://localhost:8080'>, this returns ''.\n     * If <base href='http://localhost:8080/'>, this returns ''.\n     *\n     * See: https://html.spec.whatwg.org/dev/semantics.html#the-base-element\n     */\n    PushStateLocationService.prototype._getBasePrefix = function () {\n        return common_1.stripLastPathElement(this._config.baseHref());\n    };\n    PushStateLocationService.prototype._get = function () {\n        var _a = this._location, pathname = _a.pathname, hash = _a.hash, search = _a.search;\n        search = common_1.splitQuery(search)[1]; // strip ? if found\n        hash = common_1.splitHash(hash)[1]; // strip # if found\n        var basePrefix = this._getBasePrefix();\n        var exactBaseHrefMatch = pathname === this._config.baseHref();\n        var startsWithBase = pathname.substr(0, basePrefix.length) === basePrefix;\n        pathname = exactBaseHrefMatch ? '/' : startsWithBase ? pathname.substring(basePrefix.length) : pathname;\n        return pathname + (search ? '?' + search : '') + (hash ? '#' + hash : '');\n    };\n    PushStateLocationService.prototype._set = function (state, title, url, replace) {\n        var basePrefix = this._getBasePrefix();\n        var slash = url && url[0] !== '/' ? '/' : '';\n        var fullUrl = (url === '' || url === '/') ? this._config.baseHref() : basePrefix + slash + url;\n        if (replace) {\n            this._history.replaceState(state, title, fullUrl);\n        }\n        else {\n            this._history.pushState(state, title, fullUrl);\n        }\n    };\n    PushStateLocationService.prototype.dispose = function (router) {\n        _super.prototype.dispose.call(this, router);\n        common_1.root.removeEventListener('popstate', this._listener);\n    };\n    return PushStateLocationService;\n}(baseLocationService_1.BaseLocationServices));\nexports.PushStateLocationService = PushStateLocationService;\n//# sourceMappingURL=pushStateLocationService.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3ZhbmlsbGEvcHVzaFN0YXRlTG9jYXRpb25TZXJ2aWNlLmpzPzE0MGMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBiYXNlTG9jYXRpb25TZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi9iYXNlTG9jYXRpb25TZXJ2aWNlXCIpO1xudmFyIGNvbW1vbl8xID0gcmVxdWlyZShcIi4uL2NvbW1vblwiKTtcbi8qKlxuICogQSBgTG9jYXRpb25TZXJ2aWNlc2AgdGhhdCBnZXRzL3NldHMgdGhlIGN1cnJlbnQgbG9jYXRpb24gdXNpbmcgdGhlIGJyb3dzZXIncyBgbG9jYXRpb25gIGFuZCBgaGlzdG9yeWAgYXBpc1xuICpcbiAqIFVzZXMgYGhpc3RvcnkucHVzaFN0YXRlYCBhbmQgYGhpc3RvcnkucmVwbGFjZVN0YXRlYFxuICovXG52YXIgUHVzaFN0YXRlTG9jYXRpb25TZXJ2aWNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQdXNoU3RhdGVMb2NhdGlvblNlcnZpY2UsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUHVzaFN0YXRlTG9jYXRpb25TZXJ2aWNlKHJvdXRlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCByb3V0ZXIsIHRydWUpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLl9jb25maWcgPSByb3V0ZXIudXJsU2VydmljZS5jb25maWc7XG4gICAgICAgIGNvbW1vbl8xLnJvb3QuYWRkRXZlbnRMaXN0ZW5lcigncG9wc3RhdGUnLCBfdGhpcy5fbGlzdGVuZXIsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBiYXNlIHByZWZpeCB3aXRob3V0OlxuICAgICAqIC0gdHJhaWxpbmcgc2xhc2hcbiAgICAgKiAtIHRyYWlsaW5nIGZpbGVuYW1lXG4gICAgICogLSBwcm90b2NvbCBhbmQgaG9zdG5hbWVcbiAgICAgKlxuICAgICAqIElmIDxiYXNlIGhyZWY9Jy9iYXNlLyc+LCB0aGlzIHJldHVybnMgJy9iYXNlJy5cbiAgICAgKiBJZiA8YmFzZSBocmVmPScvZm9vL2Jhc2UvJz4sIHRoaXMgcmV0dXJucyAnL2Zvby9iYXNlJy5cbiAgICAgKiBJZiA8YmFzZSBocmVmPScvYmFzZS9pbmRleC5odG1sJz4sIHRoaXMgcmV0dXJucyAnL2Jhc2UnLlxuICAgICAqIElmIDxiYXNlIGhyZWY9J2h0dHA6Ly9sb2NhbGhvc3Q6ODA4MC9iYXNlL2luZGV4Lmh0bWwnPiwgdGhpcyByZXR1cm5zICcvYmFzZScuXG4gICAgICogSWYgPGJhc2UgaHJlZj0nL2Jhc2UnPiwgdGhpcyByZXR1cm5zICcnLlxuICAgICAqIElmIDxiYXNlIGhyZWY9J2h0dHA6Ly9sb2NhbGhvc3Q6ODA4MCc+LCB0aGlzIHJldHVybnMgJycuXG4gICAgICogSWYgPGJhc2UgaHJlZj0naHR0cDovL2xvY2FsaG9zdDo4MDgwLyc+LCB0aGlzIHJldHVybnMgJycuXG4gICAgICpcbiAgICAgKiBTZWU6IGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvZGV2L3NlbWFudGljcy5odG1sI3RoZS1iYXNlLWVsZW1lbnRcbiAgICAgKi9cbiAgICBQdXNoU3RhdGVMb2NhdGlvblNlcnZpY2UucHJvdG90eXBlLl9nZXRCYXNlUHJlZml4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gY29tbW9uXzEuc3RyaXBMYXN0UGF0aEVsZW1lbnQodGhpcy5fY29uZmlnLmJhc2VIcmVmKCkpO1xuICAgIH07XG4gICAgUHVzaFN0YXRlTG9jYXRpb25TZXJ2aWNlLnByb3RvdHlwZS5fZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLl9sb2NhdGlvbiwgcGF0aG5hbWUgPSBfYS5wYXRobmFtZSwgaGFzaCA9IF9hLmhhc2gsIHNlYXJjaCA9IF9hLnNlYXJjaDtcbiAgICAgICAgc2VhcmNoID0gY29tbW9uXzEuc3BsaXRRdWVyeShzZWFyY2gpWzFdOyAvLyBzdHJpcCA/IGlmIGZvdW5kXG4gICAgICAgIGhhc2ggPSBjb21tb25fMS5zcGxpdEhhc2goaGFzaClbMV07IC8vIHN0cmlwICMgaWYgZm91bmRcbiAgICAgICAgdmFyIGJhc2VQcmVmaXggPSB0aGlzLl9nZXRCYXNlUHJlZml4KCk7XG4gICAgICAgIHZhciBleGFjdEJhc2VIcmVmTWF0Y2ggPSBwYXRobmFtZSA9PT0gdGhpcy5fY29uZmlnLmJhc2VIcmVmKCk7XG4gICAgICAgIHZhciBzdGFydHNXaXRoQmFzZSA9IHBhdGhuYW1lLnN1YnN0cigwLCBiYXNlUHJlZml4Lmxlbmd0aCkgPT09IGJhc2VQcmVmaXg7XG4gICAgICAgIHBhdGhuYW1lID0gZXhhY3RCYXNlSHJlZk1hdGNoID8gJy8nIDogc3RhcnRzV2l0aEJhc2UgPyBwYXRobmFtZS5zdWJzdHJpbmcoYmFzZVByZWZpeC5sZW5ndGgpIDogcGF0aG5hbWU7XG4gICAgICAgIHJldHVybiBwYXRobmFtZSArIChzZWFyY2ggPyAnPycgKyBzZWFyY2ggOiAnJykgKyAoaGFzaCA/ICcjJyArIGhhc2ggOiAnJyk7XG4gICAgfTtcbiAgICBQdXNoU3RhdGVMb2NhdGlvblNlcnZpY2UucHJvdG90eXBlLl9zZXQgPSBmdW5jdGlvbiAoc3RhdGUsIHRpdGxlLCB1cmwsIHJlcGxhY2UpIHtcbiAgICAgICAgdmFyIGJhc2VQcmVmaXggPSB0aGlzLl9nZXRCYXNlUHJlZml4KCk7XG4gICAgICAgIHZhciBzbGFzaCA9IHVybCAmJiB1cmxbMF0gIT09ICcvJyA/ICcvJyA6ICcnO1xuICAgICAgICB2YXIgZnVsbFVybCA9ICh1cmwgPT09ICcnIHx8IHVybCA9PT0gJy8nKSA/IHRoaXMuX2NvbmZpZy5iYXNlSHJlZigpIDogYmFzZVByZWZpeCArIHNsYXNoICsgdXJsO1xuICAgICAgICBpZiAocmVwbGFjZSkge1xuICAgICAgICAgICAgdGhpcy5faGlzdG9yeS5yZXBsYWNlU3RhdGUoc3RhdGUsIHRpdGxlLCBmdWxsVXJsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2hpc3RvcnkucHVzaFN0YXRlKHN0YXRlLCB0aXRsZSwgZnVsbFVybCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFB1c2hTdGF0ZUxvY2F0aW9uU2VydmljZS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uIChyb3V0ZXIpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcywgcm91dGVyKTtcbiAgICAgICAgY29tbW9uXzEucm9vdC5yZW1vdmVFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIHRoaXMuX2xpc3RlbmVyKTtcbiAgICB9O1xuICAgIHJldHVybiBQdXNoU3RhdGVMb2NhdGlvblNlcnZpY2U7XG59KGJhc2VMb2NhdGlvblNlcnZpY2VfMS5CYXNlTG9jYXRpb25TZXJ2aWNlcykpO1xuZXhwb3J0cy5QdXNoU3RhdGVMb2NhdGlvblNlcnZpY2UgPSBQdXNoU3RhdGVMb2NhdGlvblNlcnZpY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wdXNoU3RhdGVMb2NhdGlvblNlcnZpY2UuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3ZhbmlsbGEvcHVzaFN0YXRlTG9jYXRpb25TZXJ2aWNlLmpzXG4vLyBtb2R1bGUgaWQgPSA5MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///92\n")},function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar predicates_1 = __webpack_require__(1);\nvar common_1 = __webpack_require__(0);\n/** A `LocationConfig` mock that gets/sets all config from an in-memory object */\nvar MemoryLocationConfig = /** @class */ (function () {\n    function MemoryLocationConfig() {\n        var _this = this;\n        this.dispose = common_1.noop;\n        this._baseHref = '';\n        this._port = 80;\n        this._protocol = 'http';\n        this._host = 'localhost';\n        this._hashPrefix = '';\n        this.port = function () { return _this._port; };\n        this.protocol = function () { return _this._protocol; };\n        this.host = function () { return _this._host; };\n        this.baseHref = function () { return _this._baseHref; };\n        this.html5Mode = function () { return false; };\n        this.hashPrefix = function (newval) { return predicates_1.isDefined(newval) ? _this._hashPrefix = newval : _this._hashPrefix; };\n    }\n    return MemoryLocationConfig;\n}());\nexports.MemoryLocationConfig = MemoryLocationConfig;\n//# sourceMappingURL=memoryLocationConfig.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3ZhbmlsbGEvbWVtb3J5TG9jYXRpb25Db25maWcuanM/ZDBkNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBwcmVkaWNhdGVzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3ByZWRpY2F0ZXNcIik7XG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcbi8qKiBBIGBMb2NhdGlvbkNvbmZpZ2AgbW9jayB0aGF0IGdldHMvc2V0cyBhbGwgY29uZmlnIGZyb20gYW4gaW4tbWVtb3J5IG9iamVjdCAqL1xudmFyIE1lbW9yeUxvY2F0aW9uQ29uZmlnID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1lbW9yeUxvY2F0aW9uQ29uZmlnKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmRpc3Bvc2UgPSBjb21tb25fMS5ub29wO1xuICAgICAgICB0aGlzLl9iYXNlSHJlZiA9ICcnO1xuICAgICAgICB0aGlzLl9wb3J0ID0gODA7XG4gICAgICAgIHRoaXMuX3Byb3RvY29sID0gJ2h0dHAnO1xuICAgICAgICB0aGlzLl9ob3N0ID0gJ2xvY2FsaG9zdCc7XG4gICAgICAgIHRoaXMuX2hhc2hQcmVmaXggPSAnJztcbiAgICAgICAgdGhpcy5wb3J0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX3BvcnQ7IH07XG4gICAgICAgIHRoaXMucHJvdG9jb2wgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fcHJvdG9jb2w7IH07XG4gICAgICAgIHRoaXMuaG9zdCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9ob3N0OyB9O1xuICAgICAgICB0aGlzLmJhc2VIcmVmID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX2Jhc2VIcmVmOyB9O1xuICAgICAgICB0aGlzLmh0bWw1TW9kZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZhbHNlOyB9O1xuICAgICAgICB0aGlzLmhhc2hQcmVmaXggPSBmdW5jdGlvbiAobmV3dmFsKSB7IHJldHVybiBwcmVkaWNhdGVzXzEuaXNEZWZpbmVkKG5ld3ZhbCkgPyBfdGhpcy5faGFzaFByZWZpeCA9IG5ld3ZhbCA6IF90aGlzLl9oYXNoUHJlZml4OyB9O1xuICAgIH1cbiAgICByZXR1cm4gTWVtb3J5TG9jYXRpb25Db25maWc7XG59KCkpO1xuZXhwb3J0cy5NZW1vcnlMb2NhdGlvbkNvbmZpZyA9IE1lbW9yeUxvY2F0aW9uQ29uZmlnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVtb3J5TG9jYXRpb25Db25maWcuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3ZhbmlsbGEvbWVtb3J5TG9jYXRpb25Db25maWcuanNcbi8vIG1vZHVsZSBpZCA9IDkzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///93\n")},function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\nvar predicates_1 = __webpack_require__(1);\n/** A `LocationConfig` that delegates to the browser's `location` object */\nvar BrowserLocationConfig = /** @class */ (function () {\n    function BrowserLocationConfig(router, _isHtml5) {\n        if (_isHtml5 === void 0) { _isHtml5 = false; }\n        this._isHtml5 = _isHtml5;\n        this._baseHref = undefined;\n        this._hashPrefix = '';\n    }\n    BrowserLocationConfig.prototype.port = function () {\n        if (location.port) {\n            return Number(location.port);\n        }\n        return this.protocol() === 'https' ? 443 : 80;\n    };\n    BrowserLocationConfig.prototype.protocol = function () {\n        return location.protocol.replace(/:/g, '');\n    };\n    BrowserLocationConfig.prototype.host = function () {\n        return location.hostname;\n    };\n    BrowserLocationConfig.prototype.html5Mode = function () {\n        return this._isHtml5;\n    };\n    BrowserLocationConfig.prototype.hashPrefix = function (newprefix) {\n        return predicates_1.isDefined(newprefix) ? this._hashPrefix = newprefix : this._hashPrefix;\n    };\n    BrowserLocationConfig.prototype.baseHref = function (href) {\n        return predicates_1.isDefined(href) ? this._baseHref = href :\n            predicates_1.isDefined(this._baseHref) ? this._baseHref : this.applyDocumentBaseHref();\n    };\n    BrowserLocationConfig.prototype.applyDocumentBaseHref = function () {\n        var baseTag = document.getElementsByTagName('base')[0];\n        return this._baseHref = baseTag ? baseTag.href.substr(location.origin.length) : location.pathname || '/';\n    };\n    BrowserLocationConfig.prototype.dispose = function () { };\n    return BrowserLocationConfig;\n}());\nexports.BrowserLocationConfig = BrowserLocationConfig;\n//# sourceMappingURL=browserLocationConfig.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3ZhbmlsbGEvYnJvd3NlckxvY2F0aW9uQ29uZmlnLmpzP2RlYzQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEBpbnRlcm5hbGFwaVxuICogQG1vZHVsZSB2YW5pbGxhXG4gKi9cbi8qKiAqL1xudmFyIHByZWRpY2F0ZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vcHJlZGljYXRlc1wiKTtcbi8qKiBBIGBMb2NhdGlvbkNvbmZpZ2AgdGhhdCBkZWxlZ2F0ZXMgdG8gdGhlIGJyb3dzZXIncyBgbG9jYXRpb25gIG9iamVjdCAqL1xudmFyIEJyb3dzZXJMb2NhdGlvbkNvbmZpZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCcm93c2VyTG9jYXRpb25Db25maWcocm91dGVyLCBfaXNIdG1sNSkge1xuICAgICAgICBpZiAoX2lzSHRtbDUgPT09IHZvaWQgMCkgeyBfaXNIdG1sNSA9IGZhbHNlOyB9XG4gICAgICAgIHRoaXMuX2lzSHRtbDUgPSBfaXNIdG1sNTtcbiAgICAgICAgdGhpcy5fYmFzZUhyZWYgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX2hhc2hQcmVmaXggPSAnJztcbiAgICB9XG4gICAgQnJvd3NlckxvY2F0aW9uQ29uZmlnLnByb3RvdHlwZS5wb3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAobG9jYXRpb24ucG9ydCkge1xuICAgICAgICAgICAgcmV0dXJuIE51bWJlcihsb2NhdGlvbi5wb3J0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcm90b2NvbCgpID09PSAnaHR0cHMnID8gNDQzIDogODA7XG4gICAgfTtcbiAgICBCcm93c2VyTG9jYXRpb25Db25maWcucHJvdG90eXBlLnByb3RvY29sID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbG9jYXRpb24ucHJvdG9jb2wucmVwbGFjZSgvOi9nLCAnJyk7XG4gICAgfTtcbiAgICBCcm93c2VyTG9jYXRpb25Db25maWcucHJvdG90eXBlLmhvc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBsb2NhdGlvbi5ob3N0bmFtZTtcbiAgICB9O1xuICAgIEJyb3dzZXJMb2NhdGlvbkNvbmZpZy5wcm90b3R5cGUuaHRtbDVNb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNIdG1sNTtcbiAgICB9O1xuICAgIEJyb3dzZXJMb2NhdGlvbkNvbmZpZy5wcm90b3R5cGUuaGFzaFByZWZpeCA9IGZ1bmN0aW9uIChuZXdwcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIHByZWRpY2F0ZXNfMS5pc0RlZmluZWQobmV3cHJlZml4KSA/IHRoaXMuX2hhc2hQcmVmaXggPSBuZXdwcmVmaXggOiB0aGlzLl9oYXNoUHJlZml4O1xuICAgIH07XG4gICAgQnJvd3NlckxvY2F0aW9uQ29uZmlnLnByb3RvdHlwZS5iYXNlSHJlZiA9IGZ1bmN0aW9uIChocmVmKSB7XG4gICAgICAgIHJldHVybiBwcmVkaWNhdGVzXzEuaXNEZWZpbmVkKGhyZWYpID8gdGhpcy5fYmFzZUhyZWYgPSBocmVmIDpcbiAgICAgICAgICAgIHByZWRpY2F0ZXNfMS5pc0RlZmluZWQodGhpcy5fYmFzZUhyZWYpID8gdGhpcy5fYmFzZUhyZWYgOiB0aGlzLmFwcGx5RG9jdW1lbnRCYXNlSHJlZigpO1xuICAgIH07XG4gICAgQnJvd3NlckxvY2F0aW9uQ29uZmlnLnByb3RvdHlwZS5hcHBseURvY3VtZW50QmFzZUhyZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBiYXNlVGFnID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2Jhc2UnKVswXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Jhc2VIcmVmID0gYmFzZVRhZyA/IGJhc2VUYWcuaHJlZi5zdWJzdHIobG9jYXRpb24ub3JpZ2luLmxlbmd0aCkgOiBsb2NhdGlvbi5wYXRobmFtZSB8fCAnLyc7XG4gICAgfTtcbiAgICBCcm93c2VyTG9jYXRpb25Db25maWcucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgcmV0dXJuIEJyb3dzZXJMb2NhdGlvbkNvbmZpZztcbn0oKSk7XG5leHBvcnRzLkJyb3dzZXJMb2NhdGlvbkNvbmZpZyA9IEJyb3dzZXJMb2NhdGlvbkNvbmZpZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJyb3dzZXJMb2NhdGlvbkNvbmZpZy5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvdmFuaWxsYS9icm93c2VyTG9jYXRpb25Db25maWcuanNcbi8vIG1vZHVsZSBpZCA9IDk0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///94\n")},function(module,exports,__webpack_require__){eval("// optional / simple context binding\nvar aFunction = __webpack_require__(144);\nmodule.exports = function (fn, that, length) {\n  aFunction(fn);\n  if (that === undefined) return fn;\n  switch (length) {\n    case 1: return function (a) {\n      return fn.call(that, a);\n    };\n    case 2: return function (a, b) {\n      return fn.call(that, a, b);\n    };\n    case 3: return function (a, b, c) {\n      return fn.call(that, a, b, c);\n    };\n  }\n  return function (/* ...args */) {\n    return fn.apply(that, arguments);\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2N0eC5qcz9mOTkzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIG9wdGlvbmFsIC8gc2ltcGxlIGNvbnRleHQgYmluZGluZ1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZuLCB0aGF0LCBsZW5ndGgpIHtcbiAgYUZ1bmN0aW9uKGZuKTtcbiAgaWYgKHRoYXQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGZuO1xuICBzd2l0Y2ggKGxlbmd0aCkge1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uIChhKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhKTtcbiAgICB9O1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcbiAgICB9O1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiLCBjKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiAoLyogLi4uYXJncyAqLykge1xuICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICB9O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jdHguanNcbi8vIG1vZHVsZSBpZCA9IDk1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///95\n")},function(module,exports,__webpack_require__){eval("module.exports = !__webpack_require__(13) && !__webpack_require__(23)(function () {\n  return Object.defineProperty(__webpack_require__(97)('div'), 'a', { get: function () { return 7; } }).a != 7;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2llOC1kb20tZGVmaW5lLmpzPzQ5ZjAiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpKCdkaXYnKSwgJ2EnLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfSB9KS5hICE9IDc7XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pZTgtZG9tLWRlZmluZS5qc1xuLy8gbW9kdWxlIGlkID0gOTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///96\n")},function(module,exports,__webpack_require__){eval("var isObject = __webpack_require__(22);\nvar document = __webpack_require__(9).document;\n// typeof document.createElement is 'object' in old IE\nvar is = isObject(document) && isObject(document.createElement);\nmodule.exports = function (it) {\n  return is ? document.createElement(it) : {};\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2RvbS1jcmVhdGUuanM/MzhkZCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBkb2N1bWVudCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLmRvY3VtZW50O1xuLy8gdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCcgaW4gb2xkIElFXG52YXIgaXMgPSBpc09iamVjdChkb2N1bWVudCkgJiYgaXNPYmplY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19kb20tY3JlYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSA5N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///97\n")},function(module,exports,__webpack_require__){eval("var has = __webpack_require__(14);\nvar toIObject = __webpack_require__(15);\nvar arrayIndexOf = __webpack_require__(146)(false);\nvar IE_PROTO = __webpack_require__(53)('IE_PROTO');\n\nmodule.exports = function (object, names) {\n  var O = toIObject(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);\n  // Don't enum bug & hidden keys\n  while (names.length > i) if (has(O, key = names[i++])) {\n    ~arrayIndexOf(result, key) || result.push(key);\n  }\n  return result;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1rZXlzLWludGVybmFsLmpzPzIxYjgiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGhhcyA9IHJlcXVpcmUoJy4vX2hhcycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciBhcnJheUluZGV4T2YgPSByZXF1aXJlKCcuL19hcnJheS1pbmNsdWRlcycpKGZhbHNlKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lcykge1xuICB2YXIgTyA9IHRvSU9iamVjdChvYmplY3QpO1xuICB2YXIgaSA9IDA7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gTykgaWYgKGtleSAhPSBJRV9QUk9UTykgaGFzKE8sIGtleSkgJiYgcmVzdWx0LnB1c2goa2V5KTtcbiAgLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5c1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkgaWYgKGhhcyhPLCBrZXkgPSBuYW1lc1tpKytdKSkge1xuICAgIH5hcnJheUluZGV4T2YocmVzdWx0LCBrZXkpIHx8IHJlc3VsdC5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWtleXMtaW50ZXJuYWwuanNcbi8vIG1vZHVsZSBpZCA9IDk4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///98\n")},function(module,exports,__webpack_require__){eval("// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar cof = __webpack_require__(50);\n// eslint-disable-next-line no-prototype-builtins\nmodule.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {\n  return cof(it) == 'String' ? it.split('') : Object(it);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOTkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lvYmplY3QuanM/MzE0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIGFuZCBub24tZW51bWVyYWJsZSBvbGQgVjggc3RyaW5nc1xudmFyIGNvZiA9IHJlcXVpcmUoJy4vX2NvZicpO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QoJ3onKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKSA/IE9iamVjdCA6IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gY29mKGl0KSA9PSAnU3RyaW5nJyA/IGl0LnNwbGl0KCcnKSA6IE9iamVjdChpdCk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lvYmplY3QuanNcbi8vIG1vZHVsZSBpZCA9IDk5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///99\n")},function(module,exports,__webpack_require__){eval("__webpack_require__(156);\nvar global = __webpack_require__(9);\nvar hide = __webpack_require__(20);\nvar Iterators = __webpack_require__(40);\nvar TO_STRING_TAG = __webpack_require__(10)('toStringTag');\n\nvar DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +\n  'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +\n  'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +\n  'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +\n  'TextTrackList,TouchList').split(',');\n\nfor (var i = 0; i < DOMIterables.length; i++) {\n  var NAME = DOMIterables[i];\n  var Collection = global[NAME];\n  var proto = Collection && Collection.prototype;\n  if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);\n  Iterators[NAME] = Iterators.Array;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUuanM/ZmFkMyJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKCcuL2VzNi5hcnJheS5pdGVyYXRvcicpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG52YXIgVE9fU1RSSU5HX1RBRyA9IHJlcXVpcmUoJy4vX3drcycpKCd0b1N0cmluZ1RhZycpO1xuXG52YXIgRE9NSXRlcmFibGVzID0gKCdDU1NSdWxlTGlzdCxDU1NTdHlsZURlY2xhcmF0aW9uLENTU1ZhbHVlTGlzdCxDbGllbnRSZWN0TGlzdCxET01SZWN0TGlzdCxET01TdHJpbmdMaXN0LCcgK1xuICAnRE9NVG9rZW5MaXN0LERhdGFUcmFuc2Zlckl0ZW1MaXN0LEZpbGVMaXN0LEhUTUxBbGxDb2xsZWN0aW9uLEhUTUxDb2xsZWN0aW9uLEhUTUxGb3JtRWxlbWVudCxIVE1MU2VsZWN0RWxlbWVudCwnICtcbiAgJ01lZGlhTGlzdCxNaW1lVHlwZUFycmF5LE5hbWVkTm9kZU1hcCxOb2RlTGlzdCxQYWludFJlcXVlc3RMaXN0LFBsdWdpbixQbHVnaW5BcnJheSxTVkdMZW5ndGhMaXN0LFNWR051bWJlckxpc3QsJyArXG4gICdTVkdQYXRoU2VnTGlzdCxTVkdQb2ludExpc3QsU1ZHU3RyaW5nTGlzdCxTVkdUcmFuc2Zvcm1MaXN0LFNvdXJjZUJ1ZmZlckxpc3QsU3R5bGVTaGVldExpc3QsVGV4dFRyYWNrQ3VlTGlzdCwnICtcbiAgJ1RleHRUcmFja0xpc3QsVG91Y2hMaXN0Jykuc3BsaXQoJywnKTtcblxuZm9yICh2YXIgaSA9IDA7IGkgPCBET01JdGVyYWJsZXMubGVuZ3RoOyBpKyspIHtcbiAgdmFyIE5BTUUgPSBET01JdGVyYWJsZXNbaV07XG4gIHZhciBDb2xsZWN0aW9uID0gZ2xvYmFsW05BTUVdO1xuICB2YXIgcHJvdG8gPSBDb2xsZWN0aW9uICYmIENvbGxlY3Rpb24ucHJvdG90eXBlO1xuICBpZiAocHJvdG8gJiYgIXByb3RvW1RPX1NUUklOR19UQUddKSBoaWRlKHByb3RvLCBUT19TVFJJTkdfVEFHLCBOQU1FKTtcbiAgSXRlcmF0b3JzW05BTUVdID0gSXRlcmF0b3JzLkFycmF5O1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gMTAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///100\n")},function(module,exports,__webpack_require__){"use strict";eval("\nvar LIBRARY = __webpack_require__(59);\nvar $export = __webpack_require__(11);\nvar redefine = __webpack_require__(102);\nvar hide = __webpack_require__(20);\nvar has = __webpack_require__(14);\nvar Iterators = __webpack_require__(40);\nvar $iterCreate = __webpack_require__(159);\nvar setToStringTag = __webpack_require__(61);\nvar getPrototypeOf = __webpack_require__(103);\nvar ITERATOR = __webpack_require__(10)('iterator');\nvar BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`\nvar FF_ITERATOR = '@@iterator';\nvar KEYS = 'keys';\nvar VALUES = 'values';\n\nvar returnThis = function () { return this; };\n\nmodule.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {\n  $iterCreate(Constructor, NAME, next);\n  var getMethod = function (kind) {\n    if (!BUGGY && kind in proto) return proto[kind];\n    switch (kind) {\n      case KEYS: return function keys() { return new Constructor(this, kind); };\n      case VALUES: return function values() { return new Constructor(this, kind); };\n    } return function entries() { return new Constructor(this, kind); };\n  };\n  var TAG = NAME + ' Iterator';\n  var DEF_VALUES = DEFAULT == VALUES;\n  var VALUES_BUG = false;\n  var proto = Base.prototype;\n  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];\n  var $default = (!BUGGY && $native) || getMethod(DEFAULT);\n  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;\n  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;\n  var methods, key, IteratorPrototype;\n  // Fix native\n  if ($anyNative) {\n    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));\n    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {\n      // Set @@toStringTag to native iterators\n      setToStringTag(IteratorPrototype, TAG, true);\n      // fix for some old engines\n      if (!LIBRARY && !has(IteratorPrototype, ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis);\n    }\n  }\n  // fix Array#{values, @@iterator}.name in V8 / FF\n  if (DEF_VALUES && $native && $native.name !== VALUES) {\n    VALUES_BUG = true;\n    $default = function values() { return $native.call(this); };\n  }\n  // Define iterator\n  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {\n    hide(proto, ITERATOR, $default);\n  }\n  // Plug for library\n  Iterators[NAME] = $default;\n  Iterators[TAG] = returnThis;\n  if (DEFAULT) {\n    methods = {\n      values: DEF_VALUES ? $default : getMethod(VALUES),\n      keys: IS_SET ? $default : getMethod(KEYS),\n      entries: $entries\n    };\n    if (FORCED) for (key in methods) {\n      if (!(key in proto)) redefine(proto, key, methods[key]);\n    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);\n  }\n  return methods;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWRlZmluZS5qcz9iYzgwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciAkaXRlckNyZWF0ZSA9IHJlcXVpcmUoJy4vX2l0ZXItY3JlYXRlJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgQlVHR1kgPSAhKFtdLmtleXMgJiYgJ25leHQnIGluIFtdLmtleXMoKSk7IC8vIFNhZmFyaSBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbnZhciBGRl9JVEVSQVRPUiA9ICdAQGl0ZXJhdG9yJztcbnZhciBLRVlTID0gJ2tleXMnO1xudmFyIFZBTFVFUyA9ICd2YWx1ZXMnO1xuXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEJhc2UsIE5BTUUsIENvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQsIEZPUkNFRCkge1xuICAkaXRlckNyZWF0ZShDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG4gIHZhciBnZXRNZXRob2QgPSBmdW5jdGlvbiAoa2luZCkge1xuICAgIGlmICghQlVHR1kgJiYga2luZCBpbiBwcm90bykgcmV0dXJuIHByb3RvW2tpbmRdO1xuICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgIH0gcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gIH07XG4gIHZhciBUQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XG4gIHZhciBERUZfVkFMVUVTID0gREVGQVVMVCA9PSBWQUxVRVM7XG4gIHZhciBWQUxVRVNfQlVHID0gZmFsc2U7XG4gIHZhciBwcm90byA9IEJhc2UucHJvdG90eXBlO1xuICB2YXIgJG5hdGl2ZSA9IHByb3RvW0lURVJBVE9SXSB8fCBwcm90b1tGRl9JVEVSQVRPUl0gfHwgREVGQVVMVCAmJiBwcm90b1tERUZBVUxUXTtcbiAgdmFyICRkZWZhdWx0ID0gKCFCVUdHWSAmJiAkbmF0aXZlKSB8fCBnZXRNZXRob2QoREVGQVVMVCk7XG4gIHZhciAkZW50cmllcyA9IERFRkFVTFQgPyAhREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKCdlbnRyaWVzJykgOiB1bmRlZmluZWQ7XG4gIHZhciAkYW55TmF0aXZlID0gTkFNRSA9PSAnQXJyYXknID8gcHJvdG8uZW50cmllcyB8fCAkbmF0aXZlIDogJG5hdGl2ZTtcbiAgdmFyIG1ldGhvZHMsIGtleSwgSXRlcmF0b3JQcm90b3R5cGU7XG4gIC8vIEZpeCBuYXRpdmVcbiAgaWYgKCRhbnlOYXRpdmUpIHtcbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKCRhbnlOYXRpdmUuY2FsbChuZXcgQmFzZSgpKSk7XG4gICAgaWYgKEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlICYmIEl0ZXJhdG9yUHJvdG90eXBlLm5leHQpIHtcbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICAgIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yUHJvdG90eXBlLCBUQUcsIHRydWUpO1xuICAgICAgLy8gZml4IGZvciBzb21lIG9sZCBlbmdpbmVzXG4gICAgICBpZiAoIUxJQlJBUlkgJiYgIWhhcyhJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IpKSBoaWRlKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XG4gICAgfVxuICB9XG4gIC8vIGZpeCBBcnJheSN7dmFsdWVzLCBAQGl0ZXJhdG9yfS5uYW1lIGluIFY4IC8gRkZcbiAgaWYgKERFRl9WQUxVRVMgJiYgJG5hdGl2ZSAmJiAkbmF0aXZlLm5hbWUgIT09IFZBTFVFUykge1xuICAgIFZBTFVFU19CVUcgPSB0cnVlO1xuICAgICRkZWZhdWx0ID0gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gJG5hdGl2ZS5jYWxsKHRoaXMpOyB9O1xuICB9XG4gIC8vIERlZmluZSBpdGVyYXRvclxuICBpZiAoKCFMSUJSQVJZIHx8IEZPUkNFRCkgJiYgKEJVR0dZIHx8IFZBTFVFU19CVUcgfHwgIXByb3RvW0lURVJBVE9SXSkpIHtcbiAgICBoaWRlKHByb3RvLCBJVEVSQVRPUiwgJGRlZmF1bHQpO1xuICB9XG4gIC8vIFBsdWcgZm9yIGxpYnJhcnlcbiAgSXRlcmF0b3JzW05BTUVdID0gJGRlZmF1bHQ7XG4gIEl0ZXJhdG9yc1tUQUddID0gcmV0dXJuVGhpcztcbiAgaWYgKERFRkFVTFQpIHtcbiAgICBtZXRob2RzID0ge1xuICAgICAgdmFsdWVzOiBERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoVkFMVUVTKSxcbiAgICAgIGtleXM6IElTX1NFVCA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKEtFWVMpLFxuICAgICAgZW50cmllczogJGVudHJpZXNcbiAgICB9O1xuICAgIGlmIChGT1JDRUQpIGZvciAoa2V5IGluIG1ldGhvZHMpIHtcbiAgICAgIGlmICghKGtleSBpbiBwcm90bykpIHJlZGVmaW5lKHByb3RvLCBrZXksIG1ldGhvZHNba2V5XSk7XG4gICAgfSBlbHNlICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKEJVR0dZIHx8IFZBTFVFU19CVUcpLCBOQU1FLCBtZXRob2RzKTtcbiAgfVxuICByZXR1cm4gbWV0aG9kcztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9faXRlci1kZWZpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDEwMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///101\n")},function(module,exports,__webpack_require__){eval("module.exports = __webpack_require__(20);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19yZWRlZmluZS5qcz9mM2NkIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9faGlkZScpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3JlZGVmaW5lLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///102\n")},function(module,exports,__webpack_require__){eval("// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)\nvar has = __webpack_require__(14);\nvar toObject = __webpack_require__(57);\nvar IE_PROTO = __webpack_require__(53)('IE_PROTO');\nvar ObjectProto = Object.prototype;\n\nmodule.exports = Object.getPrototypeOf || function (O) {\n  O = toObject(O);\n  if (has(O, IE_PROTO)) return O[IE_PROTO];\n  if (typeof O.constructor == 'function' && O instanceof O.constructor) {\n    return O.constructor.prototype;\n  } return O instanceof Object ? ObjectProto : null;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ3BvLmpzPzNmM2MiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gMTkuMS4yLjkgLyAxNS4yLjMuMiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTylcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIElFX1BST1RPID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xudmFyIE9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gKE8pIHtcbiAgTyA9IHRvT2JqZWN0KE8pO1xuICBpZiAoaGFzKE8sIElFX1BST1RPKSkgcmV0dXJuIE9bSUVfUFJPVE9dO1xuICBpZiAodHlwZW9mIE8uY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBPIGluc3RhbmNlb2YgTy5jb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBPLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgfSByZXR1cm4gTyBpbnN0YW5jZW9mIE9iamVjdCA/IE9iamVjdFByb3RvIDogbnVsbDtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdwby5qc1xuLy8gbW9kdWxlIGlkID0gMTAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///103\n")},function(module,exports,__webpack_require__){"use strict";eval("\nvar $at = __webpack_require__(162)(true);\n\n// 21.1.3.27 String.prototype[@@iterator]()\n__webpack_require__(101)(String, 'String', function (iterated) {\n  this._t = String(iterated); // target\n  this._i = 0;                // next index\n// 21.1.5.2.1 %StringIteratorPrototype%.next()\n}, function () {\n  var O = this._t;\n  var index = this._i;\n  var point;\n  if (index >= O.length) return { value: undefined, done: true };\n  point = $at(O, index);\n  this._i += point.length;\n  return { value: point, done: false };\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTA0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3IuanM/Y2QwNCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgJGF0ID0gcmVxdWlyZSgnLi9fc3RyaW5nLWF0JykodHJ1ZSk7XG5cbi8vIDIxLjEuMy4yNyBTdHJpbmcucHJvdG90eXBlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vX2l0ZXItZGVmaW5lJykoU3RyaW5nLCAnU3RyaW5nJywgZnVuY3Rpb24gKGl0ZXJhdGVkKSB7XG4gIHRoaXMuX3QgPSBTdHJpbmcoaXRlcmF0ZWQpOyAvLyB0YXJnZXRcbiAgdGhpcy5faSA9IDA7ICAgICAgICAgICAgICAgIC8vIG5leHQgaW5kZXhcbi8vIDIxLjEuNS4yLjEgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJS5uZXh0KClcbn0sIGZ1bmN0aW9uICgpIHtcbiAgdmFyIE8gPSB0aGlzLl90O1xuICB2YXIgaW5kZXggPSB0aGlzLl9pO1xuICB2YXIgcG9pbnQ7XG4gIGlmIChpbmRleCA+PSBPLmxlbmd0aCkgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICBwb2ludCA9ICRhdChPLCBpbmRleCk7XG4gIHRoaXMuX2kgKz0gcG9pbnQubGVuZ3RoO1xuICByZXR1cm4geyB2YWx1ZTogcG9pbnQsIGRvbmU6IGZhbHNlIH07XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDEwNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///104\n")},function(module,exports,__webpack_require__){eval("// most Object methods by ES6 should accept primitives\nvar $export = __webpack_require__(11);\nvar core = __webpack_require__(4);\nvar fails = __webpack_require__(23);\nmodule.exports = function (KEY, exec) {\n  var fn = (core.Object || {})[KEY] || Object[KEY];\n  var exp = {};\n  exp[KEY] = exec(fn);\n  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTA1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3Qtc2FwLmpzP2JhYTUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gbW9zdCBPYmplY3QgbWV0aG9kcyBieSBFUzYgc2hvdWxkIGFjY2VwdCBwcmltaXRpdmVzXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuL19mYWlscycpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoS0VZLCBleGVjKSB7XG4gIHZhciBmbiA9IChjb3JlLk9iamVjdCB8fCB7fSlbS0VZXSB8fCBPYmplY3RbS0VZXTtcbiAgdmFyIGV4cCA9IHt9O1xuICBleHBbS0VZXSA9IGV4ZWMoZm4pO1xuICAkZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqIGZhaWxzKGZ1bmN0aW9uICgpIHsgZm4oMSk7IH0pLCAnT2JqZWN0JywgZXhwKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LXNhcC5qc1xuLy8gbW9kdWxlIGlkID0gMTA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///105\n")},function(module,exports,__webpack_require__){"use strict";eval('\n\nexports.__esModule = true;\n\nvar _iterator = __webpack_require__(169);\n\nvar _iterator2 = _interopRequireDefault(_iterator);\n\nvar _symbol = __webpack_require__(171);\n\nvar _symbol2 = _interopRequireDefault(_symbol);\n\nvar _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj; };\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {\n  return typeof obj === "undefined" ? "undefined" : _typeof(obj);\n} : function (obj) {\n  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTA2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvaGVscGVycy90eXBlb2YuanM/YTQ1NiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9pdGVyYXRvciA9IHJlcXVpcmUoXCIuLi9jb3JlLWpzL3N5bWJvbC9pdGVyYXRvclwiKTtcblxudmFyIF9pdGVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pdGVyYXRvcik7XG5cbnZhciBfc3ltYm9sID0gcmVxdWlyZShcIi4uL2NvcmUtanMvc3ltYm9sXCIpO1xuXG52YXIgX3N5bWJvbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zeW1ib2wpO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBfc3ltYm9sMi5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIF9pdGVyYXRvcjIuZGVmYXVsdCA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIF9zeW1ib2wyLmRlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IF9zeW1ib2wyLmRlZmF1bHQgJiYgb2JqICE9PSBfc3ltYm9sMi5kZWZhdWx0LnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLmRlZmF1bHQgPSB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiICYmIF90eXBlb2YoX2l0ZXJhdG9yMi5kZWZhdWx0KSA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmogPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihvYmopO1xufSA6IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgX3N5bWJvbDIuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gX3N5bWJvbDIuZGVmYXVsdCAmJiBvYmogIT09IF9zeW1ib2wyLmRlZmF1bHQucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmogPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihvYmopO1xufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2hlbHBlcnMvdHlwZW9mLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///106\n')},function(module,exports,__webpack_require__){eval("// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)\nvar $keys = __webpack_require__(98);\nvar hiddenKeys = __webpack_require__(55).concat('length', 'prototype');\n\nexports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n  return $keys(O, hiddenKeys);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTA3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wbi5qcz85ZjQ0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIDE5LjEuMi43IC8gMTUuMi4zLjQgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoTylcbnZhciAka2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJyk7XG52YXIgaGlkZGVuS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKS5jb25jYXQoJ2xlbmd0aCcsICdwcm90b3R5cGUnKTtcblxuZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKSB7XG4gIHJldHVybiAka2V5cyhPLCBoaWRkZW5LZXlzKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWdvcG4uanNcbi8vIG1vZHVsZSBpZCA9IDEwN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///107\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar _angular = __webpack_require__(7);\n\nvar angular = _interopRequireWildcard(_angular);\n\n__webpack_require__(109);\n\n__webpack_require__(132);\n\n__webpack_require__(134);\n\n__webpack_require__(136);\n\n__webpack_require__(137);\n\n__webpack_require__(138);\n\n__webpack_require__(139);\n\n__webpack_require__(203);\n\n__webpack_require__(204);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n// Register modules\nvar m = angular.module('app', ['app.services', 'app.components', 'app.filters', 'http-auth-interceptor', 'ngStorage', 'ui.router', 'ui.bootstrap', 'ui.bootstrap.tpls', 'ngAnimate', 'ngPrettyJson', 'angular-d3-word-cloud']);\nvar auths = {};\n/* @ngInject */\nm.config(['$httpProvider', function ($httpProvider) {\n    $httpProvider.interceptors.push(function () {\n        return {\n            request: function request(_request) {\n                if (auths[_request.url]) _request.headers['Authorization'] = auths[_request.url];\n                return _request;\n            }\n        };\n    });\n}]);\n/* @ngInject */\nm.config(['$stateProvider', '$urlRouterProvider', function ($stateProvider, $urlRouterProvider) {\n    $stateProvider.state('index', {\n        url: '/?endpoint',\n        params: {\n            endpoint: { dynamic: true }\n        },\n        component: 'indexView'\n    });\n    $stateProvider.state('trend', {\n        url: '/trend?endpoint&attr&{attrLength:int}&query&comparisonQuery&{plotTermFreq:bool}&{plotAbsolute:bool}&defaultLevel&furtherOptions',\n        params: {\n            endpoint: { dynamic: true },\n            attr: { dynamic: true },\n            attrLength: { dynamic: true },\n            query: { dynamic: true },\n            comparisonQuery: { dynamic: true },\n            plotTermFreq: { dynamic: true },\n            plotAbsolute: { dynamic: true },\n            defaultLevel: { dynamic: true },\n            furtherOptions: { dynamic: true }\n        },\n        component: 'trendView'\n    });\n    $stateProvider.state('search', {\n        url: '/search?endpoint&query&field&showMatches&furtherOptions&{limit:int}&defaultLevel',\n        params: {\n            endpoint: { dynamic: true },\n            query: { dynamic: true },\n            field: { dynamic: true, array: true },\n            showMatches: { dynamic: true },\n            defaultLevel: { dynamic: true },\n            limit: { dynamic: true },\n            furtherOptions: { dynamic: true }\n        },\n        component: 'searchView'\n    });\n    $stateProvider.state('word-cloud', {\n        url: '/word-cloud?endpoint&query&defaultLevel&{limit:int}&{smoothing:int}&{maxDocs:int}&{minTotalTermFreq:int}&{maxTotalTermFreq:int}&{minDocFreq:int}&{maxDocFreq:int}&{minFreqInDoc:int}&{maxFreqInDoc:int}&{minTermLength:int}&{maxTermLength:int}&{minSumFreq:int}&{maxSumFreq:int}&termFilter&localScaling&sumScaling&{mds:bool}&furtherOptions',\n        params: {\n            endpoint: { dynamic: true },\n            query: { dynamic: true },\n            defaultLevel: { dynamic: true },\n            limit: { dynamic: true },\n            smoothing: { dynamic: true },\n            maxDocs: { dynamic: true },\n            minTotalTermFreq: { dynamic: true },\n            maxTotalTermFreq: { dynamic: true },\n            minDocFreq: { dynamic: true },\n            maxDocFreq: { dynamic: true },\n            minFreqInDoc: { dynamic: true },\n            maxFreqInDoc: { dynamic: true },\n            minTermLength: { dynamic: true },\n            maxTermLength: { dynamic: true },\n            minSumFreq: { dynamic: true },\n            maxSumFreq: { dynamic: true },\n            termFilter: { dynamic: true },\n            localScaling: { dynamic: true },\n            sumScaling: { dynamic: true },\n            furtherOptions: { dynamic: true },\n            mds: { dynamic: true }\n        },\n        component: 'wordCloudView'\n    });\n    $urlRouterProvider.otherwise('/');\n}]);\n/* @ngInject */\nm.run(['$rootScope', '$localStorage', 'authService', function ($rootScope, $localStorage, authService) {\n    $rootScope.authInfo = {\n        authOpen: false,\n        url: undefined,\n        username: undefined,\n        password: undefined\n    };\n    if (!$localStorage.authorization) $localStorage.authorization = {};\n    auths = $localStorage.authorization;\n    $rootScope.setAuth = function () {\n        $rootScope.authInfo.authOpen = false;\n        auths[$rootScope.authInfo.url] = 'Basic ' + btoa($rootScope.authInfo.username + ':' + $rootScope.authInfo.password);\n        authService.loginConfirmed();\n    };\n    $rootScope.dismissAuth = function () {\n        $rootScope.authInfo.authOpen = false;\n        authService.loginCancelled({ status: 401 }, 'Authentication required');\n    };\n    $rootScope.$on('event:auth-loginRequired', function (event, rejected) {\n        $rootScope.authInfo.url = rejected.config.url;\n        $rootScope.authInfo.authOpen = true;\n    });\n}]);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTA4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2FwcC9pbmRleC50cz9kM2Y1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbmltcG9ydCAqIGFzIGFuZ3VsYXIgZnJvbSAnYW5ndWxhcic7XG5pbXBvcnQgJ0B1aXJvdXRlci9hbmd1bGFyanMnO1xuaW1wb3J0ICdhbmd1bGFyLWFuaW1hdGUnO1xuaW1wb3J0ICdhbmd1bGFyLXVpLWJvb3RzdHJhcCc7XG5pbXBvcnQgJ2FuZ3VsYXItaHR0cC1hdXRoJztcbmltcG9ydCAnc3R5bGVzL21haW4uc3R5bCc7XG4vLyBSZWdpc3RlciBtb2R1bGVzXG5pbXBvcnQgJ3NlcnZpY2VzJztcbmltcG9ydCAnY29tcG9uZW50cyc7XG5pbXBvcnQgJ2ZpbHRlcnMnO1xuaW1wb3J0ICduZ3N0b3JhZ2UnO1xubGV0IG0gPSBhbmd1bGFyLm1vZHVsZSgnYXBwJywgW1xuICAgICdhcHAuc2VydmljZXMnLFxuICAgICdhcHAuY29tcG9uZW50cycsXG4gICAgJ2FwcC5maWx0ZXJzJyxcbiAgICAnaHR0cC1hdXRoLWludGVyY2VwdG9yJyxcbiAgICAnbmdTdG9yYWdlJyxcbiAgICAndWkucm91dGVyJyxcbiAgICAndWkuYm9vdHN0cmFwJyxcbiAgICAndWkuYm9vdHN0cmFwLnRwbHMnLFxuICAgICduZ0FuaW1hdGUnLFxuICAgICduZ1ByZXR0eUpzb24nLFxuICAgICdhbmd1bGFyLWQzLXdvcmQtY2xvdWQnXG5dKTtcbmxldCBhdXRocyA9IHt9O1xuLyogQG5nSW5qZWN0ICovXG5tLmNvbmZpZygoJGh0dHBQcm92aWRlcikgPT4ge1xuICAgICRodHRwUHJvdmlkZXIuaW50ZXJjZXB0b3JzLnB1c2goKCkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVxdWVzdDogKHJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoYXV0aHNbcmVxdWVzdC51cmxdKVxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LmhlYWRlcnNbJ0F1dGhvcml6YXRpb24nXSA9IGF1dGhzW3JlcXVlc3QudXJsXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KTtcbn0pO1xuLyogQG5nSW5qZWN0ICovXG5tLmNvbmZpZygoJHN0YXRlUHJvdmlkZXIsICR1cmxSb3V0ZXJQcm92aWRlcikgPT4ge1xuICAgICRzdGF0ZVByb3ZpZGVyLnN0YXRlKCdpbmRleCcsIHtcbiAgICAgICAgdXJsOiAnLz9lbmRwb2ludCcsXG4gICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgZW5kcG9pbnQ6IHsgZHluYW1pYzogdHJ1ZSB9XG4gICAgICAgIH0sXG4gICAgICAgIGNvbXBvbmVudDogJ2luZGV4VmlldydcbiAgICB9KTtcbiAgICAkc3RhdGVQcm92aWRlci5zdGF0ZSgndHJlbmQnLCB7XG4gICAgICAgIHVybDogJy90cmVuZD9lbmRwb2ludCZhdHRyJnthdHRyTGVuZ3RoOmludH0mcXVlcnkmY29tcGFyaXNvblF1ZXJ5JntwbG90VGVybUZyZXE6Ym9vbH0me3Bsb3RBYnNvbHV0ZTpib29sfSZkZWZhdWx0TGV2ZWwmZnVydGhlck9wdGlvbnMnLFxuICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgIGVuZHBvaW50OiB7IGR5bmFtaWM6IHRydWUgfSxcbiAgICAgICAgICAgIGF0dHI6IHsgZHluYW1pYzogdHJ1ZSB9LFxuICAgICAgICAgICAgYXR0ckxlbmd0aDogeyBkeW5hbWljOiB0cnVlIH0sXG4gICAgICAgICAgICBxdWVyeTogeyBkeW5hbWljOiB0cnVlIH0sXG4gICAgICAgICAgICBjb21wYXJpc29uUXVlcnk6IHsgZHluYW1pYzogdHJ1ZSB9LFxuICAgICAgICAgICAgcGxvdFRlcm1GcmVxOiB7IGR5bmFtaWM6IHRydWUgfSxcbiAgICAgICAgICAgIHBsb3RBYnNvbHV0ZTogeyBkeW5hbWljOiB0cnVlIH0sXG4gICAgICAgICAgICBkZWZhdWx0TGV2ZWw6IHsgZHluYW1pYzogdHJ1ZSB9LFxuICAgICAgICAgICAgZnVydGhlck9wdGlvbnM6IHsgZHluYW1pYzogdHJ1ZSB9XG4gICAgICAgIH0sXG4gICAgICAgIGNvbXBvbmVudDogJ3RyZW5kVmlldydcbiAgICB9KTtcbiAgICAkc3RhdGVQcm92aWRlci5zdGF0ZSgnc2VhcmNoJywge1xuICAgICAgICB1cmw6ICcvc2VhcmNoP2VuZHBvaW50JnF1ZXJ5JmZpZWxkJnNob3dNYXRjaGVzJmZ1cnRoZXJPcHRpb25zJntsaW1pdDppbnR9JmRlZmF1bHRMZXZlbCcsXG4gICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgZW5kcG9pbnQ6IHsgZHluYW1pYzogdHJ1ZSB9LFxuICAgICAgICAgICAgcXVlcnk6IHsgZHluYW1pYzogdHJ1ZSB9LFxuICAgICAgICAgICAgZmllbGQ6IHsgZHluYW1pYzogdHJ1ZSwgYXJyYXk6IHRydWUgfSxcbiAgICAgICAgICAgIHNob3dNYXRjaGVzOiB7IGR5bmFtaWM6IHRydWUgfSxcbiAgICAgICAgICAgIGRlZmF1bHRMZXZlbDogeyBkeW5hbWljOiB0cnVlIH0sXG4gICAgICAgICAgICBsaW1pdDogeyBkeW5hbWljOiB0cnVlIH0sXG4gICAgICAgICAgICBmdXJ0aGVyT3B0aW9uczogeyBkeW5hbWljOiB0cnVlIH1cbiAgICAgICAgfSxcbiAgICAgICAgY29tcG9uZW50OiAnc2VhcmNoVmlldydcbiAgICB9KTtcbiAgICAkc3RhdGVQcm92aWRlci5zdGF0ZSgnd29yZC1jbG91ZCcsIHtcbiAgICAgICAgdXJsOiAnL3dvcmQtY2xvdWQ/ZW5kcG9pbnQmcXVlcnkmZGVmYXVsdExldmVsJntsaW1pdDppbnR9JntzbW9vdGhpbmc6aW50fSZ7bWF4RG9jczppbnR9JnttaW5Ub3RhbFRlcm1GcmVxOmludH0me21heFRvdGFsVGVybUZyZXE6aW50fSZ7bWluRG9jRnJlcTppbnR9JnttYXhEb2NGcmVxOmludH0me21pbkZyZXFJbkRvYzppbnR9JnttYXhGcmVxSW5Eb2M6aW50fSZ7bWluVGVybUxlbmd0aDppbnR9JnttYXhUZXJtTGVuZ3RoOmludH0me21pblN1bUZyZXE6aW50fSZ7bWF4U3VtRnJlcTppbnR9JnRlcm1GaWx0ZXImbG9jYWxTY2FsaW5nJnN1bVNjYWxpbmcme21kczpib29sfSZmdXJ0aGVyT3B0aW9ucycsXG4gICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgZW5kcG9pbnQ6IHsgZHluYW1pYzogdHJ1ZSB9LFxuICAgICAgICAgICAgcXVlcnk6IHsgZHluYW1pYzogdHJ1ZSB9LFxuICAgICAgICAgICAgZGVmYXVsdExldmVsOiB7IGR5bmFtaWM6IHRydWUgfSxcbiAgICAgICAgICAgIGxpbWl0OiB7IGR5bmFtaWM6IHRydWUgfSxcbiAgICAgICAgICAgIHNtb290aGluZzogeyBkeW5hbWljOiB0cnVlIH0sXG4gICAgICAgICAgICBtYXhEb2NzOiB7IGR5bmFtaWM6IHRydWUgfSxcbiAgICAgICAgICAgIG1pblRvdGFsVGVybUZyZXE6IHsgZHluYW1pYzogdHJ1ZSB9LFxuICAgICAgICAgICAgbWF4VG90YWxUZXJtRnJlcTogeyBkeW5hbWljOiB0cnVlIH0sXG4gICAgICAgICAgICBtaW5Eb2NGcmVxOiB7IGR5bmFtaWM6IHRydWUgfSxcbiAgICAgICAgICAgIG1heERvY0ZyZXE6IHsgZHluYW1pYzogdHJ1ZSB9LFxuICAgICAgICAgICAgbWluRnJlcUluRG9jOiB7IGR5bmFtaWM6IHRydWUgfSxcbiAgICAgICAgICAgIG1heEZyZXFJbkRvYzogeyBkeW5hbWljOiB0cnVlIH0sXG4gICAgICAgICAgICBtaW5UZXJtTGVuZ3RoOiB7IGR5bmFtaWM6IHRydWUgfSxcbiAgICAgICAgICAgIG1heFRlcm1MZW5ndGg6IHsgZHluYW1pYzogdHJ1ZSB9LFxuICAgICAgICAgICAgbWluU3VtRnJlcTogeyBkeW5hbWljOiB0cnVlIH0sXG4gICAgICAgICAgICBtYXhTdW1GcmVxOiB7IGR5bmFtaWM6IHRydWUgfSxcbiAgICAgICAgICAgIHRlcm1GaWx0ZXI6IHsgZHluYW1pYzogdHJ1ZSB9LFxuICAgICAgICAgICAgbG9jYWxTY2FsaW5nOiB7IGR5bmFtaWM6IHRydWUgfSxcbiAgICAgICAgICAgIHN1bVNjYWxpbmc6IHsgZHluYW1pYzogdHJ1ZSB9LFxuICAgICAgICAgICAgZnVydGhlck9wdGlvbnM6IHsgZHluYW1pYzogdHJ1ZSB9LFxuICAgICAgICAgICAgbWRzOiB7IGR5bmFtaWM6IHRydWUgfVxuICAgICAgICB9LFxuICAgICAgICBjb21wb25lbnQ6ICd3b3JkQ2xvdWRWaWV3J1xuICAgIH0pO1xuICAgICR1cmxSb3V0ZXJQcm92aWRlci5vdGhlcndpc2UoJy8nKTtcbn0pO1xuLyogQG5nSW5qZWN0ICovXG5tLnJ1bigoJHJvb3RTY29wZSwgJGxvY2FsU3RvcmFnZSwgYXV0aFNlcnZpY2UpID0+IHtcbiAgICAkcm9vdFNjb3BlLmF1dGhJbmZvID0ge1xuICAgICAgICBhdXRoT3BlbjogZmFsc2UsXG4gICAgICAgIHVybDogdW5kZWZpbmVkLFxuICAgICAgICB1c2VybmFtZTogdW5kZWZpbmVkLFxuICAgICAgICBwYXNzd29yZDogdW5kZWZpbmVkXG4gICAgfTtcbiAgICBpZiAoISRsb2NhbFN0b3JhZ2UuYXV0aG9yaXphdGlvbilcbiAgICAgICAgJGxvY2FsU3RvcmFnZS5hdXRob3JpemF0aW9uID0ge307XG4gICAgYXV0aHMgPSAkbG9jYWxTdG9yYWdlLmF1dGhvcml6YXRpb247XG4gICAgJHJvb3RTY29wZS5zZXRBdXRoID0gKCkgPT4ge1xuICAgICAgICAkcm9vdFNjb3BlLmF1dGhJbmZvLmF1dGhPcGVuID0gZmFsc2U7XG4gICAgICAgIGF1dGhzWyRyb290U2NvcGUuYXV0aEluZm8udXJsXSA9ICdCYXNpYyAnICsgYnRvYSgkcm9vdFNjb3BlLmF1dGhJbmZvLnVzZXJuYW1lICsgJzonICsgJHJvb3RTY29wZS5hdXRoSW5mby5wYXNzd29yZCk7XG4gICAgICAgIGF1dGhTZXJ2aWNlLmxvZ2luQ29uZmlybWVkKCk7XG4gICAgfTtcbiAgICAkcm9vdFNjb3BlLmRpc21pc3NBdXRoID0gKCkgPT4ge1xuICAgICAgICAkcm9vdFNjb3BlLmF1dGhJbmZvLmF1dGhPcGVuID0gZmFsc2U7XG4gICAgICAgIGF1dGhTZXJ2aWNlLmxvZ2luQ2FuY2VsbGVkKHsgc3RhdHVzOiA0MDEgfSwgJ0F1dGhlbnRpY2F0aW9uIHJlcXVpcmVkJyk7XG4gICAgfTtcbiAgICAkcm9vdFNjb3BlLiRvbignZXZlbnQ6YXV0aC1sb2dpblJlcXVpcmVkJywgKGV2ZW50LCByZWplY3RlZCkgPT4ge1xuICAgICAgICAkcm9vdFNjb3BlLmF1dGhJbmZvLnVybCA9IHJlamVjdGVkLmNvbmZpZy51cmw7XG4gICAgICAgICRyb290U2NvcGUuYXV0aEluZm8uYXV0aE9wZW4gPSB0cnVlO1xuICAgIH0pO1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gYXBwL2luZGV4LnRzIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7OztBQUxBO0FBS0E7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQVdBO0FBYkE7QUFlQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFYQTtBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXJCQTtBQXVCQTtBQXpCQTtBQTJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///108\n")},function(module,exports,__webpack_require__){eval("/**\n * State-based routing for AngularJS 1.x\n * This bundle requires the ui-router-core.js bundle from the @uirouter/core package.\n * @version v1.0.13\n * @link https://ui-router.github.io\n * @license MIT License, http://www.opensource.org/licenses/MIT\n */\n(function (global, factory) {\n\t true ? factory(exports, __webpack_require__(7), __webpack_require__(110)) :\n\ttypeof define === 'function' && define.amd ? define(['exports', 'angular', '@uirouter/core'], factory) :\n\t(factory((global['@uirouter/angularjs'] = {}),global.angular,global['@uirouter/core']));\n}(this, (function (exports,ng_from_import,core) { 'use strict';\n\nvar ng_from_global = angular;\nvar ng = (ng_from_import && ng_from_import.module) ? ng_from_import : ng_from_global;\n\nfunction getNg1ViewConfigFactory() {\n    var templateFactory = null;\n    return function (path, view) {\n        templateFactory = templateFactory || core.services.$injector.get('$templateFactory');\n        return [new Ng1ViewConfig(path, view, templateFactory)];\n    };\n}\nvar hasAnyKey = function (keys, obj) {\n    return keys.reduce(function (acc, key) { return acc || core.isDefined(obj[key]); }, false);\n};\n/**\n * This is a [[StateBuilder.builder]] function for angular1 `views`.\n *\n * When the [[StateBuilder]] builds a [[StateObject]] object from a raw [[StateDeclaration]], this builder\n * handles the `views` property with logic specific to @uirouter/angularjs (ng1).\n *\n * If no `views: {}` property exists on the [[StateDeclaration]], then it creates the `views` object\n * and applies the state-level configuration to a view named `$default`.\n */\nfunction ng1ViewsBuilder(state) {\n    // Do not process root state\n    if (!state.parent)\n        return {};\n    var tplKeys = ['templateProvider', 'templateUrl', 'template', 'notify', 'async'], ctrlKeys = ['controller', 'controllerProvider', 'controllerAs', 'resolveAs'], compKeys = ['component', 'bindings', 'componentProvider'], nonCompKeys = tplKeys.concat(ctrlKeys), allViewKeys = compKeys.concat(nonCompKeys);\n    // Do not allow a state to have both state-level props and also a `views: {}` property.\n    // A state without a `views: {}` property can declare properties for the `$default` view as properties of the state.\n    // However, the `$default` approach should not be mixed with a separate `views: ` block.\n    if (core.isDefined(state.views) && hasAnyKey(allViewKeys, state)) {\n        throw new Error(\"State '\" + state.name + \"' has a 'views' object. \" +\n            \"It cannot also have \\\"view properties\\\" at the state level.  \" +\n            \"Move the following properties into a view (in the 'views' object): \" +\n            (\" \" + allViewKeys.filter(function (key) { return core.isDefined(state[key]); }).join(', ')));\n    }\n    var views = {}, viewsObject = state.views || { '$default': core.pick(state, allViewKeys) };\n    core.forEach(viewsObject, function (config, name) {\n        // Account for views: { \"\": { template... } }\n        name = name || '$default';\n        // Account for views: { header: \"headerComponent\" }\n        if (core.isString(config))\n            config = { component: config };\n        // Make a shallow copy of the config object\n        config = core.extend({}, config);\n        // Do not allow a view to mix props for component-style view with props for template/controller-style view\n        if (hasAnyKey(compKeys, config) && hasAnyKey(nonCompKeys, config)) {\n            throw new Error(\"Cannot combine: \" + compKeys.join('|') + \" with: \" + nonCompKeys.join('|') + \" in stateview: '\" + name + \"@\" + state.name + \"'\");\n        }\n        config.resolveAs = config.resolveAs || '$resolve';\n        config.$type = 'ng1';\n        config.$context = state;\n        config.$name = name;\n        var normalized = core.ViewService.normalizeUIViewTarget(config.$context, config.$name);\n        config.$uiViewName = normalized.uiViewName;\n        config.$uiViewContextAnchor = normalized.uiViewContextAnchor;\n        views[name] = config;\n    });\n    return views;\n}\nvar id = 0;\nvar Ng1ViewConfig = /** @class */ (function () {\n    function Ng1ViewConfig(path, viewDecl, factory) {\n        var _this = this;\n        this.path = path;\n        this.viewDecl = viewDecl;\n        this.factory = factory;\n        this.$id = id++;\n        this.loaded = false;\n        this.getTemplate = function (uiView, context) {\n            return _this.component ? _this.factory.makeComponentTemplate(uiView, context, _this.component, _this.viewDecl.bindings) : _this.template;\n        };\n    }\n    Ng1ViewConfig.prototype.load = function () {\n        var _this = this;\n        var $q = core.services.$q;\n        var context = new core.ResolveContext(this.path);\n        var params = this.path.reduce(function (acc, node) { return core.extend(acc, node.paramValues); }, {});\n        var promises = {\n            template: $q.when(this.factory.fromConfig(this.viewDecl, params, context)),\n            controller: $q.when(this.getController(context)),\n        };\n        return $q.all(promises).then(function (results) {\n            core.trace.traceViewServiceEvent('Loaded', _this);\n            _this.controller = results.controller;\n            core.extend(_this, results.template); // Either { template: \"tpl\" } or { component: \"cmpName\" }\n            return _this;\n        });\n    };\n    /**\n     * Gets the controller for a view configuration.\n     *\n     * @returns {Function|Promise.<Function>} Returns a controller, or a promise that resolves to a controller.\n     */\n    Ng1ViewConfig.prototype.getController = function (context) {\n        var provider = this.viewDecl.controllerProvider;\n        if (!core.isInjectable(provider))\n            return this.viewDecl.controller;\n        var deps = core.services.$injector.annotate(provider);\n        var providerFn = core.isArray(provider) ? core.tail(provider) : provider;\n        var resolvable = new core.Resolvable('', providerFn, deps);\n        return resolvable.get(context);\n    };\n    return Ng1ViewConfig;\n}());\n\n/** @module view */\n/** for typedoc */\n/**\n * Service which manages loading of templates from a ViewConfig.\n */\nvar TemplateFactory = /** @class */ (function () {\n    function TemplateFactory() {\n        var _this = this;\n        /** @hidden */ this._useHttp = ng.version.minor < 3;\n        /** @hidden */ this.$get = ['$http', '$templateCache', '$injector', function ($http, $templateCache, $injector) {\n                _this.$templateRequest = $injector.has && $injector.has('$templateRequest') && $injector.get('$templateRequest');\n                _this.$http = $http;\n                _this.$templateCache = $templateCache;\n                return _this;\n            }];\n    }\n    /** @hidden */\n    TemplateFactory.prototype.useHttpService = function (value) {\n        this._useHttp = value;\n    };\n    /**\n     * Creates a template from a configuration object.\n     *\n     * @param config Configuration object for which to load a template.\n     * The following properties are search in the specified order, and the first one\n     * that is defined is used to create the template:\n     *\n     * @param params  Parameters to pass to the template function.\n     * @param context The resolve context associated with the template's view\n     *\n     * @return {string|object}  The template html as a string, or a promise for\n     * that string,or `null` if no template is configured.\n     */\n    TemplateFactory.prototype.fromConfig = function (config, params, context) {\n        var defaultTemplate = '<ui-view></ui-view>';\n        var asTemplate = function (result) { return core.services.$q.when(result).then(function (str) { return ({ template: str }); }); };\n        var asComponent = function (result) { return core.services.$q.when(result).then(function (str) { return ({ component: str }); }); };\n        return (core.isDefined(config.template) ? asTemplate(this.fromString(config.template, params)) :\n            core.isDefined(config.templateUrl) ? asTemplate(this.fromUrl(config.templateUrl, params)) :\n                core.isDefined(config.templateProvider) ? asTemplate(this.fromProvider(config.templateProvider, params, context)) :\n                    core.isDefined(config.component) ? asComponent(config.component) :\n                        core.isDefined(config.componentProvider) ? asComponent(this.fromComponentProvider(config.componentProvider, params, context)) :\n                            asTemplate(defaultTemplate));\n    };\n    /**\n     * Creates a template from a string or a function returning a string.\n     *\n     * @param template html template as a string or function that returns an html template as a string.\n     * @param params Parameters to pass to the template function.\n     *\n     * @return {string|object} The template html as a string, or a promise for that\n     * string.\n     */\n    TemplateFactory.prototype.fromString = function (template, params) {\n        return core.isFunction(template) ? template(params) : template;\n    };\n    /**\n     * Loads a template from the a URL via `$http` and `$templateCache`.\n     *\n     * @param {string|Function} url url of the template to load, or a function\n     * that returns a url.\n     * @param {Object} params Parameters to pass to the url function.\n     * @return {string|Promise.<string>} The template html as a string, or a promise\n     * for that string.\n     */\n    TemplateFactory.prototype.fromUrl = function (url, params) {\n        if (core.isFunction(url))\n            url = url(params);\n        if (url == null)\n            return null;\n        if (this._useHttp) {\n            return this.$http.get(url, { cache: this.$templateCache, headers: { Accept: 'text/html' } })\n                .then(function (response) {\n                return response.data;\n            });\n        }\n        return this.$templateRequest(url);\n    };\n    /**\n     * Creates a template by invoking an injectable provider function.\n     *\n     * @param provider Function to invoke via `locals`\n     * @param {Function} injectFn a function used to invoke the template provider\n     * @return {string|Promise.<string>} The template html as a string, or a promise\n     * for that string.\n     */\n    TemplateFactory.prototype.fromProvider = function (provider, params, context) {\n        var deps = core.services.$injector.annotate(provider);\n        var providerFn = core.isArray(provider) ? core.tail(provider) : provider;\n        var resolvable = new core.Resolvable('', providerFn, deps);\n        return resolvable.get(context);\n    };\n    /**\n     * Creates a component's template by invoking an injectable provider function.\n     *\n     * @param provider Function to invoke via `locals`\n     * @param {Function} injectFn a function used to invoke the template provider\n     * @return {string} The template html as a string: \"<component-name input1='::$resolve.foo'></component-name>\".\n     */\n    TemplateFactory.prototype.fromComponentProvider = function (provider, params, context) {\n        var deps = core.services.$injector.annotate(provider);\n        var providerFn = core.isArray(provider) ? core.tail(provider) : provider;\n        var resolvable = new core.Resolvable('', providerFn, deps);\n        return resolvable.get(context);\n    };\n    /**\n     * Creates a template from a component's name\n     *\n     * This implements route-to-component.\n     * It works by retrieving the component (directive) metadata from the injector.\n     * It analyses the component's bindings, then constructs a template that instantiates the component.\n     * The template wires input and output bindings to resolves or from the parent component.\n     *\n     * @param uiView {object} The parent ui-view (for binding outputs to callbacks)\n     * @param context The ResolveContext (for binding outputs to callbacks returned from resolves)\n     * @param component {string} Component's name in camel case.\n     * @param bindings An object defining the component's bindings: {foo: '<'}\n     * @return {string} The template as a string: \"<component-name input1='::$resolve.foo'></component-name>\".\n     */\n    TemplateFactory.prototype.makeComponentTemplate = function (uiView, context, component, bindings) {\n        bindings = bindings || {};\n        // Bind once prefix\n        var prefix = ng.version.minor >= 3 ? '::' : '';\n        // Convert to kebob name. Add x- prefix if the string starts with `x-` or `data-`\n        var kebob = function (camelCase) {\n            var kebobed = core.kebobString(camelCase);\n            return /^(x|data)-/.exec(kebobed) ? \"x-\" + kebobed : kebobed;\n        };\n        var attributeTpl = function (input) {\n            var name = input.name, type = input.type;\n            var attrName = kebob(name);\n            // If the ui-view has an attribute which matches a binding on the routed component\n            // then pass that attribute through to the routed component template.\n            // Prefer ui-view wired mappings to resolve data, unless the resolve was explicitly bound using `bindings:`\n            if (uiView.attr(attrName) && !bindings[name])\n                return attrName + \"='\" + uiView.attr(attrName) + \"'\";\n            var resolveName = bindings[name] || name;\n            // Pre-evaluate the expression for \"@\" bindings by enclosing in {{ }}\n            // some-attr=\"{{ ::$resolve.someResolveName }}\"\n            if (type === '@')\n                return attrName + \"='{{\" + prefix + \"$resolve.\" + resolveName + \"}}'\";\n            // Wire \"&\" callbacks to resolves that return a callback function\n            // Get the result of the resolve (should be a function) and annotate it to get its arguments.\n            // some-attr=\"$resolve.someResolveResultName(foo, bar)\"\n            if (type === '&') {\n                var res = context.getResolvable(resolveName);\n                var fn = res && res.data;\n                var args = fn && core.services.$injector.annotate(fn) || [];\n                // account for array style injection, i.e., ['foo', function(foo) {}]\n                var arrayIdxStr = core.isArray(fn) ? \"[\" + (fn.length - 1) + \"]\" : '';\n                return attrName + \"='$resolve.\" + resolveName + arrayIdxStr + \"(\" + args.join(',') + \")'\";\n            }\n            // some-attr=\"::$resolve.someResolveName\"\n            return attrName + \"='\" + prefix + \"$resolve.\" + resolveName + \"'\";\n        };\n        var attrs = getComponentBindings(component).map(attributeTpl).join(' ');\n        var kebobName = kebob(component);\n        return \"<\" + kebobName + \" \" + attrs + \"></\" + kebobName + \">\";\n    };\n    return TemplateFactory;\n}());\n// Gets all the directive(s)' inputs ('@', '=', and '<') and outputs ('&')\nfunction getComponentBindings(name) {\n    var cmpDefs = core.services.$injector.get(name + 'Directive'); // could be multiple\n    if (!cmpDefs || !cmpDefs.length)\n        throw new Error(\"Unable to find component named '\" + name + \"'\");\n    return cmpDefs.map(getBindings).reduce(core.unnestR, []);\n}\n// Given a directive definition, find its object input attributes\n// Use different properties, depending on the type of directive (component, bindToController, normal)\nvar getBindings = function (def) {\n    if (core.isObject(def.bindToController))\n        return scopeBindings(def.bindToController);\n    return scopeBindings(def.scope);\n};\n// for ng 1.2 style, process the scope: { input: \"=foo\" }\n// for ng 1.3 through ng 1.5, process the component's bindToController: { input: \"=foo\" } object\nvar scopeBindings = function (bindingsObj) { return Object.keys(bindingsObj || {})\n    .map(function (key) { return [key, /^([=<@&])[?]?(.*)/.exec(bindingsObj[key])]; })\n    .filter(function (tuple) { return core.isDefined(tuple) && core.isArray(tuple[1]); })\n    .map(function (tuple) { return ({ name: tuple[1][2] || tuple[0], type: tuple[1][1] }); }); };\n\n/** @module ng1 */ /** for typedoc */\n/**\n * The Angular 1 `StateProvider`\n *\n * The `$stateProvider` works similar to Angular's v1 router, but it focuses purely\n * on state.\n *\n * A state corresponds to a \"place\" in the application in terms of the overall UI and\n * navigation. A state describes (via the controller / template / view properties) what\n * the UI looks like and does at that place.\n *\n * States often have things in common, and the primary way of factoring out these\n * commonalities in this model is via the state hierarchy, i.e. parent/child states aka\n * nested states.\n *\n * The `$stateProvider` provides interfaces to declare these states for your app.\n */\nvar StateProvider = /** @class */ (function () {\n    function StateProvider(stateRegistry, stateService) {\n        this.stateRegistry = stateRegistry;\n        this.stateService = stateService;\n        core.createProxyFunctions(core.val(StateProvider.prototype), this, core.val(this));\n    }\n    /**\n     * Decorates states when they are registered\n     *\n     * Allows you to extend (carefully) or override (at your own peril) the\n     * `stateBuilder` object used internally by [[StateRegistry]].\n     * This can be used to add custom functionality to ui-router,\n     * for example inferring templateUrl based on the state name.\n     *\n     * When passing only a name, it returns the current (original or decorated) builder\n     * function that matches `name`.\n     *\n     * The builder functions that can be decorated are listed below. Though not all\n     * necessarily have a good use case for decoration, that is up to you to decide.\n     *\n     * In addition, users can attach custom decorators, which will generate new\n     * properties within the state's internal definition. There is currently no clear\n     * use-case for this beyond accessing internal states (i.e. $state.$current),\n     * however, expect this to become increasingly relevant as we introduce additional\n     * meta-programming features.\n     *\n     * **Warning**: Decorators should not be interdependent because the order of\n     * execution of the builder functions in non-deterministic. Builder functions\n     * should only be dependent on the state definition object and super function.\n     *\n     *\n     * Existing builder functions and current return values:\n     *\n     * - **parent** `{object}` - returns the parent state object.\n     * - **data** `{object}` - returns state data, including any inherited data that is not\n     *   overridden by own values (if any).\n     * - **url** `{object}` - returns a {@link ui.router.util.type:UrlMatcher UrlMatcher}\n     *   or `null`.\n     * - **navigable** `{object}` - returns closest ancestor state that has a URL (aka is\n     *   navigable).\n     * - **params** `{object}` - returns an array of state params that are ensured to\n     *   be a super-set of parent's params.\n     * - **views** `{object}` - returns a views object where each key is an absolute view\n     *   name (i.e. \"viewName@stateName\") and each value is the config object\n     *   (template, controller) for the view. Even when you don't use the views object\n     *   explicitly on a state config, one is still created for you internally.\n     *   So by decorating this builder function you have access to decorating template\n     *   and controller properties.\n     * - **ownParams** `{object}` - returns an array of params that belong to the state,\n     *   not including any params defined by ancestor states.\n     * - **path** `{string}` - returns the full path from the root down to this state.\n     *   Needed for state activation.\n     * - **includes** `{object}` - returns an object that includes every state that\n     *   would pass a `$state.includes()` test.\n     *\n     * #### Example:\n     * Override the internal 'views' builder with a function that takes the state\n     * definition, and a reference to the internal function being overridden:\n     * ```js\n     * $stateProvider.decorator('views', function (state, parent) {\n     *   let result = {},\n     *       views = parent(state);\n     *\n     *   angular.forEach(views, function (config, name) {\n     *     let autoName = (state.name + '.' + name).replace('.', '/');\n     *     config.templateUrl = config.templateUrl || '/partials/' + autoName + '.html';\n     *     result[name] = config;\n     *   });\n     *   return result;\n     * });\n     *\n     * $stateProvider.state('home', {\n     *   views: {\n     *     'contact.list': { controller: 'ListController' },\n     *     'contact.item': { controller: 'ItemController' }\n     *   }\n     * });\n     * ```\n     *\n     *\n     * ```js\n     * // Auto-populates list and item views with /partials/home/contact/list.html,\n     * // and /partials/home/contact/item.html, respectively.\n     * $state.go('home');\n     * ```\n     *\n     * @param {string} name The name of the builder function to decorate.\n     * @param {object} func A function that is responsible for decorating the original\n     * builder function. The function receives two parameters:\n     *\n     *   - `{object}` - state - The state config object.\n     *   - `{object}` - super - The original builder function.\n     *\n     * @return {object} $stateProvider - $stateProvider instance\n     */\n    StateProvider.prototype.decorator = function (name, func) {\n        return this.stateRegistry.decorator(name, func) || this;\n    };\n    StateProvider.prototype.state = function (name, definition) {\n        if (core.isObject(name)) {\n            definition = name;\n        }\n        else {\n            definition.name = name;\n        }\n        this.stateRegistry.register(definition);\n        return this;\n    };\n    /**\n     * Registers an invalid state handler\n     *\n     * This is a passthrough to [[StateService.onInvalid]] for ng1.\n     */\n    StateProvider.prototype.onInvalid = function (callback) {\n        return this.stateService.onInvalid(callback);\n    };\n    return StateProvider;\n}());\n\n/** @module ng1 */ /** */\n/**\n * This is a [[StateBuilder.builder]] function for angular1 `onEnter`, `onExit`,\n * `onRetain` callback hooks on a [[Ng1StateDeclaration]].\n *\n * When the [[StateBuilder]] builds a [[StateObject]] object from a raw [[StateDeclaration]], this builder\n * ensures that those hooks are injectable for @uirouter/angularjs (ng1).\n */\nvar getStateHookBuilder = function (hookName) {\n    return function stateHookBuilder(stateObject, parentFn) {\n        var hook = stateObject[hookName];\n        var pathname = hookName === 'onExit' ? 'from' : 'to';\n        function decoratedNg1Hook(trans, state) {\n            var resolveContext = new core.ResolveContext(trans.treeChanges(pathname));\n            var subContext = resolveContext.subContext(state.$$state());\n            var locals = core.extend(getLocals(subContext), { $state$: state, $transition$: trans });\n            return core.services.$injector.invoke(hook, this, locals);\n        }\n        return hook ? decoratedNg1Hook : undefined;\n    };\n};\n\n/**\n * @internalapi\n * @module ng1\n */ /** */\n/**\n * Implements UI-Router LocationServices and LocationConfig using Angular 1's $location service\n */\nvar Ng1LocationServices = /** @class */ (function () {\n    function Ng1LocationServices($locationProvider) {\n        // .onChange() registry\n        this._urlListeners = [];\n        this.$locationProvider = $locationProvider;\n        var _lp = core.val($locationProvider);\n        core.createProxyFunctions(_lp, this, _lp, ['hashPrefix']);\n    }\n    /**\n     * Applys ng1-specific path parameter encoding\n     *\n     * The Angular 1 `$location` service is a bit weird.\n     * It doesn't allow slashes to be encoded/decoded bi-directionally.\n     *\n     * See the writeup at https://github.com/angular-ui/ui-router/issues/2598\n     *\n     * This code patches the `path` parameter type so it encoded/decodes slashes as ~2F\n     *\n     * @param router\n     */\n    Ng1LocationServices.monkeyPatchPathParameterType = function (router) {\n        var pathType = router.urlMatcherFactory.type('path');\n        pathType.encode = function (x) {\n            return x != null ? x.toString().replace(/(~|\\/)/g, function (m) { return ({ '~': '~~', '/': '~2F' }[m]); }) : x;\n        };\n        pathType.decode = function (x) {\n            return x != null ? x.toString().replace(/(~~|~2F)/g, function (m) { return ({ '~~': '~', '~2F': '/' }[m]); }) : x;\n        };\n    };\n    Ng1LocationServices.prototype.dispose = function () { };\n    Ng1LocationServices.prototype.onChange = function (callback) {\n        var _this = this;\n        this._urlListeners.push(callback);\n        return function () { return core.removeFrom(_this._urlListeners)(callback); };\n    };\n    Ng1LocationServices.prototype.html5Mode = function () {\n        var html5Mode = this.$locationProvider.html5Mode();\n        html5Mode = core.isObject(html5Mode) ? html5Mode.enabled : html5Mode;\n        return html5Mode && this.$sniffer.history;\n    };\n    Ng1LocationServices.prototype.url = function (newUrl, replace, state) {\n        if (replace === void 0) { replace = false; }\n        if (core.isDefined(newUrl))\n            this.$location.url(newUrl);\n        if (replace)\n            this.$location.replace();\n        if (state)\n            this.$location.state(state);\n        return this.$location.url();\n    };\n    Ng1LocationServices.prototype._runtimeServices = function ($rootScope, $location, $sniffer, $browser) {\n        var _this = this;\n        this.$location = $location;\n        this.$sniffer = $sniffer;\n        // Bind $locationChangeSuccess to the listeners registered in LocationService.onChange\n        $rootScope.$on('$locationChangeSuccess', function (evt) { return _this._urlListeners.forEach(function (fn) { return fn(evt); }); });\n        var _loc = core.val($location);\n        var _browser = core.val($browser);\n        // Bind these LocationService functions to $location\n        core.createProxyFunctions(_loc, this, _loc, ['replace', 'path', 'search', 'hash']);\n        // Bind these LocationConfig functions to $location\n        core.createProxyFunctions(_loc, this, _loc, ['port', 'protocol', 'host']);\n        // Bind these LocationConfig functions to $browser\n        core.createProxyFunctions(_browser, this, _browser, ['baseHref']);\n    };\n    return Ng1LocationServices;\n}());\n\n/** @module url */ /** */\n/**\n * Manages rules for client-side URL\n *\n * ### Deprecation warning:\n * This class is now considered to be an internal API\n * Use the [[UrlService]] instead.\n * For configuring URL rules, use the [[UrlRulesApi]] which can be found as [[UrlService.rules]].\n *\n * This class manages the router rules for what to do when the URL changes.\n *\n * This provider remains for backwards compatibility.\n *\n * @deprecated\n */\nvar UrlRouterProvider = /** @class */ (function () {\n    /** @hidden */\n    function UrlRouterProvider(router) {\n        this._router = router;\n        this._urlRouter = router.urlRouter;\n    }\n    UrlRouterProvider.injectableHandler = function (router, handler) {\n        return function (match) {\n            return core.services.$injector.invoke(handler, null, { $match: match, $stateParams: router.globals.params });\n        };\n    };\n    /** @hidden */\n    UrlRouterProvider.prototype.$get = function () {\n        var urlRouter = this._urlRouter;\n        urlRouter.update(true);\n        if (!urlRouter.interceptDeferred)\n            urlRouter.listen();\n        return urlRouter;\n    };\n    /**\n     * Registers a url handler function.\n     *\n     * Registers a low level url handler (a `rule`).\n     * A rule detects specific URL patterns and returns a redirect, or performs some action.\n     *\n     * If a rule returns a string, the URL is replaced with the string, and all rules are fired again.\n     *\n     * #### Example:\n     * ```js\n     * var app = angular.module('app', ['ui.router.router']);\n     *\n     * app.config(function ($urlRouterProvider) {\n     *   // Here's an example of how you might allow case insensitive urls\n     *   $urlRouterProvider.rule(function ($injector, $location) {\n     *     var path = $location.path(),\n     *         normalized = path.toLowerCase();\n     *\n     *     if (path !== normalized) {\n     *       return normalized;\n     *     }\n     *   });\n     * });\n     * ```\n     *\n     * @param ruleFn\n     * Handler function that takes `$injector` and `$location` services as arguments.\n     * You can use them to detect a url and return a different url as a string.\n     *\n     * @return [[UrlRouterProvider]] (`this`)\n     */\n    UrlRouterProvider.prototype.rule = function (ruleFn) {\n        var _this = this;\n        if (!core.isFunction(ruleFn))\n            throw new Error(\"'rule' must be a function\");\n        var match = function () {\n            return ruleFn(core.services.$injector, _this._router.locationService);\n        };\n        var rule = new core.BaseUrlRule(match, core.identity);\n        this._urlRouter.rule(rule);\n        return this;\n    };\n    /**\n     * Defines the path or behavior to use when no url can be matched.\n     *\n     * #### Example:\n     * ```js\n     * var app = angular.module('app', ['ui.router.router']);\n     *\n     * app.config(function ($urlRouterProvider) {\n     *   // if the path doesn't match any of the urls you configured\n     *   // otherwise will take care of routing the user to the\n     *   // specified url\n     *   $urlRouterProvider.otherwise('/index');\n     *\n     *   // Example of using function rule as param\n     *   $urlRouterProvider.otherwise(function ($injector, $location) {\n     *     return '/a/valid/url';\n     *   });\n     * });\n     * ```\n     *\n     * @param rule\n     * The url path you want to redirect to or a function rule that returns the url path or performs a `$state.go()`.\n     * The function version is passed two params: `$injector` and `$location` services, and should return a url string.\n     *\n     * @return {object} `$urlRouterProvider` - `$urlRouterProvider` instance\n     */\n    UrlRouterProvider.prototype.otherwise = function (rule) {\n        var _this = this;\n        var urlRouter = this._urlRouter;\n        if (core.isString(rule)) {\n            urlRouter.otherwise(rule);\n        }\n        else if (core.isFunction(rule)) {\n            urlRouter.otherwise(function () { return rule(core.services.$injector, _this._router.locationService); });\n        }\n        else {\n            throw new Error(\"'rule' must be a string or function\");\n        }\n        return this;\n    };\n    /**\n     * Registers a handler for a given url matching.\n     *\n     * If the handler is a string, it is\n     * treated as a redirect, and is interpolated according to the syntax of match\n     * (i.e. like `String.replace()` for `RegExp`, or like a `UrlMatcher` pattern otherwise).\n     *\n     * If the handler is a function, it is injectable.\n     * It gets invoked if `$location` matches.\n     * You have the option of inject the match object as `$match`.\n     *\n     * The handler can return\n     *\n     * - **falsy** to indicate that the rule didn't match after all, then `$urlRouter`\n     *   will continue trying to find another one that matches.\n     * - **string** which is treated as a redirect and passed to `$location.url()`\n     * - **void** or any **truthy** value tells `$urlRouter` that the url was handled.\n     *\n     * #### Example:\n     * ```js\n     * var app = angular.module('app', ['ui.router.router']);\n     *\n     * app.config(function ($urlRouterProvider) {\n     *   $urlRouterProvider.when($state.url, function ($match, $stateParams) {\n     *     if ($state.$current.navigable !== state ||\n     *         !equalForKeys($match, $stateParams) {\n     *      $state.transitionTo(state, $match, false);\n     *     }\n     *   });\n     * });\n     * ```\n     *\n     * @param what A pattern string to match, compiled as a [[UrlMatcher]].\n     * @param handler The path (or function that returns a path) that you want to redirect your user to.\n     * @param ruleCallback [optional] A callback that receives the `rule` registered with [[UrlMatcher.rule]]\n     *\n     * Note: the handler may also invoke arbitrary code, such as `$state.go()`\n     */\n    UrlRouterProvider.prototype.when = function (what, handler) {\n        if (core.isArray(handler) || core.isFunction(handler)) {\n            handler = UrlRouterProvider.injectableHandler(this._router, handler);\n        }\n        this._urlRouter.when(what, handler);\n        return this;\n    };\n    /**\n     * Disables monitoring of the URL.\n     *\n     * Call this method before UI-Router has bootstrapped.\n     * It will stop UI-Router from performing the initial url sync.\n     *\n     * This can be useful to perform some asynchronous initialization before the router starts.\n     * Once the initialization is complete, call [[listen]] to tell UI-Router to start watching and synchronizing the URL.\n     *\n     * #### Example:\n     * ```js\n     * var app = angular.module('app', ['ui.router']);\n     *\n     * app.config(function ($urlRouterProvider) {\n     *   // Prevent $urlRouter from automatically intercepting URL changes;\n     *   $urlRouterProvider.deferIntercept();\n     * })\n     *\n     * app.run(function (MyService, $urlRouter, $http) {\n     *   $http.get(\"/stuff\").then(function(resp) {\n     *     MyService.doStuff(resp.data);\n     *     $urlRouter.listen();\n     *     $urlRouter.sync();\n     *   });\n     * });\n     * ```\n     *\n     * @param defer Indicates whether to defer location change interception.\n     *        Passing no parameter is equivalent to `true`.\n     */\n    UrlRouterProvider.prototype.deferIntercept = function (defer) {\n        this._urlRouter.deferIntercept(defer);\n    };\n    return UrlRouterProvider;\n}());\n\n/**\n * # Angular 1 types\n *\n * UI-Router core provides various Typescript types which you can use for code completion and validating parameter values, etc.\n * The customizations to the core types for Angular UI-Router are documented here.\n *\n * The optional [[$resolve]] service is also documented here.\n *\n * @module ng1\n * @preferred\n */\n/** for typedoc */\nng.module('ui.router.angular1', []);\nvar mod_init = ng.module('ui.router.init', []);\nvar mod_util = ng.module('ui.router.util', ['ng', 'ui.router.init']);\nvar mod_rtr = ng.module('ui.router.router', ['ui.router.util']);\nvar mod_state = ng.module('ui.router.state', ['ui.router.router', 'ui.router.util', 'ui.router.angular1']);\nvar mod_main = ng.module('ui.router', ['ui.router.init', 'ui.router.state', 'ui.router.angular1']);\nvar mod_cmpt = ng.module('ui.router.compat', ['ui.router']); // tslint:disable-line\nvar router = null;\n$uiRouterProvider.$inject = ['$locationProvider'];\n/** This angular 1 provider instantiates a Router and exposes its services via the angular injector */\nfunction $uiRouterProvider($locationProvider) {\n    // Create a new instance of the Router when the $uiRouterProvider is initialized\n    router = this.router = new core.UIRouter();\n    router.stateProvider = new StateProvider(router.stateRegistry, router.stateService);\n    // Apply ng1 specific StateBuilder code for `views`, `resolve`, and `onExit/Retain/Enter` properties\n    router.stateRegistry.decorator('views', ng1ViewsBuilder);\n    router.stateRegistry.decorator('onExit', getStateHookBuilder('onExit'));\n    router.stateRegistry.decorator('onRetain', getStateHookBuilder('onRetain'));\n    router.stateRegistry.decorator('onEnter', getStateHookBuilder('onEnter'));\n    router.viewService._pluginapi._viewConfigFactory('ng1', getNg1ViewConfigFactory());\n    var ng1LocationService = router.locationService = router.locationConfig = new Ng1LocationServices($locationProvider);\n    Ng1LocationServices.monkeyPatchPathParameterType(router);\n    // backwards compat: also expose router instance as $uiRouterProvider.router\n    router['router'] = router;\n    router['$get'] = $get;\n    $get.$inject = ['$location', '$browser', '$sniffer', '$rootScope', '$http', '$templateCache'];\n    function $get($location, $browser, $sniffer, $rootScope, $http, $templateCache) {\n        ng1LocationService._runtimeServices($rootScope, $location, $sniffer, $browser);\n        delete router['router'];\n        delete router['$get'];\n        return router;\n    }\n    return router;\n}\nvar getProviderFor = function (serviceName) { return ['$uiRouterProvider', function ($urp) {\n        var service = $urp.router[serviceName];\n        service['$get'] = function () { return service; };\n        return service;\n    }]; };\n// This effectively calls $get() on `$uiRouterProvider` to trigger init (when ng enters runtime)\nrunBlock.$inject = ['$injector', '$q', '$uiRouter'];\nfunction runBlock($injector, $q, $uiRouter) {\n    core.services.$injector = $injector;\n    core.services.$q = $q;\n    // The $injector is now available.\n    // Find any resolvables that had dependency annotation deferred\n    $uiRouter.stateRegistry.get()\n        .map(function (x) { return x.$$state().resolvables; })\n        .reduce(core.unnestR, [])\n        .filter(function (x) { return x.deps === 'deferred'; })\n        .forEach(function (resolvable) { return resolvable.deps = $injector.annotate(resolvable.resolveFn, $injector.strictDi); });\n}\n// $urlRouter service and $urlRouterProvider\nvar getUrlRouterProvider = function (uiRouter) {\n    return uiRouter.urlRouterProvider = new UrlRouterProvider(uiRouter);\n};\n// $state service and $stateProvider\n// $urlRouter service and $urlRouterProvider\nvar getStateProvider = function () {\n    return core.extend(router.stateProvider, { $get: function () { return router.stateService; } });\n};\nwatchDigests.$inject = ['$rootScope'];\nfunction watchDigests($rootScope) {\n    $rootScope.$watch(function () { core.trace.approximateDigests++; });\n}\nmod_init.provider('$uiRouter', $uiRouterProvider);\nmod_rtr.provider('$urlRouter', ['$uiRouterProvider', getUrlRouterProvider]);\nmod_util.provider('$urlService', getProviderFor('urlService'));\nmod_util.provider('$urlMatcherFactory', ['$uiRouterProvider', function () { return router.urlMatcherFactory; }]);\nmod_util.provider('$templateFactory', function () { return new TemplateFactory(); });\nmod_state.provider('$stateRegistry', getProviderFor('stateRegistry'));\nmod_state.provider('$uiRouterGlobals', getProviderFor('globals'));\nmod_state.provider('$transitions', getProviderFor('transitionService'));\nmod_state.provider('$state', ['$uiRouterProvider', getStateProvider]);\nmod_state.factory('$stateParams', ['$uiRouter', function ($uiRouter) { return $uiRouter.globals.params; }]);\nmod_main.factory('$view', function () { return router.viewService; });\nmod_main.service('$trace', function () { return core.trace; });\nmod_main.run(watchDigests);\nmod_util.run(['$urlMatcherFactory', function ($urlMatcherFactory) { }]);\nmod_state.run(['$state', function ($state) { }]);\nmod_rtr.run(['$urlRouter', function ($urlRouter) { }]);\nmod_init.run(runBlock);\n/** @hidden TODO: find a place to move this */\nvar getLocals = function (ctx) {\n    var tokens = ctx.getTokens().filter(core.isString);\n    var tuples = tokens.map(function (key) {\n        var resolvable = ctx.getResolvable(key);\n        var waitPolicy = ctx.getPolicy(resolvable).async;\n        return [key, waitPolicy === 'NOWAIT' ? resolvable.promise : resolvable.data];\n    });\n    return tuples.reduce(core.applyPairs, {});\n};\n\n/**\n * The current (or pending) State Parameters\n *\n * An injectable global **Service Object** which holds the state parameters for the latest **SUCCESSFUL** transition.\n *\n * The values are not updated until *after* a `Transition` successfully completes.\n *\n * **Also:** an injectable **Per-Transition Object** object which holds the pending state parameters for the pending `Transition` currently running.\n *\n * ### Deprecation warning:\n *\n * The value injected for `$stateParams` is different depending on where it is injected.\n *\n * - When injected into an angular service, the object injected is the global **Service Object** with the parameter values for the latest successful `Transition`.\n * - When injected into transition hooks, resolves, or view controllers, the object is the **Per-Transition Object** with the parameter values for the running `Transition`.\n *\n * Because of these confusing details, this service is deprecated.\n *\n * ### Instead of using the global `$stateParams` service object,\n * inject [[$uiRouterGlobals]] and use [[UIRouterGlobals.params]]\n *\n * ```js\n * MyService.$inject = ['$uiRouterGlobals'];\n * function MyService($uiRouterGlobals) {\n *   return {\n *     paramValues: function () {\n *       return $uiRouterGlobals.params;\n *     }\n *   }\n * }\n * ```\n *\n * ### Instead of using the per-transition `$stateParams` object,\n * inject the current `Transition` (as [[$transition$]]) and use [[Transition.params]]\n *\n * ```js\n * MyController.$inject = ['$transition$'];\n * function MyController($transition$) {\n *   var username = $transition$.params().username;\n *   // .. do something with username\n * }\n * ```\n *\n * ---\n *\n * This object can be injected into other services.\n *\n * #### Deprecated Example:\n * ```js\n * SomeService.$inject = ['$http', '$stateParams'];\n * function SomeService($http, $stateParams) {\n *   return {\n *     getUser: function() {\n *       return $http.get('/api/users/' + $stateParams.username);\n *     }\n *   }\n * };\n * angular.service('SomeService', SomeService);\n * ```\n * @deprecated\n */\n\n/**\n * # Angular 1 Directives\n *\n * These are the directives included in UI-Router for Angular 1.\n * These directives are used in templates to create viewports and link/navigate to states.\n *\n * @ng1api\n * @preferred\n * @module directives\n */ /** for typedoc */\n/** @hidden */\nfunction parseStateRef(ref) {\n    var parsed;\n    var paramsOnly = ref.match(/^\\s*({[^}]*})\\s*$/);\n    if (paramsOnly)\n        ref = '(' + paramsOnly[1] + ')';\n    parsed = ref.replace(/\\n/g, ' ').match(/^\\s*([^(]*?)\\s*(\\((.*)\\))?\\s*$/);\n    if (!parsed || parsed.length !== 4)\n        throw new Error(\"Invalid state ref '\" + ref + \"'\");\n    return { state: parsed[1] || null, paramExpr: parsed[3] || null };\n}\n/** @hidden */\nfunction stateContext(el) {\n    var $uiView = el.parent().inheritedData('$uiView');\n    var path = core.parse('$cfg.path')($uiView);\n    return path ? core.tail(path).state.name : undefined;\n}\n/** @hidden */\nfunction processedDef($state, $element, def) {\n    var uiState = def.uiState || $state.current.name;\n    var uiStateOpts = core.extend(defaultOpts($element, $state), def.uiStateOpts || {});\n    var href = $state.href(uiState, def.uiStateParams, uiStateOpts);\n    return { uiState: uiState, uiStateParams: def.uiStateParams, uiStateOpts: uiStateOpts, href: href };\n}\n/** @hidden */\nfunction getTypeInfo(el) {\n    // SVGAElement does not use the href attribute, but rather the 'xlinkHref' attribute.\n    var isSvg = Object.prototype.toString.call(el.prop('href')) === '[object SVGAnimatedString]';\n    var isForm = el[0].nodeName === 'FORM';\n    return {\n        attr: isForm ? 'action' : (isSvg ? 'xlink:href' : 'href'),\n        isAnchor: el.prop('tagName').toUpperCase() === 'A',\n        clickable: !isForm,\n    };\n}\n/** @hidden */\nfunction clickHook(el, $state, $timeout, type, getDef) {\n    return function (e) {\n        var button = e.which || e.button, target = getDef();\n        if (!(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || el.attr('target'))) {\n            // HACK: This is to allow ng-clicks to be processed before the transition is initiated:\n            var transition_1 = $timeout(function () {\n                $state.go(target.uiState, target.uiStateParams, target.uiStateOpts);\n            });\n            e.preventDefault();\n            // if the state has no URL, ignore one preventDefault from the <a> directive.\n            var ignorePreventDefaultCount_1 = type.isAnchor && !target.href ? 1 : 0;\n            e.preventDefault = function () {\n                if (ignorePreventDefaultCount_1-- <= 0)\n                    $timeout.cancel(transition_1);\n            };\n        }\n    };\n}\n/** @hidden */\nfunction defaultOpts(el, $state) {\n    return {\n        relative: stateContext(el) || $state.$current,\n        inherit: true,\n        source: 'sref',\n    };\n}\n/** @hidden */\nfunction bindEvents(element, scope, hookFn, uiStateOpts) {\n    var events;\n    if (uiStateOpts) {\n        events = uiStateOpts.events;\n    }\n    if (!core.isArray(events)) {\n        events = ['click'];\n    }\n    var on = element.on ? 'on' : 'bind';\n    for (var _i = 0, events_1 = events; _i < events_1.length; _i++) {\n        var event_1 = events_1[_i];\n        element[on](event_1, hookFn);\n    }\n    scope.$on('$destroy', function () {\n        var off = element.off ? 'off' : 'unbind';\n        for (var _i = 0, events_2 = events; _i < events_2.length; _i++) {\n            var event_2 = events_2[_i];\n            element[off](event_2, hookFn);\n        }\n    });\n}\n/**\n * `ui-sref`: A directive for linking to a state\n *\n * A directive which links to a state (and optionally, parameters).\n * When clicked, this directive activates the linked state with the supplied parameter values.\n *\n * ### Linked State\n * The attribute value of the `ui-sref` is the name of the state to link to.\n *\n * #### Example:\n * This will activate the `home` state when the link is clicked.\n * ```html\n * <a ui-sref=\"home\">Home</a>\n * ```\n *\n * ### Relative Links\n * You can also use relative state paths within `ui-sref`, just like a relative path passed to `$state.go()` ([[StateService.go]]).\n * You just need to be aware that the path is relative to the state that *created* the link.\n * This allows a state to create a relative `ui-sref` which always targets the same destination.\n *\n * #### Example:\n * Both these links are relative to the parent state, even when a child state is currently active.\n * ```html\n * <a ui-sref=\".child1\">child 1 state</a>\n * <a ui-sref=\".child2\">child 2 state</a>\n * ```\n *\n * This link activates the parent state.\n * ```html\n * <a ui-sref=\"^\">Return</a>\n * ```\n *\n * ### hrefs\n * If the linked state has a URL, the directive will automatically generate and\n * update the `href` attribute (using the [[StateService.href]]  method).\n *\n * #### Example:\n * Assuming the `users` state has a url of `/users/`\n * ```html\n * <a ui-sref=\"users\" href=\"/users/\">Users</a>\n * ```\n *\n * ### Parameter Values\n * In addition to the state name, a `ui-sref` can include parameter values which are applied when activating the state.\n * Param values can be provided in the `ui-sref` value after the state name, enclosed by parentheses.\n * The content inside the parentheses is an expression, evaluated to the parameter values.\n *\n * #### Example:\n * This example renders a list of links to users.\n * The state's `userId` parameter value comes from each user's `user.id` property.\n * ```html\n * <li ng-repeat=\"user in users\">\n *   <a ui-sref=\"users.detail({ userId: user.id })\">{{ user.displayName }}</a>\n * </li>\n * ```\n *\n * Note:\n * The parameter values expression is `$watch`ed for updates.\n *\n * ### Transition Options\n * You can specify [[TransitionOptions]] to pass to [[StateService.go]] by using the `ui-sref-opts` attribute.\n * Options are restricted to `location`, `inherit`, and `reload`.\n *\n * #### Example:\n * ```html\n * <a ui-sref=\"home\" ui-sref-opts=\"{ reload: true }\">Home</a>\n * ```\n *\n * ### Other DOM Events\n *\n * You can also customize which DOM events to respond to (instead of `click`) by\n * providing an `events` array in the `ui-sref-opts` attribute.\n *\n * #### Example:\n * ```html\n * <input type=\"text\" ui-sref=\"contacts\" ui-sref-opts=\"{ events: ['change', 'blur'] }\">\n * ```\n *\n * ### Highlighting the active link\n * This directive can be used in conjunction with [[uiSrefActive]] to highlight the active link.\n *\n * ### Examples\n * If you have the following template:\n *\n * ```html\n * <a ui-sref=\"home\">Home</a>\n * <a ui-sref=\"about\">About</a>\n * <a ui-sref=\"{page: 2}\">Next page</a>\n *\n * <ul>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a ui-sref=\"contacts.detail({ id: contact.id })\">{{ contact.name }}</a>\n *     </li>\n * </ul>\n * ```\n *\n * Then (assuming the current state is `contacts`) the rendered html including hrefs would be:\n *\n * ```html\n * <a href=\"#/home\" ui-sref=\"home\">Home</a>\n * <a href=\"#/about\" ui-sref=\"about\">About</a>\n * <a href=\"#/contacts?page=2\" ui-sref=\"{page: 2}\">Next page</a>\n *\n * <ul>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/1\" ui-sref=\"contacts.detail({ id: contact.id })\">Joe</a>\n *     </li>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/2\" ui-sref=\"contacts.detail({ id: contact.id })\">Alice</a>\n *     </li>\n *     <li ng-repeat=\"contact in contacts\">\n *         <a href=\"#/contacts/3\" ui-sref=\"contacts.detail({ id: contact.id })\">Bob</a>\n *     </li>\n * </ul>\n *\n * <a href=\"#/home\" ui-sref=\"home\" ui-sref-opts=\"{reload: true}\">Home</a>\n * ```\n *\n * ### Notes\n *\n * - You can use `ui-sref` to change **only the parameter values** by omitting the state name and parentheses.\n * #### Example:\n * Sets the `lang` parameter to `en` and remains on the same state.\n *\n * ```html\n * <a ui-sref=\"{ lang: 'en' }\">English</a>\n * ```\n *\n * - A middle-click, right-click, or ctrl-click is handled (natively) by the browser to open the href in a new window, for example.\n *\n * - Unlike the parameter values expression, the state name is not `$watch`ed (for performance reasons).\n * If you need to dynamically update the state being linked to, use the fully dynamic [[uiState]] directive.\n */\nvar uiSrefDirective;\nuiSrefDirective = ['$uiRouter', '$timeout',\n    function $StateRefDirective($uiRouter, $timeout) {\n        var $state = $uiRouter.stateService;\n        return {\n            restrict: 'A',\n            require: ['?^uiSrefActive', '?^uiSrefActiveEq'],\n            link: function (scope, element, attrs, uiSrefActive) {\n                var type = getTypeInfo(element);\n                var active = uiSrefActive[1] || uiSrefActive[0];\n                var unlinkInfoFn = null;\n                var hookFn;\n                var rawDef = {};\n                var getDef = function () { return processedDef($state, element, rawDef); };\n                var ref = parseStateRef(attrs.uiSref);\n                rawDef.uiState = ref.state;\n                rawDef.uiStateOpts = attrs.uiSrefOpts ? scope.$eval(attrs.uiSrefOpts) : {};\n                function update() {\n                    var def = getDef();\n                    if (unlinkInfoFn)\n                        unlinkInfoFn();\n                    if (active)\n                        unlinkInfoFn = active.$$addStateInfo(def.uiState, def.uiStateParams);\n                    if (def.href != null)\n                        attrs.$set(type.attr, def.href);\n                }\n                if (ref.paramExpr) {\n                    scope.$watch(ref.paramExpr, function (val$$1) {\n                        rawDef.uiStateParams = core.extend({}, val$$1);\n                        update();\n                    }, true);\n                    rawDef.uiStateParams = core.extend({}, scope.$eval(ref.paramExpr));\n                }\n                update();\n                scope.$on('$destroy', $uiRouter.stateRegistry.onStatesChanged(update));\n                scope.$on('$destroy', $uiRouter.transitionService.onSuccess({}, update));\n                if (!type.clickable)\n                    return;\n                hookFn = clickHook(element, $state, $timeout, type, getDef);\n                bindEvents(element, scope, hookFn, rawDef.uiStateOpts);\n            },\n        };\n    }];\n/**\n * `ui-state`: A fully dynamic directive for linking to a state\n *\n * A directive which links to a state (and optionally, parameters).\n * When clicked, this directive activates the linked state with the supplied parameter values.\n *\n * **This directive is very similar to [[uiSref]], but it `$observe`s and `$watch`es/evaluates all its inputs.**\n *\n * A directive which links to a state (and optionally, parameters).\n * When clicked, this directive activates the linked state with the supplied parameter values.\n *\n * ### Linked State\n * The attribute value of `ui-state` is an expression which is `$watch`ed and evaluated as the state to link to.\n * **This is in contrast with `ui-sref`, which takes a state name as a string literal.**\n *\n * #### Example:\n * Create a list of links.\n * ```html\n * <li ng-repeat=\"link in navlinks\">\n *   <a ui-state=\"link.state\">{{ link.displayName }}</a>\n * </li>\n * ```\n *\n * ### Relative Links\n * If the expression evaluates to a relative path, it is processed like [[uiSref]].\n * You just need to be aware that the path is relative to the state that *created* the link.\n * This allows a state to create relative `ui-state` which always targets the same destination.\n *\n * ### hrefs\n * If the linked state has a URL, the directive will automatically generate and\n * update the `href` attribute (using the [[StateService.href]]  method).\n *\n * ### Parameter Values\n * In addition to the state name expression, a `ui-state` can include parameter values which are applied when activating the state.\n * Param values should be provided using the `ui-state-params` attribute.\n * The `ui-state-params` attribute value is `$watch`ed and evaluated as an expression.\n *\n * #### Example:\n * This example renders a list of links with param values.\n * The state's `userId` parameter value comes from each user's `user.id` property.\n * ```html\n * <li ng-repeat=\"link in navlinks\">\n *   <a ui-state=\"link.state\" ui-state-params=\"link.params\">{{ link.displayName }}</a>\n * </li>\n * ```\n *\n * ### Transition Options\n * You can specify [[TransitionOptions]] to pass to [[StateService.go]] by using the `ui-state-opts` attribute.\n * Options are restricted to `location`, `inherit`, and `reload`.\n * The value of the `ui-state-opts` is `$watch`ed and evaluated as an expression.\n *\n * #### Example:\n * ```html\n * <a ui-state=\"returnto.state\" ui-state-opts=\"{ reload: true }\">Home</a>\n * ```\n *\n * ### Other DOM Events\n *\n * You can also customize which DOM events to respond to (instead of `click`) by\n * providing an `events` array in the `ui-state-opts` attribute.\n *\n * #### Example:\n * ```html\n * <input type=\"text\" ui-state=\"contacts\" ui-state-opts=\"{ events: ['change', 'blur'] }\">\n * ```\n *\n * ### Highlighting the active link\n * This directive can be used in conjunction with [[uiSrefActive]] to highlight the active link.\n *\n * ### Notes\n *\n * - You can use `ui-params` to change **only the parameter values** by omitting the state name and supplying only `ui-state-params`.\n *   However, it might be simpler to use [[uiSref]] parameter-only links.\n *\n * #### Example:\n * Sets the `lang` parameter to `en` and remains on the same state.\n *\n * ```html\n * <a ui-state=\"\" ui-state-params=\"{ lang: 'en' }\">English</a>\n * ```\n *\n * - A middle-click, right-click, or ctrl-click is handled (natively) by the browser to open the href in a new window, for example.\n * ```\n */\nvar uiStateDirective;\nuiStateDirective = ['$uiRouter', '$timeout',\n    function $StateRefDynamicDirective($uiRouter, $timeout) {\n        var $state = $uiRouter.stateService;\n        return {\n            restrict: 'A',\n            require: ['?^uiSrefActive', '?^uiSrefActiveEq'],\n            link: function (scope, element, attrs, uiSrefActive) {\n                var type = getTypeInfo(element);\n                var active = uiSrefActive[1] || uiSrefActive[0];\n                var unlinkInfoFn = null;\n                var hookFn;\n                var rawDef = {};\n                var getDef = function () { return processedDef($state, element, rawDef); };\n                var inputAttrs = ['uiState', 'uiStateParams', 'uiStateOpts'];\n                var watchDeregFns = inputAttrs.reduce(function (acc, attr) { return (acc[attr] = core.noop, acc); }, {});\n                function update() {\n                    var def = getDef();\n                    if (unlinkInfoFn)\n                        unlinkInfoFn();\n                    if (active)\n                        unlinkInfoFn = active.$$addStateInfo(def.uiState, def.uiStateParams);\n                    if (def.href != null)\n                        attrs.$set(type.attr, def.href);\n                }\n                inputAttrs.forEach(function (field) {\n                    rawDef[field] = attrs[field] ? scope.$eval(attrs[field]) : null;\n                    attrs.$observe(field, function (expr) {\n                        watchDeregFns[field]();\n                        watchDeregFns[field] = scope.$watch(expr, function (newval) {\n                            rawDef[field] = newval;\n                            update();\n                        }, true);\n                    });\n                });\n                update();\n                scope.$on('$destroy', $uiRouter.stateRegistry.onStatesChanged(update));\n                scope.$on('$destroy', $uiRouter.transitionService.onSuccess({}, update));\n                if (!type.clickable)\n                    return;\n                hookFn = clickHook(element, $state, $timeout, type, getDef);\n                bindEvents(element, scope, hookFn, rawDef.uiStateOpts);\n            },\n        };\n    }];\n/**\n * `ui-sref-active` and `ui-sref-active-eq`: A directive that adds a CSS class when a `ui-sref` is active\n *\n * A directive working alongside [[uiSref]] and [[uiState]] to add classes to an element when the\n * related directive's state is active (and remove them when it is inactive).\n *\n * The primary use-case is to highlight the active link in navigation menus,\n * distinguishing it from the inactive menu items.\n *\n * ### Linking to a `ui-sref` or `ui-state`\n * `ui-sref-active` can live on the same element as `ui-sref`/`ui-state`, or it can be on a parent element.\n * If a `ui-sref-active` is a parent to more than one `ui-sref`/`ui-state`, it will apply the CSS class when **any of the links are active**.\n *\n * ### Matching\n *\n * The `ui-sref-active` directive applies the CSS class when the `ui-sref`/`ui-state`'s target state **or any child state is active**.\n * This is a \"fuzzy match\" which uses [[StateService.includes]].\n *\n * The `ui-sref-active-eq` directive applies the CSS class when the `ui-sref`/`ui-state`'s target state is directly active (not when child states are active).\n * This is an \"exact match\" which uses [[StateService.is]].\n *\n * ### Parameter values\n * If the `ui-sref`/`ui-state` includes parameter values, the current parameter values must match the link's values for the link to be highlighted.\n * This allows a list of links to the same state with different parameters to be rendered, and the correct one highlighted.\n *\n * #### Example:\n * ```html\n * <li ng-repeat=\"user in users\" ui-sref-active=\"active\">\n *   <a ui-sref=\"user.details({ userId: user.id })\">{{ user.lastName }}</a>\n * </li>\n * ```\n *\n * ### Examples\n *\n * Given the following template:\n * #### Example:\n * ```html\n * <ul>\n *   <li ui-sref-active=\"active\" class=\"item\">\n *     <a href ui-sref=\"app.user({user: 'bilbobaggins'})\">@bilbobaggins</a>\n *   </li>\n * </ul>\n * ```\n *\n * When the app state is `app.user` (or any child state),\n * and contains the state parameter \"user\" with value \"bilbobaggins\",\n * the resulting HTML will appear as (note the 'active' class):\n *\n * ```html\n * <ul>\n *   <li ui-sref-active=\"active\" class=\"item active\">\n *     <a ui-sref=\"app.user({user: 'bilbobaggins'})\" href=\"/users/bilbobaggins\">@bilbobaggins</a>\n *   </li>\n * </ul>\n * ```\n *\n * ### Glob mode\n *\n * It is possible to pass `ui-sref-active` an expression that evaluates to an object.\n * The objects keys represent active class names and values represent the respective state names/globs.\n * `ui-sref-active` will match if the current active state **includes** any of\n * the specified state names/globs, even the abstract ones.\n *\n * #### Example:\n * Given the following template, with \"admin\" being an abstract state:\n * ```html\n * <div ui-sref-active=\"{'active': 'admin.**'}\">\n *   <a ui-sref-active=\"active\" ui-sref=\"admin.roles\">Roles</a>\n * </div>\n * ```\n *\n * When the current state is \"admin.roles\" the \"active\" class will be applied to both the `<div>` and `<a>` elements.\n * It is important to note that the state names/globs passed to `ui-sref-active` override any state provided by a linked `ui-sref`.\n *\n * ### Notes:\n *\n * - The class name is interpolated **once** during the directives link time (any further changes to the\n * interpolated value are ignored).\n *\n * - Multiple classes may be specified in a space-separated format: `ui-sref-active='class1 class2 class3'`\n */\nvar uiSrefActiveDirective;\nuiSrefActiveDirective = ['$state', '$stateParams', '$interpolate', '$uiRouter',\n    function $StateRefActiveDirective($state, $stateParams, $interpolate, $uiRouter) {\n        return {\n            restrict: 'A',\n            controller: ['$scope', '$element', '$attrs',\n                function ($scope, $element, $attrs) {\n                    var states = [];\n                    var activeEqClass;\n                    var uiSrefActive;\n                    // There probably isn't much point in $observing this\n                    // uiSrefActive and uiSrefActiveEq share the same directive object with some\n                    // slight difference in logic routing\n                    activeEqClass = $interpolate($attrs.uiSrefActiveEq || '', false)($scope);\n                    try {\n                        uiSrefActive = $scope.$eval($attrs.uiSrefActive);\n                    }\n                    catch (e) {\n                        // Do nothing. uiSrefActive is not a valid expression.\n                        // Fall back to using $interpolate below\n                    }\n                    uiSrefActive = uiSrefActive || $interpolate($attrs.uiSrefActive || '', false)($scope);\n                    if (core.isObject(uiSrefActive)) {\n                        core.forEach(uiSrefActive, function (stateOrName, activeClass) {\n                            if (core.isString(stateOrName)) {\n                                var ref = parseStateRef(stateOrName);\n                                addState(ref.state, $scope.$eval(ref.paramExpr), activeClass);\n                            }\n                        });\n                    }\n                    // Allow uiSref to communicate with uiSrefActive[Equals]\n                    this.$$addStateInfo = function (newState, newParams) {\n                        // we already got an explicit state provided by ui-sref-active, so we\n                        // shadow the one that comes from ui-sref\n                        if (core.isObject(uiSrefActive) && states.length > 0) {\n                            return;\n                        }\n                        var deregister = addState(newState, newParams, uiSrefActive);\n                        update();\n                        return deregister;\n                    };\n                    function updateAfterTransition(trans) {\n                        trans.promise.then(update, core.noop);\n                    }\n                    $scope.$on('$stateChangeSuccess', update);\n                    $scope.$on('$destroy', $uiRouter.transitionService.onStart({}, updateAfterTransition));\n                    if ($uiRouter.globals.transition) {\n                        updateAfterTransition($uiRouter.globals.transition);\n                    }\n                    function addState(stateName, stateParams, activeClass) {\n                        var state = $state.get(stateName, stateContext($element));\n                        var stateInfo = {\n                            state: state || { name: stateName },\n                            params: stateParams,\n                            activeClass: activeClass,\n                        };\n                        states.push(stateInfo);\n                        return function removeState() {\n                            core.removeFrom(states)(stateInfo);\n                        };\n                    }\n                    // Update route state\n                    function update() {\n                        var splitClasses = function (str) {\n                            return str.split(/\\s/).filter(core.identity);\n                        };\n                        var getClasses = function (stateList) {\n                            return stateList.map(function (x) { return x.activeClass; }).map(splitClasses).reduce(core.unnestR, []);\n                        };\n                        var allClasses = getClasses(states).concat(splitClasses(activeEqClass)).reduce(core.uniqR, []);\n                        var fuzzyClasses = getClasses(states.filter(function (x) { return $state.includes(x.state.name, x.params); }));\n                        var exactlyMatchesAny = !!states.filter(function (x) { return $state.is(x.state.name, x.params); }).length;\n                        var exactClasses = exactlyMatchesAny ? splitClasses(activeEqClass) : [];\n                        var addClasses = fuzzyClasses.concat(exactClasses).reduce(core.uniqR, []);\n                        var removeClasses = allClasses.filter(function (cls) { return !core.inArray(addClasses, cls); });\n                        $scope.$evalAsync(function () {\n                            addClasses.forEach(function (className) { return $element.addClass(className); });\n                            removeClasses.forEach(function (className) { return $element.removeClass(className); });\n                        });\n                    }\n                    update();\n                }],\n        };\n    }];\nng.module('ui.router.state')\n    .directive('uiSref', uiSrefDirective)\n    .directive('uiSrefActive', uiSrefActiveDirective)\n    .directive('uiSrefActiveEq', uiSrefActiveDirective)\n    .directive('uiState', uiStateDirective);\n\n/** @module ng1 */ /** for typedoc */\n/**\n * `isState` Filter: truthy if the current state is the parameter\n *\n * Translates to [[StateService.is]] `$state.is(\"stateName\")`.\n *\n * #### Example:\n * ```html\n * <div ng-if=\"'stateName' | isState\">show if state is 'stateName'</div>\n * ```\n */\n$IsStateFilter.$inject = ['$state'];\nfunction $IsStateFilter($state) {\n    var isFilter = function (state, params, options) {\n        return $state.is(state, params, options);\n    };\n    isFilter.$stateful = true;\n    return isFilter;\n}\n/**\n * `includedByState` Filter: truthy if the current state includes the parameter\n *\n * Translates to [[StateService.includes]]` $state.is(\"fullOrPartialStateName\")`.\n *\n * #### Example:\n * ```html\n * <div ng-if=\"'fullOrPartialStateName' | includedByState\">show if state includes 'fullOrPartialStateName'</div>\n * ```\n */\n$IncludedByStateFilter.$inject = ['$state'];\nfunction $IncludedByStateFilter($state) {\n    var includesFilter = function (state, params, options) {\n        return $state.includes(state, params, options);\n    };\n    includesFilter.$stateful = true;\n    return includesFilter;\n}\nng.module('ui.router.state')\n    .filter('isState', $IsStateFilter)\n    .filter('includedByState', $IncludedByStateFilter);\n\n/**\n * @ng1api\n * @module directives\n */ /** for typedoc */\n/**\n * `ui-view`: A viewport directive which is filled in by a view from the active state.\n *\n * ### Attributes\n *\n * - `name`: (Optional) A view name.\n *   The name should be unique amongst the other views in the same state.\n *   You can have views of the same name that live in different states.\n *   The ui-view can be targeted in a View using the name ([[Ng1StateDeclaration.views]]).\n *\n * - `autoscroll`: an expression. When it evaluates to true, the `ui-view` will be scrolled into view when it is activated.\n *   Uses [[$uiViewScroll]] to do the scrolling.\n *\n * - `onload`: Expression to evaluate whenever the view updates.\n *\n * #### Example:\n * A view can be unnamed or named.\n * ```html\n * \x3c!-- Unnamed --\x3e\n * <div ui-view></div>\n *\n * \x3c!-- Named --\x3e\n * <div ui-view=\"viewName\"></div>\n *\n * \x3c!-- Named (different style) --\x3e\n * <ui-view name=\"viewName\"></ui-view>\n * ```\n *\n * You can only have one unnamed view within any template (or root html). If you are only using a\n * single view and it is unnamed then you can populate it like so:\n *\n * ```html\n * <div ui-view></div>\n * $stateProvider.state(\"home\", {\n *   template: \"<h1>HELLO!</h1>\"\n * })\n * ```\n *\n * The above is a convenient shortcut equivalent to specifying your view explicitly with the\n * [[Ng1StateDeclaration.views]] config property, by name, in this case an empty name:\n *\n * ```js\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     }\n *   }\n * })\n * ```\n *\n * But typically you'll only use the views property if you name your view or have more than one view\n * in the same template. There's not really a compelling reason to name a view if its the only one,\n * but you could if you wanted, like so:\n *\n * ```html\n * <div ui-view=\"main\"></div>\n * ```\n *\n * ```js\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"main\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     }\n *   }\n * })\n * ```\n *\n * Really though, you'll use views to set up multiple views:\n *\n * ```html\n * <div ui-view></div>\n * <div ui-view=\"chart\"></div>\n * <div ui-view=\"data\"></div>\n * ```\n *\n * ```js\n * $stateProvider.state(\"home\", {\n *   views: {\n *     \"\": {\n *       template: \"<h1>HELLO!</h1>\"\n *     },\n *     \"chart\": {\n *       template: \"<chart_thing/>\"\n *     },\n *     \"data\": {\n *       template: \"<data_thing/>\"\n *     }\n *   }\n * })\n * ```\n *\n * #### Examples for `autoscroll`:\n * ```html\n * \x3c!-- If autoscroll present with no expression,\n *      then scroll ui-view into view --\x3e\n * <ui-view autoscroll/>\n *\n * \x3c!-- If autoscroll present with valid expression,\n *      then scroll ui-view into view if expression evaluates to true --\x3e\n * <ui-view autoscroll='true'/>\n * <ui-view autoscroll='false'/>\n * <ui-view autoscroll='scopeVariable'/>\n * ```\n *\n * Resolve data:\n *\n * The resolved data from the state's `resolve` block is placed on the scope as `$resolve` (this\n * can be customized using [[Ng1ViewDeclaration.resolveAs]]).  This can be then accessed from the template.\n *\n * Note that when `controllerAs` is being used, `$resolve` is set on the controller instance *after* the\n * controller is instantiated.  The `$onInit()` hook can be used to perform initialization code which\n * depends on `$resolve` data.\n *\n * #### Example:\n * ```js\n * $stateProvider.state('home', {\n *   template: '<my-component user=\"$resolve.user\"></my-component>',\n *   resolve: {\n *     user: function(UserService) { return UserService.fetchUser(); }\n *   }\n * });\n * ```\n */\nvar uiView;\nuiView = ['$view', '$animate', '$uiViewScroll', '$interpolate', '$q',\n    function $ViewDirective($view, $animate, $uiViewScroll, $interpolate, $q) {\n        function getRenderer(attrs, scope) {\n            return {\n                enter: function (element, target, cb) {\n                    if (ng.version.minor > 2) {\n                        $animate.enter(element, null, target).then(cb);\n                    }\n                    else {\n                        $animate.enter(element, null, target, cb);\n                    }\n                },\n                leave: function (element, cb) {\n                    if (ng.version.minor > 2) {\n                        $animate.leave(element).then(cb);\n                    }\n                    else {\n                        $animate.leave(element, cb);\n                    }\n                },\n            };\n        }\n        function configsEqual(config1, config2) {\n            return config1 === config2;\n        }\n        var rootData = {\n            $cfg: { viewDecl: { $context: $view._pluginapi._rootViewContext() } },\n            $uiView: {},\n        };\n        var directive = {\n            count: 0,\n            restrict: 'ECA',\n            terminal: true,\n            priority: 400,\n            transclude: 'element',\n            compile: function (tElement, tAttrs, $transclude) {\n                return function (scope, $element, attrs) {\n                    var onloadExp = attrs['onload'] || '', autoScrollExp = attrs['autoscroll'], renderer = getRenderer(attrs, scope), inherited = $element.inheritedData('$uiView') || rootData, name = $interpolate(attrs['uiView'] || attrs['name'] || '')(scope) || '$default';\n                    var previousEl, currentEl, currentScope, viewConfig, unregister;\n                    var activeUIView = {\n                        $type: 'ng1',\n                        id: directive.count++,\n                        name: name,\n                        fqn: inherited.$uiView.fqn ? inherited.$uiView.fqn + '.' + name : name,\n                        config: null,\n                        configUpdated: configUpdatedCallback,\n                        get creationContext() {\n                            var fromParentTagConfig = core.parse('$cfg.viewDecl.$context')(inherited);\n                            // Allow <ui-view name=\"foo\"><ui-view name=\"bar\"></ui-view></ui-view>\n                            // See https://github.com/angular-ui/ui-router/issues/3355\n                            var fromParentTag = core.parse('$uiView.creationContext')(inherited);\n                            return fromParentTagConfig || fromParentTag;\n                        },\n                    };\n                    core.trace.traceUIViewEvent('Linking', activeUIView);\n                    function configUpdatedCallback(config) {\n                        if (config && !(config instanceof Ng1ViewConfig))\n                            return;\n                        if (configsEqual(viewConfig, config))\n                            return;\n                        core.trace.traceUIViewConfigUpdated(activeUIView, config && config.viewDecl && config.viewDecl.$context);\n                        viewConfig = config;\n                        updateView(config);\n                    }\n                    $element.data('$uiView', { $uiView: activeUIView });\n                    updateView();\n                    unregister = $view.registerUIView(activeUIView);\n                    scope.$on('$destroy', function () {\n                        core.trace.traceUIViewEvent('Destroying/Unregistering', activeUIView);\n                        unregister();\n                    });\n                    function cleanupLastView() {\n                        if (previousEl) {\n                            core.trace.traceUIViewEvent('Removing (previous) el', previousEl.data('$uiView'));\n                            previousEl.remove();\n                            previousEl = null;\n                        }\n                        if (currentScope) {\n                            core.trace.traceUIViewEvent('Destroying scope', activeUIView);\n                            currentScope.$destroy();\n                            currentScope = null;\n                        }\n                        if (currentEl) {\n                            var _viewData_1 = currentEl.data('$uiViewAnim');\n                            core.trace.traceUIViewEvent('Animate out', _viewData_1);\n                            renderer.leave(currentEl, function () {\n                                _viewData_1.$$animLeave.resolve();\n                                previousEl = null;\n                            });\n                            previousEl = currentEl;\n                            currentEl = null;\n                        }\n                    }\n                    function updateView(config) {\n                        var newScope = scope.$new();\n                        var animEnter = $q.defer(), animLeave = $q.defer();\n                        var $uiViewData = {\n                            $cfg: config,\n                            $uiView: activeUIView,\n                        };\n                        var $uiViewAnim = {\n                            $animEnter: animEnter.promise,\n                            $animLeave: animLeave.promise,\n                            $$animLeave: animLeave,\n                        };\n                        /**\n                         * @ngdoc event\n                         * @name ui.router.state.directive:ui-view#$viewContentLoading\n                         * @eventOf ui.router.state.directive:ui-view\n                         * @eventType emits on ui-view directive scope\n                         * @description\n                         *\n                         * Fired once the view **begins loading**, *before* the DOM is rendered.\n                         *\n                         * @param {Object} event Event object.\n                         * @param {string} viewName Name of the view.\n                         */\n                        newScope.$emit('$viewContentLoading', name);\n                        var cloned = $transclude(newScope, function (clone) {\n                            clone.data('$uiViewAnim', $uiViewAnim);\n                            clone.data('$uiView', $uiViewData);\n                            renderer.enter(clone, $element, function onUIViewEnter() {\n                                animEnter.resolve();\n                                if (currentScope)\n                                    currentScope.$emit('$viewContentAnimationEnded');\n                                if (core.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {\n                                    $uiViewScroll(clone);\n                                }\n                            });\n                            cleanupLastView();\n                        });\n                        currentEl = cloned;\n                        currentScope = newScope;\n                        /**\n                         * @ngdoc event\n                         * @name ui.router.state.directive:ui-view#$viewContentLoaded\n                         * @eventOf ui.router.state.directive:ui-view\n                         * @eventType emits on ui-view directive scope\n                         * @description           *\n                         * Fired once the view is **loaded**, *after* the DOM is rendered.\n                         *\n                         * @param {Object} event Event object.\n                         */\n                        currentScope.$emit('$viewContentLoaded', config || viewConfig);\n                        currentScope.$eval(onloadExp);\n                    }\n                };\n            },\n        };\n        return directive;\n    }];\n$ViewDirectiveFill.$inject = ['$compile', '$controller', '$transitions', '$view', '$q', '$timeout'];\n/** @hidden */\nfunction $ViewDirectiveFill($compile, $controller, $transitions, $view, $q, $timeout) {\n    var getControllerAs = core.parse('viewDecl.controllerAs');\n    var getResolveAs = core.parse('viewDecl.resolveAs');\n    return {\n        restrict: 'ECA',\n        priority: -400,\n        compile: function (tElement) {\n            var initial = tElement.html();\n            tElement.empty();\n            return function (scope, $element) {\n                var data = $element.data('$uiView');\n                if (!data) {\n                    $element.html(initial);\n                    $compile($element.contents())(scope);\n                    return;\n                }\n                var cfg = data.$cfg || { viewDecl: {}, getTemplate: core.noop };\n                var resolveCtx = cfg.path && new core.ResolveContext(cfg.path);\n                $element.html(cfg.getTemplate($element, resolveCtx) || initial);\n                core.trace.traceUIViewFill(data.$uiView, $element.html());\n                var link = $compile($element.contents());\n                var controller = cfg.controller;\n                var controllerAs = getControllerAs(cfg);\n                var resolveAs = getResolveAs(cfg);\n                var locals = resolveCtx && getLocals(resolveCtx);\n                scope[resolveAs] = locals;\n                if (controller) {\n                    var controllerInstance = $controller(controller, core.extend({}, locals, { $scope: scope, $element: $element }));\n                    if (controllerAs) {\n                        scope[controllerAs] = controllerInstance;\n                        scope[controllerAs][resolveAs] = locals;\n                    }\n                    // TODO: Use $view service as a central point for registering component-level hooks\n                    // Then, when a component is created, tell the $view service, so it can invoke hooks\n                    // $view.componentLoaded(controllerInstance, { $scope: scope, $element: $element });\n                    // scope.$on('$destroy', () => $view.componentUnloaded(controllerInstance, { $scope: scope, $element: $element }));\n                    $element.data('$ngControllerController', controllerInstance);\n                    $element.children().data('$ngControllerController', controllerInstance);\n                    registerControllerCallbacks($q, $transitions, controllerInstance, scope, cfg);\n                }\n                // Wait for the component to appear in the DOM\n                if (core.isString(cfg.viewDecl.component)) {\n                    var cmp_1 = cfg.viewDecl.component;\n                    var kebobName = core.kebobString(cmp_1);\n                    var tagRegexp_1 = new RegExp(\"^(x-|data-)?\" + kebobName + \"$\", 'i');\n                    var getComponentController = function () {\n                        var directiveEl = [].slice.call($element[0].children)\n                            .filter(function (el) { return el && el.tagName && tagRegexp_1.exec(el.tagName); });\n                        return directiveEl && ng.element(directiveEl).data(\"$\" + cmp_1 + \"Controller\");\n                    };\n                    var deregisterWatch_1 = scope.$watch(getComponentController, function (ctrlInstance) {\n                        if (!ctrlInstance)\n                            return;\n                        registerControllerCallbacks($q, $transitions, ctrlInstance, scope, cfg);\n                        deregisterWatch_1();\n                    });\n                }\n                link(scope);\n            };\n        },\n    };\n}\n/** @hidden */\nvar hasComponentImpl = typeof ng.module('ui.router')['component'] === 'function';\n/** @hidden incrementing id */\nvar _uiCanExitId = 0;\n/** @hidden TODO: move these callbacks to $view and/or `/hooks/components.ts` or something */\nfunction registerControllerCallbacks($q, $transitions, controllerInstance, $scope, cfg) {\n    // Call $onInit() ASAP\n    if (core.isFunction(controllerInstance.$onInit) && !(cfg.viewDecl.component && hasComponentImpl)) {\n        controllerInstance.$onInit();\n    }\n    var viewState = core.tail(cfg.path).state.self;\n    var hookOptions = { bind: controllerInstance };\n    // Add component-level hook for onParamsChange\n    if (core.isFunction(controllerInstance.uiOnParamsChanged)) {\n        var resolveContext = new core.ResolveContext(cfg.path);\n        var viewCreationTrans_1 = resolveContext.getResolvable('$transition$').data;\n        // Fire callback on any successful transition\n        var paramsUpdated = function ($transition$) {\n            // Exit early if the $transition$ is the same as the view was created within.\n            // Exit early if the $transition$ will exit the state the view is for.\n            if ($transition$ === viewCreationTrans_1 || $transition$.exiting().indexOf(viewState) !== -1)\n                return;\n            var toParams = $transition$.params('to');\n            var fromParams = $transition$.params('from');\n            var toSchema = $transition$.treeChanges().to.map(function (node) { return node.paramSchema; }).reduce(core.unnestR, []);\n            var fromSchema = $transition$.treeChanges().from.map(function (node) { return node.paramSchema; }).reduce(core.unnestR, []);\n            // Find the to params that have different values than the from params\n            var changedToParams = toSchema.filter(function (param) {\n                var idx = fromSchema.indexOf(param);\n                return idx === -1 || !fromSchema[idx].type.equals(toParams[param.id], fromParams[param.id]);\n            });\n            // Only trigger callback if a to param has changed or is new\n            if (changedToParams.length) {\n                var changedKeys_1 = changedToParams.map(function (x) { return x.id; });\n                // Filter the params to only changed/new to params.  `$transition$.params()` may be used to get all params.\n                var newValues = core.filter(toParams, function (val$$1, key) { return changedKeys_1.indexOf(key) !== -1; });\n                controllerInstance.uiOnParamsChanged(newValues, $transition$);\n            }\n        };\n        $scope.$on('$destroy', $transitions.onSuccess({}, paramsUpdated, hookOptions));\n    }\n    // Add component-level hook for uiCanExit\n    if (core.isFunction(controllerInstance.uiCanExit)) {\n        var id_1 = _uiCanExitId++;\n        var cacheProp_1 = '_uiCanExitIds';\n        // Returns true if a redirect transition already answered truthy\n        var prevTruthyAnswer_1 = function (trans) {\n            return !!trans && (trans[cacheProp_1] && trans[cacheProp_1][id_1] === true || prevTruthyAnswer_1(trans.redirectedFrom()));\n        };\n        // If a user answered yes, but the transition was later redirected, don't also ask for the new redirect transition\n        var wrappedHook = function (trans) {\n            var promise;\n            var ids = trans[cacheProp_1] = trans[cacheProp_1] || {};\n            if (!prevTruthyAnswer_1(trans)) {\n                promise = $q.when(controllerInstance.uiCanExit(trans));\n                promise.then(function (val$$1) { return ids[id_1] = (val$$1 !== false); });\n            }\n            return promise;\n        };\n        var criteria = { exiting: viewState.name };\n        $scope.$on('$destroy', $transitions.onBefore(criteria, wrappedHook, hookOptions));\n    }\n}\nng.module('ui.router.state').directive('uiView', uiView);\nng.module('ui.router.state').directive('uiView', $ViewDirectiveFill);\n\n/** @module ng1 */ /** */\n/** @hidden */\nfunction $ViewScrollProvider() {\n    var useAnchorScroll = false;\n    this.useAnchorScroll = function () {\n        useAnchorScroll = true;\n    };\n    this.$get = ['$anchorScroll', '$timeout', function ($anchorScroll, $timeout) {\n            if (useAnchorScroll) {\n                return $anchorScroll;\n            }\n            return function ($element) {\n                return $timeout(function () {\n                    $element[0].scrollIntoView();\n                }, 0, false);\n            };\n        }];\n}\nng.module('ui.router.state').provider('$uiViewScroll', $ViewScrollProvider);\n\n/**\n * Main entry point for angular 1.x build\n * @module ng1\n */ /** */\nvar index = 'ui.router';\n\nexports['default'] = index;\nexports.core = core;\nexports.watchDigests = watchDigests;\nexports.getLocals = getLocals;\nexports.getNg1ViewConfigFactory = getNg1ViewConfigFactory;\nexports.ng1ViewsBuilder = ng1ViewsBuilder;\nexports.Ng1ViewConfig = Ng1ViewConfig;\nexports.StateProvider = StateProvider;\nexports.UrlRouterProvider = UrlRouterProvider;\nObject.keys(core).forEach(function (key) { exports[key] = core[key]; });\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=ui-router-angularjs.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTA5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9hbmd1bGFyanMvcmVsZWFzZS91aS1yb3V0ZXItYW5ndWxhcmpzLmpzP2I3MmMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBTdGF0ZS1iYXNlZCByb3V0aW5nIGZvciBBbmd1bGFySlMgMS54XG4gKiBUaGlzIGJ1bmRsZSByZXF1aXJlcyB0aGUgdWktcm91dGVyLWNvcmUuanMgYnVuZGxlIGZyb20gdGhlIEB1aXJvdXRlci9jb3JlIHBhY2thZ2UuXG4gKiBAdmVyc2lvbiB2MS4wLjEzXG4gKiBAbGluayBodHRwczovL3VpLXJvdXRlci5naXRodWIuaW9cbiAqIEBsaWNlbnNlIE1JVCBMaWNlbnNlLCBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxuICovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuXHR0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KGV4cG9ydHMsIHJlcXVpcmUoJ2FuZ3VsYXInKSwgcmVxdWlyZSgnQHVpcm91dGVyL2NvcmUnKSkgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJywgJ2FuZ3VsYXInLCAnQHVpcm91dGVyL2NvcmUnXSwgZmFjdG9yeSkgOlxuXHQoZmFjdG9yeSgoZ2xvYmFsWydAdWlyb3V0ZXIvYW5ndWxhcmpzJ10gPSB7fSksZ2xvYmFsLmFuZ3VsYXIsZ2xvYmFsWydAdWlyb3V0ZXIvY29yZSddKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cyxuZ19mcm9tX2ltcG9ydCxjb3JlKSB7ICd1c2Ugc3RyaWN0JztcblxudmFyIG5nX2Zyb21fZ2xvYmFsID0gYW5ndWxhcjtcbnZhciBuZyA9IChuZ19mcm9tX2ltcG9ydCAmJiBuZ19mcm9tX2ltcG9ydC5tb2R1bGUpID8gbmdfZnJvbV9pbXBvcnQgOiBuZ19mcm9tX2dsb2JhbDtcblxuZnVuY3Rpb24gZ2V0TmcxVmlld0NvbmZpZ0ZhY3RvcnkoKSB7XG4gICAgdmFyIHRlbXBsYXRlRmFjdG9yeSA9IG51bGw7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChwYXRoLCB2aWV3KSB7XG4gICAgICAgIHRlbXBsYXRlRmFjdG9yeSA9IHRlbXBsYXRlRmFjdG9yeSB8fCBjb3JlLnNlcnZpY2VzLiRpbmplY3Rvci5nZXQoJyR0ZW1wbGF0ZUZhY3RvcnknKTtcbiAgICAgICAgcmV0dXJuIFtuZXcgTmcxVmlld0NvbmZpZyhwYXRoLCB2aWV3LCB0ZW1wbGF0ZUZhY3RvcnkpXTtcbiAgICB9O1xufVxudmFyIGhhc0FueUtleSA9IGZ1bmN0aW9uIChrZXlzLCBvYmopIHtcbiAgICByZXR1cm4ga2V5cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywga2V5KSB7IHJldHVybiBhY2MgfHwgY29yZS5pc0RlZmluZWQob2JqW2tleV0pOyB9LCBmYWxzZSk7XG59O1xuLyoqXG4gKiBUaGlzIGlzIGEgW1tTdGF0ZUJ1aWxkZXIuYnVpbGRlcl1dIGZ1bmN0aW9uIGZvciBhbmd1bGFyMSBgdmlld3NgLlxuICpcbiAqIFdoZW4gdGhlIFtbU3RhdGVCdWlsZGVyXV0gYnVpbGRzIGEgW1tTdGF0ZU9iamVjdF1dIG9iamVjdCBmcm9tIGEgcmF3IFtbU3RhdGVEZWNsYXJhdGlvbl1dLCB0aGlzIGJ1aWxkZXJcbiAqIGhhbmRsZXMgdGhlIGB2aWV3c2AgcHJvcGVydHkgd2l0aCBsb2dpYyBzcGVjaWZpYyB0byBAdWlyb3V0ZXIvYW5ndWxhcmpzIChuZzEpLlxuICpcbiAqIElmIG5vIGB2aWV3czoge31gIHByb3BlcnR5IGV4aXN0cyBvbiB0aGUgW1tTdGF0ZURlY2xhcmF0aW9uXV0sIHRoZW4gaXQgY3JlYXRlcyB0aGUgYHZpZXdzYCBvYmplY3RcbiAqIGFuZCBhcHBsaWVzIHRoZSBzdGF0ZS1sZXZlbCBjb25maWd1cmF0aW9uIHRvIGEgdmlldyBuYW1lZCBgJGRlZmF1bHRgLlxuICovXG5mdW5jdGlvbiBuZzFWaWV3c0J1aWxkZXIoc3RhdGUpIHtcbiAgICAvLyBEbyBub3QgcHJvY2VzcyByb290IHN0YXRlXG4gICAgaWYgKCFzdGF0ZS5wYXJlbnQpXG4gICAgICAgIHJldHVybiB7fTtcbiAgICB2YXIgdHBsS2V5cyA9IFsndGVtcGxhdGVQcm92aWRlcicsICd0ZW1wbGF0ZVVybCcsICd0ZW1wbGF0ZScsICdub3RpZnknLCAnYXN5bmMnXSwgY3RybEtleXMgPSBbJ2NvbnRyb2xsZXInLCAnY29udHJvbGxlclByb3ZpZGVyJywgJ2NvbnRyb2xsZXJBcycsICdyZXNvbHZlQXMnXSwgY29tcEtleXMgPSBbJ2NvbXBvbmVudCcsICdiaW5kaW5ncycsICdjb21wb25lbnRQcm92aWRlciddLCBub25Db21wS2V5cyA9IHRwbEtleXMuY29uY2F0KGN0cmxLZXlzKSwgYWxsVmlld0tleXMgPSBjb21wS2V5cy5jb25jYXQobm9uQ29tcEtleXMpO1xuICAgIC8vIERvIG5vdCBhbGxvdyBhIHN0YXRlIHRvIGhhdmUgYm90aCBzdGF0ZS1sZXZlbCBwcm9wcyBhbmQgYWxzbyBhIGB2aWV3czoge31gIHByb3BlcnR5LlxuICAgIC8vIEEgc3RhdGUgd2l0aG91dCBhIGB2aWV3czoge31gIHByb3BlcnR5IGNhbiBkZWNsYXJlIHByb3BlcnRpZXMgZm9yIHRoZSBgJGRlZmF1bHRgIHZpZXcgYXMgcHJvcGVydGllcyBvZiB0aGUgc3RhdGUuXG4gICAgLy8gSG93ZXZlciwgdGhlIGAkZGVmYXVsdGAgYXBwcm9hY2ggc2hvdWxkIG5vdCBiZSBtaXhlZCB3aXRoIGEgc2VwYXJhdGUgYHZpZXdzOiBgIGJsb2NrLlxuICAgIGlmIChjb3JlLmlzRGVmaW5lZChzdGF0ZS52aWV3cykgJiYgaGFzQW55S2V5KGFsbFZpZXdLZXlzLCBzdGF0ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3RhdGUgJ1wiICsgc3RhdGUubmFtZSArIFwiJyBoYXMgYSAndmlld3MnIG9iamVjdC4gXCIgK1xuICAgICAgICAgICAgXCJJdCBjYW5ub3QgYWxzbyBoYXZlIFxcXCJ2aWV3IHByb3BlcnRpZXNcXFwiIGF0IHRoZSBzdGF0ZSBsZXZlbC4gIFwiICtcbiAgICAgICAgICAgIFwiTW92ZSB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXMgaW50byBhIHZpZXcgKGluIHRoZSAndmlld3MnIG9iamVjdCk6IFwiICtcbiAgICAgICAgICAgIChcIiBcIiArIGFsbFZpZXdLZXlzLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBjb3JlLmlzRGVmaW5lZChzdGF0ZVtrZXldKTsgfSkuam9pbignLCAnKSkpO1xuICAgIH1cbiAgICB2YXIgdmlld3MgPSB7fSwgdmlld3NPYmplY3QgPSBzdGF0ZS52aWV3cyB8fCB7ICckZGVmYXVsdCc6IGNvcmUucGljayhzdGF0ZSwgYWxsVmlld0tleXMpIH07XG4gICAgY29yZS5mb3JFYWNoKHZpZXdzT2JqZWN0LCBmdW5jdGlvbiAoY29uZmlnLCBuYW1lKSB7XG4gICAgICAgIC8vIEFjY291bnQgZm9yIHZpZXdzOiB7IFwiXCI6IHsgdGVtcGxhdGUuLi4gfSB9XG4gICAgICAgIG5hbWUgPSBuYW1lIHx8ICckZGVmYXVsdCc7XG4gICAgICAgIC8vIEFjY291bnQgZm9yIHZpZXdzOiB7IGhlYWRlcjogXCJoZWFkZXJDb21wb25lbnRcIiB9XG4gICAgICAgIGlmIChjb3JlLmlzU3RyaW5nKGNvbmZpZykpXG4gICAgICAgICAgICBjb25maWcgPSB7IGNvbXBvbmVudDogY29uZmlnIH07XG4gICAgICAgIC8vIE1ha2UgYSBzaGFsbG93IGNvcHkgb2YgdGhlIGNvbmZpZyBvYmplY3RcbiAgICAgICAgY29uZmlnID0gY29yZS5leHRlbmQoe30sIGNvbmZpZyk7XG4gICAgICAgIC8vIERvIG5vdCBhbGxvdyBhIHZpZXcgdG8gbWl4IHByb3BzIGZvciBjb21wb25lbnQtc3R5bGUgdmlldyB3aXRoIHByb3BzIGZvciB0ZW1wbGF0ZS9jb250cm9sbGVyLXN0eWxlIHZpZXdcbiAgICAgICAgaWYgKGhhc0FueUtleShjb21wS2V5cywgY29uZmlnKSAmJiBoYXNBbnlLZXkobm9uQ29tcEtleXMsIGNvbmZpZykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjb21iaW5lOiBcIiArIGNvbXBLZXlzLmpvaW4oJ3wnKSArIFwiIHdpdGg6IFwiICsgbm9uQ29tcEtleXMuam9pbignfCcpICsgXCIgaW4gc3RhdGV2aWV3OiAnXCIgKyBuYW1lICsgXCJAXCIgKyBzdGF0ZS5uYW1lICsgXCInXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbmZpZy5yZXNvbHZlQXMgPSBjb25maWcucmVzb2x2ZUFzIHx8ICckcmVzb2x2ZSc7XG4gICAgICAgIGNvbmZpZy4kdHlwZSA9ICduZzEnO1xuICAgICAgICBjb25maWcuJGNvbnRleHQgPSBzdGF0ZTtcbiAgICAgICAgY29uZmlnLiRuYW1lID0gbmFtZTtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWQgPSBjb3JlLlZpZXdTZXJ2aWNlLm5vcm1hbGl6ZVVJVmlld1RhcmdldChjb25maWcuJGNvbnRleHQsIGNvbmZpZy4kbmFtZSk7XG4gICAgICAgIGNvbmZpZy4kdWlWaWV3TmFtZSA9IG5vcm1hbGl6ZWQudWlWaWV3TmFtZTtcbiAgICAgICAgY29uZmlnLiR1aVZpZXdDb250ZXh0QW5jaG9yID0gbm9ybWFsaXplZC51aVZpZXdDb250ZXh0QW5jaG9yO1xuICAgICAgICB2aWV3c1tuYW1lXSA9IGNvbmZpZztcbiAgICB9KTtcbiAgICByZXR1cm4gdmlld3M7XG59XG52YXIgaWQgPSAwO1xudmFyIE5nMVZpZXdDb25maWcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTmcxVmlld0NvbmZpZyhwYXRoLCB2aWV3RGVjbCwgZmFjdG9yeSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgICAgICB0aGlzLnZpZXdEZWNsID0gdmlld0RlY2w7XG4gICAgICAgIHRoaXMuZmFjdG9yeSA9IGZhY3Rvcnk7XG4gICAgICAgIHRoaXMuJGlkID0gaWQrKztcbiAgICAgICAgdGhpcy5sb2FkZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5nZXRUZW1wbGF0ZSA9IGZ1bmN0aW9uICh1aVZpZXcsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5jb21wb25lbnQgPyBfdGhpcy5mYWN0b3J5Lm1ha2VDb21wb25lbnRUZW1wbGF0ZSh1aVZpZXcsIGNvbnRleHQsIF90aGlzLmNvbXBvbmVudCwgX3RoaXMudmlld0RlY2wuYmluZGluZ3MpIDogX3RoaXMudGVtcGxhdGU7XG4gICAgICAgIH07XG4gICAgfVxuICAgIE5nMVZpZXdDb25maWcucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciAkcSA9IGNvcmUuc2VydmljZXMuJHE7XG4gICAgICAgIHZhciBjb250ZXh0ID0gbmV3IGNvcmUuUmVzb2x2ZUNvbnRleHQodGhpcy5wYXRoKTtcbiAgICAgICAgdmFyIHBhcmFtcyA9IHRoaXMucGF0aC5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgbm9kZSkgeyByZXR1cm4gY29yZS5leHRlbmQoYWNjLCBub2RlLnBhcmFtVmFsdWVzKTsgfSwge30pO1xuICAgICAgICB2YXIgcHJvbWlzZXMgPSB7XG4gICAgICAgICAgICB0ZW1wbGF0ZTogJHEud2hlbih0aGlzLmZhY3RvcnkuZnJvbUNvbmZpZyh0aGlzLnZpZXdEZWNsLCBwYXJhbXMsIGNvbnRleHQpKSxcbiAgICAgICAgICAgIGNvbnRyb2xsZXI6ICRxLndoZW4odGhpcy5nZXRDb250cm9sbGVyKGNvbnRleHQpKSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuICRxLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbiAocmVzdWx0cykge1xuICAgICAgICAgICAgY29yZS50cmFjZS50cmFjZVZpZXdTZXJ2aWNlRXZlbnQoJ0xvYWRlZCcsIF90aGlzKTtcbiAgICAgICAgICAgIF90aGlzLmNvbnRyb2xsZXIgPSByZXN1bHRzLmNvbnRyb2xsZXI7XG4gICAgICAgICAgICBjb3JlLmV4dGVuZChfdGhpcywgcmVzdWx0cy50ZW1wbGF0ZSk7IC8vIEVpdGhlciB7IHRlbXBsYXRlOiBcInRwbFwiIH0gb3IgeyBjb21wb25lbnQ6IFwiY21wTmFtZVwiIH1cbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjb250cm9sbGVyIGZvciBhIHZpZXcgY29uZmlndXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbnxQcm9taXNlLjxGdW5jdGlvbj59IFJldHVybnMgYSBjb250cm9sbGVyLCBvciBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIGNvbnRyb2xsZXIuXG4gICAgICovXG4gICAgTmcxVmlld0NvbmZpZy5wcm90b3R5cGUuZ2V0Q29udHJvbGxlciA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIHZhciBwcm92aWRlciA9IHRoaXMudmlld0RlY2wuY29udHJvbGxlclByb3ZpZGVyO1xuICAgICAgICBpZiAoIWNvcmUuaXNJbmplY3RhYmxlKHByb3ZpZGVyKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZpZXdEZWNsLmNvbnRyb2xsZXI7XG4gICAgICAgIHZhciBkZXBzID0gY29yZS5zZXJ2aWNlcy4kaW5qZWN0b3IuYW5ub3RhdGUocHJvdmlkZXIpO1xuICAgICAgICB2YXIgcHJvdmlkZXJGbiA9IGNvcmUuaXNBcnJheShwcm92aWRlcikgPyBjb3JlLnRhaWwocHJvdmlkZXIpIDogcHJvdmlkZXI7XG4gICAgICAgIHZhciByZXNvbHZhYmxlID0gbmV3IGNvcmUuUmVzb2x2YWJsZSgnJywgcHJvdmlkZXJGbiwgZGVwcyk7XG4gICAgICAgIHJldHVybiByZXNvbHZhYmxlLmdldChjb250ZXh0KTtcbiAgICB9O1xuICAgIHJldHVybiBOZzFWaWV3Q29uZmlnO1xufSgpKTtcblxuLyoqIEBtb2R1bGUgdmlldyAqL1xuLyoqIGZvciB0eXBlZG9jICovXG4vKipcbiAqIFNlcnZpY2Ugd2hpY2ggbWFuYWdlcyBsb2FkaW5nIG9mIHRlbXBsYXRlcyBmcm9tIGEgVmlld0NvbmZpZy5cbiAqL1xudmFyIFRlbXBsYXRlRmFjdG9yeSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUZW1wbGF0ZUZhY3RvcnkoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8qKiBAaGlkZGVuICovIHRoaXMuX3VzZUh0dHAgPSBuZy52ZXJzaW9uLm1pbm9yIDwgMztcbiAgICAgICAgLyoqIEBoaWRkZW4gKi8gdGhpcy4kZ2V0ID0gWyckaHR0cCcsICckdGVtcGxhdGVDYWNoZScsICckaW5qZWN0b3InLCBmdW5jdGlvbiAoJGh0dHAsICR0ZW1wbGF0ZUNhY2hlLCAkaW5qZWN0b3IpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy4kdGVtcGxhdGVSZXF1ZXN0ID0gJGluamVjdG9yLmhhcyAmJiAkaW5qZWN0b3IuaGFzKCckdGVtcGxhdGVSZXF1ZXN0JykgJiYgJGluamVjdG9yLmdldCgnJHRlbXBsYXRlUmVxdWVzdCcpO1xuICAgICAgICAgICAgICAgIF90aGlzLiRodHRwID0gJGh0dHA7XG4gICAgICAgICAgICAgICAgX3RoaXMuJHRlbXBsYXRlQ2FjaGUgPSAkdGVtcGxhdGVDYWNoZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgICAgICB9XTtcbiAgICB9XG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBUZW1wbGF0ZUZhY3RvcnkucHJvdG90eXBlLnVzZUh0dHBTZXJ2aWNlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3VzZUh0dHAgPSB2YWx1ZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSB0ZW1wbGF0ZSBmcm9tIGEgY29uZmlndXJhdGlvbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29uZmlnIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciB3aGljaCB0byBsb2FkIGEgdGVtcGxhdGUuXG4gICAgICogVGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzIGFyZSBzZWFyY2ggaW4gdGhlIHNwZWNpZmllZCBvcmRlciwgYW5kIHRoZSBmaXJzdCBvbmVcbiAgICAgKiB0aGF0IGlzIGRlZmluZWQgaXMgdXNlZCB0byBjcmVhdGUgdGhlIHRlbXBsYXRlOlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyAgUGFyYW1ldGVycyB0byBwYXNzIHRvIHRoZSB0ZW1wbGF0ZSBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0gY29udGV4dCBUaGUgcmVzb2x2ZSBjb250ZXh0IGFzc29jaWF0ZWQgd2l0aCB0aGUgdGVtcGxhdGUncyB2aWV3XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd8b2JqZWN0fSAgVGhlIHRlbXBsYXRlIGh0bWwgYXMgYSBzdHJpbmcsIG9yIGEgcHJvbWlzZSBmb3JcbiAgICAgKiB0aGF0IHN0cmluZyxvciBgbnVsbGAgaWYgbm8gdGVtcGxhdGUgaXMgY29uZmlndXJlZC5cbiAgICAgKi9cbiAgICBUZW1wbGF0ZUZhY3RvcnkucHJvdG90eXBlLmZyb21Db25maWcgPSBmdW5jdGlvbiAoY29uZmlnLCBwYXJhbXMsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGRlZmF1bHRUZW1wbGF0ZSA9ICc8dWktdmlldz48L3VpLXZpZXc+JztcbiAgICAgICAgdmFyIGFzVGVtcGxhdGUgPSBmdW5jdGlvbiAocmVzdWx0KSB7IHJldHVybiBjb3JlLnNlcnZpY2VzLiRxLndoZW4ocmVzdWx0KS50aGVuKGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuICh7IHRlbXBsYXRlOiBzdHIgfSk7IH0pOyB9O1xuICAgICAgICB2YXIgYXNDb21wb25lbnQgPSBmdW5jdGlvbiAocmVzdWx0KSB7IHJldHVybiBjb3JlLnNlcnZpY2VzLiRxLndoZW4ocmVzdWx0KS50aGVuKGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuICh7IGNvbXBvbmVudDogc3RyIH0pOyB9KTsgfTtcbiAgICAgICAgcmV0dXJuIChjb3JlLmlzRGVmaW5lZChjb25maWcudGVtcGxhdGUpID8gYXNUZW1wbGF0ZSh0aGlzLmZyb21TdHJpbmcoY29uZmlnLnRlbXBsYXRlLCBwYXJhbXMpKSA6XG4gICAgICAgICAgICBjb3JlLmlzRGVmaW5lZChjb25maWcudGVtcGxhdGVVcmwpID8gYXNUZW1wbGF0ZSh0aGlzLmZyb21VcmwoY29uZmlnLnRlbXBsYXRlVXJsLCBwYXJhbXMpKSA6XG4gICAgICAgICAgICAgICAgY29yZS5pc0RlZmluZWQoY29uZmlnLnRlbXBsYXRlUHJvdmlkZXIpID8gYXNUZW1wbGF0ZSh0aGlzLmZyb21Qcm92aWRlcihjb25maWcudGVtcGxhdGVQcm92aWRlciwgcGFyYW1zLCBjb250ZXh0KSkgOlxuICAgICAgICAgICAgICAgICAgICBjb3JlLmlzRGVmaW5lZChjb25maWcuY29tcG9uZW50KSA/IGFzQ29tcG9uZW50KGNvbmZpZy5jb21wb25lbnQpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcmUuaXNEZWZpbmVkKGNvbmZpZy5jb21wb25lbnRQcm92aWRlcikgPyBhc0NvbXBvbmVudCh0aGlzLmZyb21Db21wb25lbnRQcm92aWRlcihjb25maWcuY29tcG9uZW50UHJvdmlkZXIsIHBhcmFtcywgY29udGV4dCkpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc1RlbXBsYXRlKGRlZmF1bHRUZW1wbGF0ZSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHRlbXBsYXRlIGZyb20gYSBzdHJpbmcgb3IgYSBmdW5jdGlvbiByZXR1cm5pbmcgYSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGVtcGxhdGUgaHRtbCB0ZW1wbGF0ZSBhcyBhIHN0cmluZyBvciBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gaHRtbCB0ZW1wbGF0ZSBhcyBhIHN0cmluZy5cbiAgICAgKiBAcGFyYW0gcGFyYW1zIFBhcmFtZXRlcnMgdG8gcGFzcyB0byB0aGUgdGVtcGxhdGUgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd8b2JqZWN0fSBUaGUgdGVtcGxhdGUgaHRtbCBhcyBhIHN0cmluZywgb3IgYSBwcm9taXNlIGZvciB0aGF0XG4gICAgICogc3RyaW5nLlxuICAgICAqL1xuICAgIFRlbXBsYXRlRmFjdG9yeS5wcm90b3R5cGUuZnJvbVN0cmluZyA9IGZ1bmN0aW9uICh0ZW1wbGF0ZSwgcGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBjb3JlLmlzRnVuY3Rpb24odGVtcGxhdGUpID8gdGVtcGxhdGUocGFyYW1zKSA6IHRlbXBsYXRlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTG9hZHMgYSB0ZW1wbGF0ZSBmcm9tIHRoZSBhIFVSTCB2aWEgYCRodHRwYCBhbmQgYCR0ZW1wbGF0ZUNhY2hlYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfEZ1bmN0aW9ufSB1cmwgdXJsIG9mIHRoZSB0ZW1wbGF0ZSB0byBsb2FkLCBvciBhIGZ1bmN0aW9uXG4gICAgICogdGhhdCByZXR1cm5zIGEgdXJsLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgUGFyYW1ldGVycyB0byBwYXNzIHRvIHRoZSB1cmwgZnVuY3Rpb24uXG4gICAgICogQHJldHVybiB7c3RyaW5nfFByb21pc2UuPHN0cmluZz59IFRoZSB0ZW1wbGF0ZSBodG1sIGFzIGEgc3RyaW5nLCBvciBhIHByb21pc2VcbiAgICAgKiBmb3IgdGhhdCBzdHJpbmcuXG4gICAgICovXG4gICAgVGVtcGxhdGVGYWN0b3J5LnByb3RvdHlwZS5mcm9tVXJsID0gZnVuY3Rpb24gKHVybCwgcGFyYW1zKSB7XG4gICAgICAgIGlmIChjb3JlLmlzRnVuY3Rpb24odXJsKSlcbiAgICAgICAgICAgIHVybCA9IHVybChwYXJhbXMpO1xuICAgICAgICBpZiAodXJsID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuX3VzZUh0dHApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRodHRwLmdldCh1cmwsIHsgY2FjaGU6IHRoaXMuJHRlbXBsYXRlQ2FjaGUsIGhlYWRlcnM6IHsgQWNjZXB0OiAndGV4dC9odG1sJyB9IH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy4kdGVtcGxhdGVSZXF1ZXN0KHVybCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgdGVtcGxhdGUgYnkgaW52b2tpbmcgYW4gaW5qZWN0YWJsZSBwcm92aWRlciBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwcm92aWRlciBGdW5jdGlvbiB0byBpbnZva2UgdmlhIGBsb2NhbHNgXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaW5qZWN0Rm4gYSBmdW5jdGlvbiB1c2VkIHRvIGludm9rZSB0aGUgdGVtcGxhdGUgcHJvdmlkZXJcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd8UHJvbWlzZS48c3RyaW5nPn0gVGhlIHRlbXBsYXRlIGh0bWwgYXMgYSBzdHJpbmcsIG9yIGEgcHJvbWlzZVxuICAgICAqIGZvciB0aGF0IHN0cmluZy5cbiAgICAgKi9cbiAgICBUZW1wbGF0ZUZhY3RvcnkucHJvdG90eXBlLmZyb21Qcm92aWRlciA9IGZ1bmN0aW9uIChwcm92aWRlciwgcGFyYW1zLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBkZXBzID0gY29yZS5zZXJ2aWNlcy4kaW5qZWN0b3IuYW5ub3RhdGUocHJvdmlkZXIpO1xuICAgICAgICB2YXIgcHJvdmlkZXJGbiA9IGNvcmUuaXNBcnJheShwcm92aWRlcikgPyBjb3JlLnRhaWwocHJvdmlkZXIpIDogcHJvdmlkZXI7XG4gICAgICAgIHZhciByZXNvbHZhYmxlID0gbmV3IGNvcmUuUmVzb2x2YWJsZSgnJywgcHJvdmlkZXJGbiwgZGVwcyk7XG4gICAgICAgIHJldHVybiByZXNvbHZhYmxlLmdldChjb250ZXh0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjb21wb25lbnQncyB0ZW1wbGF0ZSBieSBpbnZva2luZyBhbiBpbmplY3RhYmxlIHByb3ZpZGVyIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHByb3ZpZGVyIEZ1bmN0aW9uIHRvIGludm9rZSB2aWEgYGxvY2Fsc2BcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpbmplY3RGbiBhIGZ1bmN0aW9uIHVzZWQgdG8gaW52b2tlIHRoZSB0ZW1wbGF0ZSBwcm92aWRlclxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHRlbXBsYXRlIGh0bWwgYXMgYSBzdHJpbmc6IFwiPGNvbXBvbmVudC1uYW1lIGlucHV0MT0nOjokcmVzb2x2ZS5mb28nPjwvY29tcG9uZW50LW5hbWU+XCIuXG4gICAgICovXG4gICAgVGVtcGxhdGVGYWN0b3J5LnByb3RvdHlwZS5mcm9tQ29tcG9uZW50UHJvdmlkZXIgPSBmdW5jdGlvbiAocHJvdmlkZXIsIHBhcmFtcywgY29udGV4dCkge1xuICAgICAgICB2YXIgZGVwcyA9IGNvcmUuc2VydmljZXMuJGluamVjdG9yLmFubm90YXRlKHByb3ZpZGVyKTtcbiAgICAgICAgdmFyIHByb3ZpZGVyRm4gPSBjb3JlLmlzQXJyYXkocHJvdmlkZXIpID8gY29yZS50YWlsKHByb3ZpZGVyKSA6IHByb3ZpZGVyO1xuICAgICAgICB2YXIgcmVzb2x2YWJsZSA9IG5ldyBjb3JlLlJlc29sdmFibGUoJycsIHByb3ZpZGVyRm4sIGRlcHMpO1xuICAgICAgICByZXR1cm4gcmVzb2x2YWJsZS5nZXQoY29udGV4dCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgdGVtcGxhdGUgZnJvbSBhIGNvbXBvbmVudCdzIG5hbWVcbiAgICAgKlxuICAgICAqIFRoaXMgaW1wbGVtZW50cyByb3V0ZS10by1jb21wb25lbnQuXG4gICAgICogSXQgd29ya3MgYnkgcmV0cmlldmluZyB0aGUgY29tcG9uZW50IChkaXJlY3RpdmUpIG1ldGFkYXRhIGZyb20gdGhlIGluamVjdG9yLlxuICAgICAqIEl0IGFuYWx5c2VzIHRoZSBjb21wb25lbnQncyBiaW5kaW5ncywgdGhlbiBjb25zdHJ1Y3RzIGEgdGVtcGxhdGUgdGhhdCBpbnN0YW50aWF0ZXMgdGhlIGNvbXBvbmVudC5cbiAgICAgKiBUaGUgdGVtcGxhdGUgd2lyZXMgaW5wdXQgYW5kIG91dHB1dCBiaW5kaW5ncyB0byByZXNvbHZlcyBvciBmcm9tIHRoZSBwYXJlbnQgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHVpVmlldyB7b2JqZWN0fSBUaGUgcGFyZW50IHVpLXZpZXcgKGZvciBiaW5kaW5nIG91dHB1dHMgdG8gY2FsbGJhY2tzKVxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRoZSBSZXNvbHZlQ29udGV4dCAoZm9yIGJpbmRpbmcgb3V0cHV0cyB0byBjYWxsYmFja3MgcmV0dXJuZWQgZnJvbSByZXNvbHZlcylcbiAgICAgKiBAcGFyYW0gY29tcG9uZW50IHtzdHJpbmd9IENvbXBvbmVudCdzIG5hbWUgaW4gY2FtZWwgY2FzZS5cbiAgICAgKiBAcGFyYW0gYmluZGluZ3MgQW4gb2JqZWN0IGRlZmluaW5nIHRoZSBjb21wb25lbnQncyBiaW5kaW5nczoge2ZvbzogJzwnfVxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHRlbXBsYXRlIGFzIGEgc3RyaW5nOiBcIjxjb21wb25lbnQtbmFtZSBpbnB1dDE9Jzo6JHJlc29sdmUuZm9vJz48L2NvbXBvbmVudC1uYW1lPlwiLlxuICAgICAqL1xuICAgIFRlbXBsYXRlRmFjdG9yeS5wcm90b3R5cGUubWFrZUNvbXBvbmVudFRlbXBsYXRlID0gZnVuY3Rpb24gKHVpVmlldywgY29udGV4dCwgY29tcG9uZW50LCBiaW5kaW5ncykge1xuICAgICAgICBiaW5kaW5ncyA9IGJpbmRpbmdzIHx8IHt9O1xuICAgICAgICAvLyBCaW5kIG9uY2UgcHJlZml4XG4gICAgICAgIHZhciBwcmVmaXggPSBuZy52ZXJzaW9uLm1pbm9yID49IDMgPyAnOjonIDogJyc7XG4gICAgICAgIC8vIENvbnZlcnQgdG8ga2Vib2IgbmFtZS4gQWRkIHgtIHByZWZpeCBpZiB0aGUgc3RyaW5nIHN0YXJ0cyB3aXRoIGB4LWAgb3IgYGRhdGEtYFxuICAgICAgICB2YXIga2Vib2IgPSBmdW5jdGlvbiAoY2FtZWxDYXNlKSB7XG4gICAgICAgICAgICB2YXIga2Vib2JlZCA9IGNvcmUua2Vib2JTdHJpbmcoY2FtZWxDYXNlKTtcbiAgICAgICAgICAgIHJldHVybiAvXih4fGRhdGEpLS8uZXhlYyhrZWJvYmVkKSA/IFwieC1cIiArIGtlYm9iZWQgOiBrZWJvYmVkO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgYXR0cmlidXRlVHBsID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IGlucHV0Lm5hbWUsIHR5cGUgPSBpbnB1dC50eXBlO1xuICAgICAgICAgICAgdmFyIGF0dHJOYW1lID0ga2Vib2IobmFtZSk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgdWktdmlldyBoYXMgYW4gYXR0cmlidXRlIHdoaWNoIG1hdGNoZXMgYSBiaW5kaW5nIG9uIHRoZSByb3V0ZWQgY29tcG9uZW50XG4gICAgICAgICAgICAvLyB0aGVuIHBhc3MgdGhhdCBhdHRyaWJ1dGUgdGhyb3VnaCB0byB0aGUgcm91dGVkIGNvbXBvbmVudCB0ZW1wbGF0ZS5cbiAgICAgICAgICAgIC8vIFByZWZlciB1aS12aWV3IHdpcmVkIG1hcHBpbmdzIHRvIHJlc29sdmUgZGF0YSwgdW5sZXNzIHRoZSByZXNvbHZlIHdhcyBleHBsaWNpdGx5IGJvdW5kIHVzaW5nIGBiaW5kaW5nczpgXG4gICAgICAgICAgICBpZiAodWlWaWV3LmF0dHIoYXR0ck5hbWUpICYmICFiaW5kaW5nc1tuYW1lXSlcbiAgICAgICAgICAgICAgICByZXR1cm4gYXR0ck5hbWUgKyBcIj0nXCIgKyB1aVZpZXcuYXR0cihhdHRyTmFtZSkgKyBcIidcIjtcbiAgICAgICAgICAgIHZhciByZXNvbHZlTmFtZSA9IGJpbmRpbmdzW25hbWVdIHx8IG5hbWU7XG4gICAgICAgICAgICAvLyBQcmUtZXZhbHVhdGUgdGhlIGV4cHJlc3Npb24gZm9yIFwiQFwiIGJpbmRpbmdzIGJ5IGVuY2xvc2luZyBpbiB7eyB9fVxuICAgICAgICAgICAgLy8gc29tZS1hdHRyPVwie3sgOjokcmVzb2x2ZS5zb21lUmVzb2x2ZU5hbWUgfX1cIlxuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdAJylcbiAgICAgICAgICAgICAgICByZXR1cm4gYXR0ck5hbWUgKyBcIj0ne3tcIiArIHByZWZpeCArIFwiJHJlc29sdmUuXCIgKyByZXNvbHZlTmFtZSArIFwifX0nXCI7XG4gICAgICAgICAgICAvLyBXaXJlIFwiJlwiIGNhbGxiYWNrcyB0byByZXNvbHZlcyB0aGF0IHJldHVybiBhIGNhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICAgICAgICAvLyBHZXQgdGhlIHJlc3VsdCBvZiB0aGUgcmVzb2x2ZSAoc2hvdWxkIGJlIGEgZnVuY3Rpb24pIGFuZCBhbm5vdGF0ZSBpdCB0byBnZXQgaXRzIGFyZ3VtZW50cy5cbiAgICAgICAgICAgIC8vIHNvbWUtYXR0cj1cIiRyZXNvbHZlLnNvbWVSZXNvbHZlUmVzdWx0TmFtZShmb28sIGJhcilcIlxuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICcmJykge1xuICAgICAgICAgICAgICAgIHZhciByZXMgPSBjb250ZXh0LmdldFJlc29sdmFibGUocmVzb2x2ZU5hbWUpO1xuICAgICAgICAgICAgICAgIHZhciBmbiA9IHJlcyAmJiByZXMuZGF0YTtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IGZuICYmIGNvcmUuc2VydmljZXMuJGluamVjdG9yLmFubm90YXRlKGZuKSB8fCBbXTtcbiAgICAgICAgICAgICAgICAvLyBhY2NvdW50IGZvciBhcnJheSBzdHlsZSBpbmplY3Rpb24sIGkuZS4sIFsnZm9vJywgZnVuY3Rpb24oZm9vKSB7fV1cbiAgICAgICAgICAgICAgICB2YXIgYXJyYXlJZHhTdHIgPSBjb3JlLmlzQXJyYXkoZm4pID8gXCJbXCIgKyAoZm4ubGVuZ3RoIC0gMSkgKyBcIl1cIiA6ICcnO1xuICAgICAgICAgICAgICAgIHJldHVybiBhdHRyTmFtZSArIFwiPSckcmVzb2x2ZS5cIiArIHJlc29sdmVOYW1lICsgYXJyYXlJZHhTdHIgKyBcIihcIiArIGFyZ3Muam9pbignLCcpICsgXCIpJ1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc29tZS1hdHRyPVwiOjokcmVzb2x2ZS5zb21lUmVzb2x2ZU5hbWVcIlxuICAgICAgICAgICAgcmV0dXJuIGF0dHJOYW1lICsgXCI9J1wiICsgcHJlZml4ICsgXCIkcmVzb2x2ZS5cIiArIHJlc29sdmVOYW1lICsgXCInXCI7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBhdHRycyA9IGdldENvbXBvbmVudEJpbmRpbmdzKGNvbXBvbmVudCkubWFwKGF0dHJpYnV0ZVRwbCkuam9pbignICcpO1xuICAgICAgICB2YXIga2Vib2JOYW1lID0ga2Vib2IoY29tcG9uZW50KTtcbiAgICAgICAgcmV0dXJuIFwiPFwiICsga2Vib2JOYW1lICsgXCIgXCIgKyBhdHRycyArIFwiPjwvXCIgKyBrZWJvYk5hbWUgKyBcIj5cIjtcbiAgICB9O1xuICAgIHJldHVybiBUZW1wbGF0ZUZhY3Rvcnk7XG59KCkpO1xuLy8gR2V0cyBhbGwgdGhlIGRpcmVjdGl2ZShzKScgaW5wdXRzICgnQCcsICc9JywgYW5kICc8JykgYW5kIG91dHB1dHMgKCcmJylcbmZ1bmN0aW9uIGdldENvbXBvbmVudEJpbmRpbmdzKG5hbWUpIHtcbiAgICB2YXIgY21wRGVmcyA9IGNvcmUuc2VydmljZXMuJGluamVjdG9yLmdldChuYW1lICsgJ0RpcmVjdGl2ZScpOyAvLyBjb3VsZCBiZSBtdWx0aXBsZVxuICAgIGlmICghY21wRGVmcyB8fCAhY21wRGVmcy5sZW5ndGgpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBmaW5kIGNvbXBvbmVudCBuYW1lZCAnXCIgKyBuYW1lICsgXCInXCIpO1xuICAgIHJldHVybiBjbXBEZWZzLm1hcChnZXRCaW5kaW5ncykucmVkdWNlKGNvcmUudW5uZXN0UiwgW10pO1xufVxuLy8gR2l2ZW4gYSBkaXJlY3RpdmUgZGVmaW5pdGlvbiwgZmluZCBpdHMgb2JqZWN0IGlucHV0IGF0dHJpYnV0ZXNcbi8vIFVzZSBkaWZmZXJlbnQgcHJvcGVydGllcywgZGVwZW5kaW5nIG9uIHRoZSB0eXBlIG9mIGRpcmVjdGl2ZSAoY29tcG9uZW50LCBiaW5kVG9Db250cm9sbGVyLCBub3JtYWwpXG52YXIgZ2V0QmluZGluZ3MgPSBmdW5jdGlvbiAoZGVmKSB7XG4gICAgaWYgKGNvcmUuaXNPYmplY3QoZGVmLmJpbmRUb0NvbnRyb2xsZXIpKVxuICAgICAgICByZXR1cm4gc2NvcGVCaW5kaW5ncyhkZWYuYmluZFRvQ29udHJvbGxlcik7XG4gICAgcmV0dXJuIHNjb3BlQmluZGluZ3MoZGVmLnNjb3BlKTtcbn07XG4vLyBmb3IgbmcgMS4yIHN0eWxlLCBwcm9jZXNzIHRoZSBzY29wZTogeyBpbnB1dDogXCI9Zm9vXCIgfVxuLy8gZm9yIG5nIDEuMyB0aHJvdWdoIG5nIDEuNSwgcHJvY2VzcyB0aGUgY29tcG9uZW50J3MgYmluZFRvQ29udHJvbGxlcjogeyBpbnB1dDogXCI9Zm9vXCIgfSBvYmplY3RcbnZhciBzY29wZUJpbmRpbmdzID0gZnVuY3Rpb24gKGJpbmRpbmdzT2JqKSB7IHJldHVybiBPYmplY3Qua2V5cyhiaW5kaW5nc09iaiB8fCB7fSlcbiAgICAubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIFtrZXksIC9eKFs9PEAmXSlbP10/KC4qKS8uZXhlYyhiaW5kaW5nc09ialtrZXldKV07IH0pXG4gICAgLmZpbHRlcihmdW5jdGlvbiAodHVwbGUpIHsgcmV0dXJuIGNvcmUuaXNEZWZpbmVkKHR1cGxlKSAmJiBjb3JlLmlzQXJyYXkodHVwbGVbMV0pOyB9KVxuICAgIC5tYXAoZnVuY3Rpb24gKHR1cGxlKSB7IHJldHVybiAoeyBuYW1lOiB0dXBsZVsxXVsyXSB8fCB0dXBsZVswXSwgdHlwZTogdHVwbGVbMV1bMV0gfSk7IH0pOyB9O1xuXG4vKiogQG1vZHVsZSBuZzEgKi8gLyoqIGZvciB0eXBlZG9jICovXG4vKipcbiAqIFRoZSBBbmd1bGFyIDEgYFN0YXRlUHJvdmlkZXJgXG4gKlxuICogVGhlIGAkc3RhdGVQcm92aWRlcmAgd29ya3Mgc2ltaWxhciB0byBBbmd1bGFyJ3MgdjEgcm91dGVyLCBidXQgaXQgZm9jdXNlcyBwdXJlbHlcbiAqIG9uIHN0YXRlLlxuICpcbiAqIEEgc3RhdGUgY29ycmVzcG9uZHMgdG8gYSBcInBsYWNlXCIgaW4gdGhlIGFwcGxpY2F0aW9uIGluIHRlcm1zIG9mIHRoZSBvdmVyYWxsIFVJIGFuZFxuICogbmF2aWdhdGlvbi4gQSBzdGF0ZSBkZXNjcmliZXMgKHZpYSB0aGUgY29udHJvbGxlciAvIHRlbXBsYXRlIC8gdmlldyBwcm9wZXJ0aWVzKSB3aGF0XG4gKiB0aGUgVUkgbG9va3MgbGlrZSBhbmQgZG9lcyBhdCB0aGF0IHBsYWNlLlxuICpcbiAqIFN0YXRlcyBvZnRlbiBoYXZlIHRoaW5ncyBpbiBjb21tb24sIGFuZCB0aGUgcHJpbWFyeSB3YXkgb2YgZmFjdG9yaW5nIG91dCB0aGVzZVxuICogY29tbW9uYWxpdGllcyBpbiB0aGlzIG1vZGVsIGlzIHZpYSB0aGUgc3RhdGUgaGllcmFyY2h5LCBpLmUuIHBhcmVudC9jaGlsZCBzdGF0ZXMgYWthXG4gKiBuZXN0ZWQgc3RhdGVzLlxuICpcbiAqIFRoZSBgJHN0YXRlUHJvdmlkZXJgIHByb3ZpZGVzIGludGVyZmFjZXMgdG8gZGVjbGFyZSB0aGVzZSBzdGF0ZXMgZm9yIHlvdXIgYXBwLlxuICovXG52YXIgU3RhdGVQcm92aWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdGF0ZVByb3ZpZGVyKHN0YXRlUmVnaXN0cnksIHN0YXRlU2VydmljZSkge1xuICAgICAgICB0aGlzLnN0YXRlUmVnaXN0cnkgPSBzdGF0ZVJlZ2lzdHJ5O1xuICAgICAgICB0aGlzLnN0YXRlU2VydmljZSA9IHN0YXRlU2VydmljZTtcbiAgICAgICAgY29yZS5jcmVhdGVQcm94eUZ1bmN0aW9ucyhjb3JlLnZhbChTdGF0ZVByb3ZpZGVyLnByb3RvdHlwZSksIHRoaXMsIGNvcmUudmFsKHRoaXMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVjb3JhdGVzIHN0YXRlcyB3aGVuIHRoZXkgYXJlIHJlZ2lzdGVyZWRcbiAgICAgKlxuICAgICAqIEFsbG93cyB5b3UgdG8gZXh0ZW5kIChjYXJlZnVsbHkpIG9yIG92ZXJyaWRlIChhdCB5b3VyIG93biBwZXJpbCkgdGhlXG4gICAgICogYHN0YXRlQnVpbGRlcmAgb2JqZWN0IHVzZWQgaW50ZXJuYWxseSBieSBbW1N0YXRlUmVnaXN0cnldXS5cbiAgICAgKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGFkZCBjdXN0b20gZnVuY3Rpb25hbGl0eSB0byB1aS1yb3V0ZXIsXG4gICAgICogZm9yIGV4YW1wbGUgaW5mZXJyaW5nIHRlbXBsYXRlVXJsIGJhc2VkIG9uIHRoZSBzdGF0ZSBuYW1lLlxuICAgICAqXG4gICAgICogV2hlbiBwYXNzaW5nIG9ubHkgYSBuYW1lLCBpdCByZXR1cm5zIHRoZSBjdXJyZW50IChvcmlnaW5hbCBvciBkZWNvcmF0ZWQpIGJ1aWxkZXJcbiAgICAgKiBmdW5jdGlvbiB0aGF0IG1hdGNoZXMgYG5hbWVgLlxuICAgICAqXG4gICAgICogVGhlIGJ1aWxkZXIgZnVuY3Rpb25zIHRoYXQgY2FuIGJlIGRlY29yYXRlZCBhcmUgbGlzdGVkIGJlbG93LiBUaG91Z2ggbm90IGFsbFxuICAgICAqIG5lY2Vzc2FyaWx5IGhhdmUgYSBnb29kIHVzZSBjYXNlIGZvciBkZWNvcmF0aW9uLCB0aGF0IGlzIHVwIHRvIHlvdSB0byBkZWNpZGUuXG4gICAgICpcbiAgICAgKiBJbiBhZGRpdGlvbiwgdXNlcnMgY2FuIGF0dGFjaCBjdXN0b20gZGVjb3JhdG9ycywgd2hpY2ggd2lsbCBnZW5lcmF0ZSBuZXdcbiAgICAgKiBwcm9wZXJ0aWVzIHdpdGhpbiB0aGUgc3RhdGUncyBpbnRlcm5hbCBkZWZpbml0aW9uLiBUaGVyZSBpcyBjdXJyZW50bHkgbm8gY2xlYXJcbiAgICAgKiB1c2UtY2FzZSBmb3IgdGhpcyBiZXlvbmQgYWNjZXNzaW5nIGludGVybmFsIHN0YXRlcyAoaS5lLiAkc3RhdGUuJGN1cnJlbnQpLFxuICAgICAqIGhvd2V2ZXIsIGV4cGVjdCB0aGlzIHRvIGJlY29tZSBpbmNyZWFzaW5nbHkgcmVsZXZhbnQgYXMgd2UgaW50cm9kdWNlIGFkZGl0aW9uYWxcbiAgICAgKiBtZXRhLXByb2dyYW1taW5nIGZlYXR1cmVzLlxuICAgICAqXG4gICAgICogKipXYXJuaW5nKio6IERlY29yYXRvcnMgc2hvdWxkIG5vdCBiZSBpbnRlcmRlcGVuZGVudCBiZWNhdXNlIHRoZSBvcmRlciBvZlxuICAgICAqIGV4ZWN1dGlvbiBvZiB0aGUgYnVpbGRlciBmdW5jdGlvbnMgaW4gbm9uLWRldGVybWluaXN0aWMuIEJ1aWxkZXIgZnVuY3Rpb25zXG4gICAgICogc2hvdWxkIG9ubHkgYmUgZGVwZW5kZW50IG9uIHRoZSBzdGF0ZSBkZWZpbml0aW9uIG9iamVjdCBhbmQgc3VwZXIgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKlxuICAgICAqIEV4aXN0aW5nIGJ1aWxkZXIgZnVuY3Rpb25zIGFuZCBjdXJyZW50IHJldHVybiB2YWx1ZXM6XG4gICAgICpcbiAgICAgKiAtICoqcGFyZW50KiogYHtvYmplY3R9YCAtIHJldHVybnMgdGhlIHBhcmVudCBzdGF0ZSBvYmplY3QuXG4gICAgICogLSAqKmRhdGEqKiBge29iamVjdH1gIC0gcmV0dXJucyBzdGF0ZSBkYXRhLCBpbmNsdWRpbmcgYW55IGluaGVyaXRlZCBkYXRhIHRoYXQgaXMgbm90XG4gICAgICogICBvdmVycmlkZGVuIGJ5IG93biB2YWx1ZXMgKGlmIGFueSkuXG4gICAgICogLSAqKnVybCoqIGB7b2JqZWN0fWAgLSByZXR1cm5zIGEge0BsaW5rIHVpLnJvdXRlci51dGlsLnR5cGU6VXJsTWF0Y2hlciBVcmxNYXRjaGVyfVxuICAgICAqICAgb3IgYG51bGxgLlxuICAgICAqIC0gKipuYXZpZ2FibGUqKiBge29iamVjdH1gIC0gcmV0dXJucyBjbG9zZXN0IGFuY2VzdG9yIHN0YXRlIHRoYXQgaGFzIGEgVVJMIChha2EgaXNcbiAgICAgKiAgIG5hdmlnYWJsZSkuXG4gICAgICogLSAqKnBhcmFtcyoqIGB7b2JqZWN0fWAgLSByZXR1cm5zIGFuIGFycmF5IG9mIHN0YXRlIHBhcmFtcyB0aGF0IGFyZSBlbnN1cmVkIHRvXG4gICAgICogICBiZSBhIHN1cGVyLXNldCBvZiBwYXJlbnQncyBwYXJhbXMuXG4gICAgICogLSAqKnZpZXdzKiogYHtvYmplY3R9YCAtIHJldHVybnMgYSB2aWV3cyBvYmplY3Qgd2hlcmUgZWFjaCBrZXkgaXMgYW4gYWJzb2x1dGUgdmlld1xuICAgICAqICAgbmFtZSAoaS5lLiBcInZpZXdOYW1lQHN0YXRlTmFtZVwiKSBhbmQgZWFjaCB2YWx1ZSBpcyB0aGUgY29uZmlnIG9iamVjdFxuICAgICAqICAgKHRlbXBsYXRlLCBjb250cm9sbGVyKSBmb3IgdGhlIHZpZXcuIEV2ZW4gd2hlbiB5b3UgZG9uJ3QgdXNlIHRoZSB2aWV3cyBvYmplY3RcbiAgICAgKiAgIGV4cGxpY2l0bHkgb24gYSBzdGF0ZSBjb25maWcsIG9uZSBpcyBzdGlsbCBjcmVhdGVkIGZvciB5b3UgaW50ZXJuYWxseS5cbiAgICAgKiAgIFNvIGJ5IGRlY29yYXRpbmcgdGhpcyBidWlsZGVyIGZ1bmN0aW9uIHlvdSBoYXZlIGFjY2VzcyB0byBkZWNvcmF0aW5nIHRlbXBsYXRlXG4gICAgICogICBhbmQgY29udHJvbGxlciBwcm9wZXJ0aWVzLlxuICAgICAqIC0gKipvd25QYXJhbXMqKiBge29iamVjdH1gIC0gcmV0dXJucyBhbiBhcnJheSBvZiBwYXJhbXMgdGhhdCBiZWxvbmcgdG8gdGhlIHN0YXRlLFxuICAgICAqICAgbm90IGluY2x1ZGluZyBhbnkgcGFyYW1zIGRlZmluZWQgYnkgYW5jZXN0b3Igc3RhdGVzLlxuICAgICAqIC0gKipwYXRoKiogYHtzdHJpbmd9YCAtIHJldHVybnMgdGhlIGZ1bGwgcGF0aCBmcm9tIHRoZSByb290IGRvd24gdG8gdGhpcyBzdGF0ZS5cbiAgICAgKiAgIE5lZWRlZCBmb3Igc3RhdGUgYWN0aXZhdGlvbi5cbiAgICAgKiAtICoqaW5jbHVkZXMqKiBge29iamVjdH1gIC0gcmV0dXJucyBhbiBvYmplY3QgdGhhdCBpbmNsdWRlcyBldmVyeSBzdGF0ZSB0aGF0XG4gICAgICogICB3b3VsZCBwYXNzIGEgYCRzdGF0ZS5pbmNsdWRlcygpYCB0ZXN0LlxuICAgICAqXG4gICAgICogIyMjIyBFeGFtcGxlOlxuICAgICAqIE92ZXJyaWRlIHRoZSBpbnRlcm5hbCAndmlld3MnIGJ1aWxkZXIgd2l0aCBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgdGhlIHN0YXRlXG4gICAgICogZGVmaW5pdGlvbiwgYW5kIGEgcmVmZXJlbmNlIHRvIHRoZSBpbnRlcm5hbCBmdW5jdGlvbiBiZWluZyBvdmVycmlkZGVuOlxuICAgICAqIGBgYGpzXG4gICAgICogJHN0YXRlUHJvdmlkZXIuZGVjb3JhdG9yKCd2aWV3cycsIGZ1bmN0aW9uIChzdGF0ZSwgcGFyZW50KSB7XG4gICAgICogICBsZXQgcmVzdWx0ID0ge30sXG4gICAgICogICAgICAgdmlld3MgPSBwYXJlbnQoc3RhdGUpO1xuICAgICAqXG4gICAgICogICBhbmd1bGFyLmZvckVhY2godmlld3MsIGZ1bmN0aW9uIChjb25maWcsIG5hbWUpIHtcbiAgICAgKiAgICAgbGV0IGF1dG9OYW1lID0gKHN0YXRlLm5hbWUgKyAnLicgKyBuYW1lKS5yZXBsYWNlKCcuJywgJy8nKTtcbiAgICAgKiAgICAgY29uZmlnLnRlbXBsYXRlVXJsID0gY29uZmlnLnRlbXBsYXRlVXJsIHx8ICcvcGFydGlhbHMvJyArIGF1dG9OYW1lICsgJy5odG1sJztcbiAgICAgKiAgICAgcmVzdWx0W25hbWVdID0gY29uZmlnO1xuICAgICAqICAgfSk7XG4gICAgICogICByZXR1cm4gcmVzdWx0O1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogJHN0YXRlUHJvdmlkZXIuc3RhdGUoJ2hvbWUnLCB7XG4gICAgICogICB2aWV3czoge1xuICAgICAqICAgICAnY29udGFjdC5saXN0JzogeyBjb250cm9sbGVyOiAnTGlzdENvbnRyb2xsZXInIH0sXG4gICAgICogICAgICdjb250YWN0Lml0ZW0nOiB7IGNvbnRyb2xsZXI6ICdJdGVtQ29udHJvbGxlcicgfVxuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICpcbiAgICAgKiBgYGBqc1xuICAgICAqIC8vIEF1dG8tcG9wdWxhdGVzIGxpc3QgYW5kIGl0ZW0gdmlld3Mgd2l0aCAvcGFydGlhbHMvaG9tZS9jb250YWN0L2xpc3QuaHRtbCxcbiAgICAgKiAvLyBhbmQgL3BhcnRpYWxzL2hvbWUvY29udGFjdC9pdGVtLmh0bWwsIHJlc3BlY3RpdmVseS5cbiAgICAgKiAkc3RhdGUuZ28oJ2hvbWUnKTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBidWlsZGVyIGZ1bmN0aW9uIHRvIGRlY29yYXRlLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBmdW5jIEEgZnVuY3Rpb24gdGhhdCBpcyByZXNwb25zaWJsZSBmb3IgZGVjb3JhdGluZyB0aGUgb3JpZ2luYWxcbiAgICAgKiBidWlsZGVyIGZ1bmN0aW9uLiBUaGUgZnVuY3Rpb24gcmVjZWl2ZXMgdHdvIHBhcmFtZXRlcnM6XG4gICAgICpcbiAgICAgKiAgIC0gYHtvYmplY3R9YCAtIHN0YXRlIC0gVGhlIHN0YXRlIGNvbmZpZyBvYmplY3QuXG4gICAgICogICAtIGB7b2JqZWN0fWAgLSBzdXBlciAtIFRoZSBvcmlnaW5hbCBidWlsZGVyIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybiB7b2JqZWN0fSAkc3RhdGVQcm92aWRlciAtICRzdGF0ZVByb3ZpZGVyIGluc3RhbmNlXG4gICAgICovXG4gICAgU3RhdGVQcm92aWRlci5wcm90b3R5cGUuZGVjb3JhdG9yID0gZnVuY3Rpb24gKG5hbWUsIGZ1bmMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGVSZWdpc3RyeS5kZWNvcmF0b3IobmFtZSwgZnVuYykgfHwgdGhpcztcbiAgICB9O1xuICAgIFN0YXRlUHJvdmlkZXIucHJvdG90eXBlLnN0YXRlID0gZnVuY3Rpb24gKG5hbWUsIGRlZmluaXRpb24pIHtcbiAgICAgICAgaWYgKGNvcmUuaXNPYmplY3QobmFtZSkpIHtcbiAgICAgICAgICAgIGRlZmluaXRpb24gPSBuYW1lO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVmaW5pdGlvbi5uYW1lID0gbmFtZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlUmVnaXN0cnkucmVnaXN0ZXIoZGVmaW5pdGlvbik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGFuIGludmFsaWQgc3RhdGUgaGFuZGxlclxuICAgICAqXG4gICAgICogVGhpcyBpcyBhIHBhc3N0aHJvdWdoIHRvIFtbU3RhdGVTZXJ2aWNlLm9uSW52YWxpZF1dIGZvciBuZzEuXG4gICAgICovXG4gICAgU3RhdGVQcm92aWRlci5wcm90b3R5cGUub25JbnZhbGlkID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlU2VydmljZS5vbkludmFsaWQoY2FsbGJhY2spO1xuICAgIH07XG4gICAgcmV0dXJuIFN0YXRlUHJvdmlkZXI7XG59KCkpO1xuXG4vKiogQG1vZHVsZSBuZzEgKi8gLyoqICovXG4vKipcbiAqIFRoaXMgaXMgYSBbW1N0YXRlQnVpbGRlci5idWlsZGVyXV0gZnVuY3Rpb24gZm9yIGFuZ3VsYXIxIGBvbkVudGVyYCwgYG9uRXhpdGAsXG4gKiBgb25SZXRhaW5gIGNhbGxiYWNrIGhvb2tzIG9uIGEgW1tOZzFTdGF0ZURlY2xhcmF0aW9uXV0uXG4gKlxuICogV2hlbiB0aGUgW1tTdGF0ZUJ1aWxkZXJdXSBidWlsZHMgYSBbW1N0YXRlT2JqZWN0XV0gb2JqZWN0IGZyb20gYSByYXcgW1tTdGF0ZURlY2xhcmF0aW9uXV0sIHRoaXMgYnVpbGRlclxuICogZW5zdXJlcyB0aGF0IHRob3NlIGhvb2tzIGFyZSBpbmplY3RhYmxlIGZvciBAdWlyb3V0ZXIvYW5ndWxhcmpzIChuZzEpLlxuICovXG52YXIgZ2V0U3RhdGVIb29rQnVpbGRlciA9IGZ1bmN0aW9uIChob29rTmFtZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiBzdGF0ZUhvb2tCdWlsZGVyKHN0YXRlT2JqZWN0LCBwYXJlbnRGbikge1xuICAgICAgICB2YXIgaG9vayA9IHN0YXRlT2JqZWN0W2hvb2tOYW1lXTtcbiAgICAgICAgdmFyIHBhdGhuYW1lID0gaG9va05hbWUgPT09ICdvbkV4aXQnID8gJ2Zyb20nIDogJ3RvJztcbiAgICAgICAgZnVuY3Rpb24gZGVjb3JhdGVkTmcxSG9vayh0cmFucywgc3RhdGUpIHtcbiAgICAgICAgICAgIHZhciByZXNvbHZlQ29udGV4dCA9IG5ldyBjb3JlLlJlc29sdmVDb250ZXh0KHRyYW5zLnRyZWVDaGFuZ2VzKHBhdGhuYW1lKSk7XG4gICAgICAgICAgICB2YXIgc3ViQ29udGV4dCA9IHJlc29sdmVDb250ZXh0LnN1YkNvbnRleHQoc3RhdGUuJCRzdGF0ZSgpKTtcbiAgICAgICAgICAgIHZhciBsb2NhbHMgPSBjb3JlLmV4dGVuZChnZXRMb2NhbHMoc3ViQ29udGV4dCksIHsgJHN0YXRlJDogc3RhdGUsICR0cmFuc2l0aW9uJDogdHJhbnMgfSk7XG4gICAgICAgICAgICByZXR1cm4gY29yZS5zZXJ2aWNlcy4kaW5qZWN0b3IuaW52b2tlKGhvb2ssIHRoaXMsIGxvY2Fscyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhvb2sgPyBkZWNvcmF0ZWROZzFIb29rIDogdW5kZWZpbmVkO1xuICAgIH07XG59O1xuXG4vKipcbiAqIEBpbnRlcm5hbGFwaVxuICogQG1vZHVsZSBuZzFcbiAqLyAvKiogKi9cbi8qKlxuICogSW1wbGVtZW50cyBVSS1Sb3V0ZXIgTG9jYXRpb25TZXJ2aWNlcyBhbmQgTG9jYXRpb25Db25maWcgdXNpbmcgQW5ndWxhciAxJ3MgJGxvY2F0aW9uIHNlcnZpY2VcbiAqL1xudmFyIE5nMUxvY2F0aW9uU2VydmljZXMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTmcxTG9jYXRpb25TZXJ2aWNlcygkbG9jYXRpb25Qcm92aWRlcikge1xuICAgICAgICAvLyAub25DaGFuZ2UoKSByZWdpc3RyeVxuICAgICAgICB0aGlzLl91cmxMaXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgdGhpcy4kbG9jYXRpb25Qcm92aWRlciA9ICRsb2NhdGlvblByb3ZpZGVyO1xuICAgICAgICB2YXIgX2xwID0gY29yZS52YWwoJGxvY2F0aW9uUHJvdmlkZXIpO1xuICAgICAgICBjb3JlLmNyZWF0ZVByb3h5RnVuY3Rpb25zKF9scCwgdGhpcywgX2xwLCBbJ2hhc2hQcmVmaXgnXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGx5cyBuZzEtc3BlY2lmaWMgcGF0aCBwYXJhbWV0ZXIgZW5jb2RpbmdcbiAgICAgKlxuICAgICAqIFRoZSBBbmd1bGFyIDEgYCRsb2NhdGlvbmAgc2VydmljZSBpcyBhIGJpdCB3ZWlyZC5cbiAgICAgKiBJdCBkb2Vzbid0IGFsbG93IHNsYXNoZXMgdG8gYmUgZW5jb2RlZC9kZWNvZGVkIGJpLWRpcmVjdGlvbmFsbHkuXG4gICAgICpcbiAgICAgKiBTZWUgdGhlIHdyaXRldXAgYXQgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXItdWkvdWktcm91dGVyL2lzc3Vlcy8yNTk4XG4gICAgICpcbiAgICAgKiBUaGlzIGNvZGUgcGF0Y2hlcyB0aGUgYHBhdGhgIHBhcmFtZXRlciB0eXBlIHNvIGl0IGVuY29kZWQvZGVjb2RlcyBzbGFzaGVzIGFzIH4yRlxuICAgICAqXG4gICAgICogQHBhcmFtIHJvdXRlclxuICAgICAqL1xuICAgIE5nMUxvY2F0aW9uU2VydmljZXMubW9ua2V5UGF0Y2hQYXRoUGFyYW1ldGVyVHlwZSA9IGZ1bmN0aW9uIChyb3V0ZXIpIHtcbiAgICAgICAgdmFyIHBhdGhUeXBlID0gcm91dGVyLnVybE1hdGNoZXJGYWN0b3J5LnR5cGUoJ3BhdGgnKTtcbiAgICAgICAgcGF0aFR5cGUuZW5jb2RlID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIHJldHVybiB4ICE9IG51bGwgPyB4LnRvU3RyaW5nKCkucmVwbGFjZSgvKH58XFwvKS9nLCBmdW5jdGlvbiAobSkgeyByZXR1cm4gKHsgJ34nOiAnfn4nLCAnLyc6ICd+MkYnIH1bbV0pOyB9KSA6IHg7XG4gICAgICAgIH07XG4gICAgICAgIHBhdGhUeXBlLmRlY29kZSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICByZXR1cm4geCAhPSBudWxsID8geC50b1N0cmluZygpLnJlcGxhY2UoLyh+fnx+MkYpL2csIGZ1bmN0aW9uIChtKSB7IHJldHVybiAoeyAnfn4nOiAnficsICd+MkYnOiAnLycgfVttXSk7IH0pIDogeDtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIE5nMUxvY2F0aW9uU2VydmljZXMucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgTmcxTG9jYXRpb25TZXJ2aWNlcy5wcm90b3R5cGUub25DaGFuZ2UgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fdXJsTGlzdGVuZXJzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29yZS5yZW1vdmVGcm9tKF90aGlzLl91cmxMaXN0ZW5lcnMpKGNhbGxiYWNrKTsgfTtcbiAgICB9O1xuICAgIE5nMUxvY2F0aW9uU2VydmljZXMucHJvdG90eXBlLmh0bWw1TW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGh0bWw1TW9kZSA9IHRoaXMuJGxvY2F0aW9uUHJvdmlkZXIuaHRtbDVNb2RlKCk7XG4gICAgICAgIGh0bWw1TW9kZSA9IGNvcmUuaXNPYmplY3QoaHRtbDVNb2RlKSA/IGh0bWw1TW9kZS5lbmFibGVkIDogaHRtbDVNb2RlO1xuICAgICAgICByZXR1cm4gaHRtbDVNb2RlICYmIHRoaXMuJHNuaWZmZXIuaGlzdG9yeTtcbiAgICB9O1xuICAgIE5nMUxvY2F0aW9uU2VydmljZXMucHJvdG90eXBlLnVybCA9IGZ1bmN0aW9uIChuZXdVcmwsIHJlcGxhY2UsIHN0YXRlKSB7XG4gICAgICAgIGlmIChyZXBsYWNlID09PSB2b2lkIDApIHsgcmVwbGFjZSA9IGZhbHNlOyB9XG4gICAgICAgIGlmIChjb3JlLmlzRGVmaW5lZChuZXdVcmwpKVxuICAgICAgICAgICAgdGhpcy4kbG9jYXRpb24udXJsKG5ld1VybCk7XG4gICAgICAgIGlmIChyZXBsYWNlKVxuICAgICAgICAgICAgdGhpcy4kbG9jYXRpb24ucmVwbGFjZSgpO1xuICAgICAgICBpZiAoc3RhdGUpXG4gICAgICAgICAgICB0aGlzLiRsb2NhdGlvbi5zdGF0ZShzdGF0ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLiRsb2NhdGlvbi51cmwoKTtcbiAgICB9O1xuICAgIE5nMUxvY2F0aW9uU2VydmljZXMucHJvdG90eXBlLl9ydW50aW1lU2VydmljZXMgPSBmdW5jdGlvbiAoJHJvb3RTY29wZSwgJGxvY2F0aW9uLCAkc25pZmZlciwgJGJyb3dzZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy4kbG9jYXRpb24gPSAkbG9jYXRpb247XG4gICAgICAgIHRoaXMuJHNuaWZmZXIgPSAkc25pZmZlcjtcbiAgICAgICAgLy8gQmluZCAkbG9jYXRpb25DaGFuZ2VTdWNjZXNzIHRvIHRoZSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBpbiBMb2NhdGlvblNlcnZpY2Uub25DaGFuZ2VcbiAgICAgICAgJHJvb3RTY29wZS4kb24oJyRsb2NhdGlvbkNoYW5nZVN1Y2Nlc3MnLCBmdW5jdGlvbiAoZXZ0KSB7IHJldHVybiBfdGhpcy5fdXJsTGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7IHJldHVybiBmbihldnQpOyB9KTsgfSk7XG4gICAgICAgIHZhciBfbG9jID0gY29yZS52YWwoJGxvY2F0aW9uKTtcbiAgICAgICAgdmFyIF9icm93c2VyID0gY29yZS52YWwoJGJyb3dzZXIpO1xuICAgICAgICAvLyBCaW5kIHRoZXNlIExvY2F0aW9uU2VydmljZSBmdW5jdGlvbnMgdG8gJGxvY2F0aW9uXG4gICAgICAgIGNvcmUuY3JlYXRlUHJveHlGdW5jdGlvbnMoX2xvYywgdGhpcywgX2xvYywgWydyZXBsYWNlJywgJ3BhdGgnLCAnc2VhcmNoJywgJ2hhc2gnXSk7XG4gICAgICAgIC8vIEJpbmQgdGhlc2UgTG9jYXRpb25Db25maWcgZnVuY3Rpb25zIHRvICRsb2NhdGlvblxuICAgICAgICBjb3JlLmNyZWF0ZVByb3h5RnVuY3Rpb25zKF9sb2MsIHRoaXMsIF9sb2MsIFsncG9ydCcsICdwcm90b2NvbCcsICdob3N0J10pO1xuICAgICAgICAvLyBCaW5kIHRoZXNlIExvY2F0aW9uQ29uZmlnIGZ1bmN0aW9ucyB0byAkYnJvd3NlclxuICAgICAgICBjb3JlLmNyZWF0ZVByb3h5RnVuY3Rpb25zKF9icm93c2VyLCB0aGlzLCBfYnJvd3NlciwgWydiYXNlSHJlZiddKTtcbiAgICB9O1xuICAgIHJldHVybiBOZzFMb2NhdGlvblNlcnZpY2VzO1xufSgpKTtcblxuLyoqIEBtb2R1bGUgdXJsICovIC8qKiAqL1xuLyoqXG4gKiBNYW5hZ2VzIHJ1bGVzIGZvciBjbGllbnQtc2lkZSBVUkxcbiAqXG4gKiAjIyMgRGVwcmVjYXRpb24gd2FybmluZzpcbiAqIFRoaXMgY2xhc3MgaXMgbm93IGNvbnNpZGVyZWQgdG8gYmUgYW4gaW50ZXJuYWwgQVBJXG4gKiBVc2UgdGhlIFtbVXJsU2VydmljZV1dIGluc3RlYWQuXG4gKiBGb3IgY29uZmlndXJpbmcgVVJMIHJ1bGVzLCB1c2UgdGhlIFtbVXJsUnVsZXNBcGldXSB3aGljaCBjYW4gYmUgZm91bmQgYXMgW1tVcmxTZXJ2aWNlLnJ1bGVzXV0uXG4gKlxuICogVGhpcyBjbGFzcyBtYW5hZ2VzIHRoZSByb3V0ZXIgcnVsZXMgZm9yIHdoYXQgdG8gZG8gd2hlbiB0aGUgVVJMIGNoYW5nZXMuXG4gKlxuICogVGhpcyBwcm92aWRlciByZW1haW5zIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAqXG4gKiBAZGVwcmVjYXRlZFxuICovXG52YXIgVXJsUm91dGVyUHJvdmlkZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBmdW5jdGlvbiBVcmxSb3V0ZXJQcm92aWRlcihyb3V0ZXIpIHtcbiAgICAgICAgdGhpcy5fcm91dGVyID0gcm91dGVyO1xuICAgICAgICB0aGlzLl91cmxSb3V0ZXIgPSByb3V0ZXIudXJsUm91dGVyO1xuICAgIH1cbiAgICBVcmxSb3V0ZXJQcm92aWRlci5pbmplY3RhYmxlSGFuZGxlciA9IGZ1bmN0aW9uIChyb3V0ZXIsIGhhbmRsZXIpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvcmUuc2VydmljZXMuJGluamVjdG9yLmludm9rZShoYW5kbGVyLCBudWxsLCB7ICRtYXRjaDogbWF0Y2gsICRzdGF0ZVBhcmFtczogcm91dGVyLmdsb2JhbHMucGFyYW1zIH0pO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBVcmxSb3V0ZXJQcm92aWRlci5wcm90b3R5cGUuJGdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHVybFJvdXRlciA9IHRoaXMuX3VybFJvdXRlcjtcbiAgICAgICAgdXJsUm91dGVyLnVwZGF0ZSh0cnVlKTtcbiAgICAgICAgaWYgKCF1cmxSb3V0ZXIuaW50ZXJjZXB0RGVmZXJyZWQpXG4gICAgICAgICAgICB1cmxSb3V0ZXIubGlzdGVuKCk7XG4gICAgICAgIHJldHVybiB1cmxSb3V0ZXI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSB1cmwgaGFuZGxlciBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIFJlZ2lzdGVycyBhIGxvdyBsZXZlbCB1cmwgaGFuZGxlciAoYSBgcnVsZWApLlxuICAgICAqIEEgcnVsZSBkZXRlY3RzIHNwZWNpZmljIFVSTCBwYXR0ZXJucyBhbmQgcmV0dXJucyBhIHJlZGlyZWN0LCBvciBwZXJmb3JtcyBzb21lIGFjdGlvbi5cbiAgICAgKlxuICAgICAqIElmIGEgcnVsZSByZXR1cm5zIGEgc3RyaW5nLCB0aGUgVVJMIGlzIHJlcGxhY2VkIHdpdGggdGhlIHN0cmluZywgYW5kIGFsbCBydWxlcyBhcmUgZmlyZWQgYWdhaW4uXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGU6XG4gICAgICogYGBganNcbiAgICAgKiB2YXIgYXBwID0gYW5ndWxhci5tb2R1bGUoJ2FwcCcsIFsndWkucm91dGVyLnJvdXRlciddKTtcbiAgICAgKlxuICAgICAqIGFwcC5jb25maWcoZnVuY3Rpb24gKCR1cmxSb3V0ZXJQcm92aWRlcikge1xuICAgICAqICAgLy8gSGVyZSdzIGFuIGV4YW1wbGUgb2YgaG93IHlvdSBtaWdodCBhbGxvdyBjYXNlIGluc2Vuc2l0aXZlIHVybHNcbiAgICAgKiAgICR1cmxSb3V0ZXJQcm92aWRlci5ydWxlKGZ1bmN0aW9uICgkaW5qZWN0b3IsICRsb2NhdGlvbikge1xuICAgICAqICAgICB2YXIgcGF0aCA9ICRsb2NhdGlvbi5wYXRoKCksXG4gICAgICogICAgICAgICBub3JtYWxpemVkID0gcGF0aC50b0xvd2VyQ2FzZSgpO1xuICAgICAqXG4gICAgICogICAgIGlmIChwYXRoICE9PSBub3JtYWxpemVkKSB7XG4gICAgICogICAgICAgcmV0dXJuIG5vcm1hbGl6ZWQ7XG4gICAgICogICAgIH1cbiAgICAgKiAgIH0pO1xuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIHJ1bGVGblxuICAgICAqIEhhbmRsZXIgZnVuY3Rpb24gdGhhdCB0YWtlcyBgJGluamVjdG9yYCBhbmQgYCRsb2NhdGlvbmAgc2VydmljZXMgYXMgYXJndW1lbnRzLlxuICAgICAqIFlvdSBjYW4gdXNlIHRoZW0gdG8gZGV0ZWN0IGEgdXJsIGFuZCByZXR1cm4gYSBkaWZmZXJlbnQgdXJsIGFzIGEgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHJldHVybiBbW1VybFJvdXRlclByb3ZpZGVyXV0gKGB0aGlzYClcbiAgICAgKi9cbiAgICBVcmxSb3V0ZXJQcm92aWRlci5wcm90b3R5cGUucnVsZSA9IGZ1bmN0aW9uIChydWxlRm4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCFjb3JlLmlzRnVuY3Rpb24ocnVsZUZuKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIidydWxlJyBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gICAgICAgIHZhciBtYXRjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBydWxlRm4oY29yZS5zZXJ2aWNlcy4kaW5qZWN0b3IsIF90aGlzLl9yb3V0ZXIubG9jYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHJ1bGUgPSBuZXcgY29yZS5CYXNlVXJsUnVsZShtYXRjaCwgY29yZS5pZGVudGl0eSk7XG4gICAgICAgIHRoaXMuX3VybFJvdXRlci5ydWxlKHJ1bGUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERlZmluZXMgdGhlIHBhdGggb3IgYmVoYXZpb3IgdG8gdXNlIHdoZW4gbm8gdXJsIGNhbiBiZSBtYXRjaGVkLlxuICAgICAqXG4gICAgICogIyMjIyBFeGFtcGxlOlxuICAgICAqIGBgYGpzXG4gICAgICogdmFyIGFwcCA9IGFuZ3VsYXIubW9kdWxlKCdhcHAnLCBbJ3VpLnJvdXRlci5yb3V0ZXInXSk7XG4gICAgICpcbiAgICAgKiBhcHAuY29uZmlnKGZ1bmN0aW9uICgkdXJsUm91dGVyUHJvdmlkZXIpIHtcbiAgICAgKiAgIC8vIGlmIHRoZSBwYXRoIGRvZXNuJ3QgbWF0Y2ggYW55IG9mIHRoZSB1cmxzIHlvdSBjb25maWd1cmVkXG4gICAgICogICAvLyBvdGhlcndpc2Ugd2lsbCB0YWtlIGNhcmUgb2Ygcm91dGluZyB0aGUgdXNlciB0byB0aGVcbiAgICAgKiAgIC8vIHNwZWNpZmllZCB1cmxcbiAgICAgKiAgICR1cmxSb3V0ZXJQcm92aWRlci5vdGhlcndpc2UoJy9pbmRleCcpO1xuICAgICAqXG4gICAgICogICAvLyBFeGFtcGxlIG9mIHVzaW5nIGZ1bmN0aW9uIHJ1bGUgYXMgcGFyYW1cbiAgICAgKiAgICR1cmxSb3V0ZXJQcm92aWRlci5vdGhlcndpc2UoZnVuY3Rpb24gKCRpbmplY3RvciwgJGxvY2F0aW9uKSB7XG4gICAgICogICAgIHJldHVybiAnL2EvdmFsaWQvdXJsJztcbiAgICAgKiAgIH0pO1xuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIHJ1bGVcbiAgICAgKiBUaGUgdXJsIHBhdGggeW91IHdhbnQgdG8gcmVkaXJlY3QgdG8gb3IgYSBmdW5jdGlvbiBydWxlIHRoYXQgcmV0dXJucyB0aGUgdXJsIHBhdGggb3IgcGVyZm9ybXMgYSBgJHN0YXRlLmdvKClgLlxuICAgICAqIFRoZSBmdW5jdGlvbiB2ZXJzaW9uIGlzIHBhc3NlZCB0d28gcGFyYW1zOiBgJGluamVjdG9yYCBhbmQgYCRsb2NhdGlvbmAgc2VydmljZXMsIGFuZCBzaG91bGQgcmV0dXJuIGEgdXJsIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge29iamVjdH0gYCR1cmxSb3V0ZXJQcm92aWRlcmAgLSBgJHVybFJvdXRlclByb3ZpZGVyYCBpbnN0YW5jZVxuICAgICAqL1xuICAgIFVybFJvdXRlclByb3ZpZGVyLnByb3RvdHlwZS5vdGhlcndpc2UgPSBmdW5jdGlvbiAocnVsZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgdXJsUm91dGVyID0gdGhpcy5fdXJsUm91dGVyO1xuICAgICAgICBpZiAoY29yZS5pc1N0cmluZyhydWxlKSkge1xuICAgICAgICAgICAgdXJsUm91dGVyLm90aGVyd2lzZShydWxlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb3JlLmlzRnVuY3Rpb24ocnVsZSkpIHtcbiAgICAgICAgICAgIHVybFJvdXRlci5vdGhlcndpc2UoZnVuY3Rpb24gKCkgeyByZXR1cm4gcnVsZShjb3JlLnNlcnZpY2VzLiRpbmplY3RvciwgX3RoaXMuX3JvdXRlci5sb2NhdGlvblNlcnZpY2UpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIidydWxlJyBtdXN0IGJlIGEgc3RyaW5nIG9yIGZ1bmN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgaGFuZGxlciBmb3IgYSBnaXZlbiB1cmwgbWF0Y2hpbmcuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgaGFuZGxlciBpcyBhIHN0cmluZywgaXQgaXNcbiAgICAgKiB0cmVhdGVkIGFzIGEgcmVkaXJlY3QsIGFuZCBpcyBpbnRlcnBvbGF0ZWQgYWNjb3JkaW5nIHRvIHRoZSBzeW50YXggb2YgbWF0Y2hcbiAgICAgKiAoaS5lLiBsaWtlIGBTdHJpbmcucmVwbGFjZSgpYCBmb3IgYFJlZ0V4cGAsIG9yIGxpa2UgYSBgVXJsTWF0Y2hlcmAgcGF0dGVybiBvdGhlcndpc2UpLlxuICAgICAqXG4gICAgICogSWYgdGhlIGhhbmRsZXIgaXMgYSBmdW5jdGlvbiwgaXQgaXMgaW5qZWN0YWJsZS5cbiAgICAgKiBJdCBnZXRzIGludm9rZWQgaWYgYCRsb2NhdGlvbmAgbWF0Y2hlcy5cbiAgICAgKiBZb3UgaGF2ZSB0aGUgb3B0aW9uIG9mIGluamVjdCB0aGUgbWF0Y2ggb2JqZWN0IGFzIGAkbWF0Y2hgLlxuICAgICAqXG4gICAgICogVGhlIGhhbmRsZXIgY2FuIHJldHVyblxuICAgICAqXG4gICAgICogLSAqKmZhbHN5KiogdG8gaW5kaWNhdGUgdGhhdCB0aGUgcnVsZSBkaWRuJ3QgbWF0Y2ggYWZ0ZXIgYWxsLCB0aGVuIGAkdXJsUm91dGVyYFxuICAgICAqICAgd2lsbCBjb250aW51ZSB0cnlpbmcgdG8gZmluZCBhbm90aGVyIG9uZSB0aGF0IG1hdGNoZXMuXG4gICAgICogLSAqKnN0cmluZyoqIHdoaWNoIGlzIHRyZWF0ZWQgYXMgYSByZWRpcmVjdCBhbmQgcGFzc2VkIHRvIGAkbG9jYXRpb24udXJsKClgXG4gICAgICogLSAqKnZvaWQqKiBvciBhbnkgKip0cnV0aHkqKiB2YWx1ZSB0ZWxscyBgJHVybFJvdXRlcmAgdGhhdCB0aGUgdXJsIHdhcyBoYW5kbGVkLlxuICAgICAqXG4gICAgICogIyMjIyBFeGFtcGxlOlxuICAgICAqIGBgYGpzXG4gICAgICogdmFyIGFwcCA9IGFuZ3VsYXIubW9kdWxlKCdhcHAnLCBbJ3VpLnJvdXRlci5yb3V0ZXInXSk7XG4gICAgICpcbiAgICAgKiBhcHAuY29uZmlnKGZ1bmN0aW9uICgkdXJsUm91dGVyUHJvdmlkZXIpIHtcbiAgICAgKiAgICR1cmxSb3V0ZXJQcm92aWRlci53aGVuKCRzdGF0ZS51cmwsIGZ1bmN0aW9uICgkbWF0Y2gsICRzdGF0ZVBhcmFtcykge1xuICAgICAqICAgICBpZiAoJHN0YXRlLiRjdXJyZW50Lm5hdmlnYWJsZSAhPT0gc3RhdGUgfHxcbiAgICAgKiAgICAgICAgICFlcXVhbEZvcktleXMoJG1hdGNoLCAkc3RhdGVQYXJhbXMpIHtcbiAgICAgKiAgICAgICRzdGF0ZS50cmFuc2l0aW9uVG8oc3RhdGUsICRtYXRjaCwgZmFsc2UpO1xuICAgICAqICAgICB9XG4gICAgICogICB9KTtcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB3aGF0IEEgcGF0dGVybiBzdHJpbmcgdG8gbWF0Y2gsIGNvbXBpbGVkIGFzIGEgW1tVcmxNYXRjaGVyXV0uXG4gICAgICogQHBhcmFtIGhhbmRsZXIgVGhlIHBhdGggKG9yIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHBhdGgpIHRoYXQgeW91IHdhbnQgdG8gcmVkaXJlY3QgeW91ciB1c2VyIHRvLlxuICAgICAqIEBwYXJhbSBydWxlQ2FsbGJhY2sgW29wdGlvbmFsXSBBIGNhbGxiYWNrIHRoYXQgcmVjZWl2ZXMgdGhlIGBydWxlYCByZWdpc3RlcmVkIHdpdGggW1tVcmxNYXRjaGVyLnJ1bGVdXVxuICAgICAqXG4gICAgICogTm90ZTogdGhlIGhhbmRsZXIgbWF5IGFsc28gaW52b2tlIGFyYml0cmFyeSBjb2RlLCBzdWNoIGFzIGAkc3RhdGUuZ28oKWBcbiAgICAgKi9cbiAgICBVcmxSb3V0ZXJQcm92aWRlci5wcm90b3R5cGUud2hlbiA9IGZ1bmN0aW9uICh3aGF0LCBoYW5kbGVyKSB7XG4gICAgICAgIGlmIChjb3JlLmlzQXJyYXkoaGFuZGxlcikgfHwgY29yZS5pc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgICAgICAgICBoYW5kbGVyID0gVXJsUm91dGVyUHJvdmlkZXIuaW5qZWN0YWJsZUhhbmRsZXIodGhpcy5fcm91dGVyLCBoYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl91cmxSb3V0ZXIud2hlbih3aGF0LCBoYW5kbGVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBEaXNhYmxlcyBtb25pdG9yaW5nIG9mIHRoZSBVUkwuXG4gICAgICpcbiAgICAgKiBDYWxsIHRoaXMgbWV0aG9kIGJlZm9yZSBVSS1Sb3V0ZXIgaGFzIGJvb3RzdHJhcHBlZC5cbiAgICAgKiBJdCB3aWxsIHN0b3AgVUktUm91dGVyIGZyb20gcGVyZm9ybWluZyB0aGUgaW5pdGlhbCB1cmwgc3luYy5cbiAgICAgKlxuICAgICAqIFRoaXMgY2FuIGJlIHVzZWZ1bCB0byBwZXJmb3JtIHNvbWUgYXN5bmNocm9ub3VzIGluaXRpYWxpemF0aW9uIGJlZm9yZSB0aGUgcm91dGVyIHN0YXJ0cy5cbiAgICAgKiBPbmNlIHRoZSBpbml0aWFsaXphdGlvbiBpcyBjb21wbGV0ZSwgY2FsbCBbW2xpc3Rlbl1dIHRvIHRlbGwgVUktUm91dGVyIHRvIHN0YXJ0IHdhdGNoaW5nIGFuZCBzeW5jaHJvbml6aW5nIHRoZSBVUkwuXG4gICAgICpcbiAgICAgKiAjIyMjIEV4YW1wbGU6XG4gICAgICogYGBganNcbiAgICAgKiB2YXIgYXBwID0gYW5ndWxhci5tb2R1bGUoJ2FwcCcsIFsndWkucm91dGVyJ10pO1xuICAgICAqXG4gICAgICogYXBwLmNvbmZpZyhmdW5jdGlvbiAoJHVybFJvdXRlclByb3ZpZGVyKSB7XG4gICAgICogICAvLyBQcmV2ZW50ICR1cmxSb3V0ZXIgZnJvbSBhdXRvbWF0aWNhbGx5IGludGVyY2VwdGluZyBVUkwgY2hhbmdlcztcbiAgICAgKiAgICR1cmxSb3V0ZXJQcm92aWRlci5kZWZlckludGVyY2VwdCgpO1xuICAgICAqIH0pXG4gICAgICpcbiAgICAgKiBhcHAucnVuKGZ1bmN0aW9uIChNeVNlcnZpY2UsICR1cmxSb3V0ZXIsICRodHRwKSB7XG4gICAgICogICAkaHR0cC5nZXQoXCIvc3R1ZmZcIikudGhlbihmdW5jdGlvbihyZXNwKSB7XG4gICAgICogICAgIE15U2VydmljZS5kb1N0dWZmKHJlc3AuZGF0YSk7XG4gICAgICogICAgICR1cmxSb3V0ZXIubGlzdGVuKCk7XG4gICAgICogICAgICR1cmxSb3V0ZXIuc3luYygpO1xuICAgICAqICAgfSk7XG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGVmZXIgSW5kaWNhdGVzIHdoZXRoZXIgdG8gZGVmZXIgbG9jYXRpb24gY2hhbmdlIGludGVyY2VwdGlvbi5cbiAgICAgKiAgICAgICAgUGFzc2luZyBubyBwYXJhbWV0ZXIgaXMgZXF1aXZhbGVudCB0byBgdHJ1ZWAuXG4gICAgICovXG4gICAgVXJsUm91dGVyUHJvdmlkZXIucHJvdG90eXBlLmRlZmVySW50ZXJjZXB0ID0gZnVuY3Rpb24gKGRlZmVyKSB7XG4gICAgICAgIHRoaXMuX3VybFJvdXRlci5kZWZlckludGVyY2VwdChkZWZlcik7XG4gICAgfTtcbiAgICByZXR1cm4gVXJsUm91dGVyUHJvdmlkZXI7XG59KCkpO1xuXG4vKipcbiAqICMgQW5ndWxhciAxIHR5cGVzXG4gKlxuICogVUktUm91dGVyIGNvcmUgcHJvdmlkZXMgdmFyaW91cyBUeXBlc2NyaXB0IHR5cGVzIHdoaWNoIHlvdSBjYW4gdXNlIGZvciBjb2RlIGNvbXBsZXRpb24gYW5kIHZhbGlkYXRpbmcgcGFyYW1ldGVyIHZhbHVlcywgZXRjLlxuICogVGhlIGN1c3RvbWl6YXRpb25zIHRvIHRoZSBjb3JlIHR5cGVzIGZvciBBbmd1bGFyIFVJLVJvdXRlciBhcmUgZG9jdW1lbnRlZCBoZXJlLlxuICpcbiAqIFRoZSBvcHRpb25hbCBbWyRyZXNvbHZlXV0gc2VydmljZSBpcyBhbHNvIGRvY3VtZW50ZWQgaGVyZS5cbiAqXG4gKiBAbW9kdWxlIG5nMVxuICogQHByZWZlcnJlZFxuICovXG4vKiogZm9yIHR5cGVkb2MgKi9cbm5nLm1vZHVsZSgndWkucm91dGVyLmFuZ3VsYXIxJywgW10pO1xudmFyIG1vZF9pbml0ID0gbmcubW9kdWxlKCd1aS5yb3V0ZXIuaW5pdCcsIFtdKTtcbnZhciBtb2RfdXRpbCA9IG5nLm1vZHVsZSgndWkucm91dGVyLnV0aWwnLCBbJ25nJywgJ3VpLnJvdXRlci5pbml0J10pO1xudmFyIG1vZF9ydHIgPSBuZy5tb2R1bGUoJ3VpLnJvdXRlci5yb3V0ZXInLCBbJ3VpLnJvdXRlci51dGlsJ10pO1xudmFyIG1vZF9zdGF0ZSA9IG5nLm1vZHVsZSgndWkucm91dGVyLnN0YXRlJywgWyd1aS5yb3V0ZXIucm91dGVyJywgJ3VpLnJvdXRlci51dGlsJywgJ3VpLnJvdXRlci5hbmd1bGFyMSddKTtcbnZhciBtb2RfbWFpbiA9IG5nLm1vZHVsZSgndWkucm91dGVyJywgWyd1aS5yb3V0ZXIuaW5pdCcsICd1aS5yb3V0ZXIuc3RhdGUnLCAndWkucm91dGVyLmFuZ3VsYXIxJ10pO1xudmFyIG1vZF9jbXB0ID0gbmcubW9kdWxlKCd1aS5yb3V0ZXIuY29tcGF0JywgWyd1aS5yb3V0ZXInXSk7IC8vIHRzbGludDpkaXNhYmxlLWxpbmVcbnZhciByb3V0ZXIgPSBudWxsO1xuJHVpUm91dGVyUHJvdmlkZXIuJGluamVjdCA9IFsnJGxvY2F0aW9uUHJvdmlkZXInXTtcbi8qKiBUaGlzIGFuZ3VsYXIgMSBwcm92aWRlciBpbnN0YW50aWF0ZXMgYSBSb3V0ZXIgYW5kIGV4cG9zZXMgaXRzIHNlcnZpY2VzIHZpYSB0aGUgYW5ndWxhciBpbmplY3RvciAqL1xuZnVuY3Rpb24gJHVpUm91dGVyUHJvdmlkZXIoJGxvY2F0aW9uUHJvdmlkZXIpIHtcbiAgICAvLyBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIFJvdXRlciB3aGVuIHRoZSAkdWlSb3V0ZXJQcm92aWRlciBpcyBpbml0aWFsaXplZFxuICAgIHJvdXRlciA9IHRoaXMucm91dGVyID0gbmV3IGNvcmUuVUlSb3V0ZXIoKTtcbiAgICByb3V0ZXIuc3RhdGVQcm92aWRlciA9IG5ldyBTdGF0ZVByb3ZpZGVyKHJvdXRlci5zdGF0ZVJlZ2lzdHJ5LCByb3V0ZXIuc3RhdGVTZXJ2aWNlKTtcbiAgICAvLyBBcHBseSBuZzEgc3BlY2lmaWMgU3RhdGVCdWlsZGVyIGNvZGUgZm9yIGB2aWV3c2AsIGByZXNvbHZlYCwgYW5kIGBvbkV4aXQvUmV0YWluL0VudGVyYCBwcm9wZXJ0aWVzXG4gICAgcm91dGVyLnN0YXRlUmVnaXN0cnkuZGVjb3JhdG9yKCd2aWV3cycsIG5nMVZpZXdzQnVpbGRlcik7XG4gICAgcm91dGVyLnN0YXRlUmVnaXN0cnkuZGVjb3JhdG9yKCdvbkV4aXQnLCBnZXRTdGF0ZUhvb2tCdWlsZGVyKCdvbkV4aXQnKSk7XG4gICAgcm91dGVyLnN0YXRlUmVnaXN0cnkuZGVjb3JhdG9yKCdvblJldGFpbicsIGdldFN0YXRlSG9va0J1aWxkZXIoJ29uUmV0YWluJykpO1xuICAgIHJvdXRlci5zdGF0ZVJlZ2lzdHJ5LmRlY29yYXRvcignb25FbnRlcicsIGdldFN0YXRlSG9va0J1aWxkZXIoJ29uRW50ZXInKSk7XG4gICAgcm91dGVyLnZpZXdTZXJ2aWNlLl9wbHVnaW5hcGkuX3ZpZXdDb25maWdGYWN0b3J5KCduZzEnLCBnZXROZzFWaWV3Q29uZmlnRmFjdG9yeSgpKTtcbiAgICB2YXIgbmcxTG9jYXRpb25TZXJ2aWNlID0gcm91dGVyLmxvY2F0aW9uU2VydmljZSA9IHJvdXRlci5sb2NhdGlvbkNvbmZpZyA9IG5ldyBOZzFMb2NhdGlvblNlcnZpY2VzKCRsb2NhdGlvblByb3ZpZGVyKTtcbiAgICBOZzFMb2NhdGlvblNlcnZpY2VzLm1vbmtleVBhdGNoUGF0aFBhcmFtZXRlclR5cGUocm91dGVyKTtcbiAgICAvLyBiYWNrd2FyZHMgY29tcGF0OiBhbHNvIGV4cG9zZSByb3V0ZXIgaW5zdGFuY2UgYXMgJHVpUm91dGVyUHJvdmlkZXIucm91dGVyXG4gICAgcm91dGVyWydyb3V0ZXInXSA9IHJvdXRlcjtcbiAgICByb3V0ZXJbJyRnZXQnXSA9ICRnZXQ7XG4gICAgJGdldC4kaW5qZWN0ID0gWyckbG9jYXRpb24nLCAnJGJyb3dzZXInLCAnJHNuaWZmZXInLCAnJHJvb3RTY29wZScsICckaHR0cCcsICckdGVtcGxhdGVDYWNoZSddO1xuICAgIGZ1bmN0aW9uICRnZXQoJGxvY2F0aW9uLCAkYnJvd3NlciwgJHNuaWZmZXIsICRyb290U2NvcGUsICRodHRwLCAkdGVtcGxhdGVDYWNoZSkge1xuICAgICAgICBuZzFMb2NhdGlvblNlcnZpY2UuX3J1bnRpbWVTZXJ2aWNlcygkcm9vdFNjb3BlLCAkbG9jYXRpb24sICRzbmlmZmVyLCAkYnJvd3Nlcik7XG4gICAgICAgIGRlbGV0ZSByb3V0ZXJbJ3JvdXRlciddO1xuICAgICAgICBkZWxldGUgcm91dGVyWyckZ2V0J107XG4gICAgICAgIHJldHVybiByb3V0ZXI7XG4gICAgfVxuICAgIHJldHVybiByb3V0ZXI7XG59XG52YXIgZ2V0UHJvdmlkZXJGb3IgPSBmdW5jdGlvbiAoc2VydmljZU5hbWUpIHsgcmV0dXJuIFsnJHVpUm91dGVyUHJvdmlkZXInLCBmdW5jdGlvbiAoJHVycCkge1xuICAgICAgICB2YXIgc2VydmljZSA9ICR1cnAucm91dGVyW3NlcnZpY2VOYW1lXTtcbiAgICAgICAgc2VydmljZVsnJGdldCddID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VydmljZTsgfTtcbiAgICAgICAgcmV0dXJuIHNlcnZpY2U7XG4gICAgfV07IH07XG4vLyBUaGlzIGVmZmVjdGl2ZWx5IGNhbGxzICRnZXQoKSBvbiBgJHVpUm91dGVyUHJvdmlkZXJgIHRvIHRyaWdnZXIgaW5pdCAod2hlbiBuZyBlbnRlcnMgcnVudGltZSlcbnJ1bkJsb2NrLiRpbmplY3QgPSBbJyRpbmplY3RvcicsICckcScsICckdWlSb3V0ZXInXTtcbmZ1bmN0aW9uIHJ1bkJsb2NrKCRpbmplY3RvciwgJHEsICR1aVJvdXRlcikge1xuICAgIGNvcmUuc2VydmljZXMuJGluamVjdG9yID0gJGluamVjdG9yO1xuICAgIGNvcmUuc2VydmljZXMuJHEgPSAkcTtcbiAgICAvLyBUaGUgJGluamVjdG9yIGlzIG5vdyBhdmFpbGFibGUuXG4gICAgLy8gRmluZCBhbnkgcmVzb2x2YWJsZXMgdGhhdCBoYWQgZGVwZW5kZW5jeSBhbm5vdGF0aW9uIGRlZmVycmVkXG4gICAgJHVpUm91dGVyLnN0YXRlUmVnaXN0cnkuZ2V0KClcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4geC4kJHN0YXRlKCkucmVzb2x2YWJsZXM7IH0pXG4gICAgICAgIC5yZWR1Y2UoY29yZS51bm5lc3RSLCBbXSlcbiAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5kZXBzID09PSAnZGVmZXJyZWQnOyB9KVxuICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAocmVzb2x2YWJsZSkgeyByZXR1cm4gcmVzb2x2YWJsZS5kZXBzID0gJGluamVjdG9yLmFubm90YXRlKHJlc29sdmFibGUucmVzb2x2ZUZuLCAkaW5qZWN0b3Iuc3RyaWN0RGkpOyB9KTtcbn1cbi8vICR1cmxSb3V0ZXIgc2VydmljZSBhbmQgJHVybFJvdXRlclByb3ZpZGVyXG52YXIgZ2V0VXJsUm91dGVyUHJvdmlkZXIgPSBmdW5jdGlvbiAodWlSb3V0ZXIpIHtcbiAgICByZXR1cm4gdWlSb3V0ZXIudXJsUm91dGVyUHJvdmlkZXIgPSBuZXcgVXJsUm91dGVyUHJvdmlkZXIodWlSb3V0ZXIpO1xufTtcbi8vICRzdGF0ZSBzZXJ2aWNlIGFuZCAkc3RhdGVQcm92aWRlclxuLy8gJHVybFJvdXRlciBzZXJ2aWNlIGFuZCAkdXJsUm91dGVyUHJvdmlkZXJcbnZhciBnZXRTdGF0ZVByb3ZpZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjb3JlLmV4dGVuZChyb3V0ZXIuc3RhdGVQcm92aWRlciwgeyAkZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiByb3V0ZXIuc3RhdGVTZXJ2aWNlOyB9IH0pO1xufTtcbndhdGNoRGlnZXN0cy4kaW5qZWN0ID0gWyckcm9vdFNjb3BlJ107XG5mdW5jdGlvbiB3YXRjaERpZ2VzdHMoJHJvb3RTY29wZSkge1xuICAgICRyb290U2NvcGUuJHdhdGNoKGZ1bmN0aW9uICgpIHsgY29yZS50cmFjZS5hcHByb3hpbWF0ZURpZ2VzdHMrKzsgfSk7XG59XG5tb2RfaW5pdC5wcm92aWRlcignJHVpUm91dGVyJywgJHVpUm91dGVyUHJvdmlkZXIpO1xubW9kX3J0ci5wcm92aWRlcignJHVybFJvdXRlcicsIFsnJHVpUm91dGVyUHJvdmlkZXInLCBnZXRVcmxSb3V0ZXJQcm92aWRlcl0pO1xubW9kX3V0aWwucHJvdmlkZXIoJyR1cmxTZXJ2aWNlJywgZ2V0UHJvdmlkZXJGb3IoJ3VybFNlcnZpY2UnKSk7XG5tb2RfdXRpbC5wcm92aWRlcignJHVybE1hdGNoZXJGYWN0b3J5JywgWyckdWlSb3V0ZXJQcm92aWRlcicsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJvdXRlci51cmxNYXRjaGVyRmFjdG9yeTsgfV0pO1xubW9kX3V0aWwucHJvdmlkZXIoJyR0ZW1wbGF0ZUZhY3RvcnknLCBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgVGVtcGxhdGVGYWN0b3J5KCk7IH0pO1xubW9kX3N0YXRlLnByb3ZpZGVyKCckc3RhdGVSZWdpc3RyeScsIGdldFByb3ZpZGVyRm9yKCdzdGF0ZVJlZ2lzdHJ5JykpO1xubW9kX3N0YXRlLnByb3ZpZGVyKCckdWlSb3V0ZXJHbG9iYWxzJywgZ2V0UHJvdmlkZXJGb3IoJ2dsb2JhbHMnKSk7XG5tb2Rfc3RhdGUucHJvdmlkZXIoJyR0cmFuc2l0aW9ucycsIGdldFByb3ZpZGVyRm9yKCd0cmFuc2l0aW9uU2VydmljZScpKTtcbm1vZF9zdGF0ZS5wcm92aWRlcignJHN0YXRlJywgWyckdWlSb3V0ZXJQcm92aWRlcicsIGdldFN0YXRlUHJvdmlkZXJdKTtcbm1vZF9zdGF0ZS5mYWN0b3J5KCckc3RhdGVQYXJhbXMnLCBbJyR1aVJvdXRlcicsIGZ1bmN0aW9uICgkdWlSb3V0ZXIpIHsgcmV0dXJuICR1aVJvdXRlci5nbG9iYWxzLnBhcmFtczsgfV0pO1xubW9kX21haW4uZmFjdG9yeSgnJHZpZXcnLCBmdW5jdGlvbiAoKSB7IHJldHVybiByb3V0ZXIudmlld1NlcnZpY2U7IH0pO1xubW9kX21haW4uc2VydmljZSgnJHRyYWNlJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gY29yZS50cmFjZTsgfSk7XG5tb2RfbWFpbi5ydW4od2F0Y2hEaWdlc3RzKTtcbm1vZF91dGlsLnJ1bihbJyR1cmxNYXRjaGVyRmFjdG9yeScsIGZ1bmN0aW9uICgkdXJsTWF0Y2hlckZhY3RvcnkpIHsgfV0pO1xubW9kX3N0YXRlLnJ1bihbJyRzdGF0ZScsIGZ1bmN0aW9uICgkc3RhdGUpIHsgfV0pO1xubW9kX3J0ci5ydW4oWyckdXJsUm91dGVyJywgZnVuY3Rpb24gKCR1cmxSb3V0ZXIpIHsgfV0pO1xubW9kX2luaXQucnVuKHJ1bkJsb2NrKTtcbi8qKiBAaGlkZGVuIFRPRE86IGZpbmQgYSBwbGFjZSB0byBtb3ZlIHRoaXMgKi9cbnZhciBnZXRMb2NhbHMgPSBmdW5jdGlvbiAoY3R4KSB7XG4gICAgdmFyIHRva2VucyA9IGN0eC5nZXRUb2tlbnMoKS5maWx0ZXIoY29yZS5pc1N0cmluZyk7XG4gICAgdmFyIHR1cGxlcyA9IHRva2Vucy5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgcmVzb2x2YWJsZSA9IGN0eC5nZXRSZXNvbHZhYmxlKGtleSk7XG4gICAgICAgIHZhciB3YWl0UG9saWN5ID0gY3R4LmdldFBvbGljeShyZXNvbHZhYmxlKS5hc3luYztcbiAgICAgICAgcmV0dXJuIFtrZXksIHdhaXRQb2xpY3kgPT09ICdOT1dBSVQnID8gcmVzb2x2YWJsZS5wcm9taXNlIDogcmVzb2x2YWJsZS5kYXRhXTtcbiAgICB9KTtcbiAgICByZXR1cm4gdHVwbGVzLnJlZHVjZShjb3JlLmFwcGx5UGFpcnMsIHt9KTtcbn07XG5cbi8qKlxuICogVGhlIGN1cnJlbnQgKG9yIHBlbmRpbmcpIFN0YXRlIFBhcmFtZXRlcnNcbiAqXG4gKiBBbiBpbmplY3RhYmxlIGdsb2JhbCAqKlNlcnZpY2UgT2JqZWN0Kiogd2hpY2ggaG9sZHMgdGhlIHN0YXRlIHBhcmFtZXRlcnMgZm9yIHRoZSBsYXRlc3QgKipTVUNDRVNTRlVMKiogdHJhbnNpdGlvbi5cbiAqXG4gKiBUaGUgdmFsdWVzIGFyZSBub3QgdXBkYXRlZCB1bnRpbCAqYWZ0ZXIqIGEgYFRyYW5zaXRpb25gIHN1Y2Nlc3NmdWxseSBjb21wbGV0ZXMuXG4gKlxuICogKipBbHNvOioqIGFuIGluamVjdGFibGUgKipQZXItVHJhbnNpdGlvbiBPYmplY3QqKiBvYmplY3Qgd2hpY2ggaG9sZHMgdGhlIHBlbmRpbmcgc3RhdGUgcGFyYW1ldGVycyBmb3IgdGhlIHBlbmRpbmcgYFRyYW5zaXRpb25gIGN1cnJlbnRseSBydW5uaW5nLlxuICpcbiAqICMjIyBEZXByZWNhdGlvbiB3YXJuaW5nOlxuICpcbiAqIFRoZSB2YWx1ZSBpbmplY3RlZCBmb3IgYCRzdGF0ZVBhcmFtc2AgaXMgZGlmZmVyZW50IGRlcGVuZGluZyBvbiB3aGVyZSBpdCBpcyBpbmplY3RlZC5cbiAqXG4gKiAtIFdoZW4gaW5qZWN0ZWQgaW50byBhbiBhbmd1bGFyIHNlcnZpY2UsIHRoZSBvYmplY3QgaW5qZWN0ZWQgaXMgdGhlIGdsb2JhbCAqKlNlcnZpY2UgT2JqZWN0Kiogd2l0aCB0aGUgcGFyYW1ldGVyIHZhbHVlcyBmb3IgdGhlIGxhdGVzdCBzdWNjZXNzZnVsIGBUcmFuc2l0aW9uYC5cbiAqIC0gV2hlbiBpbmplY3RlZCBpbnRvIHRyYW5zaXRpb24gaG9va3MsIHJlc29sdmVzLCBvciB2aWV3IGNvbnRyb2xsZXJzLCB0aGUgb2JqZWN0IGlzIHRoZSAqKlBlci1UcmFuc2l0aW9uIE9iamVjdCoqIHdpdGggdGhlIHBhcmFtZXRlciB2YWx1ZXMgZm9yIHRoZSBydW5uaW5nIGBUcmFuc2l0aW9uYC5cbiAqXG4gKiBCZWNhdXNlIG9mIHRoZXNlIGNvbmZ1c2luZyBkZXRhaWxzLCB0aGlzIHNlcnZpY2UgaXMgZGVwcmVjYXRlZC5cbiAqXG4gKiAjIyMgSW5zdGVhZCBvZiB1c2luZyB0aGUgZ2xvYmFsIGAkc3RhdGVQYXJhbXNgIHNlcnZpY2Ugb2JqZWN0LFxuICogaW5qZWN0IFtbJHVpUm91dGVyR2xvYmFsc11dIGFuZCB1c2UgW1tVSVJvdXRlckdsb2JhbHMucGFyYW1zXV1cbiAqXG4gKiBgYGBqc1xuICogTXlTZXJ2aWNlLiRpbmplY3QgPSBbJyR1aVJvdXRlckdsb2JhbHMnXTtcbiAqIGZ1bmN0aW9uIE15U2VydmljZSgkdWlSb3V0ZXJHbG9iYWxzKSB7XG4gKiAgIHJldHVybiB7XG4gKiAgICAgcGFyYW1WYWx1ZXM6IGZ1bmN0aW9uICgpIHtcbiAqICAgICAgIHJldHVybiAkdWlSb3V0ZXJHbG9iYWxzLnBhcmFtcztcbiAqICAgICB9XG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICpcbiAqICMjIyBJbnN0ZWFkIG9mIHVzaW5nIHRoZSBwZXItdHJhbnNpdGlvbiBgJHN0YXRlUGFyYW1zYCBvYmplY3QsXG4gKiBpbmplY3QgdGhlIGN1cnJlbnQgYFRyYW5zaXRpb25gIChhcyBbWyR0cmFuc2l0aW9uJF1dKSBhbmQgdXNlIFtbVHJhbnNpdGlvbi5wYXJhbXNdXVxuICpcbiAqIGBgYGpzXG4gKiBNeUNvbnRyb2xsZXIuJGluamVjdCA9IFsnJHRyYW5zaXRpb24kJ107XG4gKiBmdW5jdGlvbiBNeUNvbnRyb2xsZXIoJHRyYW5zaXRpb24kKSB7XG4gKiAgIHZhciB1c2VybmFtZSA9ICR0cmFuc2l0aW9uJC5wYXJhbXMoKS51c2VybmFtZTtcbiAqICAgLy8gLi4gZG8gc29tZXRoaW5nIHdpdGggdXNlcm5hbWVcbiAqIH1cbiAqIGBgYFxuICpcbiAqIC0tLVxuICpcbiAqIFRoaXMgb2JqZWN0IGNhbiBiZSBpbmplY3RlZCBpbnRvIG90aGVyIHNlcnZpY2VzLlxuICpcbiAqICMjIyMgRGVwcmVjYXRlZCBFeGFtcGxlOlxuICogYGBganNcbiAqIFNvbWVTZXJ2aWNlLiRpbmplY3QgPSBbJyRodHRwJywgJyRzdGF0ZVBhcmFtcyddO1xuICogZnVuY3Rpb24gU29tZVNlcnZpY2UoJGh0dHAsICRzdGF0ZVBhcmFtcykge1xuICogICByZXR1cm4ge1xuICogICAgIGdldFVzZXI6IGZ1bmN0aW9uKCkge1xuICogICAgICAgcmV0dXJuICRodHRwLmdldCgnL2FwaS91c2Vycy8nICsgJHN0YXRlUGFyYW1zLnVzZXJuYW1lKTtcbiAqICAgICB9XG4gKiAgIH1cbiAqIH07XG4gKiBhbmd1bGFyLnNlcnZpY2UoJ1NvbWVTZXJ2aWNlJywgU29tZVNlcnZpY2UpO1xuICogYGBgXG4gKiBAZGVwcmVjYXRlZFxuICovXG5cbi8qKlxuICogIyBBbmd1bGFyIDEgRGlyZWN0aXZlc1xuICpcbiAqIFRoZXNlIGFyZSB0aGUgZGlyZWN0aXZlcyBpbmNsdWRlZCBpbiBVSS1Sb3V0ZXIgZm9yIEFuZ3VsYXIgMS5cbiAqIFRoZXNlIGRpcmVjdGl2ZXMgYXJlIHVzZWQgaW4gdGVtcGxhdGVzIHRvIGNyZWF0ZSB2aWV3cG9ydHMgYW5kIGxpbmsvbmF2aWdhdGUgdG8gc3RhdGVzLlxuICpcbiAqIEBuZzFhcGlcbiAqIEBwcmVmZXJyZWRcbiAqIEBtb2R1bGUgZGlyZWN0aXZlc1xuICovIC8qKiBmb3IgdHlwZWRvYyAqL1xuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uIHBhcnNlU3RhdGVSZWYocmVmKSB7XG4gICAgdmFyIHBhcnNlZDtcbiAgICB2YXIgcGFyYW1zT25seSA9IHJlZi5tYXRjaCgvXlxccyooe1tefV0qfSlcXHMqJC8pO1xuICAgIGlmIChwYXJhbXNPbmx5KVxuICAgICAgICByZWYgPSAnKCcgKyBwYXJhbXNPbmx5WzFdICsgJyknO1xuICAgIHBhcnNlZCA9IHJlZi5yZXBsYWNlKC9cXG4vZywgJyAnKS5tYXRjaCgvXlxccyooW14oXSo/KVxccyooXFwoKC4qKVxcKSk/XFxzKiQvKTtcbiAgICBpZiAoIXBhcnNlZCB8fCBwYXJzZWQubGVuZ3RoICE9PSA0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN0YXRlIHJlZiAnXCIgKyByZWYgKyBcIidcIik7XG4gICAgcmV0dXJuIHsgc3RhdGU6IHBhcnNlZFsxXSB8fCBudWxsLCBwYXJhbUV4cHI6IHBhcnNlZFszXSB8fCBudWxsIH07XG59XG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gc3RhdGVDb250ZXh0KGVsKSB7XG4gICAgdmFyICR1aVZpZXcgPSBlbC5wYXJlbnQoKS5pbmhlcml0ZWREYXRhKCckdWlWaWV3Jyk7XG4gICAgdmFyIHBhdGggPSBjb3JlLnBhcnNlKCckY2ZnLnBhdGgnKSgkdWlWaWV3KTtcbiAgICByZXR1cm4gcGF0aCA/IGNvcmUudGFpbChwYXRoKS5zdGF0ZS5uYW1lIDogdW5kZWZpbmVkO1xufVxuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uIHByb2Nlc3NlZERlZigkc3RhdGUsICRlbGVtZW50LCBkZWYpIHtcbiAgICB2YXIgdWlTdGF0ZSA9IGRlZi51aVN0YXRlIHx8ICRzdGF0ZS5jdXJyZW50Lm5hbWU7XG4gICAgdmFyIHVpU3RhdGVPcHRzID0gY29yZS5leHRlbmQoZGVmYXVsdE9wdHMoJGVsZW1lbnQsICRzdGF0ZSksIGRlZi51aVN0YXRlT3B0cyB8fCB7fSk7XG4gICAgdmFyIGhyZWYgPSAkc3RhdGUuaHJlZih1aVN0YXRlLCBkZWYudWlTdGF0ZVBhcmFtcywgdWlTdGF0ZU9wdHMpO1xuICAgIHJldHVybiB7IHVpU3RhdGU6IHVpU3RhdGUsIHVpU3RhdGVQYXJhbXM6IGRlZi51aVN0YXRlUGFyYW1zLCB1aVN0YXRlT3B0czogdWlTdGF0ZU9wdHMsIGhyZWY6IGhyZWYgfTtcbn1cbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiBnZXRUeXBlSW5mbyhlbCkge1xuICAgIC8vIFNWR0FFbGVtZW50IGRvZXMgbm90IHVzZSB0aGUgaHJlZiBhdHRyaWJ1dGUsIGJ1dCByYXRoZXIgdGhlICd4bGlua0hyZWYnIGF0dHJpYnV0ZS5cbiAgICB2YXIgaXNTdmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZWwucHJvcCgnaHJlZicpKSA9PT0gJ1tvYmplY3QgU1ZHQW5pbWF0ZWRTdHJpbmddJztcbiAgICB2YXIgaXNGb3JtID0gZWxbMF0ubm9kZU5hbWUgPT09ICdGT1JNJztcbiAgICByZXR1cm4ge1xuICAgICAgICBhdHRyOiBpc0Zvcm0gPyAnYWN0aW9uJyA6IChpc1N2ZyA/ICd4bGluazpocmVmJyA6ICdocmVmJyksXG4gICAgICAgIGlzQW5jaG9yOiBlbC5wcm9wKCd0YWdOYW1lJykudG9VcHBlckNhc2UoKSA9PT0gJ0EnLFxuICAgICAgICBjbGlja2FibGU6ICFpc0Zvcm0sXG4gICAgfTtcbn1cbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiBjbGlja0hvb2soZWwsICRzdGF0ZSwgJHRpbWVvdXQsIHR5cGUsIGdldERlZikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgYnV0dG9uID0gZS53aGljaCB8fCBlLmJ1dHRvbiwgdGFyZ2V0ID0gZ2V0RGVmKCk7XG4gICAgICAgIGlmICghKGJ1dHRvbiA+IDEgfHwgZS5jdHJsS2V5IHx8IGUubWV0YUtleSB8fCBlLnNoaWZ0S2V5IHx8IGVsLmF0dHIoJ3RhcmdldCcpKSkge1xuICAgICAgICAgICAgLy8gSEFDSzogVGhpcyBpcyB0byBhbGxvdyBuZy1jbGlja3MgdG8gYmUgcHJvY2Vzc2VkIGJlZm9yZSB0aGUgdHJhbnNpdGlvbiBpcyBpbml0aWF0ZWQ6XG4gICAgICAgICAgICB2YXIgdHJhbnNpdGlvbl8xID0gJHRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICRzdGF0ZS5nbyh0YXJnZXQudWlTdGF0ZSwgdGFyZ2V0LnVpU3RhdGVQYXJhbXMsIHRhcmdldC51aVN0YXRlT3B0cyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBzdGF0ZSBoYXMgbm8gVVJMLCBpZ25vcmUgb25lIHByZXZlbnREZWZhdWx0IGZyb20gdGhlIDxhPiBkaXJlY3RpdmUuXG4gICAgICAgICAgICB2YXIgaWdub3JlUHJldmVudERlZmF1bHRDb3VudF8xID0gdHlwZS5pc0FuY2hvciAmJiAhdGFyZ2V0LmhyZWYgPyAxIDogMDtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlnbm9yZVByZXZlbnREZWZhdWx0Q291bnRfMS0tIDw9IDApXG4gICAgICAgICAgICAgICAgICAgICR0aW1lb3V0LmNhbmNlbCh0cmFuc2l0aW9uXzEpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH07XG59XG4vKiogQGhpZGRlbiAqL1xuZnVuY3Rpb24gZGVmYXVsdE9wdHMoZWwsICRzdGF0ZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHJlbGF0aXZlOiBzdGF0ZUNvbnRleHQoZWwpIHx8ICRzdGF0ZS4kY3VycmVudCxcbiAgICAgICAgaW5oZXJpdDogdHJ1ZSxcbiAgICAgICAgc291cmNlOiAnc3JlZicsXG4gICAgfTtcbn1cbi8qKiBAaGlkZGVuICovXG5mdW5jdGlvbiBiaW5kRXZlbnRzKGVsZW1lbnQsIHNjb3BlLCBob29rRm4sIHVpU3RhdGVPcHRzKSB7XG4gICAgdmFyIGV2ZW50cztcbiAgICBpZiAodWlTdGF0ZU9wdHMpIHtcbiAgICAgICAgZXZlbnRzID0gdWlTdGF0ZU9wdHMuZXZlbnRzO1xuICAgIH1cbiAgICBpZiAoIWNvcmUuaXNBcnJheShldmVudHMpKSB7XG4gICAgICAgIGV2ZW50cyA9IFsnY2xpY2snXTtcbiAgICB9XG4gICAgdmFyIG9uID0gZWxlbWVudC5vbiA/ICdvbicgOiAnYmluZCc7XG4gICAgZm9yICh2YXIgX2kgPSAwLCBldmVudHNfMSA9IGV2ZW50czsgX2kgPCBldmVudHNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIGV2ZW50XzEgPSBldmVudHNfMVtfaV07XG4gICAgICAgIGVsZW1lbnRbb25dKGV2ZW50XzEsIGhvb2tGbik7XG4gICAgfVxuICAgIHNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvZmYgPSBlbGVtZW50Lm9mZiA/ICdvZmYnIDogJ3VuYmluZCc7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgZXZlbnRzXzIgPSBldmVudHM7IF9pIDwgZXZlbnRzXzIubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgZXZlbnRfMiA9IGV2ZW50c18yW19pXTtcbiAgICAgICAgICAgIGVsZW1lbnRbb2ZmXShldmVudF8yLCBob29rRm4pO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vKipcbiAqIGB1aS1zcmVmYDogQSBkaXJlY3RpdmUgZm9yIGxpbmtpbmcgdG8gYSBzdGF0ZVxuICpcbiAqIEEgZGlyZWN0aXZlIHdoaWNoIGxpbmtzIHRvIGEgc3RhdGUgKGFuZCBvcHRpb25hbGx5LCBwYXJhbWV0ZXJzKS5cbiAqIFdoZW4gY2xpY2tlZCwgdGhpcyBkaXJlY3RpdmUgYWN0aXZhdGVzIHRoZSBsaW5rZWQgc3RhdGUgd2l0aCB0aGUgc3VwcGxpZWQgcGFyYW1ldGVyIHZhbHVlcy5cbiAqXG4gKiAjIyMgTGlua2VkIFN0YXRlXG4gKiBUaGUgYXR0cmlidXRlIHZhbHVlIG9mIHRoZSBgdWktc3JlZmAgaXMgdGhlIG5hbWUgb2YgdGhlIHN0YXRlIHRvIGxpbmsgdG8uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICogVGhpcyB3aWxsIGFjdGl2YXRlIHRoZSBgaG9tZWAgc3RhdGUgd2hlbiB0aGUgbGluayBpcyBjbGlja2VkLlxuICogYGBgaHRtbFxuICogPGEgdWktc3JlZj1cImhvbWVcIj5Ib21lPC9hPlxuICogYGBgXG4gKlxuICogIyMjIFJlbGF0aXZlIExpbmtzXG4gKiBZb3UgY2FuIGFsc28gdXNlIHJlbGF0aXZlIHN0YXRlIHBhdGhzIHdpdGhpbiBgdWktc3JlZmAsIGp1c3QgbGlrZSBhIHJlbGF0aXZlIHBhdGggcGFzc2VkIHRvIGAkc3RhdGUuZ28oKWAgKFtbU3RhdGVTZXJ2aWNlLmdvXV0pLlxuICogWW91IGp1c3QgbmVlZCB0byBiZSBhd2FyZSB0aGF0IHRoZSBwYXRoIGlzIHJlbGF0aXZlIHRvIHRoZSBzdGF0ZSB0aGF0ICpjcmVhdGVkKiB0aGUgbGluay5cbiAqIFRoaXMgYWxsb3dzIGEgc3RhdGUgdG8gY3JlYXRlIGEgcmVsYXRpdmUgYHVpLXNyZWZgIHdoaWNoIGFsd2F5cyB0YXJnZXRzIHRoZSBzYW1lIGRlc3RpbmF0aW9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqIEJvdGggdGhlc2UgbGlua3MgYXJlIHJlbGF0aXZlIHRvIHRoZSBwYXJlbnQgc3RhdGUsIGV2ZW4gd2hlbiBhIGNoaWxkIHN0YXRlIGlzIGN1cnJlbnRseSBhY3RpdmUuXG4gKiBgYGBodG1sXG4gKiA8YSB1aS1zcmVmPVwiLmNoaWxkMVwiPmNoaWxkIDEgc3RhdGU8L2E+XG4gKiA8YSB1aS1zcmVmPVwiLmNoaWxkMlwiPmNoaWxkIDIgc3RhdGU8L2E+XG4gKiBgYGBcbiAqXG4gKiBUaGlzIGxpbmsgYWN0aXZhdGVzIHRoZSBwYXJlbnQgc3RhdGUuXG4gKiBgYGBodG1sXG4gKiA8YSB1aS1zcmVmPVwiXlwiPlJldHVybjwvYT5cbiAqIGBgYFxuICpcbiAqICMjIyBocmVmc1xuICogSWYgdGhlIGxpbmtlZCBzdGF0ZSBoYXMgYSBVUkwsIHRoZSBkaXJlY3RpdmUgd2lsbCBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlIGFuZFxuICogdXBkYXRlIHRoZSBgaHJlZmAgYXR0cmlidXRlICh1c2luZyB0aGUgW1tTdGF0ZVNlcnZpY2UuaHJlZl1dICBtZXRob2QpLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqIEFzc3VtaW5nIHRoZSBgdXNlcnNgIHN0YXRlIGhhcyBhIHVybCBvZiBgL3VzZXJzL2BcbiAqIGBgYGh0bWxcbiAqIDxhIHVpLXNyZWY9XCJ1c2Vyc1wiIGhyZWY9XCIvdXNlcnMvXCI+VXNlcnM8L2E+XG4gKiBgYGBcbiAqXG4gKiAjIyMgUGFyYW1ldGVyIFZhbHVlc1xuICogSW4gYWRkaXRpb24gdG8gdGhlIHN0YXRlIG5hbWUsIGEgYHVpLXNyZWZgIGNhbiBpbmNsdWRlIHBhcmFtZXRlciB2YWx1ZXMgd2hpY2ggYXJlIGFwcGxpZWQgd2hlbiBhY3RpdmF0aW5nIHRoZSBzdGF0ZS5cbiAqIFBhcmFtIHZhbHVlcyBjYW4gYmUgcHJvdmlkZWQgaW4gdGhlIGB1aS1zcmVmYCB2YWx1ZSBhZnRlciB0aGUgc3RhdGUgbmFtZSwgZW5jbG9zZWQgYnkgcGFyZW50aGVzZXMuXG4gKiBUaGUgY29udGVudCBpbnNpZGUgdGhlIHBhcmVudGhlc2VzIGlzIGFuIGV4cHJlc3Npb24sIGV2YWx1YXRlZCB0byB0aGUgcGFyYW1ldGVyIHZhbHVlcy5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKiBUaGlzIGV4YW1wbGUgcmVuZGVycyBhIGxpc3Qgb2YgbGlua3MgdG8gdXNlcnMuXG4gKiBUaGUgc3RhdGUncyBgdXNlcklkYCBwYXJhbWV0ZXIgdmFsdWUgY29tZXMgZnJvbSBlYWNoIHVzZXIncyBgdXNlci5pZGAgcHJvcGVydHkuXG4gKiBgYGBodG1sXG4gKiA8bGkgbmctcmVwZWF0PVwidXNlciBpbiB1c2Vyc1wiPlxuICogICA8YSB1aS1zcmVmPVwidXNlcnMuZGV0YWlsKHsgdXNlcklkOiB1c2VyLmlkIH0pXCI+e3sgdXNlci5kaXNwbGF5TmFtZSB9fTwvYT5cbiAqIDwvbGk+XG4gKiBgYGBcbiAqXG4gKiBOb3RlOlxuICogVGhlIHBhcmFtZXRlciB2YWx1ZXMgZXhwcmVzc2lvbiBpcyBgJHdhdGNoYGVkIGZvciB1cGRhdGVzLlxuICpcbiAqICMjIyBUcmFuc2l0aW9uIE9wdGlvbnNcbiAqIFlvdSBjYW4gc3BlY2lmeSBbW1RyYW5zaXRpb25PcHRpb25zXV0gdG8gcGFzcyB0byBbW1N0YXRlU2VydmljZS5nb11dIGJ5IHVzaW5nIHRoZSBgdWktc3JlZi1vcHRzYCBhdHRyaWJ1dGUuXG4gKiBPcHRpb25zIGFyZSByZXN0cmljdGVkIHRvIGBsb2NhdGlvbmAsIGBpbmhlcml0YCwgYW5kIGByZWxvYWRgLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqIGBgYGh0bWxcbiAqIDxhIHVpLXNyZWY9XCJob21lXCIgdWktc3JlZi1vcHRzPVwieyByZWxvYWQ6IHRydWUgfVwiPkhvbWU8L2E+XG4gKiBgYGBcbiAqXG4gKiAjIyMgT3RoZXIgRE9NIEV2ZW50c1xuICpcbiAqIFlvdSBjYW4gYWxzbyBjdXN0b21pemUgd2hpY2ggRE9NIGV2ZW50cyB0byByZXNwb25kIHRvIChpbnN0ZWFkIG9mIGBjbGlja2ApIGJ5XG4gKiBwcm92aWRpbmcgYW4gYGV2ZW50c2AgYXJyYXkgaW4gdGhlIGB1aS1zcmVmLW9wdHNgIGF0dHJpYnV0ZS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKiBgYGBodG1sXG4gKiA8aW5wdXQgdHlwZT1cInRleHRcIiB1aS1zcmVmPVwiY29udGFjdHNcIiB1aS1zcmVmLW9wdHM9XCJ7IGV2ZW50czogWydjaGFuZ2UnLCAnYmx1ciddIH1cIj5cbiAqIGBgYFxuICpcbiAqICMjIyBIaWdobGlnaHRpbmcgdGhlIGFjdGl2ZSBsaW5rXG4gKiBUaGlzIGRpcmVjdGl2ZSBjYW4gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIFtbdWlTcmVmQWN0aXZlXV0gdG8gaGlnaGxpZ2h0IHRoZSBhY3RpdmUgbGluay5cbiAqXG4gKiAjIyMgRXhhbXBsZXNcbiAqIElmIHlvdSBoYXZlIHRoZSBmb2xsb3dpbmcgdGVtcGxhdGU6XG4gKlxuICogYGBgaHRtbFxuICogPGEgdWktc3JlZj1cImhvbWVcIj5Ib21lPC9hPlxuICogPGEgdWktc3JlZj1cImFib3V0XCI+QWJvdXQ8L2E+XG4gKiA8YSB1aS1zcmVmPVwie3BhZ2U6IDJ9XCI+TmV4dCBwYWdlPC9hPlxuICpcbiAqIDx1bD5cbiAqICAgICA8bGkgbmctcmVwZWF0PVwiY29udGFjdCBpbiBjb250YWN0c1wiPlxuICogICAgICAgICA8YSB1aS1zcmVmPVwiY29udGFjdHMuZGV0YWlsKHsgaWQ6IGNvbnRhY3QuaWQgfSlcIj57eyBjb250YWN0Lm5hbWUgfX08L2E+XG4gKiAgICAgPC9saT5cbiAqIDwvdWw+XG4gKiBgYGBcbiAqXG4gKiBUaGVuIChhc3N1bWluZyB0aGUgY3VycmVudCBzdGF0ZSBpcyBgY29udGFjdHNgKSB0aGUgcmVuZGVyZWQgaHRtbCBpbmNsdWRpbmcgaHJlZnMgd291bGQgYmU6XG4gKlxuICogYGBgaHRtbFxuICogPGEgaHJlZj1cIiMvaG9tZVwiIHVpLXNyZWY9XCJob21lXCI+SG9tZTwvYT5cbiAqIDxhIGhyZWY9XCIjL2Fib3V0XCIgdWktc3JlZj1cImFib3V0XCI+QWJvdXQ8L2E+XG4gKiA8YSBocmVmPVwiIy9jb250YWN0cz9wYWdlPTJcIiB1aS1zcmVmPVwie3BhZ2U6IDJ9XCI+TmV4dCBwYWdlPC9hPlxuICpcbiAqIDx1bD5cbiAqICAgICA8bGkgbmctcmVwZWF0PVwiY29udGFjdCBpbiBjb250YWN0c1wiPlxuICogICAgICAgICA8YSBocmVmPVwiIy9jb250YWN0cy8xXCIgdWktc3JlZj1cImNvbnRhY3RzLmRldGFpbCh7IGlkOiBjb250YWN0LmlkIH0pXCI+Sm9lPC9hPlxuICogICAgIDwvbGk+XG4gKiAgICAgPGxpIG5nLXJlcGVhdD1cImNvbnRhY3QgaW4gY29udGFjdHNcIj5cbiAqICAgICAgICAgPGEgaHJlZj1cIiMvY29udGFjdHMvMlwiIHVpLXNyZWY9XCJjb250YWN0cy5kZXRhaWwoeyBpZDogY29udGFjdC5pZCB9KVwiPkFsaWNlPC9hPlxuICogICAgIDwvbGk+XG4gKiAgICAgPGxpIG5nLXJlcGVhdD1cImNvbnRhY3QgaW4gY29udGFjdHNcIj5cbiAqICAgICAgICAgPGEgaHJlZj1cIiMvY29udGFjdHMvM1wiIHVpLXNyZWY9XCJjb250YWN0cy5kZXRhaWwoeyBpZDogY29udGFjdC5pZCB9KVwiPkJvYjwvYT5cbiAqICAgICA8L2xpPlxuICogPC91bD5cbiAqXG4gKiA8YSBocmVmPVwiIy9ob21lXCIgdWktc3JlZj1cImhvbWVcIiB1aS1zcmVmLW9wdHM9XCJ7cmVsb2FkOiB0cnVlfVwiPkhvbWU8L2E+XG4gKiBgYGBcbiAqXG4gKiAjIyMgTm90ZXNcbiAqXG4gKiAtIFlvdSBjYW4gdXNlIGB1aS1zcmVmYCB0byBjaGFuZ2UgKipvbmx5IHRoZSBwYXJhbWV0ZXIgdmFsdWVzKiogYnkgb21pdHRpbmcgdGhlIHN0YXRlIG5hbWUgYW5kIHBhcmVudGhlc2VzLlxuICogIyMjIyBFeGFtcGxlOlxuICogU2V0cyB0aGUgYGxhbmdgIHBhcmFtZXRlciB0byBgZW5gIGFuZCByZW1haW5zIG9uIHRoZSBzYW1lIHN0YXRlLlxuICpcbiAqIGBgYGh0bWxcbiAqIDxhIHVpLXNyZWY9XCJ7IGxhbmc6ICdlbicgfVwiPkVuZ2xpc2g8L2E+XG4gKiBgYGBcbiAqXG4gKiAtIEEgbWlkZGxlLWNsaWNrLCByaWdodC1jbGljaywgb3IgY3RybC1jbGljayBpcyBoYW5kbGVkIChuYXRpdmVseSkgYnkgdGhlIGJyb3dzZXIgdG8gb3BlbiB0aGUgaHJlZiBpbiBhIG5ldyB3aW5kb3csIGZvciBleGFtcGxlLlxuICpcbiAqIC0gVW5saWtlIHRoZSBwYXJhbWV0ZXIgdmFsdWVzIGV4cHJlc3Npb24sIHRoZSBzdGF0ZSBuYW1lIGlzIG5vdCBgJHdhdGNoYGVkIChmb3IgcGVyZm9ybWFuY2UgcmVhc29ucykuXG4gKiBJZiB5b3UgbmVlZCB0byBkeW5hbWljYWxseSB1cGRhdGUgdGhlIHN0YXRlIGJlaW5nIGxpbmtlZCB0bywgdXNlIHRoZSBmdWxseSBkeW5hbWljIFtbdWlTdGF0ZV1dIGRpcmVjdGl2ZS5cbiAqL1xudmFyIHVpU3JlZkRpcmVjdGl2ZTtcbnVpU3JlZkRpcmVjdGl2ZSA9IFsnJHVpUm91dGVyJywgJyR0aW1lb3V0JyxcbiAgICBmdW5jdGlvbiAkU3RhdGVSZWZEaXJlY3RpdmUoJHVpUm91dGVyLCAkdGltZW91dCkge1xuICAgICAgICB2YXIgJHN0YXRlID0gJHVpUm91dGVyLnN0YXRlU2VydmljZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc3RyaWN0OiAnQScsXG4gICAgICAgICAgICByZXF1aXJlOiBbJz9edWlTcmVmQWN0aXZlJywgJz9edWlTcmVmQWN0aXZlRXEnXSxcbiAgICAgICAgICAgIGxpbms6IGZ1bmN0aW9uIChzY29wZSwgZWxlbWVudCwgYXR0cnMsIHVpU3JlZkFjdGl2ZSkge1xuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gZ2V0VHlwZUluZm8oZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgdmFyIGFjdGl2ZSA9IHVpU3JlZkFjdGl2ZVsxXSB8fCB1aVNyZWZBY3RpdmVbMF07XG4gICAgICAgICAgICAgICAgdmFyIHVubGlua0luZm9GbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgdmFyIGhvb2tGbjtcbiAgICAgICAgICAgICAgICB2YXIgcmF3RGVmID0ge307XG4gICAgICAgICAgICAgICAgdmFyIGdldERlZiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByb2Nlc3NlZERlZigkc3RhdGUsIGVsZW1lbnQsIHJhd0RlZik7IH07XG4gICAgICAgICAgICAgICAgdmFyIHJlZiA9IHBhcnNlU3RhdGVSZWYoYXR0cnMudWlTcmVmKTtcbiAgICAgICAgICAgICAgICByYXdEZWYudWlTdGF0ZSA9IHJlZi5zdGF0ZTtcbiAgICAgICAgICAgICAgICByYXdEZWYudWlTdGF0ZU9wdHMgPSBhdHRycy51aVNyZWZPcHRzID8gc2NvcGUuJGV2YWwoYXR0cnMudWlTcmVmT3B0cykgOiB7fTtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWYgPSBnZXREZWYoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVubGlua0luZm9GbilcbiAgICAgICAgICAgICAgICAgICAgICAgIHVubGlua0luZm9GbigpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aXZlKVxuICAgICAgICAgICAgICAgICAgICAgICAgdW5saW5rSW5mb0ZuID0gYWN0aXZlLiQkYWRkU3RhdGVJbmZvKGRlZi51aVN0YXRlLCBkZWYudWlTdGF0ZVBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWYuaHJlZiAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnMuJHNldCh0eXBlLmF0dHIsIGRlZi5ocmVmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlZi5wYXJhbUV4cHIpIHtcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUuJHdhdGNoKHJlZi5wYXJhbUV4cHIsIGZ1bmN0aW9uICh2YWwkJDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhd0RlZi51aVN0YXRlUGFyYW1zID0gY29yZS5leHRlbmQoe30sIHZhbCQkMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJhd0RlZi51aVN0YXRlUGFyYW1zID0gY29yZS5leHRlbmQoe30sIHNjb3BlLiRldmFsKHJlZi5wYXJhbUV4cHIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgc2NvcGUuJG9uKCckZGVzdHJveScsICR1aVJvdXRlci5zdGF0ZVJlZ2lzdHJ5Lm9uU3RhdGVzQ2hhbmdlZCh1cGRhdGUpKTtcbiAgICAgICAgICAgICAgICBzY29wZS4kb24oJyRkZXN0cm95JywgJHVpUm91dGVyLnRyYW5zaXRpb25TZXJ2aWNlLm9uU3VjY2Vzcyh7fSwgdXBkYXRlKSk7XG4gICAgICAgICAgICAgICAgaWYgKCF0eXBlLmNsaWNrYWJsZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGhvb2tGbiA9IGNsaWNrSG9vayhlbGVtZW50LCAkc3RhdGUsICR0aW1lb3V0LCB0eXBlLCBnZXREZWYpO1xuICAgICAgICAgICAgICAgIGJpbmRFdmVudHMoZWxlbWVudCwgc2NvcGUsIGhvb2tGbiwgcmF3RGVmLnVpU3RhdGVPcHRzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfV07XG4vKipcbiAqIGB1aS1zdGF0ZWA6IEEgZnVsbHkgZHluYW1pYyBkaXJlY3RpdmUgZm9yIGxpbmtpbmcgdG8gYSBzdGF0ZVxuICpcbiAqIEEgZGlyZWN0aXZlIHdoaWNoIGxpbmtzIHRvIGEgc3RhdGUgKGFuZCBvcHRpb25hbGx5LCBwYXJhbWV0ZXJzKS5cbiAqIFdoZW4gY2xpY2tlZCwgdGhpcyBkaXJlY3RpdmUgYWN0aXZhdGVzIHRoZSBsaW5rZWQgc3RhdGUgd2l0aCB0aGUgc3VwcGxpZWQgcGFyYW1ldGVyIHZhbHVlcy5cbiAqXG4gKiAqKlRoaXMgZGlyZWN0aXZlIGlzIHZlcnkgc2ltaWxhciB0byBbW3VpU3JlZl1dLCBidXQgaXQgYCRvYnNlcnZlYHMgYW5kIGAkd2F0Y2hgZXMvZXZhbHVhdGVzIGFsbCBpdHMgaW5wdXRzLioqXG4gKlxuICogQSBkaXJlY3RpdmUgd2hpY2ggbGlua3MgdG8gYSBzdGF0ZSAoYW5kIG9wdGlvbmFsbHksIHBhcmFtZXRlcnMpLlxuICogV2hlbiBjbGlja2VkLCB0aGlzIGRpcmVjdGl2ZSBhY3RpdmF0ZXMgdGhlIGxpbmtlZCBzdGF0ZSB3aXRoIHRoZSBzdXBwbGllZCBwYXJhbWV0ZXIgdmFsdWVzLlxuICpcbiAqICMjIyBMaW5rZWQgU3RhdGVcbiAqIFRoZSBhdHRyaWJ1dGUgdmFsdWUgb2YgYHVpLXN0YXRlYCBpcyBhbiBleHByZXNzaW9uIHdoaWNoIGlzIGAkd2F0Y2hgZWQgYW5kIGV2YWx1YXRlZCBhcyB0aGUgc3RhdGUgdG8gbGluayB0by5cbiAqICoqVGhpcyBpcyBpbiBjb250cmFzdCB3aXRoIGB1aS1zcmVmYCwgd2hpY2ggdGFrZXMgYSBzdGF0ZSBuYW1lIGFzIGEgc3RyaW5nIGxpdGVyYWwuKipcbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKiBDcmVhdGUgYSBsaXN0IG9mIGxpbmtzLlxuICogYGBgaHRtbFxuICogPGxpIG5nLXJlcGVhdD1cImxpbmsgaW4gbmF2bGlua3NcIj5cbiAqICAgPGEgdWktc3RhdGU9XCJsaW5rLnN0YXRlXCI+e3sgbGluay5kaXNwbGF5TmFtZSB9fTwvYT5cbiAqIDwvbGk+XG4gKiBgYGBcbiAqXG4gKiAjIyMgUmVsYXRpdmUgTGlua3NcbiAqIElmIHRoZSBleHByZXNzaW9uIGV2YWx1YXRlcyB0byBhIHJlbGF0aXZlIHBhdGgsIGl0IGlzIHByb2Nlc3NlZCBsaWtlIFtbdWlTcmVmXV0uXG4gKiBZb3UganVzdCBuZWVkIHRvIGJlIGF3YXJlIHRoYXQgdGhlIHBhdGggaXMgcmVsYXRpdmUgdG8gdGhlIHN0YXRlIHRoYXQgKmNyZWF0ZWQqIHRoZSBsaW5rLlxuICogVGhpcyBhbGxvd3MgYSBzdGF0ZSB0byBjcmVhdGUgcmVsYXRpdmUgYHVpLXN0YXRlYCB3aGljaCBhbHdheXMgdGFyZ2V0cyB0aGUgc2FtZSBkZXN0aW5hdGlvbi5cbiAqXG4gKiAjIyMgaHJlZnNcbiAqIElmIHRoZSBsaW5rZWQgc3RhdGUgaGFzIGEgVVJMLCB0aGUgZGlyZWN0aXZlIHdpbGwgYXV0b21hdGljYWxseSBnZW5lcmF0ZSBhbmRcbiAqIHVwZGF0ZSB0aGUgYGhyZWZgIGF0dHJpYnV0ZSAodXNpbmcgdGhlIFtbU3RhdGVTZXJ2aWNlLmhyZWZdXSAgbWV0aG9kKS5cbiAqXG4gKiAjIyMgUGFyYW1ldGVyIFZhbHVlc1xuICogSW4gYWRkaXRpb24gdG8gdGhlIHN0YXRlIG5hbWUgZXhwcmVzc2lvbiwgYSBgdWktc3RhdGVgIGNhbiBpbmNsdWRlIHBhcmFtZXRlciB2YWx1ZXMgd2hpY2ggYXJlIGFwcGxpZWQgd2hlbiBhY3RpdmF0aW5nIHRoZSBzdGF0ZS5cbiAqIFBhcmFtIHZhbHVlcyBzaG91bGQgYmUgcHJvdmlkZWQgdXNpbmcgdGhlIGB1aS1zdGF0ZS1wYXJhbXNgIGF0dHJpYnV0ZS5cbiAqIFRoZSBgdWktc3RhdGUtcGFyYW1zYCBhdHRyaWJ1dGUgdmFsdWUgaXMgYCR3YXRjaGBlZCBhbmQgZXZhbHVhdGVkIGFzIGFuIGV4cHJlc3Npb24uXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICogVGhpcyBleGFtcGxlIHJlbmRlcnMgYSBsaXN0IG9mIGxpbmtzIHdpdGggcGFyYW0gdmFsdWVzLlxuICogVGhlIHN0YXRlJ3MgYHVzZXJJZGAgcGFyYW1ldGVyIHZhbHVlIGNvbWVzIGZyb20gZWFjaCB1c2VyJ3MgYHVzZXIuaWRgIHByb3BlcnR5LlxuICogYGBgaHRtbFxuICogPGxpIG5nLXJlcGVhdD1cImxpbmsgaW4gbmF2bGlua3NcIj5cbiAqICAgPGEgdWktc3RhdGU9XCJsaW5rLnN0YXRlXCIgdWktc3RhdGUtcGFyYW1zPVwibGluay5wYXJhbXNcIj57eyBsaW5rLmRpc3BsYXlOYW1lIH19PC9hPlxuICogPC9saT5cbiAqIGBgYFxuICpcbiAqICMjIyBUcmFuc2l0aW9uIE9wdGlvbnNcbiAqIFlvdSBjYW4gc3BlY2lmeSBbW1RyYW5zaXRpb25PcHRpb25zXV0gdG8gcGFzcyB0byBbW1N0YXRlU2VydmljZS5nb11dIGJ5IHVzaW5nIHRoZSBgdWktc3RhdGUtb3B0c2AgYXR0cmlidXRlLlxuICogT3B0aW9ucyBhcmUgcmVzdHJpY3RlZCB0byBgbG9jYXRpb25gLCBgaW5oZXJpdGAsIGFuZCBgcmVsb2FkYC5cbiAqIFRoZSB2YWx1ZSBvZiB0aGUgYHVpLXN0YXRlLW9wdHNgIGlzIGAkd2F0Y2hgZWQgYW5kIGV2YWx1YXRlZCBhcyBhbiBleHByZXNzaW9uLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqIGBgYGh0bWxcbiAqIDxhIHVpLXN0YXRlPVwicmV0dXJudG8uc3RhdGVcIiB1aS1zdGF0ZS1vcHRzPVwieyByZWxvYWQ6IHRydWUgfVwiPkhvbWU8L2E+XG4gKiBgYGBcbiAqXG4gKiAjIyMgT3RoZXIgRE9NIEV2ZW50c1xuICpcbiAqIFlvdSBjYW4gYWxzbyBjdXN0b21pemUgd2hpY2ggRE9NIGV2ZW50cyB0byByZXNwb25kIHRvIChpbnN0ZWFkIG9mIGBjbGlja2ApIGJ5XG4gKiBwcm92aWRpbmcgYW4gYGV2ZW50c2AgYXJyYXkgaW4gdGhlIGB1aS1zdGF0ZS1vcHRzYCBhdHRyaWJ1dGUuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICogYGBgaHRtbFxuICogPGlucHV0IHR5cGU9XCJ0ZXh0XCIgdWktc3RhdGU9XCJjb250YWN0c1wiIHVpLXN0YXRlLW9wdHM9XCJ7IGV2ZW50czogWydjaGFuZ2UnLCAnYmx1ciddIH1cIj5cbiAqIGBgYFxuICpcbiAqICMjIyBIaWdobGlnaHRpbmcgdGhlIGFjdGl2ZSBsaW5rXG4gKiBUaGlzIGRpcmVjdGl2ZSBjYW4gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIFtbdWlTcmVmQWN0aXZlXV0gdG8gaGlnaGxpZ2h0IHRoZSBhY3RpdmUgbGluay5cbiAqXG4gKiAjIyMgTm90ZXNcbiAqXG4gKiAtIFlvdSBjYW4gdXNlIGB1aS1wYXJhbXNgIHRvIGNoYW5nZSAqKm9ubHkgdGhlIHBhcmFtZXRlciB2YWx1ZXMqKiBieSBvbWl0dGluZyB0aGUgc3RhdGUgbmFtZSBhbmQgc3VwcGx5aW5nIG9ubHkgYHVpLXN0YXRlLXBhcmFtc2AuXG4gKiAgIEhvd2V2ZXIsIGl0IG1pZ2h0IGJlIHNpbXBsZXIgdG8gdXNlIFtbdWlTcmVmXV0gcGFyYW1ldGVyLW9ubHkgbGlua3MuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICogU2V0cyB0aGUgYGxhbmdgIHBhcmFtZXRlciB0byBgZW5gIGFuZCByZW1haW5zIG9uIHRoZSBzYW1lIHN0YXRlLlxuICpcbiAqIGBgYGh0bWxcbiAqIDxhIHVpLXN0YXRlPVwiXCIgdWktc3RhdGUtcGFyYW1zPVwieyBsYW5nOiAnZW4nIH1cIj5FbmdsaXNoPC9hPlxuICogYGBgXG4gKlxuICogLSBBIG1pZGRsZS1jbGljaywgcmlnaHQtY2xpY2ssIG9yIGN0cmwtY2xpY2sgaXMgaGFuZGxlZCAobmF0aXZlbHkpIGJ5IHRoZSBicm93c2VyIHRvIG9wZW4gdGhlIGhyZWYgaW4gYSBuZXcgd2luZG93LCBmb3IgZXhhbXBsZS5cbiAqIGBgYFxuICovXG52YXIgdWlTdGF0ZURpcmVjdGl2ZTtcbnVpU3RhdGVEaXJlY3RpdmUgPSBbJyR1aVJvdXRlcicsICckdGltZW91dCcsXG4gICAgZnVuY3Rpb24gJFN0YXRlUmVmRHluYW1pY0RpcmVjdGl2ZSgkdWlSb3V0ZXIsICR0aW1lb3V0KSB7XG4gICAgICAgIHZhciAkc3RhdGUgPSAkdWlSb3V0ZXIuc3RhdGVTZXJ2aWNlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVzdHJpY3Q6ICdBJyxcbiAgICAgICAgICAgIHJlcXVpcmU6IFsnP151aVNyZWZBY3RpdmUnLCAnP151aVNyZWZBY3RpdmVFcSddLFxuICAgICAgICAgICAgbGluazogZnVuY3Rpb24gKHNjb3BlLCBlbGVtZW50LCBhdHRycywgdWlTcmVmQWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBnZXRUeXBlSW5mbyhlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB2YXIgYWN0aXZlID0gdWlTcmVmQWN0aXZlWzFdIHx8IHVpU3JlZkFjdGl2ZVswXTtcbiAgICAgICAgICAgICAgICB2YXIgdW5saW5rSW5mb0ZuID0gbnVsbDtcbiAgICAgICAgICAgICAgICB2YXIgaG9va0ZuO1xuICAgICAgICAgICAgICAgIHZhciByYXdEZWYgPSB7fTtcbiAgICAgICAgICAgICAgICB2YXIgZ2V0RGVmID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvY2Vzc2VkRGVmKCRzdGF0ZSwgZWxlbWVudCwgcmF3RGVmKTsgfTtcbiAgICAgICAgICAgICAgICB2YXIgaW5wdXRBdHRycyA9IFsndWlTdGF0ZScsICd1aVN0YXRlUGFyYW1zJywgJ3VpU3RhdGVPcHRzJ107XG4gICAgICAgICAgICAgICAgdmFyIHdhdGNoRGVyZWdGbnMgPSBpbnB1dEF0dHJzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBhdHRyKSB7IHJldHVybiAoYWNjW2F0dHJdID0gY29yZS5ub29wLCBhY2MpOyB9LCB7fSk7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVmID0gZ2V0RGVmKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1bmxpbmtJbmZvRm4pXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmxpbmtJbmZvRm4oKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjdGl2ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHVubGlua0luZm9GbiA9IGFjdGl2ZS4kJGFkZFN0YXRlSW5mbyhkZWYudWlTdGF0ZSwgZGVmLnVpU3RhdGVQYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVmLmhyZWYgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJzLiRzZXQodHlwZS5hdHRyLCBkZWYuaHJlZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlucHV0QXR0cnMuZm9yRWFjaChmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmF3RGVmW2ZpZWxkXSA9IGF0dHJzW2ZpZWxkXSA/IHNjb3BlLiRldmFsKGF0dHJzW2ZpZWxkXSkgOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICBhdHRycy4kb2JzZXJ2ZShmaWVsZCwgZnVuY3Rpb24gKGV4cHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhdGNoRGVyZWdGbnNbZmllbGRdKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YXRjaERlcmVnRm5zW2ZpZWxkXSA9IHNjb3BlLiR3YXRjaChleHByLCBmdW5jdGlvbiAobmV3dmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmF3RGVmW2ZpZWxkXSA9IG5ld3ZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB1cGRhdGUoKTtcbiAgICAgICAgICAgICAgICBzY29wZS4kb24oJyRkZXN0cm95JywgJHVpUm91dGVyLnN0YXRlUmVnaXN0cnkub25TdGF0ZXNDaGFuZ2VkKHVwZGF0ZSkpO1xuICAgICAgICAgICAgICAgIHNjb3BlLiRvbignJGRlc3Ryb3knLCAkdWlSb3V0ZXIudHJhbnNpdGlvblNlcnZpY2Uub25TdWNjZXNzKHt9LCB1cGRhdGUpKTtcbiAgICAgICAgICAgICAgICBpZiAoIXR5cGUuY2xpY2thYmxlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgaG9va0ZuID0gY2xpY2tIb29rKGVsZW1lbnQsICRzdGF0ZSwgJHRpbWVvdXQsIHR5cGUsIGdldERlZik7XG4gICAgICAgICAgICAgICAgYmluZEV2ZW50cyhlbGVtZW50LCBzY29wZSwgaG9va0ZuLCByYXdEZWYudWlTdGF0ZU9wdHMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XTtcbi8qKlxuICogYHVpLXNyZWYtYWN0aXZlYCBhbmQgYHVpLXNyZWYtYWN0aXZlLWVxYDogQSBkaXJlY3RpdmUgdGhhdCBhZGRzIGEgQ1NTIGNsYXNzIHdoZW4gYSBgdWktc3JlZmAgaXMgYWN0aXZlXG4gKlxuICogQSBkaXJlY3RpdmUgd29ya2luZyBhbG9uZ3NpZGUgW1t1aVNyZWZdXSBhbmQgW1t1aVN0YXRlXV0gdG8gYWRkIGNsYXNzZXMgdG8gYW4gZWxlbWVudCB3aGVuIHRoZVxuICogcmVsYXRlZCBkaXJlY3RpdmUncyBzdGF0ZSBpcyBhY3RpdmUgKGFuZCByZW1vdmUgdGhlbSB3aGVuIGl0IGlzIGluYWN0aXZlKS5cbiAqXG4gKiBUaGUgcHJpbWFyeSB1c2UtY2FzZSBpcyB0byBoaWdobGlnaHQgdGhlIGFjdGl2ZSBsaW5rIGluIG5hdmlnYXRpb24gbWVudXMsXG4gKiBkaXN0aW5ndWlzaGluZyBpdCBmcm9tIHRoZSBpbmFjdGl2ZSBtZW51IGl0ZW1zLlxuICpcbiAqICMjIyBMaW5raW5nIHRvIGEgYHVpLXNyZWZgIG9yIGB1aS1zdGF0ZWBcbiAqIGB1aS1zcmVmLWFjdGl2ZWAgY2FuIGxpdmUgb24gdGhlIHNhbWUgZWxlbWVudCBhcyBgdWktc3JlZmAvYHVpLXN0YXRlYCwgb3IgaXQgY2FuIGJlIG9uIGEgcGFyZW50IGVsZW1lbnQuXG4gKiBJZiBhIGB1aS1zcmVmLWFjdGl2ZWAgaXMgYSBwYXJlbnQgdG8gbW9yZSB0aGFuIG9uZSBgdWktc3JlZmAvYHVpLXN0YXRlYCwgaXQgd2lsbCBhcHBseSB0aGUgQ1NTIGNsYXNzIHdoZW4gKiphbnkgb2YgdGhlIGxpbmtzIGFyZSBhY3RpdmUqKi5cbiAqXG4gKiAjIyMgTWF0Y2hpbmdcbiAqXG4gKiBUaGUgYHVpLXNyZWYtYWN0aXZlYCBkaXJlY3RpdmUgYXBwbGllcyB0aGUgQ1NTIGNsYXNzIHdoZW4gdGhlIGB1aS1zcmVmYC9gdWktc3RhdGVgJ3MgdGFyZ2V0IHN0YXRlICoqb3IgYW55IGNoaWxkIHN0YXRlIGlzIGFjdGl2ZSoqLlxuICogVGhpcyBpcyBhIFwiZnV6enkgbWF0Y2hcIiB3aGljaCB1c2VzIFtbU3RhdGVTZXJ2aWNlLmluY2x1ZGVzXV0uXG4gKlxuICogVGhlIGB1aS1zcmVmLWFjdGl2ZS1lcWAgZGlyZWN0aXZlIGFwcGxpZXMgdGhlIENTUyBjbGFzcyB3aGVuIHRoZSBgdWktc3JlZmAvYHVpLXN0YXRlYCdzIHRhcmdldCBzdGF0ZSBpcyBkaXJlY3RseSBhY3RpdmUgKG5vdCB3aGVuIGNoaWxkIHN0YXRlcyBhcmUgYWN0aXZlKS5cbiAqIFRoaXMgaXMgYW4gXCJleGFjdCBtYXRjaFwiIHdoaWNoIHVzZXMgW1tTdGF0ZVNlcnZpY2UuaXNdXS5cbiAqXG4gKiAjIyMgUGFyYW1ldGVyIHZhbHVlc1xuICogSWYgdGhlIGB1aS1zcmVmYC9gdWktc3RhdGVgIGluY2x1ZGVzIHBhcmFtZXRlciB2YWx1ZXMsIHRoZSBjdXJyZW50IHBhcmFtZXRlciB2YWx1ZXMgbXVzdCBtYXRjaCB0aGUgbGluaydzIHZhbHVlcyBmb3IgdGhlIGxpbmsgdG8gYmUgaGlnaGxpZ2h0ZWQuXG4gKiBUaGlzIGFsbG93cyBhIGxpc3Qgb2YgbGlua3MgdG8gdGhlIHNhbWUgc3RhdGUgd2l0aCBkaWZmZXJlbnQgcGFyYW1ldGVycyB0byBiZSByZW5kZXJlZCwgYW5kIHRoZSBjb3JyZWN0IG9uZSBoaWdobGlnaHRlZC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKiBgYGBodG1sXG4gKiA8bGkgbmctcmVwZWF0PVwidXNlciBpbiB1c2Vyc1wiIHVpLXNyZWYtYWN0aXZlPVwiYWN0aXZlXCI+XG4gKiAgIDxhIHVpLXNyZWY9XCJ1c2VyLmRldGFpbHMoeyB1c2VySWQ6IHVzZXIuaWQgfSlcIj57eyB1c2VyLmxhc3ROYW1lIH19PC9hPlxuICogPC9saT5cbiAqIGBgYFxuICpcbiAqICMjIyBFeGFtcGxlc1xuICpcbiAqIEdpdmVuIHRoZSBmb2xsb3dpbmcgdGVtcGxhdGU6XG4gKiAjIyMjIEV4YW1wbGU6XG4gKiBgYGBodG1sXG4gKiA8dWw+XG4gKiAgIDxsaSB1aS1zcmVmLWFjdGl2ZT1cImFjdGl2ZVwiIGNsYXNzPVwiaXRlbVwiPlxuICogICAgIDxhIGhyZWYgdWktc3JlZj1cImFwcC51c2VyKHt1c2VyOiAnYmlsYm9iYWdnaW5zJ30pXCI+QGJpbGJvYmFnZ2luczwvYT5cbiAqICAgPC9saT5cbiAqIDwvdWw+XG4gKiBgYGBcbiAqXG4gKiBXaGVuIHRoZSBhcHAgc3RhdGUgaXMgYGFwcC51c2VyYCAob3IgYW55IGNoaWxkIHN0YXRlKSxcbiAqIGFuZCBjb250YWlucyB0aGUgc3RhdGUgcGFyYW1ldGVyIFwidXNlclwiIHdpdGggdmFsdWUgXCJiaWxib2JhZ2dpbnNcIixcbiAqIHRoZSByZXN1bHRpbmcgSFRNTCB3aWxsIGFwcGVhciBhcyAobm90ZSB0aGUgJ2FjdGl2ZScgY2xhc3MpOlxuICpcbiAqIGBgYGh0bWxcbiAqIDx1bD5cbiAqICAgPGxpIHVpLXNyZWYtYWN0aXZlPVwiYWN0aXZlXCIgY2xhc3M9XCJpdGVtIGFjdGl2ZVwiPlxuICogICAgIDxhIHVpLXNyZWY9XCJhcHAudXNlcih7dXNlcjogJ2JpbGJvYmFnZ2lucyd9KVwiIGhyZWY9XCIvdXNlcnMvYmlsYm9iYWdnaW5zXCI+QGJpbGJvYmFnZ2luczwvYT5cbiAqICAgPC9saT5cbiAqIDwvdWw+XG4gKiBgYGBcbiAqXG4gKiAjIyMgR2xvYiBtb2RlXG4gKlxuICogSXQgaXMgcG9zc2libGUgdG8gcGFzcyBgdWktc3JlZi1hY3RpdmVgIGFuIGV4cHJlc3Npb24gdGhhdCBldmFsdWF0ZXMgdG8gYW4gb2JqZWN0LlxuICogVGhlIG9iamVjdHMga2V5cyByZXByZXNlbnQgYWN0aXZlIGNsYXNzIG5hbWVzIGFuZCB2YWx1ZXMgcmVwcmVzZW50IHRoZSByZXNwZWN0aXZlIHN0YXRlIG5hbWVzL2dsb2JzLlxuICogYHVpLXNyZWYtYWN0aXZlYCB3aWxsIG1hdGNoIGlmIHRoZSBjdXJyZW50IGFjdGl2ZSBzdGF0ZSAqKmluY2x1ZGVzKiogYW55IG9mXG4gKiB0aGUgc3BlY2lmaWVkIHN0YXRlIG5hbWVzL2dsb2JzLCBldmVuIHRoZSBhYnN0cmFjdCBvbmVzLlxuICpcbiAqICMjIyMgRXhhbXBsZTpcbiAqIEdpdmVuIHRoZSBmb2xsb3dpbmcgdGVtcGxhdGUsIHdpdGggXCJhZG1pblwiIGJlaW5nIGFuIGFic3RyYWN0IHN0YXRlOlxuICogYGBgaHRtbFxuICogPGRpdiB1aS1zcmVmLWFjdGl2ZT1cInsnYWN0aXZlJzogJ2FkbWluLioqJ31cIj5cbiAqICAgPGEgdWktc3JlZi1hY3RpdmU9XCJhY3RpdmVcIiB1aS1zcmVmPVwiYWRtaW4ucm9sZXNcIj5Sb2xlczwvYT5cbiAqIDwvZGl2PlxuICogYGBgXG4gKlxuICogV2hlbiB0aGUgY3VycmVudCBzdGF0ZSBpcyBcImFkbWluLnJvbGVzXCIgdGhlIFwiYWN0aXZlXCIgY2xhc3Mgd2lsbCBiZSBhcHBsaWVkIHRvIGJvdGggdGhlIGA8ZGl2PmAgYW5kIGA8YT5gIGVsZW1lbnRzLlxuICogSXQgaXMgaW1wb3J0YW50IHRvIG5vdGUgdGhhdCB0aGUgc3RhdGUgbmFtZXMvZ2xvYnMgcGFzc2VkIHRvIGB1aS1zcmVmLWFjdGl2ZWAgb3ZlcnJpZGUgYW55IHN0YXRlIHByb3ZpZGVkIGJ5IGEgbGlua2VkIGB1aS1zcmVmYC5cbiAqXG4gKiAjIyMgTm90ZXM6XG4gKlxuICogLSBUaGUgY2xhc3MgbmFtZSBpcyBpbnRlcnBvbGF0ZWQgKipvbmNlKiogZHVyaW5nIHRoZSBkaXJlY3RpdmVzIGxpbmsgdGltZSAoYW55IGZ1cnRoZXIgY2hhbmdlcyB0byB0aGVcbiAqIGludGVycG9sYXRlZCB2YWx1ZSBhcmUgaWdub3JlZCkuXG4gKlxuICogLSBNdWx0aXBsZSBjbGFzc2VzIG1heSBiZSBzcGVjaWZpZWQgaW4gYSBzcGFjZS1zZXBhcmF0ZWQgZm9ybWF0OiBgdWktc3JlZi1hY3RpdmU9J2NsYXNzMSBjbGFzczIgY2xhc3MzJ2BcbiAqL1xudmFyIHVpU3JlZkFjdGl2ZURpcmVjdGl2ZTtcbnVpU3JlZkFjdGl2ZURpcmVjdGl2ZSA9IFsnJHN0YXRlJywgJyRzdGF0ZVBhcmFtcycsICckaW50ZXJwb2xhdGUnLCAnJHVpUm91dGVyJyxcbiAgICBmdW5jdGlvbiAkU3RhdGVSZWZBY3RpdmVEaXJlY3RpdmUoJHN0YXRlLCAkc3RhdGVQYXJhbXMsICRpbnRlcnBvbGF0ZSwgJHVpUm91dGVyKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZXN0cmljdDogJ0EnLFxuICAgICAgICAgICAgY29udHJvbGxlcjogWyckc2NvcGUnLCAnJGVsZW1lbnQnLCAnJGF0dHJzJyxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoJHNjb3BlLCAkZWxlbWVudCwgJGF0dHJzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGF0ZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFjdGl2ZUVxQ2xhc3M7XG4gICAgICAgICAgICAgICAgICAgIHZhciB1aVNyZWZBY3RpdmU7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXJlIHByb2JhYmx5IGlzbid0IG11Y2ggcG9pbnQgaW4gJG9ic2VydmluZyB0aGlzXG4gICAgICAgICAgICAgICAgICAgIC8vIHVpU3JlZkFjdGl2ZSBhbmQgdWlTcmVmQWN0aXZlRXEgc2hhcmUgdGhlIHNhbWUgZGlyZWN0aXZlIG9iamVjdCB3aXRoIHNvbWVcbiAgICAgICAgICAgICAgICAgICAgLy8gc2xpZ2h0IGRpZmZlcmVuY2UgaW4gbG9naWMgcm91dGluZ1xuICAgICAgICAgICAgICAgICAgICBhY3RpdmVFcUNsYXNzID0gJGludGVycG9sYXRlKCRhdHRycy51aVNyZWZBY3RpdmVFcSB8fCAnJywgZmFsc2UpKCRzY29wZSk7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1aVNyZWZBY3RpdmUgPSAkc2NvcGUuJGV2YWwoJGF0dHJzLnVpU3JlZkFjdGl2ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvIG5vdGhpbmcuIHVpU3JlZkFjdGl2ZSBpcyBub3QgYSB2YWxpZCBleHByZXNzaW9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmFsbCBiYWNrIHRvIHVzaW5nICRpbnRlcnBvbGF0ZSBiZWxvd1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHVpU3JlZkFjdGl2ZSA9IHVpU3JlZkFjdGl2ZSB8fCAkaW50ZXJwb2xhdGUoJGF0dHJzLnVpU3JlZkFjdGl2ZSB8fCAnJywgZmFsc2UpKCRzY29wZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3JlLmlzT2JqZWN0KHVpU3JlZkFjdGl2ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcmUuZm9yRWFjaCh1aVNyZWZBY3RpdmUsIGZ1bmN0aW9uIChzdGF0ZU9yTmFtZSwgYWN0aXZlQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29yZS5pc1N0cmluZyhzdGF0ZU9yTmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlZiA9IHBhcnNlU3RhdGVSZWYoc3RhdGVPck5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRTdGF0ZShyZWYuc3RhdGUsICRzY29wZS4kZXZhbChyZWYucGFyYW1FeHByKSwgYWN0aXZlQ2xhc3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEFsbG93IHVpU3JlZiB0byBjb21tdW5pY2F0ZSB3aXRoIHVpU3JlZkFjdGl2ZVtFcXVhbHNdXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJCRhZGRTdGF0ZUluZm8gPSBmdW5jdGlvbiAobmV3U3RhdGUsIG5ld1BhcmFtcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgYWxyZWFkeSBnb3QgYW4gZXhwbGljaXQgc3RhdGUgcHJvdmlkZWQgYnkgdWktc3JlZi1hY3RpdmUsIHNvIHdlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzaGFkb3cgdGhlIG9uZSB0aGF0IGNvbWVzIGZyb20gdWktc3JlZlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvcmUuaXNPYmplY3QodWlTcmVmQWN0aXZlKSAmJiBzdGF0ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZXJlZ2lzdGVyID0gYWRkU3RhdGUobmV3U3RhdGUsIG5ld1BhcmFtcywgdWlTcmVmQWN0aXZlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlcmVnaXN0ZXI7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZUFmdGVyVHJhbnNpdGlvbih0cmFucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnMucHJvbWlzZS50aGVuKHVwZGF0ZSwgY29yZS5ub29wKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAkc2NvcGUuJG9uKCckc3RhdGVDaGFuZ2VTdWNjZXNzJywgdXBkYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgJHNjb3BlLiRvbignJGRlc3Ryb3knLCAkdWlSb3V0ZXIudHJhbnNpdGlvblNlcnZpY2Uub25TdGFydCh7fSwgdXBkYXRlQWZ0ZXJUcmFuc2l0aW9uKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICgkdWlSb3V0ZXIuZ2xvYmFscy50cmFuc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVBZnRlclRyYW5zaXRpb24oJHVpUm91dGVyLmdsb2JhbHMudHJhbnNpdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gYWRkU3RhdGUoc3RhdGVOYW1lLCBzdGF0ZVBhcmFtcywgYWN0aXZlQ2xhc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGF0ZSA9ICRzdGF0ZS5nZXQoc3RhdGVOYW1lLCBzdGF0ZUNvbnRleHQoJGVsZW1lbnQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGF0ZUluZm8gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGU6IHN0YXRlIHx8IHsgbmFtZTogc3RhdGVOYW1lIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBzdGF0ZVBhcmFtcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmVDbGFzczogYWN0aXZlQ2xhc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGVzLnB1c2goc3RhdGVJbmZvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiByZW1vdmVTdGF0ZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3JlLnJlbW92ZUZyb20oc3RhdGVzKShzdGF0ZUluZm8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgcm91dGUgc3RhdGVcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNwbGl0Q2xhc3NlcyA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyLnNwbGl0KC9cXHMvKS5maWx0ZXIoY29yZS5pZGVudGl0eSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdldENsYXNzZXMgPSBmdW5jdGlvbiAoc3RhdGVMaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlTGlzdC5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHguYWN0aXZlQ2xhc3M7IH0pLm1hcChzcGxpdENsYXNzZXMpLnJlZHVjZShjb3JlLnVubmVzdFIsIFtdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWxsQ2xhc3NlcyA9IGdldENsYXNzZXMoc3RhdGVzKS5jb25jYXQoc3BsaXRDbGFzc2VzKGFjdGl2ZUVxQ2xhc3MpKS5yZWR1Y2UoY29yZS51bmlxUiwgW10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZ1enp5Q2xhc3NlcyA9IGdldENsYXNzZXMoc3RhdGVzLmZpbHRlcihmdW5jdGlvbiAoeCkgeyByZXR1cm4gJHN0YXRlLmluY2x1ZGVzKHguc3RhdGUubmFtZSwgeC5wYXJhbXMpOyB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXhhY3RseU1hdGNoZXNBbnkgPSAhIXN0YXRlcy5maWx0ZXIoZnVuY3Rpb24gKHgpIHsgcmV0dXJuICRzdGF0ZS5pcyh4LnN0YXRlLm5hbWUsIHgucGFyYW1zKTsgfSkubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV4YWN0Q2xhc3NlcyA9IGV4YWN0bHlNYXRjaGVzQW55ID8gc3BsaXRDbGFzc2VzKGFjdGl2ZUVxQ2xhc3MpIDogW107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWRkQ2xhc3NlcyA9IGZ1enp5Q2xhc3Nlcy5jb25jYXQoZXhhY3RDbGFzc2VzKS5yZWR1Y2UoY29yZS51bmlxUiwgW10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlbW92ZUNsYXNzZXMgPSBhbGxDbGFzc2VzLmZpbHRlcihmdW5jdGlvbiAoY2xzKSB7IHJldHVybiAhY29yZS5pbkFycmF5KGFkZENsYXNzZXMsIGNscyk7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgJHNjb3BlLiRldmFsQXN5bmMoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZENsYXNzZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xhc3NOYW1lKSB7IHJldHVybiAkZWxlbWVudC5hZGRDbGFzcyhjbGFzc05hbWUpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVDbGFzc2VzLmZvckVhY2goZnVuY3Rpb24gKGNsYXNzTmFtZSkgeyByZXR1cm4gJGVsZW1lbnQucmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB1cGRhdGUoKTtcbiAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgfTtcbiAgICB9XTtcbm5nLm1vZHVsZSgndWkucm91dGVyLnN0YXRlJylcbiAgICAuZGlyZWN0aXZlKCd1aVNyZWYnLCB1aVNyZWZEaXJlY3RpdmUpXG4gICAgLmRpcmVjdGl2ZSgndWlTcmVmQWN0aXZlJywgdWlTcmVmQWN0aXZlRGlyZWN0aXZlKVxuICAgIC5kaXJlY3RpdmUoJ3VpU3JlZkFjdGl2ZUVxJywgdWlTcmVmQWN0aXZlRGlyZWN0aXZlKVxuICAgIC5kaXJlY3RpdmUoJ3VpU3RhdGUnLCB1aVN0YXRlRGlyZWN0aXZlKTtcblxuLyoqIEBtb2R1bGUgbmcxICovIC8qKiBmb3IgdHlwZWRvYyAqL1xuLyoqXG4gKiBgaXNTdGF0ZWAgRmlsdGVyOiB0cnV0aHkgaWYgdGhlIGN1cnJlbnQgc3RhdGUgaXMgdGhlIHBhcmFtZXRlclxuICpcbiAqIFRyYW5zbGF0ZXMgdG8gW1tTdGF0ZVNlcnZpY2UuaXNdXSBgJHN0YXRlLmlzKFwic3RhdGVOYW1lXCIpYC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKiBgYGBodG1sXG4gKiA8ZGl2IG5nLWlmPVwiJ3N0YXRlTmFtZScgfCBpc1N0YXRlXCI+c2hvdyBpZiBzdGF0ZSBpcyAnc3RhdGVOYW1lJzwvZGl2PlxuICogYGBgXG4gKi9cbiRJc1N0YXRlRmlsdGVyLiRpbmplY3QgPSBbJyRzdGF0ZSddO1xuZnVuY3Rpb24gJElzU3RhdGVGaWx0ZXIoJHN0YXRlKSB7XG4gICAgdmFyIGlzRmlsdGVyID0gZnVuY3Rpb24gKHN0YXRlLCBwYXJhbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICRzdGF0ZS5pcyhzdGF0ZSwgcGFyYW1zLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIGlzRmlsdGVyLiRzdGF0ZWZ1bCA9IHRydWU7XG4gICAgcmV0dXJuIGlzRmlsdGVyO1xufVxuLyoqXG4gKiBgaW5jbHVkZWRCeVN0YXRlYCBGaWx0ZXI6IHRydXRoeSBpZiB0aGUgY3VycmVudCBzdGF0ZSBpbmNsdWRlcyB0aGUgcGFyYW1ldGVyXG4gKlxuICogVHJhbnNsYXRlcyB0byBbW1N0YXRlU2VydmljZS5pbmNsdWRlc11dYCAkc3RhdGUuaXMoXCJmdWxsT3JQYXJ0aWFsU3RhdGVOYW1lXCIpYC5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKiBgYGBodG1sXG4gKiA8ZGl2IG5nLWlmPVwiJ2Z1bGxPclBhcnRpYWxTdGF0ZU5hbWUnIHwgaW5jbHVkZWRCeVN0YXRlXCI+c2hvdyBpZiBzdGF0ZSBpbmNsdWRlcyAnZnVsbE9yUGFydGlhbFN0YXRlTmFtZSc8L2Rpdj5cbiAqIGBgYFxuICovXG4kSW5jbHVkZWRCeVN0YXRlRmlsdGVyLiRpbmplY3QgPSBbJyRzdGF0ZSddO1xuZnVuY3Rpb24gJEluY2x1ZGVkQnlTdGF0ZUZpbHRlcigkc3RhdGUpIHtcbiAgICB2YXIgaW5jbHVkZXNGaWx0ZXIgPSBmdW5jdGlvbiAoc3RhdGUsIHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gJHN0YXRlLmluY2x1ZGVzKHN0YXRlLCBwYXJhbXMsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgaW5jbHVkZXNGaWx0ZXIuJHN0YXRlZnVsID0gdHJ1ZTtcbiAgICByZXR1cm4gaW5jbHVkZXNGaWx0ZXI7XG59XG5uZy5tb2R1bGUoJ3VpLnJvdXRlci5zdGF0ZScpXG4gICAgLmZpbHRlcignaXNTdGF0ZScsICRJc1N0YXRlRmlsdGVyKVxuICAgIC5maWx0ZXIoJ2luY2x1ZGVkQnlTdGF0ZScsICRJbmNsdWRlZEJ5U3RhdGVGaWx0ZXIpO1xuXG4vKipcbiAqIEBuZzFhcGlcbiAqIEBtb2R1bGUgZGlyZWN0aXZlc1xuICovIC8qKiBmb3IgdHlwZWRvYyAqL1xuLyoqXG4gKiBgdWktdmlld2A6IEEgdmlld3BvcnQgZGlyZWN0aXZlIHdoaWNoIGlzIGZpbGxlZCBpbiBieSBhIHZpZXcgZnJvbSB0aGUgYWN0aXZlIHN0YXRlLlxuICpcbiAqICMjIyBBdHRyaWJ1dGVzXG4gKlxuICogLSBgbmFtZWA6IChPcHRpb25hbCkgQSB2aWV3IG5hbWUuXG4gKiAgIFRoZSBuYW1lIHNob3VsZCBiZSB1bmlxdWUgYW1vbmdzdCB0aGUgb3RoZXIgdmlld3MgaW4gdGhlIHNhbWUgc3RhdGUuXG4gKiAgIFlvdSBjYW4gaGF2ZSB2aWV3cyBvZiB0aGUgc2FtZSBuYW1lIHRoYXQgbGl2ZSBpbiBkaWZmZXJlbnQgc3RhdGVzLlxuICogICBUaGUgdWktdmlldyBjYW4gYmUgdGFyZ2V0ZWQgaW4gYSBWaWV3IHVzaW5nIHRoZSBuYW1lIChbW05nMVN0YXRlRGVjbGFyYXRpb24udmlld3NdXSkuXG4gKlxuICogLSBgYXV0b3Njcm9sbGA6IGFuIGV4cHJlc3Npb24uIFdoZW4gaXQgZXZhbHVhdGVzIHRvIHRydWUsIHRoZSBgdWktdmlld2Agd2lsbCBiZSBzY3JvbGxlZCBpbnRvIHZpZXcgd2hlbiBpdCBpcyBhY3RpdmF0ZWQuXG4gKiAgIFVzZXMgW1skdWlWaWV3U2Nyb2xsXV0gdG8gZG8gdGhlIHNjcm9sbGluZy5cbiAqXG4gKiAtIGBvbmxvYWRgOiBFeHByZXNzaW9uIHRvIGV2YWx1YXRlIHdoZW5ldmVyIHRoZSB2aWV3IHVwZGF0ZXMuXG4gKlxuICogIyMjIyBFeGFtcGxlOlxuICogQSB2aWV3IGNhbiBiZSB1bm5hbWVkIG9yIG5hbWVkLlxuICogYGBgaHRtbFxuICogPCEtLSBVbm5hbWVkIC0tPlxuICogPGRpdiB1aS12aWV3PjwvZGl2PlxuICpcbiAqIDwhLS0gTmFtZWQgLS0+XG4gKiA8ZGl2IHVpLXZpZXc9XCJ2aWV3TmFtZVwiPjwvZGl2PlxuICpcbiAqIDwhLS0gTmFtZWQgKGRpZmZlcmVudCBzdHlsZSkgLS0+XG4gKiA8dWktdmlldyBuYW1lPVwidmlld05hbWVcIj48L3VpLXZpZXc+XG4gKiBgYGBcbiAqXG4gKiBZb3UgY2FuIG9ubHkgaGF2ZSBvbmUgdW5uYW1lZCB2aWV3IHdpdGhpbiBhbnkgdGVtcGxhdGUgKG9yIHJvb3QgaHRtbCkuIElmIHlvdSBhcmUgb25seSB1c2luZyBhXG4gKiBzaW5nbGUgdmlldyBhbmQgaXQgaXMgdW5uYW1lZCB0aGVuIHlvdSBjYW4gcG9wdWxhdGUgaXQgbGlrZSBzbzpcbiAqXG4gKiBgYGBodG1sXG4gKiA8ZGl2IHVpLXZpZXc+PC9kaXY+XG4gKiAkc3RhdGVQcm92aWRlci5zdGF0ZShcImhvbWVcIiwge1xuICogICB0ZW1wbGF0ZTogXCI8aDE+SEVMTE8hPC9oMT5cIlxuICogfSlcbiAqIGBgYFxuICpcbiAqIFRoZSBhYm92ZSBpcyBhIGNvbnZlbmllbnQgc2hvcnRjdXQgZXF1aXZhbGVudCB0byBzcGVjaWZ5aW5nIHlvdXIgdmlldyBleHBsaWNpdGx5IHdpdGggdGhlXG4gKiBbW05nMVN0YXRlRGVjbGFyYXRpb24udmlld3NdXSBjb25maWcgcHJvcGVydHksIGJ5IG5hbWUsIGluIHRoaXMgY2FzZSBhbiBlbXB0eSBuYW1lOlxuICpcbiAqIGBgYGpzXG4gKiAkc3RhdGVQcm92aWRlci5zdGF0ZShcImhvbWVcIiwge1xuICogICB2aWV3czoge1xuICogICAgIFwiXCI6IHtcbiAqICAgICAgIHRlbXBsYXRlOiBcIjxoMT5IRUxMTyE8L2gxPlwiXG4gKiAgICAgfVxuICogICB9XG4gKiB9KVxuICogYGBgXG4gKlxuICogQnV0IHR5cGljYWxseSB5b3UnbGwgb25seSB1c2UgdGhlIHZpZXdzIHByb3BlcnR5IGlmIHlvdSBuYW1lIHlvdXIgdmlldyBvciBoYXZlIG1vcmUgdGhhbiBvbmUgdmlld1xuICogaW4gdGhlIHNhbWUgdGVtcGxhdGUuIFRoZXJlJ3Mgbm90IHJlYWxseSBhIGNvbXBlbGxpbmcgcmVhc29uIHRvIG5hbWUgYSB2aWV3IGlmIGl0cyB0aGUgb25seSBvbmUsXG4gKiBidXQgeW91IGNvdWxkIGlmIHlvdSB3YW50ZWQsIGxpa2Ugc286XG4gKlxuICogYGBgaHRtbFxuICogPGRpdiB1aS12aWV3PVwibWFpblwiPjwvZGl2PlxuICogYGBgXG4gKlxuICogYGBganNcbiAqICRzdGF0ZVByb3ZpZGVyLnN0YXRlKFwiaG9tZVwiLCB7XG4gKiAgIHZpZXdzOiB7XG4gKiAgICAgXCJtYWluXCI6IHtcbiAqICAgICAgIHRlbXBsYXRlOiBcIjxoMT5IRUxMTyE8L2gxPlwiXG4gKiAgICAgfVxuICogICB9XG4gKiB9KVxuICogYGBgXG4gKlxuICogUmVhbGx5IHRob3VnaCwgeW91J2xsIHVzZSB2aWV3cyB0byBzZXQgdXAgbXVsdGlwbGUgdmlld3M6XG4gKlxuICogYGBgaHRtbFxuICogPGRpdiB1aS12aWV3PjwvZGl2PlxuICogPGRpdiB1aS12aWV3PVwiY2hhcnRcIj48L2Rpdj5cbiAqIDxkaXYgdWktdmlldz1cImRhdGFcIj48L2Rpdj5cbiAqIGBgYFxuICpcbiAqIGBgYGpzXG4gKiAkc3RhdGVQcm92aWRlci5zdGF0ZShcImhvbWVcIiwge1xuICogICB2aWV3czoge1xuICogICAgIFwiXCI6IHtcbiAqICAgICAgIHRlbXBsYXRlOiBcIjxoMT5IRUxMTyE8L2gxPlwiXG4gKiAgICAgfSxcbiAqICAgICBcImNoYXJ0XCI6IHtcbiAqICAgICAgIHRlbXBsYXRlOiBcIjxjaGFydF90aGluZy8+XCJcbiAqICAgICB9LFxuICogICAgIFwiZGF0YVwiOiB7XG4gKiAgICAgICB0ZW1wbGF0ZTogXCI8ZGF0YV90aGluZy8+XCJcbiAqICAgICB9XG4gKiAgIH1cbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiAjIyMjIEV4YW1wbGVzIGZvciBgYXV0b3Njcm9sbGA6XG4gKiBgYGBodG1sXG4gKiA8IS0tIElmIGF1dG9zY3JvbGwgcHJlc2VudCB3aXRoIG5vIGV4cHJlc3Npb24sXG4gKiAgICAgIHRoZW4gc2Nyb2xsIHVpLXZpZXcgaW50byB2aWV3IC0tPlxuICogPHVpLXZpZXcgYXV0b3Njcm9sbC8+XG4gKlxuICogPCEtLSBJZiBhdXRvc2Nyb2xsIHByZXNlbnQgd2l0aCB2YWxpZCBleHByZXNzaW9uLFxuICogICAgICB0aGVuIHNjcm9sbCB1aS12aWV3IGludG8gdmlldyBpZiBleHByZXNzaW9uIGV2YWx1YXRlcyB0byB0cnVlIC0tPlxuICogPHVpLXZpZXcgYXV0b3Njcm9sbD0ndHJ1ZScvPlxuICogPHVpLXZpZXcgYXV0b3Njcm9sbD0nZmFsc2UnLz5cbiAqIDx1aS12aWV3IGF1dG9zY3JvbGw9J3Njb3BlVmFyaWFibGUnLz5cbiAqIGBgYFxuICpcbiAqIFJlc29sdmUgZGF0YTpcbiAqXG4gKiBUaGUgcmVzb2x2ZWQgZGF0YSBmcm9tIHRoZSBzdGF0ZSdzIGByZXNvbHZlYCBibG9jayBpcyBwbGFjZWQgb24gdGhlIHNjb3BlIGFzIGAkcmVzb2x2ZWAgKHRoaXNcbiAqIGNhbiBiZSBjdXN0b21pemVkIHVzaW5nIFtbTmcxVmlld0RlY2xhcmF0aW9uLnJlc29sdmVBc11dKS4gIFRoaXMgY2FuIGJlIHRoZW4gYWNjZXNzZWQgZnJvbSB0aGUgdGVtcGxhdGUuXG4gKlxuICogTm90ZSB0aGF0IHdoZW4gYGNvbnRyb2xsZXJBc2AgaXMgYmVpbmcgdXNlZCwgYCRyZXNvbHZlYCBpcyBzZXQgb24gdGhlIGNvbnRyb2xsZXIgaW5zdGFuY2UgKmFmdGVyKiB0aGVcbiAqIGNvbnRyb2xsZXIgaXMgaW5zdGFudGlhdGVkLiAgVGhlIGAkb25Jbml0KClgIGhvb2sgY2FuIGJlIHVzZWQgdG8gcGVyZm9ybSBpbml0aWFsaXphdGlvbiBjb2RlIHdoaWNoXG4gKiBkZXBlbmRzIG9uIGAkcmVzb2x2ZWAgZGF0YS5cbiAqXG4gKiAjIyMjIEV4YW1wbGU6XG4gKiBgYGBqc1xuICogJHN0YXRlUHJvdmlkZXIuc3RhdGUoJ2hvbWUnLCB7XG4gKiAgIHRlbXBsYXRlOiAnPG15LWNvbXBvbmVudCB1c2VyPVwiJHJlc29sdmUudXNlclwiPjwvbXktY29tcG9uZW50PicsXG4gKiAgIHJlc29sdmU6IHtcbiAqICAgICB1c2VyOiBmdW5jdGlvbihVc2VyU2VydmljZSkgeyByZXR1cm4gVXNlclNlcnZpY2UuZmV0Y2hVc2VyKCk7IH1cbiAqICAgfVxuICogfSk7XG4gKiBgYGBcbiAqL1xudmFyIHVpVmlldztcbnVpVmlldyA9IFsnJHZpZXcnLCAnJGFuaW1hdGUnLCAnJHVpVmlld1Njcm9sbCcsICckaW50ZXJwb2xhdGUnLCAnJHEnLFxuICAgIGZ1bmN0aW9uICRWaWV3RGlyZWN0aXZlKCR2aWV3LCAkYW5pbWF0ZSwgJHVpVmlld1Njcm9sbCwgJGludGVycG9sYXRlLCAkcSkge1xuICAgICAgICBmdW5jdGlvbiBnZXRSZW5kZXJlcihhdHRycywgc2NvcGUpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZW50ZXI6IGZ1bmN0aW9uIChlbGVtZW50LCB0YXJnZXQsIGNiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZy52ZXJzaW9uLm1pbm9yID4gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgJGFuaW1hdGUuZW50ZXIoZWxlbWVudCwgbnVsbCwgdGFyZ2V0KS50aGVuKGNiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICRhbmltYXRlLmVudGVyKGVsZW1lbnQsIG51bGwsIHRhcmdldCwgY2IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBsZWF2ZTogZnVuY3Rpb24gKGVsZW1lbnQsIGNiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZy52ZXJzaW9uLm1pbm9yID4gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgJGFuaW1hdGUubGVhdmUoZWxlbWVudCkudGhlbihjYik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkYW5pbWF0ZS5sZWF2ZShlbGVtZW50LCBjYik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjb25maWdzRXF1YWwoY29uZmlnMSwgY29uZmlnMikge1xuICAgICAgICAgICAgcmV0dXJuIGNvbmZpZzEgPT09IGNvbmZpZzI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJvb3REYXRhID0ge1xuICAgICAgICAgICAgJGNmZzogeyB2aWV3RGVjbDogeyAkY29udGV4dDogJHZpZXcuX3BsdWdpbmFwaS5fcm9vdFZpZXdDb250ZXh0KCkgfSB9LFxuICAgICAgICAgICAgJHVpVmlldzoge30sXG4gICAgICAgIH07XG4gICAgICAgIHZhciBkaXJlY3RpdmUgPSB7XG4gICAgICAgICAgICBjb3VudDogMCxcbiAgICAgICAgICAgIHJlc3RyaWN0OiAnRUNBJyxcbiAgICAgICAgICAgIHRlcm1pbmFsOiB0cnVlLFxuICAgICAgICAgICAgcHJpb3JpdHk6IDQwMCxcbiAgICAgICAgICAgIHRyYW5zY2x1ZGU6ICdlbGVtZW50JyxcbiAgICAgICAgICAgIGNvbXBpbGU6IGZ1bmN0aW9uICh0RWxlbWVudCwgdEF0dHJzLCAkdHJhbnNjbHVkZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoc2NvcGUsICRlbGVtZW50LCBhdHRycykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb25sb2FkRXhwID0gYXR0cnNbJ29ubG9hZCddIHx8ICcnLCBhdXRvU2Nyb2xsRXhwID0gYXR0cnNbJ2F1dG9zY3JvbGwnXSwgcmVuZGVyZXIgPSBnZXRSZW5kZXJlcihhdHRycywgc2NvcGUpLCBpbmhlcml0ZWQgPSAkZWxlbWVudC5pbmhlcml0ZWREYXRhKCckdWlWaWV3JykgfHwgcm9vdERhdGEsIG5hbWUgPSAkaW50ZXJwb2xhdGUoYXR0cnNbJ3VpVmlldyddIHx8IGF0dHJzWyduYW1lJ10gfHwgJycpKHNjb3BlKSB8fCAnJGRlZmF1bHQnO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJldmlvdXNFbCwgY3VycmVudEVsLCBjdXJyZW50U2NvcGUsIHZpZXdDb25maWcsIHVucmVnaXN0ZXI7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhY3RpdmVVSVZpZXcgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkdHlwZTogJ25nMScsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogZGlyZWN0aXZlLmNvdW50KyssXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgZnFuOiBpbmhlcml0ZWQuJHVpVmlldy5mcW4gPyBpbmhlcml0ZWQuJHVpVmlldy5mcW4gKyAnLicgKyBuYW1lIDogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZzogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ1VwZGF0ZWQ6IGNvbmZpZ1VwZGF0ZWRDYWxsYmFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldCBjcmVhdGlvbkNvbnRleHQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZyb21QYXJlbnRUYWdDb25maWcgPSBjb3JlLnBhcnNlKCckY2ZnLnZpZXdEZWNsLiRjb250ZXh0JykoaW5oZXJpdGVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGxvdyA8dWktdmlldyBuYW1lPVwiZm9vXCI+PHVpLXZpZXcgbmFtZT1cImJhclwiPjwvdWktdmlldz48L3VpLXZpZXc+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyLXVpL3VpLXJvdXRlci9pc3N1ZXMvMzM1NVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmcm9tUGFyZW50VGFnID0gY29yZS5wYXJzZSgnJHVpVmlldy5jcmVhdGlvbkNvbnRleHQnKShpbmhlcml0ZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmcm9tUGFyZW50VGFnQ29uZmlnIHx8IGZyb21QYXJlbnRUYWc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjb3JlLnRyYWNlLnRyYWNlVUlWaWV3RXZlbnQoJ0xpbmtpbmcnLCBhY3RpdmVVSVZpZXcpO1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBjb25maWdVcGRhdGVkQ2FsbGJhY2soY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlnICYmICEoY29uZmlnIGluc3RhbmNlb2YgTmcxVmlld0NvbmZpZykpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbmZpZ3NFcXVhbCh2aWV3Q29uZmlnLCBjb25maWcpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcmUudHJhY2UudHJhY2VVSVZpZXdDb25maWdVcGRhdGVkKGFjdGl2ZVVJVmlldywgY29uZmlnICYmIGNvbmZpZy52aWV3RGVjbCAmJiBjb25maWcudmlld0RlY2wuJGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlld0NvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVZpZXcoY29uZmlnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAkZWxlbWVudC5kYXRhKCckdWlWaWV3JywgeyAkdWlWaWV3OiBhY3RpdmVVSVZpZXcgfSk7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVZpZXcoKTtcbiAgICAgICAgICAgICAgICAgICAgdW5yZWdpc3RlciA9ICR2aWV3LnJlZ2lzdGVyVUlWaWV3KGFjdGl2ZVVJVmlldyk7XG4gICAgICAgICAgICAgICAgICAgIHNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3JlLnRyYWNlLnRyYWNlVUlWaWV3RXZlbnQoJ0Rlc3Ryb3lpbmcvVW5yZWdpc3RlcmluZycsIGFjdGl2ZVVJVmlldyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB1bnJlZ2lzdGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiBjbGVhbnVwTGFzdFZpZXcoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNFbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcmUudHJhY2UudHJhY2VVSVZpZXdFdmVudCgnUmVtb3ZpbmcgKHByZXZpb3VzKSBlbCcsIHByZXZpb3VzRWwuZGF0YSgnJHVpVmlldycpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91c0VsLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzRWwgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRTY29wZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcmUudHJhY2UudHJhY2VVSVZpZXdFdmVudCgnRGVzdHJveWluZyBzY29wZScsIGFjdGl2ZVVJVmlldyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFNjb3BlLiRkZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFNjb3BlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50RWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3ZpZXdEYXRhXzEgPSBjdXJyZW50RWwuZGF0YSgnJHVpVmlld0FuaW0nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3JlLnRyYWNlLnRyYWNlVUlWaWV3RXZlbnQoJ0FuaW1hdGUgb3V0JywgX3ZpZXdEYXRhXzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlcmVyLmxlYXZlKGN1cnJlbnRFbCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdmlld0RhdGFfMS4kJGFuaW1MZWF2ZS5yZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzRWwgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzRWwgPSBjdXJyZW50RWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEVsID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiB1cGRhdGVWaWV3KGNvbmZpZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1Njb3BlID0gc2NvcGUuJG5ldygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFuaW1FbnRlciA9ICRxLmRlZmVyKCksIGFuaW1MZWF2ZSA9ICRxLmRlZmVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgJHVpVmlld0RhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJGNmZzogY29uZmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR1aVZpZXc6IGFjdGl2ZVVJVmlldyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgJHVpVmlld0FuaW0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJGFuaW1FbnRlcjogYW5pbUVudGVyLnByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJGFuaW1MZWF2ZTogYW5pbUxlYXZlLnByb21pc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJCRhbmltTGVhdmU6IGFuaW1MZWF2ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBuZ2RvYyBldmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICogQG5hbWUgdWkucm91dGVyLnN0YXRlLmRpcmVjdGl2ZTp1aS12aWV3IyR2aWV3Q29udGVudExvYWRpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBldmVudE9mIHVpLnJvdXRlci5zdGF0ZS5kaXJlY3RpdmU6dWktdmlld1xuICAgICAgICAgICAgICAgICAgICAgICAgICogQGV2ZW50VHlwZSBlbWl0cyBvbiB1aS12aWV3IGRpcmVjdGl2ZSBzY29wZVxuICAgICAgICAgICAgICAgICAgICAgICAgICogQGRlc2NyaXB0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogRmlyZWQgb25jZSB0aGUgdmlldyAqKmJlZ2lucyBsb2FkaW5nKiosICpiZWZvcmUqIHRoZSBET00gaXMgcmVuZGVyZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IEV2ZW50IG9iamVjdC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2aWV3TmFtZSBOYW1lIG9mIHRoZSB2aWV3LlxuICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdTY29wZS4kZW1pdCgnJHZpZXdDb250ZW50TG9hZGluZycsIG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNsb25lZCA9ICR0cmFuc2NsdWRlKG5ld1Njb3BlLCBmdW5jdGlvbiAoY2xvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9uZS5kYXRhKCckdWlWaWV3QW5pbScsICR1aVZpZXdBbmltKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9uZS5kYXRhKCckdWlWaWV3JywgJHVpVmlld0RhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlcmVyLmVudGVyKGNsb25lLCAkZWxlbWVudCwgZnVuY3Rpb24gb25VSVZpZXdFbnRlcigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbUVudGVyLnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRTY29wZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTY29wZS4kZW1pdCgnJHZpZXdDb250ZW50QW5pbWF0aW9uRW5kZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvcmUuaXNEZWZpbmVkKGF1dG9TY3JvbGxFeHApICYmICFhdXRvU2Nyb2xsRXhwIHx8IHNjb3BlLiRldmFsKGF1dG9TY3JvbGxFeHApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdWlWaWV3U2Nyb2xsKGNsb25lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFudXBMYXN0VmlldygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50RWwgPSBjbG9uZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2NvcGUgPSBuZXdTY29wZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogQG5nZG9jIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAbmFtZSB1aS5yb3V0ZXIuc3RhdGUuZGlyZWN0aXZlOnVpLXZpZXcjJHZpZXdDb250ZW50TG9hZGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBAZXZlbnRPZiB1aS5yb3V0ZXIuc3RhdGUuZGlyZWN0aXZlOnVpLXZpZXdcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBldmVudFR5cGUgZW1pdHMgb24gdWktdmlldyBkaXJlY3RpdmUgc2NvcGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIEBkZXNjcmlwdGlvbiAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogRmlyZWQgb25jZSB0aGUgdmlldyBpcyAqKmxvYWRlZCoqLCAqYWZ0ZXIqIHRoZSBET00gaXMgcmVuZGVyZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IEV2ZW50IG9iamVjdC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudFNjb3BlLiRlbWl0KCckdmlld0NvbnRlbnRMb2FkZWQnLCBjb25maWcgfHwgdmlld0NvbmZpZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50U2NvcGUuJGV2YWwob25sb2FkRXhwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZGlyZWN0aXZlO1xuICAgIH1dO1xuJFZpZXdEaXJlY3RpdmVGaWxsLiRpbmplY3QgPSBbJyRjb21waWxlJywgJyRjb250cm9sbGVyJywgJyR0cmFuc2l0aW9ucycsICckdmlldycsICckcScsICckdGltZW91dCddO1xuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uICRWaWV3RGlyZWN0aXZlRmlsbCgkY29tcGlsZSwgJGNvbnRyb2xsZXIsICR0cmFuc2l0aW9ucywgJHZpZXcsICRxLCAkdGltZW91dCkge1xuICAgIHZhciBnZXRDb250cm9sbGVyQXMgPSBjb3JlLnBhcnNlKCd2aWV3RGVjbC5jb250cm9sbGVyQXMnKTtcbiAgICB2YXIgZ2V0UmVzb2x2ZUFzID0gY29yZS5wYXJzZSgndmlld0RlY2wucmVzb2x2ZUFzJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVzdHJpY3Q6ICdFQ0EnLFxuICAgICAgICBwcmlvcml0eTogLTQwMCxcbiAgICAgICAgY29tcGlsZTogZnVuY3Rpb24gKHRFbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgaW5pdGlhbCA9IHRFbGVtZW50Lmh0bWwoKTtcbiAgICAgICAgICAgIHRFbGVtZW50LmVtcHR5KCk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHNjb3BlLCAkZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gJGVsZW1lbnQuZGF0YSgnJHVpVmlldycpO1xuICAgICAgICAgICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAkZWxlbWVudC5odG1sKGluaXRpYWwpO1xuICAgICAgICAgICAgICAgICAgICAkY29tcGlsZSgkZWxlbWVudC5jb250ZW50cygpKShzY29wZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGNmZyA9IGRhdGEuJGNmZyB8fCB7IHZpZXdEZWNsOiB7fSwgZ2V0VGVtcGxhdGU6IGNvcmUubm9vcCB9O1xuICAgICAgICAgICAgICAgIHZhciByZXNvbHZlQ3R4ID0gY2ZnLnBhdGggJiYgbmV3IGNvcmUuUmVzb2x2ZUNvbnRleHQoY2ZnLnBhdGgpO1xuICAgICAgICAgICAgICAgICRlbGVtZW50Lmh0bWwoY2ZnLmdldFRlbXBsYXRlKCRlbGVtZW50LCByZXNvbHZlQ3R4KSB8fCBpbml0aWFsKTtcbiAgICAgICAgICAgICAgICBjb3JlLnRyYWNlLnRyYWNlVUlWaWV3RmlsbChkYXRhLiR1aVZpZXcsICRlbGVtZW50Lmh0bWwoKSk7XG4gICAgICAgICAgICAgICAgdmFyIGxpbmsgPSAkY29tcGlsZSgkZWxlbWVudC5jb250ZW50cygpKTtcbiAgICAgICAgICAgICAgICB2YXIgY29udHJvbGxlciA9IGNmZy5jb250cm9sbGVyO1xuICAgICAgICAgICAgICAgIHZhciBjb250cm9sbGVyQXMgPSBnZXRDb250cm9sbGVyQXMoY2ZnKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVzb2x2ZUFzID0gZ2V0UmVzb2x2ZUFzKGNmZyk7XG4gICAgICAgICAgICAgICAgdmFyIGxvY2FscyA9IHJlc29sdmVDdHggJiYgZ2V0TG9jYWxzKHJlc29sdmVDdHgpO1xuICAgICAgICAgICAgICAgIHNjb3BlW3Jlc29sdmVBc10gPSBsb2NhbHM7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRyb2xsZXJJbnN0YW5jZSA9ICRjb250cm9sbGVyKGNvbnRyb2xsZXIsIGNvcmUuZXh0ZW5kKHt9LCBsb2NhbHMsIHsgJHNjb3BlOiBzY29wZSwgJGVsZW1lbnQ6ICRlbGVtZW50IH0pKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRyb2xsZXJBcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2NvcGVbY29udHJvbGxlckFzXSA9IGNvbnRyb2xsZXJJbnN0YW5jZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlW2NvbnRyb2xsZXJBc11bcmVzb2x2ZUFzXSA9IGxvY2FscztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBVc2UgJHZpZXcgc2VydmljZSBhcyBhIGNlbnRyYWwgcG9pbnQgZm9yIHJlZ2lzdGVyaW5nIGNvbXBvbmVudC1sZXZlbCBob29rc1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGVuLCB3aGVuIGEgY29tcG9uZW50IGlzIGNyZWF0ZWQsIHRlbGwgdGhlICR2aWV3IHNlcnZpY2UsIHNvIGl0IGNhbiBpbnZva2UgaG9va3NcbiAgICAgICAgICAgICAgICAgICAgLy8gJHZpZXcuY29tcG9uZW50TG9hZGVkKGNvbnRyb2xsZXJJbnN0YW5jZSwgeyAkc2NvcGU6IHNjb3BlLCAkZWxlbWVudDogJGVsZW1lbnQgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNjb3BlLiRvbignJGRlc3Ryb3knLCAoKSA9PiAkdmlldy5jb21wb25lbnRVbmxvYWRlZChjb250cm9sbGVySW5zdGFuY2UsIHsgJHNjb3BlOiBzY29wZSwgJGVsZW1lbnQ6ICRlbGVtZW50IH0pKTtcbiAgICAgICAgICAgICAgICAgICAgJGVsZW1lbnQuZGF0YSgnJG5nQ29udHJvbGxlckNvbnRyb2xsZXInLCBjb250cm9sbGVySW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgICAgICAkZWxlbWVudC5jaGlsZHJlbigpLmRhdGEoJyRuZ0NvbnRyb2xsZXJDb250cm9sbGVyJywgY29udHJvbGxlckluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgcmVnaXN0ZXJDb250cm9sbGVyQ2FsbGJhY2tzKCRxLCAkdHJhbnNpdGlvbnMsIGNvbnRyb2xsZXJJbnN0YW5jZSwgc2NvcGUsIGNmZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFdhaXQgZm9yIHRoZSBjb21wb25lbnQgdG8gYXBwZWFyIGluIHRoZSBET01cbiAgICAgICAgICAgICAgICBpZiAoY29yZS5pc1N0cmluZyhjZmcudmlld0RlY2wuY29tcG9uZW50KSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY21wXzEgPSBjZmcudmlld0RlY2wuY29tcG9uZW50O1xuICAgICAgICAgICAgICAgICAgICB2YXIga2Vib2JOYW1lID0gY29yZS5rZWJvYlN0cmluZyhjbXBfMSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0YWdSZWdleHBfMSA9IG5ldyBSZWdFeHAoXCJeKHgtfGRhdGEtKT9cIiArIGtlYm9iTmFtZSArIFwiJFwiLCAnaScpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZ2V0Q29tcG9uZW50Q29udHJvbGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkaXJlY3RpdmVFbCA9IFtdLnNsaWNlLmNhbGwoJGVsZW1lbnRbMF0uY2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoZWwpIHsgcmV0dXJuIGVsICYmIGVsLnRhZ05hbWUgJiYgdGFnUmVnZXhwXzEuZXhlYyhlbC50YWdOYW1lKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGlyZWN0aXZlRWwgJiYgbmcuZWxlbWVudChkaXJlY3RpdmVFbCkuZGF0YShcIiRcIiArIGNtcF8xICsgXCJDb250cm9sbGVyXCIpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGVyZWdpc3RlcldhdGNoXzEgPSBzY29wZS4kd2F0Y2goZ2V0Q29tcG9uZW50Q29udHJvbGxlciwgZnVuY3Rpb24gKGN0cmxJbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjdHJsSW5zdGFuY2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVnaXN0ZXJDb250cm9sbGVyQ2FsbGJhY2tzKCRxLCAkdHJhbnNpdGlvbnMsIGN0cmxJbnN0YW5jZSwgc2NvcGUsIGNmZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXJlZ2lzdGVyV2F0Y2hfMSgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGluayhzY29wZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgIH07XG59XG4vKiogQGhpZGRlbiAqL1xudmFyIGhhc0NvbXBvbmVudEltcGwgPSB0eXBlb2YgbmcubW9kdWxlKCd1aS5yb3V0ZXInKVsnY29tcG9uZW50J10gPT09ICdmdW5jdGlvbic7XG4vKiogQGhpZGRlbiBpbmNyZW1lbnRpbmcgaWQgKi9cbnZhciBfdWlDYW5FeGl0SWQgPSAwO1xuLyoqIEBoaWRkZW4gVE9ETzogbW92ZSB0aGVzZSBjYWxsYmFja3MgdG8gJHZpZXcgYW5kL29yIGAvaG9va3MvY29tcG9uZW50cy50c2Agb3Igc29tZXRoaW5nICovXG5mdW5jdGlvbiByZWdpc3RlckNvbnRyb2xsZXJDYWxsYmFja3MoJHEsICR0cmFuc2l0aW9ucywgY29udHJvbGxlckluc3RhbmNlLCAkc2NvcGUsIGNmZykge1xuICAgIC8vIENhbGwgJG9uSW5pdCgpIEFTQVBcbiAgICBpZiAoY29yZS5pc0Z1bmN0aW9uKGNvbnRyb2xsZXJJbnN0YW5jZS4kb25Jbml0KSAmJiAhKGNmZy52aWV3RGVjbC5jb21wb25lbnQgJiYgaGFzQ29tcG9uZW50SW1wbCkpIHtcbiAgICAgICAgY29udHJvbGxlckluc3RhbmNlLiRvbkluaXQoKTtcbiAgICB9XG4gICAgdmFyIHZpZXdTdGF0ZSA9IGNvcmUudGFpbChjZmcucGF0aCkuc3RhdGUuc2VsZjtcbiAgICB2YXIgaG9va09wdGlvbnMgPSB7IGJpbmQ6IGNvbnRyb2xsZXJJbnN0YW5jZSB9O1xuICAgIC8vIEFkZCBjb21wb25lbnQtbGV2ZWwgaG9vayBmb3Igb25QYXJhbXNDaGFuZ2VcbiAgICBpZiAoY29yZS5pc0Z1bmN0aW9uKGNvbnRyb2xsZXJJbnN0YW5jZS51aU9uUGFyYW1zQ2hhbmdlZCkpIHtcbiAgICAgICAgdmFyIHJlc29sdmVDb250ZXh0ID0gbmV3IGNvcmUuUmVzb2x2ZUNvbnRleHQoY2ZnLnBhdGgpO1xuICAgICAgICB2YXIgdmlld0NyZWF0aW9uVHJhbnNfMSA9IHJlc29sdmVDb250ZXh0LmdldFJlc29sdmFibGUoJyR0cmFuc2l0aW9uJCcpLmRhdGE7XG4gICAgICAgIC8vIEZpcmUgY2FsbGJhY2sgb24gYW55IHN1Y2Nlc3NmdWwgdHJhbnNpdGlvblxuICAgICAgICB2YXIgcGFyYW1zVXBkYXRlZCA9IGZ1bmN0aW9uICgkdHJhbnNpdGlvbiQpIHtcbiAgICAgICAgICAgIC8vIEV4aXQgZWFybHkgaWYgdGhlICR0cmFuc2l0aW9uJCBpcyB0aGUgc2FtZSBhcyB0aGUgdmlldyB3YXMgY3JlYXRlZCB3aXRoaW4uXG4gICAgICAgICAgICAvLyBFeGl0IGVhcmx5IGlmIHRoZSAkdHJhbnNpdGlvbiQgd2lsbCBleGl0IHRoZSBzdGF0ZSB0aGUgdmlldyBpcyBmb3IuXG4gICAgICAgICAgICBpZiAoJHRyYW5zaXRpb24kID09PSB2aWV3Q3JlYXRpb25UcmFuc18xIHx8ICR0cmFuc2l0aW9uJC5leGl0aW5nKCkuaW5kZXhPZih2aWV3U3RhdGUpICE9PSAtMSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgdG9QYXJhbXMgPSAkdHJhbnNpdGlvbiQucGFyYW1zKCd0bycpO1xuICAgICAgICAgICAgdmFyIGZyb21QYXJhbXMgPSAkdHJhbnNpdGlvbiQucGFyYW1zKCdmcm9tJyk7XG4gICAgICAgICAgICB2YXIgdG9TY2hlbWEgPSAkdHJhbnNpdGlvbiQudHJlZUNoYW5nZXMoKS50by5tYXAoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUucGFyYW1TY2hlbWE7IH0pLnJlZHVjZShjb3JlLnVubmVzdFIsIFtdKTtcbiAgICAgICAgICAgIHZhciBmcm9tU2NoZW1hID0gJHRyYW5zaXRpb24kLnRyZWVDaGFuZ2VzKCkuZnJvbS5tYXAoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUucGFyYW1TY2hlbWE7IH0pLnJlZHVjZShjb3JlLnVubmVzdFIsIFtdKTtcbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIHRvIHBhcmFtcyB0aGF0IGhhdmUgZGlmZmVyZW50IHZhbHVlcyB0aGFuIHRoZSBmcm9tIHBhcmFtc1xuICAgICAgICAgICAgdmFyIGNoYW5nZWRUb1BhcmFtcyA9IHRvU2NoZW1hLmZpbHRlcihmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgaWR4ID0gZnJvbVNjaGVtYS5pbmRleE9mKHBhcmFtKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWR4ID09PSAtMSB8fCAhZnJvbVNjaGVtYVtpZHhdLnR5cGUuZXF1YWxzKHRvUGFyYW1zW3BhcmFtLmlkXSwgZnJvbVBhcmFtc1twYXJhbS5pZF0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBPbmx5IHRyaWdnZXIgY2FsbGJhY2sgaWYgYSB0byBwYXJhbSBoYXMgY2hhbmdlZCBvciBpcyBuZXdcbiAgICAgICAgICAgIGlmIChjaGFuZ2VkVG9QYXJhbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoYW5nZWRLZXlzXzEgPSBjaGFuZ2VkVG9QYXJhbXMubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4LmlkOyB9KTtcbiAgICAgICAgICAgICAgICAvLyBGaWx0ZXIgdGhlIHBhcmFtcyB0byBvbmx5IGNoYW5nZWQvbmV3IHRvIHBhcmFtcy4gIGAkdHJhbnNpdGlvbiQucGFyYW1zKClgIG1heSBiZSB1c2VkIHRvIGdldCBhbGwgcGFyYW1zLlxuICAgICAgICAgICAgICAgIHZhciBuZXdWYWx1ZXMgPSBjb3JlLmZpbHRlcih0b1BhcmFtcywgZnVuY3Rpb24gKHZhbCQkMSwga2V5KSB7IHJldHVybiBjaGFuZ2VkS2V5c18xLmluZGV4T2Yoa2V5KSAhPT0gLTE7IH0pO1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXJJbnN0YW5jZS51aU9uUGFyYW1zQ2hhbmdlZChuZXdWYWx1ZXMsICR0cmFuc2l0aW9uJCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgICRzY29wZS4kb24oJyRkZXN0cm95JywgJHRyYW5zaXRpb25zLm9uU3VjY2Vzcyh7fSwgcGFyYW1zVXBkYXRlZCwgaG9va09wdGlvbnMpKTtcbiAgICB9XG4gICAgLy8gQWRkIGNvbXBvbmVudC1sZXZlbCBob29rIGZvciB1aUNhbkV4aXRcbiAgICBpZiAoY29yZS5pc0Z1bmN0aW9uKGNvbnRyb2xsZXJJbnN0YW5jZS51aUNhbkV4aXQpKSB7XG4gICAgICAgIHZhciBpZF8xID0gX3VpQ2FuRXhpdElkKys7XG4gICAgICAgIHZhciBjYWNoZVByb3BfMSA9ICdfdWlDYW5FeGl0SWRzJztcbiAgICAgICAgLy8gUmV0dXJucyB0cnVlIGlmIGEgcmVkaXJlY3QgdHJhbnNpdGlvbiBhbHJlYWR5IGFuc3dlcmVkIHRydXRoeVxuICAgICAgICB2YXIgcHJldlRydXRoeUFuc3dlcl8xID0gZnVuY3Rpb24gKHRyYW5zKSB7XG4gICAgICAgICAgICByZXR1cm4gISF0cmFucyAmJiAodHJhbnNbY2FjaGVQcm9wXzFdICYmIHRyYW5zW2NhY2hlUHJvcF8xXVtpZF8xXSA9PT0gdHJ1ZSB8fCBwcmV2VHJ1dGh5QW5zd2VyXzEodHJhbnMucmVkaXJlY3RlZEZyb20oKSkpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBJZiBhIHVzZXIgYW5zd2VyZWQgeWVzLCBidXQgdGhlIHRyYW5zaXRpb24gd2FzIGxhdGVyIHJlZGlyZWN0ZWQsIGRvbid0IGFsc28gYXNrIGZvciB0aGUgbmV3IHJlZGlyZWN0IHRyYW5zaXRpb25cbiAgICAgICAgdmFyIHdyYXBwZWRIb29rID0gZnVuY3Rpb24gKHRyYW5zKSB7XG4gICAgICAgICAgICB2YXIgcHJvbWlzZTtcbiAgICAgICAgICAgIHZhciBpZHMgPSB0cmFuc1tjYWNoZVByb3BfMV0gPSB0cmFuc1tjYWNoZVByb3BfMV0gfHwge307XG4gICAgICAgICAgICBpZiAoIXByZXZUcnV0aHlBbnN3ZXJfMSh0cmFucykpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlID0gJHEud2hlbihjb250cm9sbGVySW5zdGFuY2UudWlDYW5FeGl0KHRyYW5zKSk7XG4gICAgICAgICAgICAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uICh2YWwkJDEpIHsgcmV0dXJuIGlkc1tpZF8xXSA9ICh2YWwkJDEgIT09IGZhbHNlKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGNyaXRlcmlhID0geyBleGl0aW5nOiB2aWV3U3RhdGUubmFtZSB9O1xuICAgICAgICAkc2NvcGUuJG9uKCckZGVzdHJveScsICR0cmFuc2l0aW9ucy5vbkJlZm9yZShjcml0ZXJpYSwgd3JhcHBlZEhvb2ssIGhvb2tPcHRpb25zKSk7XG4gICAgfVxufVxubmcubW9kdWxlKCd1aS5yb3V0ZXIuc3RhdGUnKS5kaXJlY3RpdmUoJ3VpVmlldycsIHVpVmlldyk7XG5uZy5tb2R1bGUoJ3VpLnJvdXRlci5zdGF0ZScpLmRpcmVjdGl2ZSgndWlWaWV3JywgJFZpZXdEaXJlY3RpdmVGaWxsKTtcblxuLyoqIEBtb2R1bGUgbmcxICovIC8qKiAqL1xuLyoqIEBoaWRkZW4gKi9cbmZ1bmN0aW9uICRWaWV3U2Nyb2xsUHJvdmlkZXIoKSB7XG4gICAgdmFyIHVzZUFuY2hvclNjcm9sbCA9IGZhbHNlO1xuICAgIHRoaXMudXNlQW5jaG9yU2Nyb2xsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB1c2VBbmNob3JTY3JvbGwgPSB0cnVlO1xuICAgIH07XG4gICAgdGhpcy4kZ2V0ID0gWyckYW5jaG9yU2Nyb2xsJywgJyR0aW1lb3V0JywgZnVuY3Rpb24gKCRhbmNob3JTY3JvbGwsICR0aW1lb3V0KSB7XG4gICAgICAgICAgICBpZiAodXNlQW5jaG9yU2Nyb2xsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRhbmNob3JTY3JvbGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCRlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICR0aW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgJGVsZW1lbnRbMF0uc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICAgICAgICAgICAgICB9LCAwLCBmYWxzZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XTtcbn1cbm5nLm1vZHVsZSgndWkucm91dGVyLnN0YXRlJykucHJvdmlkZXIoJyR1aVZpZXdTY3JvbGwnLCAkVmlld1Njcm9sbFByb3ZpZGVyKTtcblxuLyoqXG4gKiBNYWluIGVudHJ5IHBvaW50IGZvciBhbmd1bGFyIDEueCBidWlsZFxuICogQG1vZHVsZSBuZzFcbiAqLyAvKiogKi9cbnZhciBpbmRleCA9ICd1aS5yb3V0ZXInO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBpbmRleDtcbmV4cG9ydHMuY29yZSA9IGNvcmU7XG5leHBvcnRzLndhdGNoRGlnZXN0cyA9IHdhdGNoRGlnZXN0cztcbmV4cG9ydHMuZ2V0TG9jYWxzID0gZ2V0TG9jYWxzO1xuZXhwb3J0cy5nZXROZzFWaWV3Q29uZmlnRmFjdG9yeSA9IGdldE5nMVZpZXdDb25maWdGYWN0b3J5O1xuZXhwb3J0cy5uZzFWaWV3c0J1aWxkZXIgPSBuZzFWaWV3c0J1aWxkZXI7XG5leHBvcnRzLk5nMVZpZXdDb25maWcgPSBOZzFWaWV3Q29uZmlnO1xuZXhwb3J0cy5TdGF0ZVByb3ZpZGVyID0gU3RhdGVQcm92aWRlcjtcbmV4cG9ydHMuVXJsUm91dGVyUHJvdmlkZXIgPSBVcmxSb3V0ZXJQcm92aWRlcjtcbk9iamVjdC5rZXlzKGNvcmUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBleHBvcnRzW2tleV0gPSBjb3JlW2tleV07IH0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG59KSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dWktcm91dGVyLWFuZ3VsYXJqcy5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9hbmd1bGFyanMvcmVsZWFzZS91aS1yb3V0ZXItYW5ndWxhcmpzLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///109\n")},function(module,exports,__webpack_require__){"use strict";eval('\n/**\n * @coreapi\n * @module common\n */ /** */\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, "__esModule", { value: true });\n__export(__webpack_require__(5));\n__export(__webpack_require__(112));\n__export(__webpack_require__(113));\n__export(__webpack_require__(114));\n__export(__webpack_require__(115));\n__export(__webpack_require__(125));\n__export(__webpack_require__(126));\n__export(__webpack_require__(127));\n__export(__webpack_require__(84));\n__export(__webpack_require__(79));\n__export(__webpack_require__(128));\n__export(__webpack_require__(131));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9pbmRleC5qcz9hMGZmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAY29yZWFwaVxuICogQG1vZHVsZSBjb21tb25cbiAqLyAvKiogKi9cbmZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9jb21tb24vaW5kZXhcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vcGFyYW1zL2luZGV4XCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3BhdGgvaW5kZXhcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vcmVzb2x2ZS9pbmRleFwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9zdGF0ZS9pbmRleFwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi90cmFuc2l0aW9uL2luZGV4XCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3VybC9pbmRleFwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi92aWV3L2luZGV4XCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2dsb2JhbHNcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vcm91dGVyXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3ZhbmlsbGFcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vaW50ZXJmYWNlXCIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///110\n')},function(module,exports){eval('var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function("return this")() || (1,eval)("this");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === "object")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it\'s\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTExLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcz8zNjk4Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBnO1xyXG5cclxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcclxuZyA9IChmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcztcclxufSkoKTtcclxuXHJcbnRyeSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXHJcblx0ZyA9IGcgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpIHx8ICgxLGV2YWwpKFwidGhpc1wiKTtcclxufSBjYXRjaChlKSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcclxuXHRpZih0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKVxyXG5cdFx0ZyA9IHdpbmRvdztcclxufVxyXG5cclxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxyXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xyXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGc7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qc1xuLy8gbW9kdWxlIGlkID0gMTExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///111\n')},function(module,exports,__webpack_require__){"use strict";eval('\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, "__esModule", { value: true });\n__export(__webpack_require__(18));\n__export(__webpack_require__(72));\n__export(__webpack_require__(73));\n__export(__webpack_require__(46));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9wYXJhbXMvaW5kZXguanM/OTliMiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9wYXJhbVwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9wYXJhbVR5cGVzXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3N0YXRlUGFyYW1zXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3BhcmFtVHlwZVwiKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvcGFyYW1zL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///112\n')},function(module,exports,__webpack_require__){"use strict";eval('\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, "__esModule", { value: true });\n/** @module path */ /** for typedoc */\n__export(__webpack_require__(45));\n__export(__webpack_require__(30));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9wYXRoL2luZGV4LmpzPzJmODciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqIEBtb2R1bGUgcGF0aCAqLyAvKiogZm9yIHR5cGVkb2MgKi9cbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3BhdGhOb2RlXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3BhdGhVdGlsc1wiKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvcGF0aC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///113\n')},function(module,exports,__webpack_require__){"use strict";eval('\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, "__esModule", { value: true });\n/** @module resolve */ /** for typedoc */\n__export(__webpack_require__(71));\n__export(__webpack_require__(26));\n__export(__webpack_require__(31));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTE0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9yZXNvbHZlL2luZGV4LmpzPzNjMGUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqIEBtb2R1bGUgcmVzb2x2ZSAqLyAvKiogZm9yIHR5cGVkb2MgKi9cbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2ludGVyZmFjZVwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9yZXNvbHZhYmxlXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3Jlc29sdmVDb250ZXh0XCIpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9yZXNvbHZlL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///114\n')},function(module,exports,__webpack_require__){"use strict";eval('\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, "__esModule", { value: true });\n__export(__webpack_require__(74));\n__export(__webpack_require__(42));\n__export(__webpack_require__(75));\n__export(__webpack_require__(76));\n__export(__webpack_require__(77));\n__export(__webpack_require__(78));\n__export(__webpack_require__(17));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTE1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9zdGF0ZS9pbmRleC5qcz80MGY5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gX19leHBvcnQobSkge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3N0YXRlQnVpbGRlclwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9zdGF0ZU9iamVjdFwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9zdGF0ZU1hdGNoZXJcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vc3RhdGVRdWV1ZU1hbmFnZXJcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vc3RhdGVSZWdpc3RyeVwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9zdGF0ZVNlcnZpY2VcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vdGFyZ2V0U3RhdGVcIikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3N0YXRlL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///115\n')},function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @module hooks */ /** */\nvar transition_1 = __webpack_require__(29);\nvar router_1 = __webpack_require__(79);\nfunction addCoreResolvables(trans) {\n    trans.addResolvable({ token: router_1.UIRouter, deps: [], resolveFn: function () { return trans.router; }, data: trans.router }, '');\n    trans.addResolvable({ token: transition_1.Transition, deps: [], resolveFn: function () { return trans; }, data: trans }, '');\n    trans.addResolvable({ token: '$transition$', deps: [], resolveFn: function () { return trans; }, data: trans }, '');\n    trans.addResolvable({ token: '$stateParams', deps: [], resolveFn: function () { return trans.params(); }, data: trans.params() }, '');\n    trans.entering().forEach(function (state) {\n        trans.addResolvable({ token: '$state$', deps: [], resolveFn: function () { return state; }, data: state }, state);\n    });\n}\nexports.registerAddCoreResolvables = function (transitionService) {\n    return transitionService.onCreate({}, addCoreResolvables);\n};\n//# sourceMappingURL=coreResolvables.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTE2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9ob29rcy9jb3JlUmVzb2x2YWJsZXMuanM/MmRjMyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKiBAbW9kdWxlIGhvb2tzICovIC8qKiAqL1xudmFyIHRyYW5zaXRpb25fMSA9IHJlcXVpcmUoXCIuLi90cmFuc2l0aW9uL3RyYW5zaXRpb25cIik7XG52YXIgcm91dGVyXzEgPSByZXF1aXJlKFwiLi4vcm91dGVyXCIpO1xuZnVuY3Rpb24gYWRkQ29yZVJlc29sdmFibGVzKHRyYW5zKSB7XG4gICAgdHJhbnMuYWRkUmVzb2x2YWJsZSh7IHRva2VuOiByb3V0ZXJfMS5VSVJvdXRlciwgZGVwczogW10sIHJlc29sdmVGbjogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJhbnMucm91dGVyOyB9LCBkYXRhOiB0cmFucy5yb3V0ZXIgfSwgJycpO1xuICAgIHRyYW5zLmFkZFJlc29sdmFibGUoeyB0b2tlbjogdHJhbnNpdGlvbl8xLlRyYW5zaXRpb24sIGRlcHM6IFtdLCByZXNvbHZlRm46IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRyYW5zOyB9LCBkYXRhOiB0cmFucyB9LCAnJyk7XG4gICAgdHJhbnMuYWRkUmVzb2x2YWJsZSh7IHRva2VuOiAnJHRyYW5zaXRpb24kJywgZGVwczogW10sIHJlc29sdmVGbjogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJhbnM7IH0sIGRhdGE6IHRyYW5zIH0sICcnKTtcbiAgICB0cmFucy5hZGRSZXNvbHZhYmxlKHsgdG9rZW46ICckc3RhdGVQYXJhbXMnLCBkZXBzOiBbXSwgcmVzb2x2ZUZuOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0cmFucy5wYXJhbXMoKTsgfSwgZGF0YTogdHJhbnMucGFyYW1zKCkgfSwgJycpO1xuICAgIHRyYW5zLmVudGVyaW5nKCkuZm9yRWFjaChmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgdHJhbnMuYWRkUmVzb2x2YWJsZSh7IHRva2VuOiAnJHN0YXRlJCcsIGRlcHM6IFtdLCByZXNvbHZlRm46IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0YXRlOyB9LCBkYXRhOiBzdGF0ZSB9LCBzdGF0ZSk7XG4gICAgfSk7XG59XG5leHBvcnRzLnJlZ2lzdGVyQWRkQ29yZVJlc29sdmFibGVzID0gZnVuY3Rpb24gKHRyYW5zaXRpb25TZXJ2aWNlKSB7XG4gICAgcmV0dXJuIHRyYW5zaXRpb25TZXJ2aWNlLm9uQ3JlYXRlKHt9LCBhZGRDb3JlUmVzb2x2YWJsZXMpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvcmVSZXNvbHZhYmxlcy5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvaG9va3MvY29yZVJlc29sdmFibGVzLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///116\n")},function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @module hooks */ /** */\nvar predicates_1 = __webpack_require__(1);\nvar coreservices_1 = __webpack_require__(3);\nvar targetState_1 = __webpack_require__(17);\n/**\n * A [[TransitionHookFn]] that redirects to a different state or params\n *\n * Registered using `transitionService.onStart({ to: (state) => !!state.redirectTo }, redirectHook);`\n *\n * See [[StateDeclaration.redirectTo]]\n */\nvar redirectToHook = function (trans) {\n    var redirect = trans.to().redirectTo;\n    if (!redirect)\n        return;\n    var $state = trans.router.stateService;\n    function handleResult(result) {\n        if (!result)\n            return;\n        if (result instanceof targetState_1.TargetState)\n            return result;\n        if (predicates_1.isString(result))\n            return $state.target(result, trans.params(), trans.options());\n        if (result['state'] || result['params'])\n            return $state.target(result['state'] || trans.to(), result['params'] || trans.params(), trans.options());\n    }\n    if (predicates_1.isFunction(redirect)) {\n        return coreservices_1.services.$q.when(redirect(trans)).then(handleResult);\n    }\n    return handleResult(redirect);\n};\nexports.registerRedirectToHook = function (transitionService) {\n    return transitionService.onStart({ to: function (state) { return !!state.redirectTo; } }, redirectToHook);\n};\n//# sourceMappingURL=redirectTo.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTE3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9ob29rcy9yZWRpcmVjdFRvLmpzPzBkNGIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKiogQG1vZHVsZSBob29rcyAqLyAvKiogKi9cbnZhciBwcmVkaWNhdGVzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL3ByZWRpY2F0ZXNcIik7XG52YXIgY29yZXNlcnZpY2VzXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvcmVzZXJ2aWNlc1wiKTtcbnZhciB0YXJnZXRTdGF0ZV8xID0gcmVxdWlyZShcIi4uL3N0YXRlL3RhcmdldFN0YXRlXCIpO1xuLyoqXG4gKiBBIFtbVHJhbnNpdGlvbkhvb2tGbl1dIHRoYXQgcmVkaXJlY3RzIHRvIGEgZGlmZmVyZW50IHN0YXRlIG9yIHBhcmFtc1xuICpcbiAqIFJlZ2lzdGVyZWQgdXNpbmcgYHRyYW5zaXRpb25TZXJ2aWNlLm9uU3RhcnQoeyB0bzogKHN0YXRlKSA9PiAhIXN0YXRlLnJlZGlyZWN0VG8gfSwgcmVkaXJlY3RIb29rKTtgXG4gKlxuICogU2VlIFtbU3RhdGVEZWNsYXJhdGlvbi5yZWRpcmVjdFRvXV1cbiAqL1xudmFyIHJlZGlyZWN0VG9Ib29rID0gZnVuY3Rpb24gKHRyYW5zKSB7XG4gICAgdmFyIHJlZGlyZWN0ID0gdHJhbnMudG8oKS5yZWRpcmVjdFRvO1xuICAgIGlmICghcmVkaXJlY3QpXG4gICAgICAgIHJldHVybjtcbiAgICB2YXIgJHN0YXRlID0gdHJhbnMucm91dGVyLnN0YXRlU2VydmljZTtcbiAgICBmdW5jdGlvbiBoYW5kbGVSZXN1bHQocmVzdWx0KSB7XG4gICAgICAgIGlmICghcmVzdWx0KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgdGFyZ2V0U3RhdGVfMS5UYXJnZXRTdGF0ZSlcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIGlmIChwcmVkaWNhdGVzXzEuaXNTdHJpbmcocmVzdWx0KSlcbiAgICAgICAgICAgIHJldHVybiAkc3RhdGUudGFyZ2V0KHJlc3VsdCwgdHJhbnMucGFyYW1zKCksIHRyYW5zLm9wdGlvbnMoKSk7XG4gICAgICAgIGlmIChyZXN1bHRbJ3N0YXRlJ10gfHwgcmVzdWx0WydwYXJhbXMnXSlcbiAgICAgICAgICAgIHJldHVybiAkc3RhdGUudGFyZ2V0KHJlc3VsdFsnc3RhdGUnXSB8fCB0cmFucy50bygpLCByZXN1bHRbJ3BhcmFtcyddIHx8IHRyYW5zLnBhcmFtcygpLCB0cmFucy5vcHRpb25zKCkpO1xuICAgIH1cbiAgICBpZiAocHJlZGljYXRlc18xLmlzRnVuY3Rpb24ocmVkaXJlY3QpKSB7XG4gICAgICAgIHJldHVybiBjb3Jlc2VydmljZXNfMS5zZXJ2aWNlcy4kcS53aGVuKHJlZGlyZWN0KHRyYW5zKSkudGhlbihoYW5kbGVSZXN1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gaGFuZGxlUmVzdWx0KHJlZGlyZWN0KTtcbn07XG5leHBvcnRzLnJlZ2lzdGVyUmVkaXJlY3RUb0hvb2sgPSBmdW5jdGlvbiAodHJhbnNpdGlvblNlcnZpY2UpIHtcbiAgICByZXR1cm4gdHJhbnNpdGlvblNlcnZpY2Uub25TdGFydCh7IHRvOiBmdW5jdGlvbiAoc3RhdGUpIHsgcmV0dXJuICEhc3RhdGUucmVkaXJlY3RUbzsgfSB9LCByZWRpcmVjdFRvSG9vayk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVkaXJlY3RUby5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvaG9va3MvcmVkaXJlY3RUby5qc1xuLy8gbW9kdWxlIGlkID0gMTE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///117\n")},function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * A factory which creates an onEnter, onExit or onRetain transition hook function\n *\n * The returned function invokes the (for instance) state.onEnter hook when the\n * state is being entered.\n *\n * @hidden\n */\nfunction makeEnterExitRetainHook(hookName) {\n    return function (transition, state) {\n        var _state = state.$$state();\n        var hookFn = _state[hookName];\n        return hookFn(transition, state);\n    };\n}\n/**\n * The [[TransitionStateHookFn]] for onExit\n *\n * When the state is being exited, the state's .onExit function is invoked.\n *\n * Registered using `transitionService.onExit({ exiting: (state) => !!state.onExit }, onExitHook);`\n *\n * See: [[IHookRegistry.onExit]]\n */\nvar onExitHook = makeEnterExitRetainHook('onExit');\nexports.registerOnExitHook = function (transitionService) {\n    return transitionService.onExit({ exiting: function (state) { return !!state.onExit; } }, onExitHook);\n};\n/**\n * The [[TransitionStateHookFn]] for onRetain\n *\n * When the state was already entered, and is not being exited or re-entered, the state's .onRetain function is invoked.\n *\n * Registered using `transitionService.onRetain({ retained: (state) => !!state.onRetain }, onRetainHook);`\n *\n * See: [[IHookRegistry.onRetain]]\n */\nvar onRetainHook = makeEnterExitRetainHook('onRetain');\nexports.registerOnRetainHook = function (transitionService) {\n    return transitionService.onRetain({ retained: function (state) { return !!state.onRetain; } }, onRetainHook);\n};\n/**\n * The [[TransitionStateHookFn]] for onEnter\n *\n * When the state is being entered, the state's .onEnter function is invoked.\n *\n * Registered using `transitionService.onEnter({ entering: (state) => !!state.onEnter }, onEnterHook);`\n *\n * See: [[IHookRegistry.onEnter]]\n */\nvar onEnterHook = makeEnterExitRetainHook('onEnter');\nexports.registerOnEnterHook = function (transitionService) {\n    return transitionService.onEnter({ entering: function (state) { return !!state.onEnter; } }, onEnterHook);\n};\n//# sourceMappingURL=onEnterExitRetain.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTE4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9ob29rcy9vbkVudGVyRXhpdFJldGFpbi5qcz9mYzczIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBBIGZhY3Rvcnkgd2hpY2ggY3JlYXRlcyBhbiBvbkVudGVyLCBvbkV4aXQgb3Igb25SZXRhaW4gdHJhbnNpdGlvbiBob29rIGZ1bmN0aW9uXG4gKlxuICogVGhlIHJldHVybmVkIGZ1bmN0aW9uIGludm9rZXMgdGhlIChmb3IgaW5zdGFuY2UpIHN0YXRlLm9uRW50ZXIgaG9vayB3aGVuIHRoZVxuICogc3RhdGUgaXMgYmVpbmcgZW50ZXJlZC5cbiAqXG4gKiBAaGlkZGVuXG4gKi9cbmZ1bmN0aW9uIG1ha2VFbnRlckV4aXRSZXRhaW5Ib29rKGhvb2tOYW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0cmFuc2l0aW9uLCBzdGF0ZSkge1xuICAgICAgICB2YXIgX3N0YXRlID0gc3RhdGUuJCRzdGF0ZSgpO1xuICAgICAgICB2YXIgaG9va0ZuID0gX3N0YXRlW2hvb2tOYW1lXTtcbiAgICAgICAgcmV0dXJuIGhvb2tGbih0cmFuc2l0aW9uLCBzdGF0ZSk7XG4gICAgfTtcbn1cbi8qKlxuICogVGhlIFtbVHJhbnNpdGlvblN0YXRlSG9va0ZuXV0gZm9yIG9uRXhpdFxuICpcbiAqIFdoZW4gdGhlIHN0YXRlIGlzIGJlaW5nIGV4aXRlZCwgdGhlIHN0YXRlJ3MgLm9uRXhpdCBmdW5jdGlvbiBpcyBpbnZva2VkLlxuICpcbiAqIFJlZ2lzdGVyZWQgdXNpbmcgYHRyYW5zaXRpb25TZXJ2aWNlLm9uRXhpdCh7IGV4aXRpbmc6IChzdGF0ZSkgPT4gISFzdGF0ZS5vbkV4aXQgfSwgb25FeGl0SG9vayk7YFxuICpcbiAqIFNlZTogW1tJSG9va1JlZ2lzdHJ5Lm9uRXhpdF1dXG4gKi9cbnZhciBvbkV4aXRIb29rID0gbWFrZUVudGVyRXhpdFJldGFpbkhvb2soJ29uRXhpdCcpO1xuZXhwb3J0cy5yZWdpc3Rlck9uRXhpdEhvb2sgPSBmdW5jdGlvbiAodHJhbnNpdGlvblNlcnZpY2UpIHtcbiAgICByZXR1cm4gdHJhbnNpdGlvblNlcnZpY2Uub25FeGl0KHsgZXhpdGluZzogZnVuY3Rpb24gKHN0YXRlKSB7IHJldHVybiAhIXN0YXRlLm9uRXhpdDsgfSB9LCBvbkV4aXRIb29rKTtcbn07XG4vKipcbiAqIFRoZSBbW1RyYW5zaXRpb25TdGF0ZUhvb2tGbl1dIGZvciBvblJldGFpblxuICpcbiAqIFdoZW4gdGhlIHN0YXRlIHdhcyBhbHJlYWR5IGVudGVyZWQsIGFuZCBpcyBub3QgYmVpbmcgZXhpdGVkIG9yIHJlLWVudGVyZWQsIHRoZSBzdGF0ZSdzIC5vblJldGFpbiBmdW5jdGlvbiBpcyBpbnZva2VkLlxuICpcbiAqIFJlZ2lzdGVyZWQgdXNpbmcgYHRyYW5zaXRpb25TZXJ2aWNlLm9uUmV0YWluKHsgcmV0YWluZWQ6IChzdGF0ZSkgPT4gISFzdGF0ZS5vblJldGFpbiB9LCBvblJldGFpbkhvb2spO2BcbiAqXG4gKiBTZWU6IFtbSUhvb2tSZWdpc3RyeS5vblJldGFpbl1dXG4gKi9cbnZhciBvblJldGFpbkhvb2sgPSBtYWtlRW50ZXJFeGl0UmV0YWluSG9vaygnb25SZXRhaW4nKTtcbmV4cG9ydHMucmVnaXN0ZXJPblJldGFpbkhvb2sgPSBmdW5jdGlvbiAodHJhbnNpdGlvblNlcnZpY2UpIHtcbiAgICByZXR1cm4gdHJhbnNpdGlvblNlcnZpY2Uub25SZXRhaW4oeyByZXRhaW5lZDogZnVuY3Rpb24gKHN0YXRlKSB7IHJldHVybiAhIXN0YXRlLm9uUmV0YWluOyB9IH0sIG9uUmV0YWluSG9vayk7XG59O1xuLyoqXG4gKiBUaGUgW1tUcmFuc2l0aW9uU3RhdGVIb29rRm5dXSBmb3Igb25FbnRlclxuICpcbiAqIFdoZW4gdGhlIHN0YXRlIGlzIGJlaW5nIGVudGVyZWQsIHRoZSBzdGF0ZSdzIC5vbkVudGVyIGZ1bmN0aW9uIGlzIGludm9rZWQuXG4gKlxuICogUmVnaXN0ZXJlZCB1c2luZyBgdHJhbnNpdGlvblNlcnZpY2Uub25FbnRlcih7IGVudGVyaW5nOiAoc3RhdGUpID0+ICEhc3RhdGUub25FbnRlciB9LCBvbkVudGVySG9vayk7YFxuICpcbiAqIFNlZTogW1tJSG9va1JlZ2lzdHJ5Lm9uRW50ZXJdXVxuICovXG52YXIgb25FbnRlckhvb2sgPSBtYWtlRW50ZXJFeGl0UmV0YWluSG9vaygnb25FbnRlcicpO1xuZXhwb3J0cy5yZWdpc3Rlck9uRW50ZXJIb29rID0gZnVuY3Rpb24gKHRyYW5zaXRpb25TZXJ2aWNlKSB7XG4gICAgcmV0dXJuIHRyYW5zaXRpb25TZXJ2aWNlLm9uRW50ZXIoeyBlbnRlcmluZzogZnVuY3Rpb24gKHN0YXRlKSB7IHJldHVybiAhIXN0YXRlLm9uRW50ZXI7IH0gfSwgb25FbnRlckhvb2spO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9uRW50ZXJFeGl0UmV0YWluLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9ob29rcy9vbkVudGVyRXhpdFJldGFpbi5qc1xuLy8gbW9kdWxlIGlkID0gMTE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///118\n")},function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @module hooks */\n/** for typedoc */\nvar common_1 = __webpack_require__(0);\nvar resolveContext_1 = __webpack_require__(31);\nvar hof_1 = __webpack_require__(2);\nexports.RESOLVE_HOOK_PRIORITY = 1000;\n/**\n * A [[TransitionHookFn]] which resolves all EAGER Resolvables in the To Path\n *\n * Registered using `transitionService.onStart({}, eagerResolvePath, { priority: 1000 });`\n *\n * When a Transition starts, this hook resolves all the EAGER Resolvables, which the transition then waits for.\n *\n * See [[StateDeclaration.resolve]]\n */\nvar eagerResolvePath = function (trans) {\n    return new resolveContext_1.ResolveContext(trans.treeChanges().to)\n        .resolvePath('EAGER', trans)\n        .then(common_1.noop);\n};\nexports.registerEagerResolvePath = function (transitionService) {\n    return transitionService.onStart({}, eagerResolvePath, { priority: exports.RESOLVE_HOOK_PRIORITY });\n};\n/**\n * A [[TransitionHookFn]] which resolves all LAZY Resolvables for the state (and all its ancestors) in the To Path\n *\n * Registered using `transitionService.onEnter({ entering: () => true }, lazyResolveState, { priority: 1000 });`\n *\n * When a State is being entered, this hook resolves all the Resolvables for this state, which the transition then waits for.\n *\n * See [[StateDeclaration.resolve]]\n */\nvar lazyResolveState = function (trans, state) {\n    return new resolveContext_1.ResolveContext(trans.treeChanges().to)\n        .subContext(state.$$state())\n        .resolvePath('LAZY', trans)\n        .then(common_1.noop);\n};\nexports.registerLazyResolveState = function (transitionService) {\n    return transitionService.onEnter({ entering: hof_1.val(true) }, lazyResolveState, { priority: exports.RESOLVE_HOOK_PRIORITY });\n};\n/**\n * A [[TransitionHookFn]] which resolves any dynamically added (LAZY or EAGER) Resolvables.\n *\n * Registered using `transitionService.onFinish({}, eagerResolvePath, { priority: 1000 });`\n *\n * After all entering states have been entered, this hook resolves any remaining Resolvables.\n * These are typically dynamic resolves which were added by some Transition Hook using [[Transition.addResolvable]].\n *\n * See [[StateDeclaration.resolve]]\n */\nvar resolveRemaining = function (trans) {\n    return new resolveContext_1.ResolveContext(trans.treeChanges().to)\n        .resolvePath('LAZY', trans)\n        .then(common_1.noop);\n};\nexports.registerResolveRemaining = function (transitionService) {\n    return transitionService.onFinish({}, resolveRemaining, { priority: exports.RESOLVE_HOOK_PRIORITY });\n};\n//# sourceMappingURL=resolve.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTE5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9ob29rcy9yZXNvbHZlLmpzPzU4MWMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKiogQG1vZHVsZSBob29rcyAqL1xuLyoqIGZvciB0eXBlZG9jICovXG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcbnZhciByZXNvbHZlQ29udGV4dF8xID0gcmVxdWlyZShcIi4uL3Jlc29sdmUvcmVzb2x2ZUNvbnRleHRcIik7XG52YXIgaG9mXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2hvZlwiKTtcbmV4cG9ydHMuUkVTT0xWRV9IT09LX1BSSU9SSVRZID0gMTAwMDtcbi8qKlxuICogQSBbW1RyYW5zaXRpb25Ib29rRm5dXSB3aGljaCByZXNvbHZlcyBhbGwgRUFHRVIgUmVzb2x2YWJsZXMgaW4gdGhlIFRvIFBhdGhcbiAqXG4gKiBSZWdpc3RlcmVkIHVzaW5nIGB0cmFuc2l0aW9uU2VydmljZS5vblN0YXJ0KHt9LCBlYWdlclJlc29sdmVQYXRoLCB7IHByaW9yaXR5OiAxMDAwIH0pO2BcbiAqXG4gKiBXaGVuIGEgVHJhbnNpdGlvbiBzdGFydHMsIHRoaXMgaG9vayByZXNvbHZlcyBhbGwgdGhlIEVBR0VSIFJlc29sdmFibGVzLCB3aGljaCB0aGUgdHJhbnNpdGlvbiB0aGVuIHdhaXRzIGZvci5cbiAqXG4gKiBTZWUgW1tTdGF0ZURlY2xhcmF0aW9uLnJlc29sdmVdXVxuICovXG52YXIgZWFnZXJSZXNvbHZlUGF0aCA9IGZ1bmN0aW9uICh0cmFucykge1xuICAgIHJldHVybiBuZXcgcmVzb2x2ZUNvbnRleHRfMS5SZXNvbHZlQ29udGV4dCh0cmFucy50cmVlQ2hhbmdlcygpLnRvKVxuICAgICAgICAucmVzb2x2ZVBhdGgoJ0VBR0VSJywgdHJhbnMpXG4gICAgICAgIC50aGVuKGNvbW1vbl8xLm5vb3ApO1xufTtcbmV4cG9ydHMucmVnaXN0ZXJFYWdlclJlc29sdmVQYXRoID0gZnVuY3Rpb24gKHRyYW5zaXRpb25TZXJ2aWNlKSB7XG4gICAgcmV0dXJuIHRyYW5zaXRpb25TZXJ2aWNlLm9uU3RhcnQoe30sIGVhZ2VyUmVzb2x2ZVBhdGgsIHsgcHJpb3JpdHk6IGV4cG9ydHMuUkVTT0xWRV9IT09LX1BSSU9SSVRZIH0pO1xufTtcbi8qKlxuICogQSBbW1RyYW5zaXRpb25Ib29rRm5dXSB3aGljaCByZXNvbHZlcyBhbGwgTEFaWSBSZXNvbHZhYmxlcyBmb3IgdGhlIHN0YXRlIChhbmQgYWxsIGl0cyBhbmNlc3RvcnMpIGluIHRoZSBUbyBQYXRoXG4gKlxuICogUmVnaXN0ZXJlZCB1c2luZyBgdHJhbnNpdGlvblNlcnZpY2Uub25FbnRlcih7IGVudGVyaW5nOiAoKSA9PiB0cnVlIH0sIGxhenlSZXNvbHZlU3RhdGUsIHsgcHJpb3JpdHk6IDEwMDAgfSk7YFxuICpcbiAqIFdoZW4gYSBTdGF0ZSBpcyBiZWluZyBlbnRlcmVkLCB0aGlzIGhvb2sgcmVzb2x2ZXMgYWxsIHRoZSBSZXNvbHZhYmxlcyBmb3IgdGhpcyBzdGF0ZSwgd2hpY2ggdGhlIHRyYW5zaXRpb24gdGhlbiB3YWl0cyBmb3IuXG4gKlxuICogU2VlIFtbU3RhdGVEZWNsYXJhdGlvbi5yZXNvbHZlXV1cbiAqL1xudmFyIGxhenlSZXNvbHZlU3RhdGUgPSBmdW5jdGlvbiAodHJhbnMsIHN0YXRlKSB7XG4gICAgcmV0dXJuIG5ldyByZXNvbHZlQ29udGV4dF8xLlJlc29sdmVDb250ZXh0KHRyYW5zLnRyZWVDaGFuZ2VzKCkudG8pXG4gICAgICAgIC5zdWJDb250ZXh0KHN0YXRlLiQkc3RhdGUoKSlcbiAgICAgICAgLnJlc29sdmVQYXRoKCdMQVpZJywgdHJhbnMpXG4gICAgICAgIC50aGVuKGNvbW1vbl8xLm5vb3ApO1xufTtcbmV4cG9ydHMucmVnaXN0ZXJMYXp5UmVzb2x2ZVN0YXRlID0gZnVuY3Rpb24gKHRyYW5zaXRpb25TZXJ2aWNlKSB7XG4gICAgcmV0dXJuIHRyYW5zaXRpb25TZXJ2aWNlLm9uRW50ZXIoeyBlbnRlcmluZzogaG9mXzEudmFsKHRydWUpIH0sIGxhenlSZXNvbHZlU3RhdGUsIHsgcHJpb3JpdHk6IGV4cG9ydHMuUkVTT0xWRV9IT09LX1BSSU9SSVRZIH0pO1xufTtcbi8qKlxuICogQSBbW1RyYW5zaXRpb25Ib29rRm5dXSB3aGljaCByZXNvbHZlcyBhbnkgZHluYW1pY2FsbHkgYWRkZWQgKExBWlkgb3IgRUFHRVIpIFJlc29sdmFibGVzLlxuICpcbiAqIFJlZ2lzdGVyZWQgdXNpbmcgYHRyYW5zaXRpb25TZXJ2aWNlLm9uRmluaXNoKHt9LCBlYWdlclJlc29sdmVQYXRoLCB7IHByaW9yaXR5OiAxMDAwIH0pO2BcbiAqXG4gKiBBZnRlciBhbGwgZW50ZXJpbmcgc3RhdGVzIGhhdmUgYmVlbiBlbnRlcmVkLCB0aGlzIGhvb2sgcmVzb2x2ZXMgYW55IHJlbWFpbmluZyBSZXNvbHZhYmxlcy5cbiAqIFRoZXNlIGFyZSB0eXBpY2FsbHkgZHluYW1pYyByZXNvbHZlcyB3aGljaCB3ZXJlIGFkZGVkIGJ5IHNvbWUgVHJhbnNpdGlvbiBIb29rIHVzaW5nIFtbVHJhbnNpdGlvbi5hZGRSZXNvbHZhYmxlXV0uXG4gKlxuICogU2VlIFtbU3RhdGVEZWNsYXJhdGlvbi5yZXNvbHZlXV1cbiAqL1xudmFyIHJlc29sdmVSZW1haW5pbmcgPSBmdW5jdGlvbiAodHJhbnMpIHtcbiAgICByZXR1cm4gbmV3IHJlc29sdmVDb250ZXh0XzEuUmVzb2x2ZUNvbnRleHQodHJhbnMudHJlZUNoYW5nZXMoKS50bylcbiAgICAgICAgLnJlc29sdmVQYXRoKCdMQVpZJywgdHJhbnMpXG4gICAgICAgIC50aGVuKGNvbW1vbl8xLm5vb3ApO1xufTtcbmV4cG9ydHMucmVnaXN0ZXJSZXNvbHZlUmVtYWluaW5nID0gZnVuY3Rpb24gKHRyYW5zaXRpb25TZXJ2aWNlKSB7XG4gICAgcmV0dXJuIHRyYW5zaXRpb25TZXJ2aWNlLm9uRmluaXNoKHt9LCByZXNvbHZlUmVtYWluaW5nLCB7IHByaW9yaXR5OiBleHBvcnRzLlJFU09MVkVfSE9PS19QUklPUklUWSB9KTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNvbHZlLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9ob29rcy9yZXNvbHZlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///119\n")},function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** @module hooks */ /** for typedoc */\nvar common_1 = __webpack_require__(0);\nvar coreservices_1 = __webpack_require__(3);\n/**\n * A [[TransitionHookFn]] which waits for the views to load\n *\n * Registered using `transitionService.onStart({}, loadEnteringViews);`\n *\n * Allows the views to do async work in [[ViewConfig.load]] before the transition continues.\n * In angular 1, this includes loading the templates.\n */\nvar loadEnteringViews = function (transition) {\n    var $q = coreservices_1.services.$q;\n    var enteringViews = transition.views('entering');\n    if (!enteringViews.length)\n        return;\n    return $q.all(enteringViews.map(function (view) { return $q.when(view.load()); })).then(common_1.noop);\n};\nexports.registerLoadEnteringViews = function (transitionService) {\n    return transitionService.onFinish({}, loadEnteringViews);\n};\n/**\n * A [[TransitionHookFn]] which activates the new views when a transition is successful.\n *\n * Registered using `transitionService.onSuccess({}, activateViews);`\n *\n * After a transition is complete, this hook deactivates the old views from the previous state,\n * and activates the new views from the destination state.\n *\n * See [[ViewService]]\n */\nvar activateViews = function (transition) {\n    var enteringViews = transition.views('entering');\n    var exitingViews = transition.views('exiting');\n    if (!enteringViews.length && !exitingViews.length)\n        return;\n    var $view = transition.router.viewService;\n    exitingViews.forEach(function (vc) { return $view.deactivateViewConfig(vc); });\n    enteringViews.forEach(function (vc) { return $view.activateViewConfig(vc); });\n    $view.sync();\n};\nexports.registerActivateViews = function (transitionService) {\n    return transitionService.onSuccess({}, activateViews);\n};\n//# sourceMappingURL=views.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9ob29rcy92aWV3cy5qcz82MWE2Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqIEBtb2R1bGUgaG9va3MgKi8gLyoqIGZvciB0eXBlZG9jICovXG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcbnZhciBjb3Jlc2VydmljZXNfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vY29yZXNlcnZpY2VzXCIpO1xuLyoqXG4gKiBBIFtbVHJhbnNpdGlvbkhvb2tGbl1dIHdoaWNoIHdhaXRzIGZvciB0aGUgdmlld3MgdG8gbG9hZFxuICpcbiAqIFJlZ2lzdGVyZWQgdXNpbmcgYHRyYW5zaXRpb25TZXJ2aWNlLm9uU3RhcnQoe30sIGxvYWRFbnRlcmluZ1ZpZXdzKTtgXG4gKlxuICogQWxsb3dzIHRoZSB2aWV3cyB0byBkbyBhc3luYyB3b3JrIGluIFtbVmlld0NvbmZpZy5sb2FkXV0gYmVmb3JlIHRoZSB0cmFuc2l0aW9uIGNvbnRpbnVlcy5cbiAqIEluIGFuZ3VsYXIgMSwgdGhpcyBpbmNsdWRlcyBsb2FkaW5nIHRoZSB0ZW1wbGF0ZXMuXG4gKi9cbnZhciBsb2FkRW50ZXJpbmdWaWV3cyA9IGZ1bmN0aW9uICh0cmFuc2l0aW9uKSB7XG4gICAgdmFyICRxID0gY29yZXNlcnZpY2VzXzEuc2VydmljZXMuJHE7XG4gICAgdmFyIGVudGVyaW5nVmlld3MgPSB0cmFuc2l0aW9uLnZpZXdzKCdlbnRlcmluZycpO1xuICAgIGlmICghZW50ZXJpbmdWaWV3cy5sZW5ndGgpXG4gICAgICAgIHJldHVybjtcbiAgICByZXR1cm4gJHEuYWxsKGVudGVyaW5nVmlld3MubWFwKGZ1bmN0aW9uICh2aWV3KSB7IHJldHVybiAkcS53aGVuKHZpZXcubG9hZCgpKTsgfSkpLnRoZW4oY29tbW9uXzEubm9vcCk7XG59O1xuZXhwb3J0cy5yZWdpc3RlckxvYWRFbnRlcmluZ1ZpZXdzID0gZnVuY3Rpb24gKHRyYW5zaXRpb25TZXJ2aWNlKSB7XG4gICAgcmV0dXJuIHRyYW5zaXRpb25TZXJ2aWNlLm9uRmluaXNoKHt9LCBsb2FkRW50ZXJpbmdWaWV3cyk7XG59O1xuLyoqXG4gKiBBIFtbVHJhbnNpdGlvbkhvb2tGbl1dIHdoaWNoIGFjdGl2YXRlcyB0aGUgbmV3IHZpZXdzIHdoZW4gYSB0cmFuc2l0aW9uIGlzIHN1Y2Nlc3NmdWwuXG4gKlxuICogUmVnaXN0ZXJlZCB1c2luZyBgdHJhbnNpdGlvblNlcnZpY2Uub25TdWNjZXNzKHt9LCBhY3RpdmF0ZVZpZXdzKTtgXG4gKlxuICogQWZ0ZXIgYSB0cmFuc2l0aW9uIGlzIGNvbXBsZXRlLCB0aGlzIGhvb2sgZGVhY3RpdmF0ZXMgdGhlIG9sZCB2aWV3cyBmcm9tIHRoZSBwcmV2aW91cyBzdGF0ZSxcbiAqIGFuZCBhY3RpdmF0ZXMgdGhlIG5ldyB2aWV3cyBmcm9tIHRoZSBkZXN0aW5hdGlvbiBzdGF0ZS5cbiAqXG4gKiBTZWUgW1tWaWV3U2VydmljZV1dXG4gKi9cbnZhciBhY3RpdmF0ZVZpZXdzID0gZnVuY3Rpb24gKHRyYW5zaXRpb24pIHtcbiAgICB2YXIgZW50ZXJpbmdWaWV3cyA9IHRyYW5zaXRpb24udmlld3MoJ2VudGVyaW5nJyk7XG4gICAgdmFyIGV4aXRpbmdWaWV3cyA9IHRyYW5zaXRpb24udmlld3MoJ2V4aXRpbmcnKTtcbiAgICBpZiAoIWVudGVyaW5nVmlld3MubGVuZ3RoICYmICFleGl0aW5nVmlld3MubGVuZ3RoKVxuICAgICAgICByZXR1cm47XG4gICAgdmFyICR2aWV3ID0gdHJhbnNpdGlvbi5yb3V0ZXIudmlld1NlcnZpY2U7XG4gICAgZXhpdGluZ1ZpZXdzLmZvckVhY2goZnVuY3Rpb24gKHZjKSB7IHJldHVybiAkdmlldy5kZWFjdGl2YXRlVmlld0NvbmZpZyh2Yyk7IH0pO1xuICAgIGVudGVyaW5nVmlld3MuZm9yRWFjaChmdW5jdGlvbiAodmMpIHsgcmV0dXJuICR2aWV3LmFjdGl2YXRlVmlld0NvbmZpZyh2Yyk7IH0pO1xuICAgICR2aWV3LnN5bmMoKTtcbn07XG5leHBvcnRzLnJlZ2lzdGVyQWN0aXZhdGVWaWV3cyA9IGZ1bmN0aW9uICh0cmFuc2l0aW9uU2VydmljZSkge1xuICAgIHJldHVybiB0cmFuc2l0aW9uU2VydmljZS5vblN1Y2Nlc3Moe30sIGFjdGl2YXRlVmlld3MpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZpZXdzLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9ob29rcy92aWV3cy5qc1xuLy8gbW9kdWxlIGlkID0gMTIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///120\n")},function(module,exports,__webpack_require__){"use strict";eval('\nObject.defineProperty(exports, "__esModule", { value: true });\nvar common_1 = __webpack_require__(0);\n/**\n * A [[TransitionHookFn]] which updates global UI-Router state\n *\n * Registered using `transitionService.onBefore({}, updateGlobalState);`\n *\n * Before a [[Transition]] starts, updates the global value of "the current transition" ([[Globals.transition]]).\n * After a successful [[Transition]], updates the global values of "the current state"\n * ([[Globals.current]] and [[Globals.$current]]) and "the current param values" ([[Globals.params]]).\n *\n * See also the deprecated properties:\n * [[StateService.transition]], [[StateService.current]], [[StateService.params]]\n */\nvar updateGlobalState = function (trans) {\n    var globals = trans.router.globals;\n    var transitionSuccessful = function () {\n        globals.successfulTransitions.enqueue(trans);\n        globals.$current = trans.$to();\n        globals.current = globals.$current.self;\n        common_1.copy(trans.params(), globals.params);\n    };\n    var clearCurrentTransition = function () {\n        // Do not clear globals.transition if a different transition has started in the meantime\n        if (globals.transition === trans)\n            globals.transition = null;\n    };\n    trans.onSuccess({}, transitionSuccessful, { priority: 10000 });\n    trans.promise.then(clearCurrentTransition, clearCurrentTransition);\n};\nexports.registerUpdateGlobalState = function (transitionService) {\n    return transitionService.onCreate({}, updateGlobalState);\n};\n//# sourceMappingURL=updateGlobals.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9ob29rcy91cGRhdGVHbG9iYWxzLmpzPzU2ZGYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY29tbW9uXzEgPSByZXF1aXJlKFwiLi4vY29tbW9uL2NvbW1vblwiKTtcbi8qKlxuICogQSBbW1RyYW5zaXRpb25Ib29rRm5dXSB3aGljaCB1cGRhdGVzIGdsb2JhbCBVSS1Sb3V0ZXIgc3RhdGVcbiAqXG4gKiBSZWdpc3RlcmVkIHVzaW5nIGB0cmFuc2l0aW9uU2VydmljZS5vbkJlZm9yZSh7fSwgdXBkYXRlR2xvYmFsU3RhdGUpO2BcbiAqXG4gKiBCZWZvcmUgYSBbW1RyYW5zaXRpb25dXSBzdGFydHMsIHVwZGF0ZXMgdGhlIGdsb2JhbCB2YWx1ZSBvZiBcInRoZSBjdXJyZW50IHRyYW5zaXRpb25cIiAoW1tHbG9iYWxzLnRyYW5zaXRpb25dXSkuXG4gKiBBZnRlciBhIHN1Y2Nlc3NmdWwgW1tUcmFuc2l0aW9uXV0sIHVwZGF0ZXMgdGhlIGdsb2JhbCB2YWx1ZXMgb2YgXCJ0aGUgY3VycmVudCBzdGF0ZVwiXG4gKiAoW1tHbG9iYWxzLmN1cnJlbnRdXSBhbmQgW1tHbG9iYWxzLiRjdXJyZW50XV0pIGFuZCBcInRoZSBjdXJyZW50IHBhcmFtIHZhbHVlc1wiIChbW0dsb2JhbHMucGFyYW1zXV0pLlxuICpcbiAqIFNlZSBhbHNvIHRoZSBkZXByZWNhdGVkIHByb3BlcnRpZXM6XG4gKiBbW1N0YXRlU2VydmljZS50cmFuc2l0aW9uXV0sIFtbU3RhdGVTZXJ2aWNlLmN1cnJlbnRdXSwgW1tTdGF0ZVNlcnZpY2UucGFyYW1zXV1cbiAqL1xudmFyIHVwZGF0ZUdsb2JhbFN0YXRlID0gZnVuY3Rpb24gKHRyYW5zKSB7XG4gICAgdmFyIGdsb2JhbHMgPSB0cmFucy5yb3V0ZXIuZ2xvYmFscztcbiAgICB2YXIgdHJhbnNpdGlvblN1Y2Nlc3NmdWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGdsb2JhbHMuc3VjY2Vzc2Z1bFRyYW5zaXRpb25zLmVucXVldWUodHJhbnMpO1xuICAgICAgICBnbG9iYWxzLiRjdXJyZW50ID0gdHJhbnMuJHRvKCk7XG4gICAgICAgIGdsb2JhbHMuY3VycmVudCA9IGdsb2JhbHMuJGN1cnJlbnQuc2VsZjtcbiAgICAgICAgY29tbW9uXzEuY29weSh0cmFucy5wYXJhbXMoKSwgZ2xvYmFscy5wYXJhbXMpO1xuICAgIH07XG4gICAgdmFyIGNsZWFyQ3VycmVudFRyYW5zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIERvIG5vdCBjbGVhciBnbG9iYWxzLnRyYW5zaXRpb24gaWYgYSBkaWZmZXJlbnQgdHJhbnNpdGlvbiBoYXMgc3RhcnRlZCBpbiB0aGUgbWVhbnRpbWVcbiAgICAgICAgaWYgKGdsb2JhbHMudHJhbnNpdGlvbiA9PT0gdHJhbnMpXG4gICAgICAgICAgICBnbG9iYWxzLnRyYW5zaXRpb24gPSBudWxsO1xuICAgIH07XG4gICAgdHJhbnMub25TdWNjZXNzKHt9LCB0cmFuc2l0aW9uU3VjY2Vzc2Z1bCwgeyBwcmlvcml0eTogMTAwMDAgfSk7XG4gICAgdHJhbnMucHJvbWlzZS50aGVuKGNsZWFyQ3VycmVudFRyYW5zaXRpb24sIGNsZWFyQ3VycmVudFRyYW5zaXRpb24pO1xufTtcbmV4cG9ydHMucmVnaXN0ZXJVcGRhdGVHbG9iYWxTdGF0ZSA9IGZ1bmN0aW9uICh0cmFuc2l0aW9uU2VydmljZSkge1xuICAgIHJldHVybiB0cmFuc2l0aW9uU2VydmljZS5vbkNyZWF0ZSh7fSwgdXBkYXRlR2xvYmFsU3RhdGUpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVwZGF0ZUdsb2JhbHMuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2hvb2tzL3VwZGF0ZUdsb2JhbHMuanNcbi8vIG1vZHVsZSBpZCA9IDEyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///121\n')},function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * A [[TransitionHookFn]] which updates the URL after a successful transition\n *\n * Registered using `transitionService.onSuccess({}, updateUrl);`\n */\nvar updateUrl = function (transition) {\n    var options = transition.options();\n    var $state = transition.router.stateService;\n    var $urlRouter = transition.router.urlRouter;\n    // Dont update the url in these situations:\n    // The transition was triggered by a URL sync (options.source === 'url')\n    // The user doesn't want the url to update (options.location === false)\n    // The destination state, and all parents have no navigable url\n    if (options.source !== 'url' && options.location && $state.$current.navigable) {\n        var urlOptions = { replace: options.location === 'replace' };\n        $urlRouter.push($state.$current.navigable.url, $state.params, urlOptions);\n    }\n    $urlRouter.update(true);\n};\nexports.registerUpdateUrl = function (transitionService) {\n    return transitionService.onSuccess({}, updateUrl, { priority: 9999 });\n};\n//# sourceMappingURL=url.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9ob29rcy91cmwuanM/OWZmZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQSBbW1RyYW5zaXRpb25Ib29rRm5dXSB3aGljaCB1cGRhdGVzIHRoZSBVUkwgYWZ0ZXIgYSBzdWNjZXNzZnVsIHRyYW5zaXRpb25cbiAqXG4gKiBSZWdpc3RlcmVkIHVzaW5nIGB0cmFuc2l0aW9uU2VydmljZS5vblN1Y2Nlc3Moe30sIHVwZGF0ZVVybCk7YFxuICovXG52YXIgdXBkYXRlVXJsID0gZnVuY3Rpb24gKHRyYW5zaXRpb24pIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRyYW5zaXRpb24ub3B0aW9ucygpO1xuICAgIHZhciAkc3RhdGUgPSB0cmFuc2l0aW9uLnJvdXRlci5zdGF0ZVNlcnZpY2U7XG4gICAgdmFyICR1cmxSb3V0ZXIgPSB0cmFuc2l0aW9uLnJvdXRlci51cmxSb3V0ZXI7XG4gICAgLy8gRG9udCB1cGRhdGUgdGhlIHVybCBpbiB0aGVzZSBzaXR1YXRpb25zOlxuICAgIC8vIFRoZSB0cmFuc2l0aW9uIHdhcyB0cmlnZ2VyZWQgYnkgYSBVUkwgc3luYyAob3B0aW9ucy5zb3VyY2UgPT09ICd1cmwnKVxuICAgIC8vIFRoZSB1c2VyIGRvZXNuJ3Qgd2FudCB0aGUgdXJsIHRvIHVwZGF0ZSAob3B0aW9ucy5sb2NhdGlvbiA9PT0gZmFsc2UpXG4gICAgLy8gVGhlIGRlc3RpbmF0aW9uIHN0YXRlLCBhbmQgYWxsIHBhcmVudHMgaGF2ZSBubyBuYXZpZ2FibGUgdXJsXG4gICAgaWYgKG9wdGlvbnMuc291cmNlICE9PSAndXJsJyAmJiBvcHRpb25zLmxvY2F0aW9uICYmICRzdGF0ZS4kY3VycmVudC5uYXZpZ2FibGUpIHtcbiAgICAgICAgdmFyIHVybE9wdGlvbnMgPSB7IHJlcGxhY2U6IG9wdGlvbnMubG9jYXRpb24gPT09ICdyZXBsYWNlJyB9O1xuICAgICAgICAkdXJsUm91dGVyLnB1c2goJHN0YXRlLiRjdXJyZW50Lm5hdmlnYWJsZS51cmwsICRzdGF0ZS5wYXJhbXMsIHVybE9wdGlvbnMpO1xuICAgIH1cbiAgICAkdXJsUm91dGVyLnVwZGF0ZSh0cnVlKTtcbn07XG5leHBvcnRzLnJlZ2lzdGVyVXBkYXRlVXJsID0gZnVuY3Rpb24gKHRyYW5zaXRpb25TZXJ2aWNlKSB7XG4gICAgcmV0dXJuIHRyYW5zaXRpb25TZXJ2aWNlLm9uU3VjY2Vzcyh7fSwgdXBkYXRlVXJsLCB7IHByaW9yaXR5OiA5OTk5IH0pO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVybC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvaG9va3MvdXJsLmpzXG4vLyBtb2R1bGUgaWQgPSAxMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///122\n")},function(module,exports,__webpack_require__){"use strict";eval("\n/** @module hooks */ /** */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar trace_1 = __webpack_require__(8);\nvar rejectFactory_1 = __webpack_require__(24);\n/**\n * A [[TransitionHookFn]] that skips a transition if it should be ignored\n *\n * This hook is invoked at the end of the onBefore phase.\n *\n * If the transition should be ignored (because no parameter or states changed)\n * then the transition is ignored and not processed.\n */\nfunction ignoredHook(trans) {\n    var ignoredReason = trans._ignoredReason();\n    if (!ignoredReason)\n        return;\n    trace_1.trace.traceTransitionIgnored(trans);\n    var pending = trans.router.globals.transition;\n    // The user clicked a link going back to the *current state* ('A')\n    // However, there is also a pending transition in flight (to 'B')\n    // Abort the transition to 'B' because the user now wants to be back at 'A'.\n    if (ignoredReason === 'SameAsCurrent' && pending) {\n        pending.abort();\n    }\n    return rejectFactory_1.Rejection.ignored().toPromise();\n}\nexports.registerIgnoredTransitionHook = function (transitionService) {\n    return transitionService.onBefore({}, ignoredHook, { priority: -9999 });\n};\n//# sourceMappingURL=ignoredTransition.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9ob29rcy9pZ25vcmVkVHJhbnNpdGlvbi5qcz9jZDRiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqIEBtb2R1bGUgaG9va3MgKi8gLyoqICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHJhY2VfMSA9IHJlcXVpcmUoXCIuLi9jb21tb24vdHJhY2VcIik7XG52YXIgcmVqZWN0RmFjdG9yeV8xID0gcmVxdWlyZShcIi4uL3RyYW5zaXRpb24vcmVqZWN0RmFjdG9yeVwiKTtcbi8qKlxuICogQSBbW1RyYW5zaXRpb25Ib29rRm5dXSB0aGF0IHNraXBzIGEgdHJhbnNpdGlvbiBpZiBpdCBzaG91bGQgYmUgaWdub3JlZFxuICpcbiAqIFRoaXMgaG9vayBpcyBpbnZva2VkIGF0IHRoZSBlbmQgb2YgdGhlIG9uQmVmb3JlIHBoYXNlLlxuICpcbiAqIElmIHRoZSB0cmFuc2l0aW9uIHNob3VsZCBiZSBpZ25vcmVkIChiZWNhdXNlIG5vIHBhcmFtZXRlciBvciBzdGF0ZXMgY2hhbmdlZClcbiAqIHRoZW4gdGhlIHRyYW5zaXRpb24gaXMgaWdub3JlZCBhbmQgbm90IHByb2Nlc3NlZC5cbiAqL1xuZnVuY3Rpb24gaWdub3JlZEhvb2sodHJhbnMpIHtcbiAgICB2YXIgaWdub3JlZFJlYXNvbiA9IHRyYW5zLl9pZ25vcmVkUmVhc29uKCk7XG4gICAgaWYgKCFpZ25vcmVkUmVhc29uKVxuICAgICAgICByZXR1cm47XG4gICAgdHJhY2VfMS50cmFjZS50cmFjZVRyYW5zaXRpb25JZ25vcmVkKHRyYW5zKTtcbiAgICB2YXIgcGVuZGluZyA9IHRyYW5zLnJvdXRlci5nbG9iYWxzLnRyYW5zaXRpb247XG4gICAgLy8gVGhlIHVzZXIgY2xpY2tlZCBhIGxpbmsgZ29pbmcgYmFjayB0byB0aGUgKmN1cnJlbnQgc3RhdGUqICgnQScpXG4gICAgLy8gSG93ZXZlciwgdGhlcmUgaXMgYWxzbyBhIHBlbmRpbmcgdHJhbnNpdGlvbiBpbiBmbGlnaHQgKHRvICdCJylcbiAgICAvLyBBYm9ydCB0aGUgdHJhbnNpdGlvbiB0byAnQicgYmVjYXVzZSB0aGUgdXNlciBub3cgd2FudHMgdG8gYmUgYmFjayBhdCAnQScuXG4gICAgaWYgKGlnbm9yZWRSZWFzb24gPT09ICdTYW1lQXNDdXJyZW50JyAmJiBwZW5kaW5nKSB7XG4gICAgICAgIHBlbmRpbmcuYWJvcnQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlamVjdEZhY3RvcnlfMS5SZWplY3Rpb24uaWdub3JlZCgpLnRvUHJvbWlzZSgpO1xufVxuZXhwb3J0cy5yZWdpc3Rlcklnbm9yZWRUcmFuc2l0aW9uSG9vayA9IGZ1bmN0aW9uICh0cmFuc2l0aW9uU2VydmljZSkge1xuICAgIHJldHVybiB0cmFuc2l0aW9uU2VydmljZS5vbkJlZm9yZSh7fSwgaWdub3JlZEhvb2ssIHsgcHJpb3JpdHk6IC05OTk5IH0pO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlnbm9yZWRUcmFuc2l0aW9uLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9ob29rcy9pZ25vcmVkVHJhbnNpdGlvbi5qc1xuLy8gbW9kdWxlIGlkID0gMTIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///123\n")},function(module,exports,__webpack_require__){"use strict";eval('\n/** @module hooks */ /** */\nObject.defineProperty(exports, "__esModule", { value: true });\n/**\n * A [[TransitionHookFn]] that rejects the Transition if it is invalid\n *\n * This hook is invoked at the end of the onBefore phase.\n * If the transition is invalid (for example, param values do not validate)\n * then the transition is rejected.\n */\nfunction invalidTransitionHook(trans) {\n    if (!trans.valid()) {\n        throw new Error(trans.error());\n    }\n}\nexports.registerInvalidTransitionHook = function (transitionService) {\n    return transitionService.onBefore({}, invalidTransitionHook, { priority: -10000 });\n};\n//# sourceMappingURL=invalidTransition.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9ob29rcy9pbnZhbGlkVHJhbnNpdGlvbi5qcz84YzA0Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqIEBtb2R1bGUgaG9va3MgKi8gLyoqICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKipcbiAqIEEgW1tUcmFuc2l0aW9uSG9va0ZuXV0gdGhhdCByZWplY3RzIHRoZSBUcmFuc2l0aW9uIGlmIGl0IGlzIGludmFsaWRcbiAqXG4gKiBUaGlzIGhvb2sgaXMgaW52b2tlZCBhdCB0aGUgZW5kIG9mIHRoZSBvbkJlZm9yZSBwaGFzZS5cbiAqIElmIHRoZSB0cmFuc2l0aW9uIGlzIGludmFsaWQgKGZvciBleGFtcGxlLCBwYXJhbSB2YWx1ZXMgZG8gbm90IHZhbGlkYXRlKVxuICogdGhlbiB0aGUgdHJhbnNpdGlvbiBpcyByZWplY3RlZC5cbiAqL1xuZnVuY3Rpb24gaW52YWxpZFRyYW5zaXRpb25Ib29rKHRyYW5zKSB7XG4gICAgaWYgKCF0cmFucy52YWxpZCgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcih0cmFucy5lcnJvcigpKTtcbiAgICB9XG59XG5leHBvcnRzLnJlZ2lzdGVySW52YWxpZFRyYW5zaXRpb25Ib29rID0gZnVuY3Rpb24gKHRyYW5zaXRpb25TZXJ2aWNlKSB7XG4gICAgcmV0dXJuIHRyYW5zaXRpb25TZXJ2aWNlLm9uQmVmb3JlKHt9LCBpbnZhbGlkVHJhbnNpdGlvbkhvb2ssIHsgcHJpb3JpdHk6IC0xMDAwMCB9KTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnZhbGlkVHJhbnNpdGlvbi5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvaG9va3MvaW52YWxpZFRyYW5zaXRpb24uanNcbi8vIG1vZHVsZSBpZCA9IDEyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///124\n')},function(module,exports,__webpack_require__){"use strict";eval('\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, "__esModule", { value: true });\n/**\n * # Transition subsystem\n *\n * This module contains APIs related to a Transition.\n *\n * See:\n * - [[TransitionService]]\n * - [[Transition]]\n * - [[HookFn]], [[TransitionHookFn]], [[TransitionStateHookFn]], [[HookMatchCriteria]], [[HookResult]]\n *\n * @coreapi\n * @preferred\n * @module transition\n */ /** for typedoc */\n__export(__webpack_require__(16));\n__export(__webpack_require__(70));\n__export(__webpack_require__(44));\n__export(__webpack_require__(24));\n__export(__webpack_require__(29));\n__export(__webpack_require__(25));\n__export(__webpack_require__(87));\n__export(__webpack_require__(47));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi90cmFuc2l0aW9uL2luZGV4LmpzPzY2M2MiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiAjIFRyYW5zaXRpb24gc3Vic3lzdGVtXG4gKlxuICogVGhpcyBtb2R1bGUgY29udGFpbnMgQVBJcyByZWxhdGVkIHRvIGEgVHJhbnNpdGlvbi5cbiAqXG4gKiBTZWU6XG4gKiAtIFtbVHJhbnNpdGlvblNlcnZpY2VdXVxuICogLSBbW1RyYW5zaXRpb25dXVxuICogLSBbW0hvb2tGbl1dLCBbW1RyYW5zaXRpb25Ib29rRm5dXSwgW1tUcmFuc2l0aW9uU3RhdGVIb29rRm5dXSwgW1tIb29rTWF0Y2hDcml0ZXJpYV1dLCBbW0hvb2tSZXN1bHRdXVxuICpcbiAqIEBjb3JlYXBpXG4gKiBAcHJlZmVycmVkXG4gKiBAbW9kdWxlIHRyYW5zaXRpb25cbiAqLyAvKiogZm9yIHR5cGVkb2MgKi9cbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2ludGVyZmFjZVwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9ob29rQnVpbGRlclwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9ob29rUmVnaXN0cnlcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vcmVqZWN0RmFjdG9yeVwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi90cmFuc2l0aW9uXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3RyYW5zaXRpb25Ib29rXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3RyYW5zaXRpb25FdmVudFR5cGVcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vdHJhbnNpdGlvblNlcnZpY2VcIikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3RyYW5zaXRpb24vaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDEyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///125\n')},function(module,exports,__webpack_require__){"use strict";eval('\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, "__esModule", { value: true });\n__export(__webpack_require__(32));\n__export(__webpack_require__(80));\n__export(__webpack_require__(81));\n__export(__webpack_require__(82));\n__export(__webpack_require__(85));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi91cmwvaW5kZXguanM/ZDFjOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmZ1bmN0aW9uIF9fZXhwb3J0KG0pIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi91cmxNYXRjaGVyXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3VybE1hdGNoZXJGYWN0b3J5XCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3VybFJvdXRlclwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi91cmxSdWxlXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3VybFNlcnZpY2VcIikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL3VybC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///126\n')},function(module,exports,__webpack_require__){"use strict";eval('\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, "__esModule", { value: true });\n__export(__webpack_require__(83));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi92aWV3L2luZGV4LmpzPzBjMGMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnQocmVxdWlyZShcIi4vdmlld1wiKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvdmlldy9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTI3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///127\n')},function(module,exports,__webpack_require__){"use strict";eval('\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, "__esModule", { value: true });\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\n__export(__webpack_require__(129));\n//# sourceMappingURL=vanilla.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi92YW5pbGxhLmpzP2I3MzEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAaW50ZXJuYWxhcGlcbiAqIEBtb2R1bGUgdmFuaWxsYVxuICovXG4vKiogKi9cbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3ZhbmlsbGEvaW5kZXhcIikpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmFuaWxsYS5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvdmFuaWxsYS5qc1xuLy8gbW9kdWxlIGlkID0gMTI4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///128\n')},function(module,exports,__webpack_require__){"use strict";eval('\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, "__esModule", { value: true });\n__export(__webpack_require__(88));\n__export(__webpack_require__(89));\n__export(__webpack_require__(33));\n__export(__webpack_require__(90));\n__export(__webpack_require__(91));\n__export(__webpack_require__(92));\n__export(__webpack_require__(93));\n__export(__webpack_require__(94));\n__export(__webpack_require__(48));\n__export(__webpack_require__(130));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTI5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi92YW5pbGxhL2luZGV4LmpzPzk3NWUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnQocmVxdWlyZShcIi4vcVwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9pbmplY3RvclwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9iYXNlTG9jYXRpb25TZXJ2aWNlXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL2hhc2hMb2NhdGlvblNlcnZpY2VcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vbWVtb3J5TG9jYXRpb25TZXJ2aWNlXCIpKTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3B1c2hTdGF0ZUxvY2F0aW9uU2VydmljZVwiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9tZW1vcnlMb2NhdGlvbkNvbmZpZ1wiKSk7XG5fX2V4cG9ydChyZXF1aXJlKFwiLi9icm93c2VyTG9jYXRpb25Db25maWdcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vdXRpbHNcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vcGx1Z2luc1wiKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvdmFuaWxsYS9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///129\n')},function(module,exports,__webpack_require__){"use strict";eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @internalapi\n * @module vanilla\n */\n/** */\nvar browserLocationConfig_1 = __webpack_require__(94);\nvar hashLocationService_1 = __webpack_require__(90);\nvar utils_1 = __webpack_require__(48);\nvar pushStateLocationService_1 = __webpack_require__(92);\nvar memoryLocationService_1 = __webpack_require__(91);\nvar memoryLocationConfig_1 = __webpack_require__(93);\nvar injector_1 = __webpack_require__(89);\nvar q_1 = __webpack_require__(88);\nvar coreservices_1 = __webpack_require__(3);\nfunction servicesPlugin(router) {\n    coreservices_1.services.$injector = injector_1.$injector;\n    coreservices_1.services.$q = q_1.$q;\n    return { name: 'vanilla.services', $q: q_1.$q, $injector: injector_1.$injector, dispose: function () { return null; } };\n}\nexports.servicesPlugin = servicesPlugin;\n/** A `UIRouterPlugin` uses the browser hash to get/set the current location */\nexports.hashLocationPlugin = utils_1.locationPluginFactory('vanilla.hashBangLocation', false, hashLocationService_1.HashLocationService, browserLocationConfig_1.BrowserLocationConfig);\n/** A `UIRouterPlugin` that gets/sets the current location using the browser's `location` and `history` apis */\nexports.pushStateLocationPlugin = utils_1.locationPluginFactory('vanilla.pushStateLocation', true, pushStateLocationService_1.PushStateLocationService, browserLocationConfig_1.BrowserLocationConfig);\n/** A `UIRouterPlugin` that gets/sets the current location from an in-memory object */\nexports.memoryLocationPlugin = utils_1.locationPluginFactory('vanilla.memoryLocation', false, memoryLocationService_1.MemoryLocationService, memoryLocationConfig_1.MemoryLocationConfig);\n//# sourceMappingURL=plugins.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi92YW5pbGxhL3BsdWdpbnMuanM/MjcyNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogQGludGVybmFsYXBpXG4gKiBAbW9kdWxlIHZhbmlsbGFcbiAqL1xuLyoqICovXG52YXIgYnJvd3NlckxvY2F0aW9uQ29uZmlnXzEgPSByZXF1aXJlKFwiLi9icm93c2VyTG9jYXRpb25Db25maWdcIik7XG52YXIgaGFzaExvY2F0aW9uU2VydmljZV8xID0gcmVxdWlyZShcIi4vaGFzaExvY2F0aW9uU2VydmljZVwiKTtcbnZhciB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG52YXIgcHVzaFN0YXRlTG9jYXRpb25TZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi9wdXNoU3RhdGVMb2NhdGlvblNlcnZpY2VcIik7XG52YXIgbWVtb3J5TG9jYXRpb25TZXJ2aWNlXzEgPSByZXF1aXJlKFwiLi9tZW1vcnlMb2NhdGlvblNlcnZpY2VcIik7XG52YXIgbWVtb3J5TG9jYXRpb25Db25maWdfMSA9IHJlcXVpcmUoXCIuL21lbW9yeUxvY2F0aW9uQ29uZmlnXCIpO1xudmFyIGluamVjdG9yXzEgPSByZXF1aXJlKFwiLi9pbmplY3RvclwiKTtcbnZhciBxXzEgPSByZXF1aXJlKFwiLi9xXCIpO1xudmFyIGNvcmVzZXJ2aWNlc18xID0gcmVxdWlyZShcIi4uL2NvbW1vbi9jb3Jlc2VydmljZXNcIik7XG5mdW5jdGlvbiBzZXJ2aWNlc1BsdWdpbihyb3V0ZXIpIHtcbiAgICBjb3Jlc2VydmljZXNfMS5zZXJ2aWNlcy4kaW5qZWN0b3IgPSBpbmplY3Rvcl8xLiRpbmplY3RvcjtcbiAgICBjb3Jlc2VydmljZXNfMS5zZXJ2aWNlcy4kcSA9IHFfMS4kcTtcbiAgICByZXR1cm4geyBuYW1lOiAndmFuaWxsYS5zZXJ2aWNlcycsICRxOiBxXzEuJHEsICRpbmplY3RvcjogaW5qZWN0b3JfMS4kaW5qZWN0b3IsIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG51bGw7IH0gfTtcbn1cbmV4cG9ydHMuc2VydmljZXNQbHVnaW4gPSBzZXJ2aWNlc1BsdWdpbjtcbi8qKiBBIGBVSVJvdXRlclBsdWdpbmAgdXNlcyB0aGUgYnJvd3NlciBoYXNoIHRvIGdldC9zZXQgdGhlIGN1cnJlbnQgbG9jYXRpb24gKi9cbmV4cG9ydHMuaGFzaExvY2F0aW9uUGx1Z2luID0gdXRpbHNfMS5sb2NhdGlvblBsdWdpbkZhY3RvcnkoJ3ZhbmlsbGEuaGFzaEJhbmdMb2NhdGlvbicsIGZhbHNlLCBoYXNoTG9jYXRpb25TZXJ2aWNlXzEuSGFzaExvY2F0aW9uU2VydmljZSwgYnJvd3NlckxvY2F0aW9uQ29uZmlnXzEuQnJvd3NlckxvY2F0aW9uQ29uZmlnKTtcbi8qKiBBIGBVSVJvdXRlclBsdWdpbmAgdGhhdCBnZXRzL3NldHMgdGhlIGN1cnJlbnQgbG9jYXRpb24gdXNpbmcgdGhlIGJyb3dzZXIncyBgbG9jYXRpb25gIGFuZCBgaGlzdG9yeWAgYXBpcyAqL1xuZXhwb3J0cy5wdXNoU3RhdGVMb2NhdGlvblBsdWdpbiA9IHV0aWxzXzEubG9jYXRpb25QbHVnaW5GYWN0b3J5KCd2YW5pbGxhLnB1c2hTdGF0ZUxvY2F0aW9uJywgdHJ1ZSwgcHVzaFN0YXRlTG9jYXRpb25TZXJ2aWNlXzEuUHVzaFN0YXRlTG9jYXRpb25TZXJ2aWNlLCBicm93c2VyTG9jYXRpb25Db25maWdfMS5Ccm93c2VyTG9jYXRpb25Db25maWcpO1xuLyoqIEEgYFVJUm91dGVyUGx1Z2luYCB0aGF0IGdldHMvc2V0cyB0aGUgY3VycmVudCBsb2NhdGlvbiBmcm9tIGFuIGluLW1lbW9yeSBvYmplY3QgKi9cbmV4cG9ydHMubWVtb3J5TG9jYXRpb25QbHVnaW4gPSB1dGlsc18xLmxvY2F0aW9uUGx1Z2luRmFjdG9yeSgndmFuaWxsYS5tZW1vcnlMb2NhdGlvbicsIGZhbHNlLCBtZW1vcnlMb2NhdGlvblNlcnZpY2VfMS5NZW1vcnlMb2NhdGlvblNlcnZpY2UsIG1lbW9yeUxvY2F0aW9uQ29uZmlnXzEuTWVtb3J5TG9jYXRpb25Db25maWcpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGx1Z2lucy5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AdWlyb3V0ZXIvY29yZS9saWIvdmFuaWxsYS9wbHVnaW5zLmpzXG4vLyBtb2R1bGUgaWQgPSAxMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///130\n")},function(module,exports,__webpack_require__){"use strict";eval('\n/**\n * # Core classes and interfaces\n *\n * The classes and interfaces that are core to ui-router and do not belong\n * to a more specific subsystem (such as resolve).\n *\n * @coreapi\n * @preferred\n * @module core\n */ /** for typedoc */\nObject.defineProperty(exports, "__esModule", { value: true });\n/** @internalapi */\nvar UIRouterPluginBase = /** @class */ (function () {\n    function UIRouterPluginBase() {\n    }\n    UIRouterPluginBase.prototype.dispose = function (router) { };\n    return UIRouterPluginBase;\n}());\nexports.UIRouterPluginBase = UIRouterPluginBase;\n//# sourceMappingURL=interface.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B1aXJvdXRlci9jb3JlL2xpYi9pbnRlcmZhY2UuanM/ODc1NCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogIyBDb3JlIGNsYXNzZXMgYW5kIGludGVyZmFjZXNcbiAqXG4gKiBUaGUgY2xhc3NlcyBhbmQgaW50ZXJmYWNlcyB0aGF0IGFyZSBjb3JlIHRvIHVpLXJvdXRlciBhbmQgZG8gbm90IGJlbG9uZ1xuICogdG8gYSBtb3JlIHNwZWNpZmljIHN1YnN5c3RlbSAoc3VjaCBhcyByZXNvbHZlKS5cbiAqXG4gKiBAY29yZWFwaVxuICogQHByZWZlcnJlZFxuICogQG1vZHVsZSBjb3JlXG4gKi8gLyoqIGZvciB0eXBlZG9jICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vKiogQGludGVybmFsYXBpICovXG52YXIgVUlSb3V0ZXJQbHVnaW5CYXNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFVJUm91dGVyUGx1Z2luQmFzZSgpIHtcbiAgICB9XG4gICAgVUlSb3V0ZXJQbHVnaW5CYXNlLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKHJvdXRlcikgeyB9O1xuICAgIHJldHVybiBVSVJvdXRlclBsdWdpbkJhc2U7XG59KCkpO1xuZXhwb3J0cy5VSVJvdXRlclBsdWdpbkJhc2UgPSBVSVJvdXRlclBsdWdpbkJhc2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbnRlcmZhY2UuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHVpcm91dGVyL2NvcmUvbGliL2ludGVyZmFjZS5qc1xuLy8gbW9kdWxlIGlkID0gMTMxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///131\n')},function(module,exports,__webpack_require__){eval("__webpack_require__(133);\nmodule.exports = 'ngAnimate';\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FuZ3VsYXItYW5pbWF0ZS9pbmRleC5qcz85OTY1Il0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUoJy4vYW5ndWxhci1hbmltYXRlJyk7XG5tb2R1bGUuZXhwb3J0cyA9ICduZ0FuaW1hdGUnO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYW5ndWxhci1hbmltYXRlL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///132\n")},function(module,exports){eval("/**\n * @license AngularJS v1.6.8\n * (c) 2010-2017 Google, Inc. http://angularjs.org\n * License: MIT\n */\n(function(window, angular) {'use strict';\n\nvar ELEMENT_NODE = 1;\nvar COMMENT_NODE = 8;\n\nvar ADD_CLASS_SUFFIX = '-add';\nvar REMOVE_CLASS_SUFFIX = '-remove';\nvar EVENT_CLASS_PREFIX = 'ng-';\nvar ACTIVE_CLASS_SUFFIX = '-active';\nvar PREPARE_CLASS_SUFFIX = '-prepare';\n\nvar NG_ANIMATE_CLASSNAME = 'ng-animate';\nvar NG_ANIMATE_CHILDREN_DATA = '$$ngAnimateChildren';\n\n// Detect proper transitionend/animationend event names.\nvar CSS_PREFIX = '', TRANSITION_PROP, TRANSITIONEND_EVENT, ANIMATION_PROP, ANIMATIONEND_EVENT;\n\n// If unprefixed events are not supported but webkit-prefixed are, use the latter.\n// Otherwise, just use W3C names, browsers not supporting them at all will just ignore them.\n// Note: Chrome implements `window.onwebkitanimationend` and doesn't implement `window.onanimationend`\n// but at the same time dispatches the `animationend` event and not `webkitAnimationEnd`.\n// Register both events in case `window.onanimationend` is not supported because of that,\n// do the same for `transitionend` as Safari is likely to exhibit similar behavior.\n// Also, the only modern browser that uses vendor prefixes for transitions/keyframes is webkit\n// therefore there is no reason to test anymore for other vendor prefixes:\n// http://caniuse.com/#search=transition\nif ((window.ontransitionend === undefined) && (window.onwebkittransitionend !== undefined)) {\n  CSS_PREFIX = '-webkit-';\n  TRANSITION_PROP = 'WebkitTransition';\n  TRANSITIONEND_EVENT = 'webkitTransitionEnd transitionend';\n} else {\n  TRANSITION_PROP = 'transition';\n  TRANSITIONEND_EVENT = 'transitionend';\n}\n\nif ((window.onanimationend === undefined) && (window.onwebkitanimationend !== undefined)) {\n  CSS_PREFIX = '-webkit-';\n  ANIMATION_PROP = 'WebkitAnimation';\n  ANIMATIONEND_EVENT = 'webkitAnimationEnd animationend';\n} else {\n  ANIMATION_PROP = 'animation';\n  ANIMATIONEND_EVENT = 'animationend';\n}\n\nvar DURATION_KEY = 'Duration';\nvar PROPERTY_KEY = 'Property';\nvar DELAY_KEY = 'Delay';\nvar TIMING_KEY = 'TimingFunction';\nvar ANIMATION_ITERATION_COUNT_KEY = 'IterationCount';\nvar ANIMATION_PLAYSTATE_KEY = 'PlayState';\nvar SAFE_FAST_FORWARD_DURATION_VALUE = 9999;\n\nvar ANIMATION_DELAY_PROP = ANIMATION_PROP + DELAY_KEY;\nvar ANIMATION_DURATION_PROP = ANIMATION_PROP + DURATION_KEY;\nvar TRANSITION_DELAY_PROP = TRANSITION_PROP + DELAY_KEY;\nvar TRANSITION_DURATION_PROP = TRANSITION_PROP + DURATION_KEY;\n\nvar ngMinErr = angular.$$minErr('ng');\nfunction assertArg(arg, name, reason) {\n  if (!arg) {\n    throw ngMinErr('areq', 'Argument \\'{0}\\' is {1}', (name || '?'), (reason || 'required'));\n  }\n  return arg;\n}\n\nfunction mergeClasses(a,b) {\n  if (!a && !b) return '';\n  if (!a) return b;\n  if (!b) return a;\n  if (isArray(a)) a = a.join(' ');\n  if (isArray(b)) b = b.join(' ');\n  return a + ' ' + b;\n}\n\nfunction packageStyles(options) {\n  var styles = {};\n  if (options && (options.to || options.from)) {\n    styles.to = options.to;\n    styles.from = options.from;\n  }\n  return styles;\n}\n\nfunction pendClasses(classes, fix, isPrefix) {\n  var className = '';\n  classes = isArray(classes)\n      ? classes\n      : classes && isString(classes) && classes.length\n          ? classes.split(/\\s+/)\n          : [];\n  forEach(classes, function(klass, i) {\n    if (klass && klass.length > 0) {\n      className += (i > 0) ? ' ' : '';\n      className += isPrefix ? fix + klass\n                            : klass + fix;\n    }\n  });\n  return className;\n}\n\nfunction removeFromArray(arr, val) {\n  var index = arr.indexOf(val);\n  if (val >= 0) {\n    arr.splice(index, 1);\n  }\n}\n\nfunction stripCommentsFromElement(element) {\n  if (element instanceof jqLite) {\n    switch (element.length) {\n      case 0:\n        return element;\n\n      case 1:\n        // there is no point of stripping anything if the element\n        // is the only element within the jqLite wrapper.\n        // (it's important that we retain the element instance.)\n        if (element[0].nodeType === ELEMENT_NODE) {\n          return element;\n        }\n        break;\n\n      default:\n        return jqLite(extractElementNode(element));\n    }\n  }\n\n  if (element.nodeType === ELEMENT_NODE) {\n    return jqLite(element);\n  }\n}\n\nfunction extractElementNode(element) {\n  if (!element[0]) return element;\n  for (var i = 0; i < element.length; i++) {\n    var elm = element[i];\n    if (elm.nodeType === ELEMENT_NODE) {\n      return elm;\n    }\n  }\n}\n\nfunction $$addClass($$jqLite, element, className) {\n  forEach(element, function(elm) {\n    $$jqLite.addClass(elm, className);\n  });\n}\n\nfunction $$removeClass($$jqLite, element, className) {\n  forEach(element, function(elm) {\n    $$jqLite.removeClass(elm, className);\n  });\n}\n\nfunction applyAnimationClassesFactory($$jqLite) {\n  return function(element, options) {\n    if (options.addClass) {\n      $$addClass($$jqLite, element, options.addClass);\n      options.addClass = null;\n    }\n    if (options.removeClass) {\n      $$removeClass($$jqLite, element, options.removeClass);\n      options.removeClass = null;\n    }\n  };\n}\n\nfunction prepareAnimationOptions(options) {\n  options = options || {};\n  if (!options.$$prepared) {\n    var domOperation = options.domOperation || noop;\n    options.domOperation = function() {\n      options.$$domOperationFired = true;\n      domOperation();\n      domOperation = noop;\n    };\n    options.$$prepared = true;\n  }\n  return options;\n}\n\nfunction applyAnimationStyles(element, options) {\n  applyAnimationFromStyles(element, options);\n  applyAnimationToStyles(element, options);\n}\n\nfunction applyAnimationFromStyles(element, options) {\n  if (options.from) {\n    element.css(options.from);\n    options.from = null;\n  }\n}\n\nfunction applyAnimationToStyles(element, options) {\n  if (options.to) {\n    element.css(options.to);\n    options.to = null;\n  }\n}\n\nfunction mergeAnimationDetails(element, oldAnimation, newAnimation) {\n  var target = oldAnimation.options || {};\n  var newOptions = newAnimation.options || {};\n\n  var toAdd = (target.addClass || '') + ' ' + (newOptions.addClass || '');\n  var toRemove = (target.removeClass || '') + ' ' + (newOptions.removeClass || '');\n  var classes = resolveElementClasses(element.attr('class'), toAdd, toRemove);\n\n  if (newOptions.preparationClasses) {\n    target.preparationClasses = concatWithSpace(newOptions.preparationClasses, target.preparationClasses);\n    delete newOptions.preparationClasses;\n  }\n\n  // noop is basically when there is no callback; otherwise something has been set\n  var realDomOperation = target.domOperation !== noop ? target.domOperation : null;\n\n  extend(target, newOptions);\n\n  // TODO(matsko or sreeramu): proper fix is to maintain all animation callback in array and call at last,but now only leave has the callback so no issue with this.\n  if (realDomOperation) {\n    target.domOperation = realDomOperation;\n  }\n\n  if (classes.addClass) {\n    target.addClass = classes.addClass;\n  } else {\n    target.addClass = null;\n  }\n\n  if (classes.removeClass) {\n    target.removeClass = classes.removeClass;\n  } else {\n    target.removeClass = null;\n  }\n\n  oldAnimation.addClass = target.addClass;\n  oldAnimation.removeClass = target.removeClass;\n\n  return target;\n}\n\nfunction resolveElementClasses(existing, toAdd, toRemove) {\n  var ADD_CLASS = 1;\n  var REMOVE_CLASS = -1;\n\n  var flags = {};\n  existing = splitClassesToLookup(existing);\n\n  toAdd = splitClassesToLookup(toAdd);\n  forEach(toAdd, function(value, key) {\n    flags[key] = ADD_CLASS;\n  });\n\n  toRemove = splitClassesToLookup(toRemove);\n  forEach(toRemove, function(value, key) {\n    flags[key] = flags[key] === ADD_CLASS ? null : REMOVE_CLASS;\n  });\n\n  var classes = {\n    addClass: '',\n    removeClass: ''\n  };\n\n  forEach(flags, function(val, klass) {\n    var prop, allow;\n    if (val === ADD_CLASS) {\n      prop = 'addClass';\n      allow = !existing[klass] || existing[klass + REMOVE_CLASS_SUFFIX];\n    } else if (val === REMOVE_CLASS) {\n      prop = 'removeClass';\n      allow = existing[klass] || existing[klass + ADD_CLASS_SUFFIX];\n    }\n    if (allow) {\n      if (classes[prop].length) {\n        classes[prop] += ' ';\n      }\n      classes[prop] += klass;\n    }\n  });\n\n  function splitClassesToLookup(classes) {\n    if (isString(classes)) {\n      classes = classes.split(' ');\n    }\n\n    var obj = {};\n    forEach(classes, function(klass) {\n      // sometimes the split leaves empty string values\n      // incase extra spaces were applied to the options\n      if (klass.length) {\n        obj[klass] = true;\n      }\n    });\n    return obj;\n  }\n\n  return classes;\n}\n\nfunction getDomNode(element) {\n  return (element instanceof jqLite) ? element[0] : element;\n}\n\nfunction applyGeneratedPreparationClasses(element, event, options) {\n  var classes = '';\n  if (event) {\n    classes = pendClasses(event, EVENT_CLASS_PREFIX, true);\n  }\n  if (options.addClass) {\n    classes = concatWithSpace(classes, pendClasses(options.addClass, ADD_CLASS_SUFFIX));\n  }\n  if (options.removeClass) {\n    classes = concatWithSpace(classes, pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX));\n  }\n  if (classes.length) {\n    options.preparationClasses = classes;\n    element.addClass(classes);\n  }\n}\n\nfunction clearGeneratedClasses(element, options) {\n  if (options.preparationClasses) {\n    element.removeClass(options.preparationClasses);\n    options.preparationClasses = null;\n  }\n  if (options.activeClasses) {\n    element.removeClass(options.activeClasses);\n    options.activeClasses = null;\n  }\n}\n\nfunction blockTransitions(node, duration) {\n  // we use a negative delay value since it performs blocking\n  // yet it doesn't kill any existing transitions running on the\n  // same element which makes this safe for class-based animations\n  var value = duration ? '-' + duration + 's' : '';\n  applyInlineStyle(node, [TRANSITION_DELAY_PROP, value]);\n  return [TRANSITION_DELAY_PROP, value];\n}\n\nfunction blockKeyframeAnimations(node, applyBlock) {\n  var value = applyBlock ? 'paused' : '';\n  var key = ANIMATION_PROP + ANIMATION_PLAYSTATE_KEY;\n  applyInlineStyle(node, [key, value]);\n  return [key, value];\n}\n\nfunction applyInlineStyle(node, styleTuple) {\n  var prop = styleTuple[0];\n  var value = styleTuple[1];\n  node.style[prop] = value;\n}\n\nfunction concatWithSpace(a,b) {\n  if (!a) return b;\n  if (!b) return a;\n  return a + ' ' + b;\n}\n\nvar $$rAFSchedulerFactory = ['$$rAF', function($$rAF) {\n  var queue, cancelFn;\n\n  function scheduler(tasks) {\n    // we make a copy since RAFScheduler mutates the state\n    // of the passed in array variable and this would be difficult\n    // to track down on the outside code\n    queue = queue.concat(tasks);\n    nextTick();\n  }\n\n  queue = scheduler.queue = [];\n\n  /* waitUntilQuiet does two things:\n   * 1. It will run the FINAL `fn` value only when an uncanceled RAF has passed through\n   * 2. It will delay the next wave of tasks from running until the quiet `fn` has run.\n   *\n   * The motivation here is that animation code can request more time from the scheduler\n   * before the next wave runs. This allows for certain DOM properties such as classes to\n   * be resolved in time for the next animation to run.\n   */\n  scheduler.waitUntilQuiet = function(fn) {\n    if (cancelFn) cancelFn();\n\n    cancelFn = $$rAF(function() {\n      cancelFn = null;\n      fn();\n      nextTick();\n    });\n  };\n\n  return scheduler;\n\n  function nextTick() {\n    if (!queue.length) return;\n\n    var items = queue.shift();\n    for (var i = 0; i < items.length; i++) {\n      items[i]();\n    }\n\n    if (!cancelFn) {\n      $$rAF(function() {\n        if (!cancelFn) nextTick();\n      });\n    }\n  }\n}];\n\n/**\n * @ngdoc directive\n * @name ngAnimateChildren\n * @restrict AE\n * @element ANY\n *\n * @description\n *\n * ngAnimateChildren allows you to specify that children of this element should animate even if any\n * of the children's parents are currently animating. By default, when an element has an active `enter`, `leave`, or `move`\n * (structural) animation, child elements that also have an active structural animation are not animated.\n *\n * Note that even if `ngAnimateChildren` is set, no child animations will run when the parent element is removed from the DOM (`leave` animation).\n *\n *\n * @param {string} ngAnimateChildren If the value is empty, `true` or `on`,\n *     then child animations are allowed. If the value is `false`, child animations are not allowed.\n *\n * @example\n * <example module=\"ngAnimateChildren\" name=\"ngAnimateChildren\" deps=\"angular-animate.js\" animations=\"true\">\n     <file name=\"index.html\">\n       <div ng-controller=\"MainController as main\">\n         <label>Show container? <input type=\"checkbox\" ng-model=\"main.enterElement\" /></label>\n         <label>Animate children? <input type=\"checkbox\" ng-model=\"main.animateChildren\" /></label>\n         <hr>\n         <div ng-animate-children=\"{{main.animateChildren}}\">\n           <div ng-if=\"main.enterElement\" class=\"container\">\n             List of items:\n             <div ng-repeat=\"item in [0, 1, 2, 3]\" class=\"item\">Item {{item}}</div>\n           </div>\n         </div>\n       </div>\n     </file>\n     <file name=\"animations.css\">\n\n      .container.ng-enter,\n      .container.ng-leave {\n        transition: all ease 1.5s;\n      }\n\n      .container.ng-enter,\n      .container.ng-leave-active {\n        opacity: 0;\n      }\n\n      .container.ng-leave,\n      .container.ng-enter-active {\n        opacity: 1;\n      }\n\n      .item {\n        background: firebrick;\n        color: #FFF;\n        margin-bottom: 10px;\n      }\n\n      .item.ng-enter,\n      .item.ng-leave {\n        transition: transform 1.5s ease;\n      }\n\n      .item.ng-enter {\n        transform: translateX(50px);\n      }\n\n      .item.ng-enter-active {\n        transform: translateX(0);\n      }\n    </file>\n    <file name=\"script.js\">\n      angular.module('ngAnimateChildren', ['ngAnimate'])\n        .controller('MainController', function MainController() {\n          this.animateChildren = false;\n          this.enterElement = false;\n        });\n    </file>\n  </example>\n */\nvar $$AnimateChildrenDirective = ['$interpolate', function($interpolate) {\n  return {\n    link: function(scope, element, attrs) {\n      var val = attrs.ngAnimateChildren;\n      if (isString(val) && val.length === 0) { //empty attribute\n        element.data(NG_ANIMATE_CHILDREN_DATA, true);\n      } else {\n        // Interpolate and set the value, so that it is available to\n        // animations that run right after compilation\n        setData($interpolate(val)(scope));\n        attrs.$observe('ngAnimateChildren', setData);\n      }\n\n      function setData(value) {\n        value = value === 'on' || value === 'true';\n        element.data(NG_ANIMATE_CHILDREN_DATA, value);\n      }\n    }\n  };\n}];\n\n/* exported $AnimateCssProvider */\n\nvar ANIMATE_TIMER_KEY = '$$animateCss';\n\n/**\n * @ngdoc service\n * @name $animateCss\n * @kind object\n *\n * @description\n * The `$animateCss` service is a useful utility to trigger customized CSS-based transitions/keyframes\n * from a JavaScript-based animation or directly from a directive. The purpose of `$animateCss` is NOT\n * to side-step how `$animate` and ngAnimate work, but the goal is to allow pre-existing animations or\n * directives to create more complex animations that can be purely driven using CSS code.\n *\n * Note that only browsers that support CSS transitions and/or keyframe animations are capable of\n * rendering animations triggered via `$animateCss` (bad news for IE9 and lower).\n *\n * ## General Use\n * Once again, `$animateCss` is designed to be used inside of a registered JavaScript animation that\n * is powered by ngAnimate. It is possible to use `$animateCss` directly inside of a directive, however,\n * any automatic control over cancelling animations and/or preventing animations from being run on\n * child elements will not be handled by Angular. For this to work as expected, please use `$animate` to\n * trigger the animation and then setup a JavaScript animation that injects `$animateCss` to trigger\n * the CSS animation.\n *\n * The example below shows how we can create a folding animation on an element using `ng-if`:\n *\n * ```html\n * \x3c!-- notice the `fold-animation` CSS class --\x3e\n * <div ng-if=\"onOff\" class=\"fold-animation\">\n *   This element will go BOOM\n * </div>\n * <button ng-click=\"onOff=true\">Fold In</button>\n * ```\n *\n * Now we create the **JavaScript animation** that will trigger the CSS transition:\n *\n * ```js\n * ngModule.animation('.fold-animation', ['$animateCss', function($animateCss) {\n *   return {\n *     enter: function(element, doneFn) {\n *       var height = element[0].offsetHeight;\n *       return $animateCss(element, {\n *         from: { height:'0px' },\n *         to: { height:height + 'px' },\n *         duration: 1 // one second\n *       });\n *     }\n *   }\n * }]);\n * ```\n *\n * ## More Advanced Uses\n *\n * `$animateCss` is the underlying code that ngAnimate uses to power **CSS-based animations** behind the scenes. Therefore CSS hooks\n * like `.ng-EVENT`, `.ng-EVENT-active`, `.ng-EVENT-stagger` are all features that can be triggered using `$animateCss` via JavaScript code.\n *\n * This also means that just about any combination of adding classes, removing classes, setting styles, dynamically setting a keyframe animation,\n * applying a hardcoded duration or delay value, changing the animation easing or applying a stagger animation are all options that work with\n * `$animateCss`. The service itself is smart enough to figure out the combination of options and examine the element styling properties in order\n * to provide a working animation that will run in CSS.\n *\n * The example below showcases a more advanced version of the `.fold-animation` from the example above:\n *\n * ```js\n * ngModule.animation('.fold-animation', ['$animateCss', function($animateCss) {\n *   return {\n *     enter: function(element, doneFn) {\n *       var height = element[0].offsetHeight;\n *       return $animateCss(element, {\n *         addClass: 'red large-text pulse-twice',\n *         easing: 'ease-out',\n *         from: { height:'0px' },\n *         to: { height:height + 'px' },\n *         duration: 1 // one second\n *       });\n *     }\n *   }\n * }]);\n * ```\n *\n * Since we're adding/removing CSS classes then the CSS transition will also pick those up:\n *\n * ```css\n * /&#42; since a hardcoded duration value of 1 was provided in the JavaScript animation code,\n * the CSS classes below will be transitioned despite them being defined as regular CSS classes &#42;/\n * .red { background:red; }\n * .large-text { font-size:20px; }\n *\n * /&#42; we can also use a keyframe animation and $animateCss will make it work alongside the transition &#42;/\n * .pulse-twice {\n *   animation: 0.5s pulse linear 2;\n *   -webkit-animation: 0.5s pulse linear 2;\n * }\n *\n * @keyframes pulse {\n *   from { transform: scale(0.5); }\n *   to { transform: scale(1.5); }\n * }\n *\n * @-webkit-keyframes pulse {\n *   from { -webkit-transform: scale(0.5); }\n *   to { -webkit-transform: scale(1.5); }\n * }\n * ```\n *\n * Given this complex combination of CSS classes, styles and options, `$animateCss` will figure everything out and make the animation happen.\n *\n * ## How the Options are handled\n *\n * `$animateCss` is very versatile and intelligent when it comes to figuring out what configurations to apply to the element to ensure the animation\n * works with the options provided. Say for example we were adding a class that contained a keyframe value and we wanted to also animate some inline\n * styles using the `from` and `to` properties.\n *\n * ```js\n * var animator = $animateCss(element, {\n *   from: { background:'red' },\n *   to: { background:'blue' }\n * });\n * animator.start();\n * ```\n *\n * ```css\n * .rotating-animation {\n *   animation:0.5s rotate linear;\n *   -webkit-animation:0.5s rotate linear;\n * }\n *\n * @keyframes rotate {\n *   from { transform: rotate(0deg); }\n *   to { transform: rotate(360deg); }\n * }\n *\n * @-webkit-keyframes rotate {\n *   from { -webkit-transform: rotate(0deg); }\n *   to { -webkit-transform: rotate(360deg); }\n * }\n * ```\n *\n * The missing pieces here are that we do not have a transition set (within the CSS code nor within the `$animateCss` options) and the duration of the animation is\n * going to be detected from what the keyframe styles on the CSS class are. In this event, `$animateCss` will automatically create an inline transition\n * style matching the duration detected from the keyframe style (which is present in the CSS class that is being added) and then prepare both the transition\n * and keyframe animations to run in parallel on the element. Then when the animation is underway the provided `from` and `to` CSS styles will be applied\n * and spread across the transition and keyframe animation.\n *\n * ## What is returned\n *\n * `$animateCss` works in two stages: a preparation phase and an animation phase. Therefore when `$animateCss` is first called it will NOT actually\n * start the animation. All that is going on here is that the element is being prepared for the animation (which means that the generated CSS classes are\n * added and removed on the element). Once `$animateCss` is called it will return an object with the following properties:\n *\n * ```js\n * var animator = $animateCss(element, { ... });\n * ```\n *\n * Now what do the contents of our `animator` variable look like:\n *\n * ```js\n * {\n *   // starts the animation\n *   start: Function,\n *\n *   // ends (aborts) the animation\n *   end: Function\n * }\n * ```\n *\n * To actually start the animation we need to run `animation.start()` which will then return a promise that we can hook into to detect when the animation ends.\n * If we choose not to run the animation then we MUST run `animation.end()` to perform a cleanup on the element (since some CSS classes and styles may have been\n * applied to the element during the preparation phase). Note that all other properties such as duration, delay, transitions and keyframes are just properties\n * and that changing them will not reconfigure the parameters of the animation.\n *\n * ### runner.done() vs runner.then()\n * It is documented that `animation.start()` will return a promise object and this is true, however, there is also an additional method available on the\n * runner called `.done(callbackFn)`. The done method works the same as `.finally(callbackFn)`, however, it does **not trigger a digest to occur**.\n * Therefore, for performance reasons, it's always best to use `runner.done(callback)` instead of `runner.then()`, `runner.catch()` or `runner.finally()`\n * unless you really need a digest to kick off afterwards.\n *\n * Keep in mind that, to make this easier, ngAnimate has tweaked the JS animations API to recognize when a runner instance is returned from $animateCss\n * (so there is no need to call `runner.done(doneFn)` inside of your JavaScript animation code).\n * Check the {@link ngAnimate.$animateCss#usage animation code above} to see how this works.\n *\n * @param {DOMElement} element the element that will be animated\n * @param {object} options the animation-related options that will be applied during the animation\n *\n * * `event` - The DOM event (e.g. enter, leave, move). When used, a generated CSS class of `ng-EVENT` and `ng-EVENT-active` will be applied\n * to the element during the animation. Multiple events can be provided when spaces are used as a separator. (Note that this will not perform any DOM operation.)\n * * `structural` - Indicates that the `ng-` prefix will be added to the event class. Setting to `false` or omitting will turn `ng-EVENT` and\n * `ng-EVENT-active` in `EVENT` and `EVENT-active`. Unused if `event` is omitted.\n * * `easing` - The CSS easing value that will be applied to the transition or keyframe animation (or both).\n * * `transitionStyle` - The raw CSS transition style that will be used (e.g. `1s linear all`).\n * * `keyframeStyle` - The raw CSS keyframe animation style that will be used (e.g. `1s my_animation linear`).\n * * `from` - The starting CSS styles (a key/value object) that will be applied at the start of the animation.\n * * `to` - The ending CSS styles (a key/value object) that will be applied across the animation via a CSS transition.\n * * `addClass` - A space separated list of CSS classes that will be added to the element and spread across the animation.\n * * `removeClass` - A space separated list of CSS classes that will be removed from the element and spread across the animation.\n * * `duration` - A number value representing the total duration of the transition and/or keyframe (note that a value of 1 is 1000ms). If a value of `0`\n * is provided then the animation will be skipped entirely.\n * * `delay` - A number value representing the total delay of the transition and/or keyframe (note that a value of 1 is 1000ms). If a value of `true` is\n * used then whatever delay value is detected from the CSS classes will be mirrored on the elements styles (e.g. by setting delay true then the style value\n * of the element will be `transition-delay: DETECTED_VALUE`). Using `true` is useful when you want the CSS classes and inline styles to all share the same\n * CSS delay value.\n * * `stagger` - A numeric time value representing the delay between successively animated elements\n * ({@link ngAnimate#css-staggering-animations Click here to learn how CSS-based staggering works in ngAnimate.})\n * * `staggerIndex` - The numeric index representing the stagger item (e.g. a value of 5 is equal to the sixth item in the stagger; therefore when a\n *   `stagger` option value of `0.1` is used then there will be a stagger delay of `600ms`)\n * * `applyClassesEarly` - Whether or not the classes being added or removed will be used when detecting the animation. This is set by `$animate` when enter/leave/move animations are fired to ensure that the CSS classes are resolved in time. (Note that this will prevent any transitions from occurring on the classes being added and removed.)\n * * `cleanupStyles` - Whether or not the provided `from` and `to` styles will be removed once\n *    the animation is closed. This is useful for when the styles are used purely for the sake of\n *    the animation and do not have a lasting visual effect on the element (e.g. a collapse and open animation).\n *    By default this value is set to `false`.\n *\n * @return {object} an object with start and end methods and details about the animation.\n *\n * * `start` - The method to start the animation. This will return a `Promise` when called.\n * * `end` - This method will cancel the animation and remove all applied CSS classes and styles.\n */\nvar ONE_SECOND = 1000;\n\nvar ELAPSED_TIME_MAX_DECIMAL_PLACES = 3;\nvar CLOSING_TIME_BUFFER = 1.5;\n\nvar DETECT_CSS_PROPERTIES = {\n  transitionDuration:      TRANSITION_DURATION_PROP,\n  transitionDelay:         TRANSITION_DELAY_PROP,\n  transitionProperty:      TRANSITION_PROP + PROPERTY_KEY,\n  animationDuration:       ANIMATION_DURATION_PROP,\n  animationDelay:          ANIMATION_DELAY_PROP,\n  animationIterationCount: ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY\n};\n\nvar DETECT_STAGGER_CSS_PROPERTIES = {\n  transitionDuration:      TRANSITION_DURATION_PROP,\n  transitionDelay:         TRANSITION_DELAY_PROP,\n  animationDuration:       ANIMATION_DURATION_PROP,\n  animationDelay:          ANIMATION_DELAY_PROP\n};\n\nfunction getCssKeyframeDurationStyle(duration) {\n  return [ANIMATION_DURATION_PROP, duration + 's'];\n}\n\nfunction getCssDelayStyle(delay, isKeyframeAnimation) {\n  var prop = isKeyframeAnimation ? ANIMATION_DELAY_PROP : TRANSITION_DELAY_PROP;\n  return [prop, delay + 's'];\n}\n\nfunction computeCssStyles($window, element, properties) {\n  var styles = Object.create(null);\n  var detectedStyles = $window.getComputedStyle(element) || {};\n  forEach(properties, function(formalStyleName, actualStyleName) {\n    var val = detectedStyles[formalStyleName];\n    if (val) {\n      var c = val.charAt(0);\n\n      // only numerical-based values have a negative sign or digit as the first value\n      if (c === '-' || c === '+' || c >= 0) {\n        val = parseMaxTime(val);\n      }\n\n      // by setting this to null in the event that the delay is not set or is set directly as 0\n      // then we can still allow for negative values to be used later on and not mistake this\n      // value for being greater than any other negative value.\n      if (val === 0) {\n        val = null;\n      }\n      styles[actualStyleName] = val;\n    }\n  });\n\n  return styles;\n}\n\nfunction parseMaxTime(str) {\n  var maxValue = 0;\n  var values = str.split(/\\s*,\\s*/);\n  forEach(values, function(value) {\n    // it's always safe to consider only second values and omit `ms` values since\n    // getComputedStyle will always handle the conversion for us\n    if (value.charAt(value.length - 1) === 's') {\n      value = value.substring(0, value.length - 1);\n    }\n    value = parseFloat(value) || 0;\n    maxValue = maxValue ? Math.max(value, maxValue) : value;\n  });\n  return maxValue;\n}\n\nfunction truthyTimingValue(val) {\n  return val === 0 || val != null;\n}\n\nfunction getCssTransitionDurationStyle(duration, applyOnlyDuration) {\n  var style = TRANSITION_PROP;\n  var value = duration + 's';\n  if (applyOnlyDuration) {\n    style += DURATION_KEY;\n  } else {\n    value += ' linear all';\n  }\n  return [style, value];\n}\n\nfunction createLocalCacheLookup() {\n  var cache = Object.create(null);\n  return {\n    flush: function() {\n      cache = Object.create(null);\n    },\n\n    count: function(key) {\n      var entry = cache[key];\n      return entry ? entry.total : 0;\n    },\n\n    get: function(key) {\n      var entry = cache[key];\n      return entry && entry.value;\n    },\n\n    put: function(key, value) {\n      if (!cache[key]) {\n        cache[key] = { total: 1, value: value };\n      } else {\n        cache[key].total++;\n      }\n    }\n  };\n}\n\n// we do not reassign an already present style value since\n// if we detect the style property value again we may be\n// detecting styles that were added via the `from` styles.\n// We make use of `isDefined` here since an empty string\n// or null value (which is what getPropertyValue will return\n// for a non-existing style) will still be marked as a valid\n// value for the style (a falsy value implies that the style\n// is to be removed at the end of the animation). If we had a simple\n// \"OR\" statement then it would not be enough to catch that.\nfunction registerRestorableStyles(backup, node, properties) {\n  forEach(properties, function(prop) {\n    backup[prop] = isDefined(backup[prop])\n        ? backup[prop]\n        : node.style.getPropertyValue(prop);\n  });\n}\n\nvar $AnimateCssProvider = ['$animateProvider', /** @this */ function($animateProvider) {\n  var gcsLookup = createLocalCacheLookup();\n  var gcsStaggerLookup = createLocalCacheLookup();\n\n  this.$get = ['$window', '$$jqLite', '$$AnimateRunner', '$timeout',\n               '$$forceReflow', '$sniffer', '$$rAFScheduler', '$$animateQueue',\n       function($window,   $$jqLite,   $$AnimateRunner,   $timeout,\n                $$forceReflow,   $sniffer,   $$rAFScheduler, $$animateQueue) {\n\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\n    var parentCounter = 0;\n    function gcsHashFn(node, extraClasses) {\n      var KEY = '$$ngAnimateParentKey';\n      var parentNode = node.parentNode;\n      var parentID = parentNode[KEY] || (parentNode[KEY] = ++parentCounter);\n      return parentID + '-' + node.getAttribute('class') + '-' + extraClasses;\n    }\n\n    function computeCachedCssStyles(node, className, cacheKey, properties) {\n      var timings = gcsLookup.get(cacheKey);\n\n      if (!timings) {\n        timings = computeCssStyles($window, node, properties);\n        if (timings.animationIterationCount === 'infinite') {\n          timings.animationIterationCount = 1;\n        }\n      }\n\n      // we keep putting this in multiple times even though the value and the cacheKey are the same\n      // because we're keeping an internal tally of how many duplicate animations are detected.\n      gcsLookup.put(cacheKey, timings);\n      return timings;\n    }\n\n    function computeCachedCssStaggerStyles(node, className, cacheKey, properties) {\n      var stagger;\n\n      // if we have one or more existing matches of matching elements\n      // containing the same parent + CSS styles (which is how cacheKey works)\n      // then staggering is possible\n      if (gcsLookup.count(cacheKey) > 0) {\n        stagger = gcsStaggerLookup.get(cacheKey);\n\n        if (!stagger) {\n          var staggerClassName = pendClasses(className, '-stagger');\n\n          $$jqLite.addClass(node, staggerClassName);\n\n          stagger = computeCssStyles($window, node, properties);\n\n          // force the conversion of a null value to zero incase not set\n          stagger.animationDuration = Math.max(stagger.animationDuration, 0);\n          stagger.transitionDuration = Math.max(stagger.transitionDuration, 0);\n\n          $$jqLite.removeClass(node, staggerClassName);\n\n          gcsStaggerLookup.put(cacheKey, stagger);\n        }\n      }\n\n      return stagger || {};\n    }\n\n    var rafWaitQueue = [];\n    function waitUntilQuiet(callback) {\n      rafWaitQueue.push(callback);\n      $$rAFScheduler.waitUntilQuiet(function() {\n        gcsLookup.flush();\n        gcsStaggerLookup.flush();\n\n        // DO NOT REMOVE THIS LINE OR REFACTOR OUT THE `pageWidth` variable.\n        // PLEASE EXAMINE THE `$$forceReflow` service to understand why.\n        var pageWidth = $$forceReflow();\n\n        // we use a for loop to ensure that if the queue is changed\n        // during this looping then it will consider new requests\n        for (var i = 0; i < rafWaitQueue.length; i++) {\n          rafWaitQueue[i](pageWidth);\n        }\n        rafWaitQueue.length = 0;\n      });\n    }\n\n    function computeTimings(node, className, cacheKey) {\n      var timings = computeCachedCssStyles(node, className, cacheKey, DETECT_CSS_PROPERTIES);\n      var aD = timings.animationDelay;\n      var tD = timings.transitionDelay;\n      timings.maxDelay = aD && tD\n          ? Math.max(aD, tD)\n          : (aD || tD);\n      timings.maxDuration = Math.max(\n          timings.animationDuration * timings.animationIterationCount,\n          timings.transitionDuration);\n\n      return timings;\n    }\n\n    return function init(element, initialOptions) {\n      // all of the animation functions should create\n      // a copy of the options data, however, if a\n      // parent service has already created a copy then\n      // we should stick to using that\n      var options = initialOptions || {};\n      if (!options.$$prepared) {\n        options = prepareAnimationOptions(copy(options));\n      }\n\n      var restoreStyles = {};\n      var node = getDomNode(element);\n      if (!node\n          || !node.parentNode\n          || !$$animateQueue.enabled()) {\n        return closeAndReturnNoopAnimator();\n      }\n\n      var temporaryStyles = [];\n      var classes = element.attr('class');\n      var styles = packageStyles(options);\n      var animationClosed;\n      var animationPaused;\n      var animationCompleted;\n      var runner;\n      var runnerHost;\n      var maxDelay;\n      var maxDelayTime;\n      var maxDuration;\n      var maxDurationTime;\n      var startTime;\n      var events = [];\n\n      if (options.duration === 0 || (!$sniffer.animations && !$sniffer.transitions)) {\n        return closeAndReturnNoopAnimator();\n      }\n\n      var method = options.event && isArray(options.event)\n            ? options.event.join(' ')\n            : options.event;\n\n      var isStructural = method && options.structural;\n      var structuralClassName = '';\n      var addRemoveClassName = '';\n\n      if (isStructural) {\n        structuralClassName = pendClasses(method, EVENT_CLASS_PREFIX, true);\n      } else if (method) {\n        structuralClassName = method;\n      }\n\n      if (options.addClass) {\n        addRemoveClassName += pendClasses(options.addClass, ADD_CLASS_SUFFIX);\n      }\n\n      if (options.removeClass) {\n        if (addRemoveClassName.length) {\n          addRemoveClassName += ' ';\n        }\n        addRemoveClassName += pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX);\n      }\n\n      // there may be a situation where a structural animation is combined together\n      // with CSS classes that need to resolve before the animation is computed.\n      // However this means that there is no explicit CSS code to block the animation\n      // from happening (by setting 0s none in the class name). If this is the case\n      // we need to apply the classes before the first rAF so we know to continue if\n      // there actually is a detected transition or keyframe animation\n      if (options.applyClassesEarly && addRemoveClassName.length) {\n        applyAnimationClasses(element, options);\n      }\n\n      var preparationClasses = [structuralClassName, addRemoveClassName].join(' ').trim();\n      var fullClassName = classes + ' ' + preparationClasses;\n      var activeClasses = pendClasses(preparationClasses, ACTIVE_CLASS_SUFFIX);\n      var hasToStyles = styles.to && Object.keys(styles.to).length > 0;\n      var containsKeyframeAnimation = (options.keyframeStyle || '').length > 0;\n\n      // there is no way we can trigger an animation if no styles and\n      // no classes are being applied which would then trigger a transition,\n      // unless there a is raw keyframe value that is applied to the element.\n      if (!containsKeyframeAnimation\n           && !hasToStyles\n           && !preparationClasses) {\n        return closeAndReturnNoopAnimator();\n      }\n\n      var cacheKey, stagger;\n      if (options.stagger > 0) {\n        var staggerVal = parseFloat(options.stagger);\n        stagger = {\n          transitionDelay: staggerVal,\n          animationDelay: staggerVal,\n          transitionDuration: 0,\n          animationDuration: 0\n        };\n      } else {\n        cacheKey = gcsHashFn(node, fullClassName);\n        stagger = computeCachedCssStaggerStyles(node, preparationClasses, cacheKey, DETECT_STAGGER_CSS_PROPERTIES);\n      }\n\n      if (!options.$$skipPreparationClasses) {\n        $$jqLite.addClass(element, preparationClasses);\n      }\n\n      var applyOnlyDuration;\n\n      if (options.transitionStyle) {\n        var transitionStyle = [TRANSITION_PROP, options.transitionStyle];\n        applyInlineStyle(node, transitionStyle);\n        temporaryStyles.push(transitionStyle);\n      }\n\n      if (options.duration >= 0) {\n        applyOnlyDuration = node.style[TRANSITION_PROP].length > 0;\n        var durationStyle = getCssTransitionDurationStyle(options.duration, applyOnlyDuration);\n\n        // we set the duration so that it will be picked up by getComputedStyle later\n        applyInlineStyle(node, durationStyle);\n        temporaryStyles.push(durationStyle);\n      }\n\n      if (options.keyframeStyle) {\n        var keyframeStyle = [ANIMATION_PROP, options.keyframeStyle];\n        applyInlineStyle(node, keyframeStyle);\n        temporaryStyles.push(keyframeStyle);\n      }\n\n      var itemIndex = stagger\n          ? options.staggerIndex >= 0\n              ? options.staggerIndex\n              : gcsLookup.count(cacheKey)\n          : 0;\n\n      var isFirst = itemIndex === 0;\n\n      // this is a pre-emptive way of forcing the setup classes to be added and applied INSTANTLY\n      // without causing any combination of transitions to kick in. By adding a negative delay value\n      // it forces the setup class' transition to end immediately. We later then remove the negative\n      // transition delay to allow for the transition to naturally do it's thing. The beauty here is\n      // that if there is no transition defined then nothing will happen and this will also allow\n      // other transitions to be stacked on top of each other without any chopping them out.\n      if (isFirst && !options.skipBlocking) {\n        blockTransitions(node, SAFE_FAST_FORWARD_DURATION_VALUE);\n      }\n\n      var timings = computeTimings(node, fullClassName, cacheKey);\n      var relativeDelay = timings.maxDelay;\n      maxDelay = Math.max(relativeDelay, 0);\n      maxDuration = timings.maxDuration;\n\n      var flags = {};\n      flags.hasTransitions          = timings.transitionDuration > 0;\n      flags.hasAnimations           = timings.animationDuration > 0;\n      flags.hasTransitionAll        = flags.hasTransitions && timings.transitionProperty === 'all';\n      flags.applyTransitionDuration = hasToStyles && (\n                                        (flags.hasTransitions && !flags.hasTransitionAll)\n                                         || (flags.hasAnimations && !flags.hasTransitions));\n      flags.applyAnimationDuration  = options.duration && flags.hasAnimations;\n      flags.applyTransitionDelay    = truthyTimingValue(options.delay) && (flags.applyTransitionDuration || flags.hasTransitions);\n      flags.applyAnimationDelay     = truthyTimingValue(options.delay) && flags.hasAnimations;\n      flags.recalculateTimingStyles = addRemoveClassName.length > 0;\n\n      if (flags.applyTransitionDuration || flags.applyAnimationDuration) {\n        maxDuration = options.duration ? parseFloat(options.duration) : maxDuration;\n\n        if (flags.applyTransitionDuration) {\n          flags.hasTransitions = true;\n          timings.transitionDuration = maxDuration;\n          applyOnlyDuration = node.style[TRANSITION_PROP + PROPERTY_KEY].length > 0;\n          temporaryStyles.push(getCssTransitionDurationStyle(maxDuration, applyOnlyDuration));\n        }\n\n        if (flags.applyAnimationDuration) {\n          flags.hasAnimations = true;\n          timings.animationDuration = maxDuration;\n          temporaryStyles.push(getCssKeyframeDurationStyle(maxDuration));\n        }\n      }\n\n      if (maxDuration === 0 && !flags.recalculateTimingStyles) {\n        return closeAndReturnNoopAnimator();\n      }\n\n      if (options.delay != null) {\n        var delayStyle;\n        if (typeof options.delay !== 'boolean') {\n          delayStyle = parseFloat(options.delay);\n          // number in options.delay means we have to recalculate the delay for the closing timeout\n          maxDelay = Math.max(delayStyle, 0);\n        }\n\n        if (flags.applyTransitionDelay) {\n          temporaryStyles.push(getCssDelayStyle(delayStyle));\n        }\n\n        if (flags.applyAnimationDelay) {\n          temporaryStyles.push(getCssDelayStyle(delayStyle, true));\n        }\n      }\n\n      // we need to recalculate the delay value since we used a pre-emptive negative\n      // delay value and the delay value is required for the final event checking. This\n      // property will ensure that this will happen after the RAF phase has passed.\n      if (options.duration == null && timings.transitionDuration > 0) {\n        flags.recalculateTimingStyles = flags.recalculateTimingStyles || isFirst;\n      }\n\n      maxDelayTime = maxDelay * ONE_SECOND;\n      maxDurationTime = maxDuration * ONE_SECOND;\n      if (!options.skipBlocking) {\n        flags.blockTransition = timings.transitionDuration > 0;\n        flags.blockKeyframeAnimation = timings.animationDuration > 0 &&\n                                       stagger.animationDelay > 0 &&\n                                       stagger.animationDuration === 0;\n      }\n\n      if (options.from) {\n        if (options.cleanupStyles) {\n          registerRestorableStyles(restoreStyles, node, Object.keys(options.from));\n        }\n        applyAnimationFromStyles(element, options);\n      }\n\n      if (flags.blockTransition || flags.blockKeyframeAnimation) {\n        applyBlocking(maxDuration);\n      } else if (!options.skipBlocking) {\n        blockTransitions(node, false);\n      }\n\n      // TODO(matsko): for 1.5 change this code to have an animator object for better debugging\n      return {\n        $$willAnimate: true,\n        end: endFn,\n        start: function() {\n          if (animationClosed) return;\n\n          runnerHost = {\n            end: endFn,\n            cancel: cancelFn,\n            resume: null, //this will be set during the start() phase\n            pause: null\n          };\n\n          runner = new $$AnimateRunner(runnerHost);\n\n          waitUntilQuiet(start);\n\n          // we don't have access to pause/resume the animation\n          // since it hasn't run yet. AnimateRunner will therefore\n          // set noop functions for resume and pause and they will\n          // later be overridden once the animation is triggered\n          return runner;\n        }\n      };\n\n      function endFn() {\n        close();\n      }\n\n      function cancelFn() {\n        close(true);\n      }\n\n      function close(rejected) {\n        // if the promise has been called already then we shouldn't close\n        // the animation again\n        if (animationClosed || (animationCompleted && animationPaused)) return;\n        animationClosed = true;\n        animationPaused = false;\n\n        if (!options.$$skipPreparationClasses) {\n          $$jqLite.removeClass(element, preparationClasses);\n        }\n        $$jqLite.removeClass(element, activeClasses);\n\n        blockKeyframeAnimations(node, false);\n        blockTransitions(node, false);\n\n        forEach(temporaryStyles, function(entry) {\n          // There is only one way to remove inline style properties entirely from elements.\n          // By using `removeProperty` this works, but we need to convert camel-cased CSS\n          // styles down to hyphenated values.\n          node.style[entry[0]] = '';\n        });\n\n        applyAnimationClasses(element, options);\n        applyAnimationStyles(element, options);\n\n        if (Object.keys(restoreStyles).length) {\n          forEach(restoreStyles, function(value, prop) {\n            if (value) {\n              node.style.setProperty(prop, value);\n            } else {\n              node.style.removeProperty(prop);\n            }\n          });\n        }\n\n        // the reason why we have this option is to allow a synchronous closing callback\n        // that is fired as SOON as the animation ends (when the CSS is removed) or if\n        // the animation never takes off at all. A good example is a leave animation since\n        // the element must be removed just after the animation is over or else the element\n        // will appear on screen for one animation frame causing an overbearing flicker.\n        if (options.onDone) {\n          options.onDone();\n        }\n\n        if (events && events.length) {\n          // Remove the transitionend / animationend listener(s)\n          element.off(events.join(' '), onAnimationProgress);\n        }\n\n        //Cancel the fallback closing timeout and remove the timer data\n        var animationTimerData = element.data(ANIMATE_TIMER_KEY);\n        if (animationTimerData) {\n          $timeout.cancel(animationTimerData[0].timer);\n          element.removeData(ANIMATE_TIMER_KEY);\n        }\n\n        // if the preparation function fails then the promise is not setup\n        if (runner) {\n          runner.complete(!rejected);\n        }\n      }\n\n      function applyBlocking(duration) {\n        if (flags.blockTransition) {\n          blockTransitions(node, duration);\n        }\n\n        if (flags.blockKeyframeAnimation) {\n          blockKeyframeAnimations(node, !!duration);\n        }\n      }\n\n      function closeAndReturnNoopAnimator() {\n        runner = new $$AnimateRunner({\n          end: endFn,\n          cancel: cancelFn\n        });\n\n        // should flush the cache animation\n        waitUntilQuiet(noop);\n        close();\n\n        return {\n          $$willAnimate: false,\n          start: function() {\n            return runner;\n          },\n          end: endFn\n        };\n      }\n\n      function onAnimationProgress(event) {\n        event.stopPropagation();\n        var ev = event.originalEvent || event;\n\n        if (ev.target !== node) {\n          // Since TransitionEvent / AnimationEvent bubble up,\n          // we have to ignore events by finished child animations\n          return;\n        }\n\n        // we now always use `Date.now()` due to the recent changes with\n        // event.timeStamp in Firefox, Webkit and Chrome (see #13494 for more info)\n        var timeStamp = ev.$manualTimeStamp || Date.now();\n\n        /* Firefox (or possibly just Gecko) likes to not round values up\n         * when a ms measurement is used for the animation */\n        var elapsedTime = parseFloat(ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES));\n\n        /* $manualTimeStamp is a mocked timeStamp value which is set\n         * within browserTrigger(). This is only here so that tests can\n         * mock animations properly. Real events fallback to event.timeStamp,\n         * or, if they don't, then a timeStamp is automatically created for them.\n         * We're checking to see if the timeStamp surpasses the expected delay,\n         * but we're using elapsedTime instead of the timeStamp on the 2nd\n         * pre-condition since animationPauseds sometimes close off early */\n        if (Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration) {\n          // we set this flag to ensure that if the transition is paused then, when resumed,\n          // the animation will automatically close itself since transitions cannot be paused.\n          animationCompleted = true;\n          close();\n        }\n      }\n\n      function start() {\n        if (animationClosed) return;\n        if (!node.parentNode) {\n          close();\n          return;\n        }\n\n        // even though we only pause keyframe animations here the pause flag\n        // will still happen when transitions are used. Only the transition will\n        // not be paused since that is not possible. If the animation ends when\n        // paused then it will not complete until unpaused or cancelled.\n        var playPause = function(playAnimation) {\n          if (!animationCompleted) {\n            animationPaused = !playAnimation;\n            if (timings.animationDuration) {\n              var value = blockKeyframeAnimations(node, animationPaused);\n              if (animationPaused) {\n                temporaryStyles.push(value);\n              } else {\n                removeFromArray(temporaryStyles, value);\n              }\n            }\n          } else if (animationPaused && playAnimation) {\n            animationPaused = false;\n            close();\n          }\n        };\n\n        // checking the stagger duration prevents an accidentally cascade of the CSS delay style\n        // being inherited from the parent. If the transition duration is zero then we can safely\n        // rely that the delay value is an intentional stagger delay style.\n        var maxStagger = itemIndex > 0\n                         && ((timings.transitionDuration && stagger.transitionDuration === 0) ||\n                            (timings.animationDuration && stagger.animationDuration === 0))\n                         && Math.max(stagger.animationDelay, stagger.transitionDelay);\n        if (maxStagger) {\n          $timeout(triggerAnimationStart,\n                   Math.floor(maxStagger * itemIndex * ONE_SECOND),\n                   false);\n        } else {\n          triggerAnimationStart();\n        }\n\n        // this will decorate the existing promise runner with pause/resume methods\n        runnerHost.resume = function() {\n          playPause(true);\n        };\n\n        runnerHost.pause = function() {\n          playPause(false);\n        };\n\n        function triggerAnimationStart() {\n          // just incase a stagger animation kicks in when the animation\n          // itself was cancelled entirely\n          if (animationClosed) return;\n\n          applyBlocking(false);\n\n          forEach(temporaryStyles, function(entry) {\n            var key = entry[0];\n            var value = entry[1];\n            node.style[key] = value;\n          });\n\n          applyAnimationClasses(element, options);\n          $$jqLite.addClass(element, activeClasses);\n\n          if (flags.recalculateTimingStyles) {\n            fullClassName = node.getAttribute('class') + ' ' + preparationClasses;\n            cacheKey = gcsHashFn(node, fullClassName);\n\n            timings = computeTimings(node, fullClassName, cacheKey);\n            relativeDelay = timings.maxDelay;\n            maxDelay = Math.max(relativeDelay, 0);\n            maxDuration = timings.maxDuration;\n\n            if (maxDuration === 0) {\n              close();\n              return;\n            }\n\n            flags.hasTransitions = timings.transitionDuration > 0;\n            flags.hasAnimations = timings.animationDuration > 0;\n          }\n\n          if (flags.applyAnimationDelay) {\n            relativeDelay = typeof options.delay !== 'boolean' && truthyTimingValue(options.delay)\n                  ? parseFloat(options.delay)\n                  : relativeDelay;\n\n            maxDelay = Math.max(relativeDelay, 0);\n            timings.animationDelay = relativeDelay;\n            delayStyle = getCssDelayStyle(relativeDelay, true);\n            temporaryStyles.push(delayStyle);\n            node.style[delayStyle[0]] = delayStyle[1];\n          }\n\n          maxDelayTime = maxDelay * ONE_SECOND;\n          maxDurationTime = maxDuration * ONE_SECOND;\n\n          if (options.easing) {\n            var easeProp, easeVal = options.easing;\n            if (flags.hasTransitions) {\n              easeProp = TRANSITION_PROP + TIMING_KEY;\n              temporaryStyles.push([easeProp, easeVal]);\n              node.style[easeProp] = easeVal;\n            }\n            if (flags.hasAnimations) {\n              easeProp = ANIMATION_PROP + TIMING_KEY;\n              temporaryStyles.push([easeProp, easeVal]);\n              node.style[easeProp] = easeVal;\n            }\n          }\n\n          if (timings.transitionDuration) {\n            events.push(TRANSITIONEND_EVENT);\n          }\n\n          if (timings.animationDuration) {\n            events.push(ANIMATIONEND_EVENT);\n          }\n\n          startTime = Date.now();\n          var timerTime = maxDelayTime + CLOSING_TIME_BUFFER * maxDurationTime;\n          var endTime = startTime + timerTime;\n\n          var animationsData = element.data(ANIMATE_TIMER_KEY) || [];\n          var setupFallbackTimer = true;\n          if (animationsData.length) {\n            var currentTimerData = animationsData[0];\n            setupFallbackTimer = endTime > currentTimerData.expectedEndTime;\n            if (setupFallbackTimer) {\n              $timeout.cancel(currentTimerData.timer);\n            } else {\n              animationsData.push(close);\n            }\n          }\n\n          if (setupFallbackTimer) {\n            var timer = $timeout(onAnimationExpired, timerTime, false);\n            animationsData[0] = {\n              timer: timer,\n              expectedEndTime: endTime\n            };\n            animationsData.push(close);\n            element.data(ANIMATE_TIMER_KEY, animationsData);\n          }\n\n          if (events.length) {\n            element.on(events.join(' '), onAnimationProgress);\n          }\n\n          if (options.to) {\n            if (options.cleanupStyles) {\n              registerRestorableStyles(restoreStyles, node, Object.keys(options.to));\n            }\n            applyAnimationToStyles(element, options);\n          }\n        }\n\n        function onAnimationExpired() {\n          var animationsData = element.data(ANIMATE_TIMER_KEY);\n\n          // this will be false in the event that the element was\n          // removed from the DOM (via a leave animation or something\n          // similar)\n          if (animationsData) {\n            for (var i = 1; i < animationsData.length; i++) {\n              animationsData[i]();\n            }\n            element.removeData(ANIMATE_TIMER_KEY);\n          }\n        }\n      }\n    };\n  }];\n}];\n\nvar $$AnimateCssDriverProvider = ['$$animationProvider', /** @this */ function($$animationProvider) {\n  $$animationProvider.drivers.push('$$animateCssDriver');\n\n  var NG_ANIMATE_SHIM_CLASS_NAME = 'ng-animate-shim';\n  var NG_ANIMATE_ANCHOR_CLASS_NAME = 'ng-anchor';\n\n  var NG_OUT_ANCHOR_CLASS_NAME = 'ng-anchor-out';\n  var NG_IN_ANCHOR_CLASS_NAME = 'ng-anchor-in';\n\n  function isDocumentFragment(node) {\n    return node.parentNode && node.parentNode.nodeType === 11;\n  }\n\n  this.$get = ['$animateCss', '$rootScope', '$$AnimateRunner', '$rootElement', '$sniffer', '$$jqLite', '$document',\n       function($animateCss,   $rootScope,   $$AnimateRunner,   $rootElement,   $sniffer,   $$jqLite,   $document) {\n\n    // only browsers that support these properties can render animations\n    if (!$sniffer.animations && !$sniffer.transitions) return noop;\n\n    var bodyNode = $document[0].body;\n    var rootNode = getDomNode($rootElement);\n\n    var rootBodyElement = jqLite(\n      // this is to avoid using something that exists outside of the body\n      // we also special case the doc fragment case because our unit test code\n      // appends the $rootElement to the body after the app has been bootstrapped\n      isDocumentFragment(rootNode) || bodyNode.contains(rootNode) ? rootNode : bodyNode\n    );\n\n    return function initDriverFn(animationDetails) {\n      return animationDetails.from && animationDetails.to\n          ? prepareFromToAnchorAnimation(animationDetails.from,\n                                         animationDetails.to,\n                                         animationDetails.classes,\n                                         animationDetails.anchors)\n          : prepareRegularAnimation(animationDetails);\n    };\n\n    function filterCssClasses(classes) {\n      //remove all the `ng-` stuff\n      return classes.replace(/\\bng-\\S+\\b/g, '');\n    }\n\n    function getUniqueValues(a, b) {\n      if (isString(a)) a = a.split(' ');\n      if (isString(b)) b = b.split(' ');\n      return a.filter(function(val) {\n        return b.indexOf(val) === -1;\n      }).join(' ');\n    }\n\n    function prepareAnchoredAnimation(classes, outAnchor, inAnchor) {\n      var clone = jqLite(getDomNode(outAnchor).cloneNode(true));\n      var startingClasses = filterCssClasses(getClassVal(clone));\n\n      outAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);\n      inAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);\n\n      clone.addClass(NG_ANIMATE_ANCHOR_CLASS_NAME);\n\n      rootBodyElement.append(clone);\n\n      var animatorIn, animatorOut = prepareOutAnimation();\n\n      // the user may not end up using the `out` animation and\n      // only making use of the `in` animation or vice-versa.\n      // In either case we should allow this and not assume the\n      // animation is over unless both animations are not used.\n      if (!animatorOut) {\n        animatorIn = prepareInAnimation();\n        if (!animatorIn) {\n          return end();\n        }\n      }\n\n      var startingAnimator = animatorOut || animatorIn;\n\n      return {\n        start: function() {\n          var runner;\n\n          var currentAnimation = startingAnimator.start();\n          currentAnimation.done(function() {\n            currentAnimation = null;\n            if (!animatorIn) {\n              animatorIn = prepareInAnimation();\n              if (animatorIn) {\n                currentAnimation = animatorIn.start();\n                currentAnimation.done(function() {\n                  currentAnimation = null;\n                  end();\n                  runner.complete();\n                });\n                return currentAnimation;\n              }\n            }\n            // in the event that there is no `in` animation\n            end();\n            runner.complete();\n          });\n\n          runner = new $$AnimateRunner({\n            end: endFn,\n            cancel: endFn\n          });\n\n          return runner;\n\n          function endFn() {\n            if (currentAnimation) {\n              currentAnimation.end();\n            }\n          }\n        }\n      };\n\n      function calculateAnchorStyles(anchor) {\n        var styles = {};\n\n        var coords = getDomNode(anchor).getBoundingClientRect();\n\n        // we iterate directly since safari messes up and doesn't return\n        // all the keys for the coords object when iterated\n        forEach(['width','height','top','left'], function(key) {\n          var value = coords[key];\n          switch (key) {\n            case 'top':\n              value += bodyNode.scrollTop;\n              break;\n            case 'left':\n              value += bodyNode.scrollLeft;\n              break;\n          }\n          styles[key] = Math.floor(value) + 'px';\n        });\n        return styles;\n      }\n\n      function prepareOutAnimation() {\n        var animator = $animateCss(clone, {\n          addClass: NG_OUT_ANCHOR_CLASS_NAME,\n          delay: true,\n          from: calculateAnchorStyles(outAnchor)\n        });\n\n        // read the comment within `prepareRegularAnimation` to understand\n        // why this check is necessary\n        return animator.$$willAnimate ? animator : null;\n      }\n\n      function getClassVal(element) {\n        return element.attr('class') || '';\n      }\n\n      function prepareInAnimation() {\n        var endingClasses = filterCssClasses(getClassVal(inAnchor));\n        var toAdd = getUniqueValues(endingClasses, startingClasses);\n        var toRemove = getUniqueValues(startingClasses, endingClasses);\n\n        var animator = $animateCss(clone, {\n          to: calculateAnchorStyles(inAnchor),\n          addClass: NG_IN_ANCHOR_CLASS_NAME + ' ' + toAdd,\n          removeClass: NG_OUT_ANCHOR_CLASS_NAME + ' ' + toRemove,\n          delay: true\n        });\n\n        // read the comment within `prepareRegularAnimation` to understand\n        // why this check is necessary\n        return animator.$$willAnimate ? animator : null;\n      }\n\n      function end() {\n        clone.remove();\n        outAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);\n        inAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);\n      }\n    }\n\n    function prepareFromToAnchorAnimation(from, to, classes, anchors) {\n      var fromAnimation = prepareRegularAnimation(from, noop);\n      var toAnimation = prepareRegularAnimation(to, noop);\n\n      var anchorAnimations = [];\n      forEach(anchors, function(anchor) {\n        var outElement = anchor['out'];\n        var inElement = anchor['in'];\n        var animator = prepareAnchoredAnimation(classes, outElement, inElement);\n        if (animator) {\n          anchorAnimations.push(animator);\n        }\n      });\n\n      // no point in doing anything when there are no elements to animate\n      if (!fromAnimation && !toAnimation && anchorAnimations.length === 0) return;\n\n      return {\n        start: function() {\n          var animationRunners = [];\n\n          if (fromAnimation) {\n            animationRunners.push(fromAnimation.start());\n          }\n\n          if (toAnimation) {\n            animationRunners.push(toAnimation.start());\n          }\n\n          forEach(anchorAnimations, function(animation) {\n            animationRunners.push(animation.start());\n          });\n\n          var runner = new $$AnimateRunner({\n            end: endFn,\n            cancel: endFn // CSS-driven animations cannot be cancelled, only ended\n          });\n\n          $$AnimateRunner.all(animationRunners, function(status) {\n            runner.complete(status);\n          });\n\n          return runner;\n\n          function endFn() {\n            forEach(animationRunners, function(runner) {\n              runner.end();\n            });\n          }\n        }\n      };\n    }\n\n    function prepareRegularAnimation(animationDetails) {\n      var element = animationDetails.element;\n      var options = animationDetails.options || {};\n\n      if (animationDetails.structural) {\n        options.event = animationDetails.event;\n        options.structural = true;\n        options.applyClassesEarly = true;\n\n        // we special case the leave animation since we want to ensure that\n        // the element is removed as soon as the animation is over. Otherwise\n        // a flicker might appear or the element may not be removed at all\n        if (animationDetails.event === 'leave') {\n          options.onDone = options.domOperation;\n        }\n      }\n\n      // We assign the preparationClasses as the actual animation event since\n      // the internals of $animateCss will just suffix the event token values\n      // with `-active` to trigger the animation.\n      if (options.preparationClasses) {\n        options.event = concatWithSpace(options.event, options.preparationClasses);\n      }\n\n      var animator = $animateCss(element, options);\n\n      // the driver lookup code inside of $$animation attempts to spawn a\n      // driver one by one until a driver returns a.$$willAnimate animator object.\n      // $animateCss will always return an object, however, it will pass in\n      // a flag as a hint as to whether an animation was detected or not\n      return animator.$$willAnimate ? animator : null;\n    }\n  }];\n}];\n\n// TODO(matsko): use caching here to speed things up for detection\n// TODO(matsko): add documentation\n//  by the time...\n\nvar $$AnimateJsProvider = ['$animateProvider', /** @this */ function($animateProvider) {\n  this.$get = ['$injector', '$$AnimateRunner', '$$jqLite',\n       function($injector,   $$AnimateRunner,   $$jqLite) {\n\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n         // $animateJs(element, 'enter');\n    return function(element, event, classes, options) {\n      var animationClosed = false;\n\n      // the `classes` argument is optional and if it is not used\n      // then the classes will be resolved from the element's className\n      // property as well as options.addClass/options.removeClass.\n      if (arguments.length === 3 && isObject(classes)) {\n        options = classes;\n        classes = null;\n      }\n\n      options = prepareAnimationOptions(options);\n      if (!classes) {\n        classes = element.attr('class') || '';\n        if (options.addClass) {\n          classes += ' ' + options.addClass;\n        }\n        if (options.removeClass) {\n          classes += ' ' + options.removeClass;\n        }\n      }\n\n      var classesToAdd = options.addClass;\n      var classesToRemove = options.removeClass;\n\n      // the lookupAnimations function returns a series of animation objects that are\n      // matched up with one or more of the CSS classes. These animation objects are\n      // defined via the module.animation factory function. If nothing is detected then\n      // we don't return anything which then makes $animation query the next driver.\n      var animations = lookupAnimations(classes);\n      var before, after;\n      if (animations.length) {\n        var afterFn, beforeFn;\n        if (event === 'leave') {\n          beforeFn = 'leave';\n          afterFn = 'afterLeave'; // TODO(matsko): get rid of this\n        } else {\n          beforeFn = 'before' + event.charAt(0).toUpperCase() + event.substr(1);\n          afterFn = event;\n        }\n\n        if (event !== 'enter' && event !== 'move') {\n          before = packageAnimations(element, event, options, animations, beforeFn);\n        }\n        after  = packageAnimations(element, event, options, animations, afterFn);\n      }\n\n      // no matching animations\n      if (!before && !after) return;\n\n      function applyOptions() {\n        options.domOperation();\n        applyAnimationClasses(element, options);\n      }\n\n      function close() {\n        animationClosed = true;\n        applyOptions();\n        applyAnimationStyles(element, options);\n      }\n\n      var runner;\n\n      return {\n        $$willAnimate: true,\n        end: function() {\n          if (runner) {\n            runner.end();\n          } else {\n            close();\n            runner = new $$AnimateRunner();\n            runner.complete(true);\n          }\n          return runner;\n        },\n        start: function() {\n          if (runner) {\n            return runner;\n          }\n\n          runner = new $$AnimateRunner();\n          var closeActiveAnimations;\n          var chain = [];\n\n          if (before) {\n            chain.push(function(fn) {\n              closeActiveAnimations = before(fn);\n            });\n          }\n\n          if (chain.length) {\n            chain.push(function(fn) {\n              applyOptions();\n              fn(true);\n            });\n          } else {\n            applyOptions();\n          }\n\n          if (after) {\n            chain.push(function(fn) {\n              closeActiveAnimations = after(fn);\n            });\n          }\n\n          runner.setHost({\n            end: function() {\n              endAnimations();\n            },\n            cancel: function() {\n              endAnimations(true);\n            }\n          });\n\n          $$AnimateRunner.chain(chain, onComplete);\n          return runner;\n\n          function onComplete(success) {\n            close(success);\n            runner.complete(success);\n          }\n\n          function endAnimations(cancelled) {\n            if (!animationClosed) {\n              (closeActiveAnimations || noop)(cancelled);\n              onComplete(cancelled);\n            }\n          }\n        }\n      };\n\n      function executeAnimationFn(fn, element, event, options, onDone) {\n        var args;\n        switch (event) {\n          case 'animate':\n            args = [element, options.from, options.to, onDone];\n            break;\n\n          case 'setClass':\n            args = [element, classesToAdd, classesToRemove, onDone];\n            break;\n\n          case 'addClass':\n            args = [element, classesToAdd, onDone];\n            break;\n\n          case 'removeClass':\n            args = [element, classesToRemove, onDone];\n            break;\n\n          default:\n            args = [element, onDone];\n            break;\n        }\n\n        args.push(options);\n\n        var value = fn.apply(fn, args);\n        if (value) {\n          if (isFunction(value.start)) {\n            value = value.start();\n          }\n\n          if (value instanceof $$AnimateRunner) {\n            value.done(onDone);\n          } else if (isFunction(value)) {\n            // optional onEnd / onCancel callback\n            return value;\n          }\n        }\n\n        return noop;\n      }\n\n      function groupEventedAnimations(element, event, options, animations, fnName) {\n        var operations = [];\n        forEach(animations, function(ani) {\n          var animation = ani[fnName];\n          if (!animation) return;\n\n          // note that all of these animations will run in parallel\n          operations.push(function() {\n            var runner;\n            var endProgressCb;\n\n            var resolved = false;\n            var onAnimationComplete = function(rejected) {\n              if (!resolved) {\n                resolved = true;\n                (endProgressCb || noop)(rejected);\n                runner.complete(!rejected);\n              }\n            };\n\n            runner = new $$AnimateRunner({\n              end: function() {\n                onAnimationComplete();\n              },\n              cancel: function() {\n                onAnimationComplete(true);\n              }\n            });\n\n            endProgressCb = executeAnimationFn(animation, element, event, options, function(result) {\n              var cancelled = result === false;\n              onAnimationComplete(cancelled);\n            });\n\n            return runner;\n          });\n        });\n\n        return operations;\n      }\n\n      function packageAnimations(element, event, options, animations, fnName) {\n        var operations = groupEventedAnimations(element, event, options, animations, fnName);\n        if (operations.length === 0) {\n          var a, b;\n          if (fnName === 'beforeSetClass') {\n            a = groupEventedAnimations(element, 'removeClass', options, animations, 'beforeRemoveClass');\n            b = groupEventedAnimations(element, 'addClass', options, animations, 'beforeAddClass');\n          } else if (fnName === 'setClass') {\n            a = groupEventedAnimations(element, 'removeClass', options, animations, 'removeClass');\n            b = groupEventedAnimations(element, 'addClass', options, animations, 'addClass');\n          }\n\n          if (a) {\n            operations = operations.concat(a);\n          }\n          if (b) {\n            operations = operations.concat(b);\n          }\n        }\n\n        if (operations.length === 0) return;\n\n        // TODO(matsko): add documentation\n        return function startAnimation(callback) {\n          var runners = [];\n          if (operations.length) {\n            forEach(operations, function(animateFn) {\n              runners.push(animateFn());\n            });\n          }\n\n          if (runners.length) {\n            $$AnimateRunner.all(runners, callback);\n          }  else {\n            callback();\n          }\n\n          return function endFn(reject) {\n            forEach(runners, function(runner) {\n              if (reject) {\n                runner.cancel();\n              } else {\n                runner.end();\n              }\n            });\n          };\n        };\n      }\n    };\n\n    function lookupAnimations(classes) {\n      classes = isArray(classes) ? classes : classes.split(' ');\n      var matches = [], flagMap = {};\n      for (var i = 0; i < classes.length; i++) {\n        var klass = classes[i],\n            animationFactory = $animateProvider.$$registeredAnimations[klass];\n        if (animationFactory && !flagMap[klass]) {\n          matches.push($injector.get(animationFactory));\n          flagMap[klass] = true;\n        }\n      }\n      return matches;\n    }\n  }];\n}];\n\nvar $$AnimateJsDriverProvider = ['$$animationProvider', /** @this */ function($$animationProvider) {\n  $$animationProvider.drivers.push('$$animateJsDriver');\n  this.$get = ['$$animateJs', '$$AnimateRunner', function($$animateJs, $$AnimateRunner) {\n    return function initDriverFn(animationDetails) {\n      if (animationDetails.from && animationDetails.to) {\n        var fromAnimation = prepareAnimation(animationDetails.from);\n        var toAnimation = prepareAnimation(animationDetails.to);\n        if (!fromAnimation && !toAnimation) return;\n\n        return {\n          start: function() {\n            var animationRunners = [];\n\n            if (fromAnimation) {\n              animationRunners.push(fromAnimation.start());\n            }\n\n            if (toAnimation) {\n              animationRunners.push(toAnimation.start());\n            }\n\n            $$AnimateRunner.all(animationRunners, done);\n\n            var runner = new $$AnimateRunner({\n              end: endFnFactory(),\n              cancel: endFnFactory()\n            });\n\n            return runner;\n\n            function endFnFactory() {\n              return function() {\n                forEach(animationRunners, function(runner) {\n                  // at this point we cannot cancel animations for groups just yet. 1.5+\n                  runner.end();\n                });\n              };\n            }\n\n            function done(status) {\n              runner.complete(status);\n            }\n          }\n        };\n      } else {\n        return prepareAnimation(animationDetails);\n      }\n    };\n\n    function prepareAnimation(animationDetails) {\n      // TODO(matsko): make sure to check for grouped animations and delegate down to normal animations\n      var element = animationDetails.element;\n      var event = animationDetails.event;\n      var options = animationDetails.options;\n      var classes = animationDetails.classes;\n      return $$animateJs(element, event, classes, options);\n    }\n  }];\n}];\n\nvar NG_ANIMATE_ATTR_NAME = 'data-ng-animate';\nvar NG_ANIMATE_PIN_DATA = '$ngAnimatePin';\nvar $$AnimateQueueProvider = ['$animateProvider', /** @this */ function($animateProvider) {\n  var PRE_DIGEST_STATE = 1;\n  var RUNNING_STATE = 2;\n  var ONE_SPACE = ' ';\n\n  var rules = this.rules = {\n    skip: [],\n    cancel: [],\n    join: []\n  };\n\n  function makeTruthyCssClassMap(classString) {\n    if (!classString) {\n      return null;\n    }\n\n    var keys = classString.split(ONE_SPACE);\n    var map = Object.create(null);\n\n    forEach(keys, function(key) {\n      map[key] = true;\n    });\n    return map;\n  }\n\n  function hasMatchingClasses(newClassString, currentClassString) {\n    if (newClassString && currentClassString) {\n      var currentClassMap = makeTruthyCssClassMap(currentClassString);\n      return newClassString.split(ONE_SPACE).some(function(className) {\n        return currentClassMap[className];\n      });\n    }\n  }\n\n  function isAllowed(ruleType, currentAnimation, previousAnimation) {\n    return rules[ruleType].some(function(fn) {\n      return fn(currentAnimation, previousAnimation);\n    });\n  }\n\n  function hasAnimationClasses(animation, and) {\n    var a = (animation.addClass || '').length > 0;\n    var b = (animation.removeClass || '').length > 0;\n    return and ? a && b : a || b;\n  }\n\n  rules.join.push(function(newAnimation, currentAnimation) {\n    // if the new animation is class-based then we can just tack that on\n    return !newAnimation.structural && hasAnimationClasses(newAnimation);\n  });\n\n  rules.skip.push(function(newAnimation, currentAnimation) {\n    // there is no need to animate anything if no classes are being added and\n    // there is no structural animation that will be triggered\n    return !newAnimation.structural && !hasAnimationClasses(newAnimation);\n  });\n\n  rules.skip.push(function(newAnimation, currentAnimation) {\n    // why should we trigger a new structural animation if the element will\n    // be removed from the DOM anyway?\n    return currentAnimation.event === 'leave' && newAnimation.structural;\n  });\n\n  rules.skip.push(function(newAnimation, currentAnimation) {\n    // if there is an ongoing current animation then don't even bother running the class-based animation\n    return currentAnimation.structural && currentAnimation.state === RUNNING_STATE && !newAnimation.structural;\n  });\n\n  rules.cancel.push(function(newAnimation, currentAnimation) {\n    // there can never be two structural animations running at the same time\n    return currentAnimation.structural && newAnimation.structural;\n  });\n\n  rules.cancel.push(function(newAnimation, currentAnimation) {\n    // if the previous animation is already running, but the new animation will\n    // be triggered, but the new animation is structural\n    return currentAnimation.state === RUNNING_STATE && newAnimation.structural;\n  });\n\n  rules.cancel.push(function(newAnimation, currentAnimation) {\n    // cancel the animation if classes added / removed in both animation cancel each other out,\n    // but only if the current animation isn't structural\n\n    if (currentAnimation.structural) return false;\n\n    var nA = newAnimation.addClass;\n    var nR = newAnimation.removeClass;\n    var cA = currentAnimation.addClass;\n    var cR = currentAnimation.removeClass;\n\n    // early detection to save the global CPU shortage :)\n    if ((isUndefined(nA) && isUndefined(nR)) || (isUndefined(cA) && isUndefined(cR))) {\n      return false;\n    }\n\n    return hasMatchingClasses(nA, cR) || hasMatchingClasses(nR, cA);\n  });\n\n  this.$get = ['$$rAF', '$rootScope', '$rootElement', '$document', '$$Map',\n               '$$animation', '$$AnimateRunner', '$templateRequest', '$$jqLite', '$$forceReflow',\n               '$$isDocumentHidden',\n       function($$rAF,   $rootScope,   $rootElement,   $document,   $$Map,\n                $$animation,   $$AnimateRunner,   $templateRequest,   $$jqLite,   $$forceReflow,\n                $$isDocumentHidden) {\n\n    var activeAnimationsLookup = new $$Map();\n    var disabledElementsLookup = new $$Map();\n    var animationsEnabled = null;\n\n    function postDigestTaskFactory() {\n      var postDigestCalled = false;\n      return function(fn) {\n        // we only issue a call to postDigest before\n        // it has first passed. This prevents any callbacks\n        // from not firing once the animation has completed\n        // since it will be out of the digest cycle.\n        if (postDigestCalled) {\n          fn();\n        } else {\n          $rootScope.$$postDigest(function() {\n            postDigestCalled = true;\n            fn();\n          });\n        }\n      };\n    }\n\n    // Wait until all directive and route-related templates are downloaded and\n    // compiled. The $templateRequest.totalPendingRequests variable keeps track of\n    // all of the remote templates being currently downloaded. If there are no\n    // templates currently downloading then the watcher will still fire anyway.\n    var deregisterWatch = $rootScope.$watch(\n      function() { return $templateRequest.totalPendingRequests === 0; },\n      function(isEmpty) {\n        if (!isEmpty) return;\n        deregisterWatch();\n\n        // Now that all templates have been downloaded, $animate will wait until\n        // the post digest queue is empty before enabling animations. By having two\n        // calls to $postDigest calls we can ensure that the flag is enabled at the\n        // very end of the post digest queue. Since all of the animations in $animate\n        // use $postDigest, it's important that the code below executes at the end.\n        // This basically means that the page is fully downloaded and compiled before\n        // any animations are triggered.\n        $rootScope.$$postDigest(function() {\n          $rootScope.$$postDigest(function() {\n            // we check for null directly in the event that the application already called\n            // .enabled() with whatever arguments that it provided it with\n            if (animationsEnabled === null) {\n              animationsEnabled = true;\n            }\n          });\n        });\n      }\n    );\n\n    var callbackRegistry = Object.create(null);\n\n    // remember that the `customFilter`/`classNameFilter` are set during the\n    // provider/config stage therefore we can optimize here and setup helper functions\n    var customFilter = $animateProvider.customFilter();\n    var classNameFilter = $animateProvider.classNameFilter();\n    var returnTrue = function() { return true; };\n\n    var isAnimatableByFilter = customFilter || returnTrue;\n    var isAnimatableClassName = !classNameFilter ? returnTrue : function(node, options) {\n      var className = [node.getAttribute('class'), options.addClass, options.removeClass].join(' ');\n      return classNameFilter.test(className);\n    };\n\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\n    function normalizeAnimationDetails(element, animation) {\n      return mergeAnimationDetails(element, animation, {});\n    }\n\n    // IE9-11 has no method \"contains\" in SVG element and in Node.prototype. Bug #10259.\n    var contains = window.Node.prototype.contains || /** @this */ function(arg) {\n      // eslint-disable-next-line no-bitwise\n      return this === arg || !!(this.compareDocumentPosition(arg) & 16);\n    };\n\n    function findCallbacks(targetParentNode, targetNode, event) {\n      var matches = [];\n      var entries = callbackRegistry[event];\n      if (entries) {\n        forEach(entries, function(entry) {\n          if (contains.call(entry.node, targetNode)) {\n            matches.push(entry.callback);\n          } else if (event === 'leave' && contains.call(entry.node, targetParentNode)) {\n            matches.push(entry.callback);\n          }\n        });\n      }\n\n      return matches;\n    }\n\n    function filterFromRegistry(list, matchContainer, matchCallback) {\n      var containerNode = extractElementNode(matchContainer);\n      return list.filter(function(entry) {\n        var isMatch = entry.node === containerNode &&\n                        (!matchCallback || entry.callback === matchCallback);\n        return !isMatch;\n      });\n    }\n\n    function cleanupEventListeners(phase, node) {\n      if (phase === 'close' && !node.parentNode) {\n        // If the element is not attached to a parentNode, it has been removed by\n        // the domOperation, and we can safely remove the event callbacks\n        $animate.off(node);\n      }\n    }\n\n    var $animate = {\n      on: function(event, container, callback) {\n        var node = extractElementNode(container);\n        callbackRegistry[event] = callbackRegistry[event] || [];\n        callbackRegistry[event].push({\n          node: node,\n          callback: callback\n        });\n\n        // Remove the callback when the element is removed from the DOM\n        jqLite(container).on('$destroy', function() {\n          var animationDetails = activeAnimationsLookup.get(node);\n\n          if (!animationDetails) {\n            // If there's an animation ongoing, the callback calling code will remove\n            // the event listeners. If we'd remove here, the callbacks would be removed\n            // before the animation ends\n            $animate.off(event, container, callback);\n          }\n        });\n      },\n\n      off: function(event, container, callback) {\n        if (arguments.length === 1 && !isString(arguments[0])) {\n          container = arguments[0];\n          for (var eventType in callbackRegistry) {\n            callbackRegistry[eventType] = filterFromRegistry(callbackRegistry[eventType], container);\n          }\n\n          return;\n        }\n\n        var entries = callbackRegistry[event];\n        if (!entries) return;\n\n        callbackRegistry[event] = arguments.length === 1\n            ? null\n            : filterFromRegistry(entries, container, callback);\n      },\n\n      pin: function(element, parentElement) {\n        assertArg(isElement(element), 'element', 'not an element');\n        assertArg(isElement(parentElement), 'parentElement', 'not an element');\n        element.data(NG_ANIMATE_PIN_DATA, parentElement);\n      },\n\n      push: function(element, event, options, domOperation) {\n        options = options || {};\n        options.domOperation = domOperation;\n        return queueAnimation(element, event, options);\n      },\n\n      // this method has four signatures:\n      //  () - global getter\n      //  (bool) - global setter\n      //  (element) - element getter\n      //  (element, bool) - element setter<F37>\n      enabled: function(element, bool) {\n        var argCount = arguments.length;\n\n        if (argCount === 0) {\n          // () - Global getter\n          bool = !!animationsEnabled;\n        } else {\n          var hasElement = isElement(element);\n\n          if (!hasElement) {\n            // (bool) - Global setter\n            bool = animationsEnabled = !!element;\n          } else {\n            var node = getDomNode(element);\n\n            if (argCount === 1) {\n              // (element) - Element getter\n              bool = !disabledElementsLookup.get(node);\n            } else {\n              // (element, bool) - Element setter\n              disabledElementsLookup.set(node, !bool);\n            }\n          }\n        }\n\n        return bool;\n      }\n    };\n\n    return $animate;\n\n    function queueAnimation(originalElement, event, initialOptions) {\n      // we always make a copy of the options since\n      // there should never be any side effects on\n      // the input data when running `$animateCss`.\n      var options = copy(initialOptions);\n\n      var element = stripCommentsFromElement(originalElement);\n      var node = getDomNode(element);\n      var parentNode = node && node.parentNode;\n\n      options = prepareAnimationOptions(options);\n\n      // we create a fake runner with a working promise.\n      // These methods will become available after the digest has passed\n      var runner = new $$AnimateRunner();\n\n      // this is used to trigger callbacks in postDigest mode\n      var runInNextPostDigestOrNow = postDigestTaskFactory();\n\n      if (isArray(options.addClass)) {\n        options.addClass = options.addClass.join(' ');\n      }\n\n      if (options.addClass && !isString(options.addClass)) {\n        options.addClass = null;\n      }\n\n      if (isArray(options.removeClass)) {\n        options.removeClass = options.removeClass.join(' ');\n      }\n\n      if (options.removeClass && !isString(options.removeClass)) {\n        options.removeClass = null;\n      }\n\n      if (options.from && !isObject(options.from)) {\n        options.from = null;\n      }\n\n      if (options.to && !isObject(options.to)) {\n        options.to = null;\n      }\n\n      // If animations are hard-disabled for the whole application there is no need to continue.\n      // There are also situations where a directive issues an animation for a jqLite wrapper that\n      // contains only comment nodes. In this case, there is no way we can perform an animation.\n      if (!animationsEnabled ||\n          !node ||\n          !isAnimatableByFilter(node, event, initialOptions) ||\n          !isAnimatableClassName(node, options)) {\n        close();\n        return runner;\n      }\n\n      var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;\n\n      var documentHidden = $$isDocumentHidden();\n\n      // This is a hard disable of all animations the element itself, therefore  there is no need to\n      // continue further past this point if not enabled\n      // Animations are also disabled if the document is currently hidden (page is not visible\n      // to the user), because browsers slow down or do not flush calls to requestAnimationFrame\n      var skipAnimations = documentHidden || disabledElementsLookup.get(node);\n      var existingAnimation = (!skipAnimations && activeAnimationsLookup.get(node)) || {};\n      var hasExistingAnimation = !!existingAnimation.state;\n\n      // there is no point in traversing the same collection of parent ancestors if a followup\n      // animation will be run on the same element that already did all that checking work\n      if (!skipAnimations && (!hasExistingAnimation || existingAnimation.state !== PRE_DIGEST_STATE)) {\n        skipAnimations = !areAnimationsAllowed(node, parentNode, event);\n      }\n\n      if (skipAnimations) {\n        // Callbacks should fire even if the document is hidden (regression fix for issue #14120)\n        if (documentHidden) notifyProgress(runner, event, 'start');\n        close();\n        if (documentHidden) notifyProgress(runner, event, 'close');\n        return runner;\n      }\n\n      if (isStructural) {\n        closeChildAnimations(node);\n      }\n\n      var newAnimation = {\n        structural: isStructural,\n        element: element,\n        event: event,\n        addClass: options.addClass,\n        removeClass: options.removeClass,\n        close: close,\n        options: options,\n        runner: runner\n      };\n\n      if (hasExistingAnimation) {\n        var skipAnimationFlag = isAllowed('skip', newAnimation, existingAnimation);\n        if (skipAnimationFlag) {\n          if (existingAnimation.state === RUNNING_STATE) {\n            close();\n            return runner;\n          } else {\n            mergeAnimationDetails(element, existingAnimation, newAnimation);\n            return existingAnimation.runner;\n          }\n        }\n        var cancelAnimationFlag = isAllowed('cancel', newAnimation, existingAnimation);\n        if (cancelAnimationFlag) {\n          if (existingAnimation.state === RUNNING_STATE) {\n            // this will end the animation right away and it is safe\n            // to do so since the animation is already running and the\n            // runner callback code will run in async\n            existingAnimation.runner.end();\n          } else if (existingAnimation.structural) {\n            // this means that the animation is queued into a digest, but\n            // hasn't started yet. Therefore it is safe to run the close\n            // method which will call the runner methods in async.\n            existingAnimation.close();\n          } else {\n            // this will merge the new animation options into existing animation options\n            mergeAnimationDetails(element, existingAnimation, newAnimation);\n\n            return existingAnimation.runner;\n          }\n        } else {\n          // a joined animation means that this animation will take over the existing one\n          // so an example would involve a leave animation taking over an enter. Then when\n          // the postDigest kicks in the enter will be ignored.\n          var joinAnimationFlag = isAllowed('join', newAnimation, existingAnimation);\n          if (joinAnimationFlag) {\n            if (existingAnimation.state === RUNNING_STATE) {\n              normalizeAnimationDetails(element, newAnimation);\n            } else {\n              applyGeneratedPreparationClasses(element, isStructural ? event : null, options);\n\n              event = newAnimation.event = existingAnimation.event;\n              options = mergeAnimationDetails(element, existingAnimation, newAnimation);\n\n              //we return the same runner since only the option values of this animation will\n              //be fed into the `existingAnimation`.\n              return existingAnimation.runner;\n            }\n          }\n        }\n      } else {\n        // normalization in this case means that it removes redundant CSS classes that\n        // already exist (addClass) or do not exist (removeClass) on the element\n        normalizeAnimationDetails(element, newAnimation);\n      }\n\n      // when the options are merged and cleaned up we may end up not having to do\n      // an animation at all, therefore we should check this before issuing a post\n      // digest callback. Structural animations will always run no matter what.\n      var isValidAnimation = newAnimation.structural;\n      if (!isValidAnimation) {\n        // animate (from/to) can be quickly checked first, otherwise we check if any classes are present\n        isValidAnimation = (newAnimation.event === 'animate' && Object.keys(newAnimation.options.to || {}).length > 0)\n                            || hasAnimationClasses(newAnimation);\n      }\n\n      if (!isValidAnimation) {\n        close();\n        clearElementAnimationState(node);\n        return runner;\n      }\n\n      // the counter keeps track of cancelled animations\n      var counter = (existingAnimation.counter || 0) + 1;\n      newAnimation.counter = counter;\n\n      markElementAnimationState(node, PRE_DIGEST_STATE, newAnimation);\n\n      $rootScope.$$postDigest(function() {\n        // It is possible that the DOM nodes inside `originalElement` have been replaced. This can\n        // happen if the animated element is a transcluded clone and also has a `templateUrl`\n        // directive on it. Therefore, we must recreate `element` in order to interact with the\n        // actual DOM nodes.\n        // Note: We still need to use the old `node` for certain things, such as looking up in\n        //       HashMaps where it was used as the key.\n\n        element = stripCommentsFromElement(originalElement);\n\n        var animationDetails = activeAnimationsLookup.get(node);\n        var animationCancelled = !animationDetails;\n        animationDetails = animationDetails || {};\n\n        // if addClass/removeClass is called before something like enter then the\n        // registered parent element may not be present. The code below will ensure\n        // that a final value for parent element is obtained\n        var parentElement = element.parent() || [];\n\n        // animate/structural/class-based animations all have requirements. Otherwise there\n        // is no point in performing an animation. The parent node must also be set.\n        var isValidAnimation = parentElement.length > 0\n                                && (animationDetails.event === 'animate'\n                                    || animationDetails.structural\n                                    || hasAnimationClasses(animationDetails));\n\n        // this means that the previous animation was cancelled\n        // even if the follow-up animation is the same event\n        if (animationCancelled || animationDetails.counter !== counter || !isValidAnimation) {\n          // if another animation did not take over then we need\n          // to make sure that the domOperation and options are\n          // handled accordingly\n          if (animationCancelled) {\n            applyAnimationClasses(element, options);\n            applyAnimationStyles(element, options);\n          }\n\n          // if the event changed from something like enter to leave then we do\n          // it, otherwise if it's the same then the end result will be the same too\n          if (animationCancelled || (isStructural && animationDetails.event !== event)) {\n            options.domOperation();\n            runner.end();\n          }\n\n          // in the event that the element animation was not cancelled or a follow-up animation\n          // isn't allowed to animate from here then we need to clear the state of the element\n          // so that any future animations won't read the expired animation data.\n          if (!isValidAnimation) {\n            clearElementAnimationState(node);\n          }\n\n          return;\n        }\n\n        // this combined multiple class to addClass / removeClass into a setClass event\n        // so long as a structural event did not take over the animation\n        event = !animationDetails.structural && hasAnimationClasses(animationDetails, true)\n            ? 'setClass'\n            : animationDetails.event;\n\n        markElementAnimationState(node, RUNNING_STATE);\n        var realRunner = $$animation(element, event, animationDetails.options);\n\n        // this will update the runner's flow-control events based on\n        // the `realRunner` object.\n        runner.setHost(realRunner);\n        notifyProgress(runner, event, 'start', {});\n\n        realRunner.done(function(status) {\n          close(!status);\n          var animationDetails = activeAnimationsLookup.get(node);\n          if (animationDetails && animationDetails.counter === counter) {\n            clearElementAnimationState(node);\n          }\n          notifyProgress(runner, event, 'close', {});\n        });\n      });\n\n      return runner;\n\n      function notifyProgress(runner, event, phase, data) {\n        runInNextPostDigestOrNow(function() {\n          var callbacks = findCallbacks(parentNode, node, event);\n          if (callbacks.length) {\n            // do not optimize this call here to RAF because\n            // we don't know how heavy the callback code here will\n            // be and if this code is buffered then this can\n            // lead to a performance regression.\n            $$rAF(function() {\n              forEach(callbacks, function(callback) {\n                callback(element, phase, data);\n              });\n              cleanupEventListeners(phase, node);\n            });\n          } else {\n            cleanupEventListeners(phase, node);\n          }\n        });\n        runner.progress(event, phase, data);\n      }\n\n      function close(reject) {\n        clearGeneratedClasses(element, options);\n        applyAnimationClasses(element, options);\n        applyAnimationStyles(element, options);\n        options.domOperation();\n        runner.complete(!reject);\n      }\n    }\n\n    function closeChildAnimations(node) {\n      var children = node.querySelectorAll('[' + NG_ANIMATE_ATTR_NAME + ']');\n      forEach(children, function(child) {\n        var state = parseInt(child.getAttribute(NG_ANIMATE_ATTR_NAME), 10);\n        var animationDetails = activeAnimationsLookup.get(child);\n        if (animationDetails) {\n          switch (state) {\n            case RUNNING_STATE:\n              animationDetails.runner.end();\n              /* falls through */\n            case PRE_DIGEST_STATE:\n              activeAnimationsLookup.delete(child);\n              break;\n          }\n        }\n      });\n    }\n\n    function clearElementAnimationState(node) {\n      node.removeAttribute(NG_ANIMATE_ATTR_NAME);\n      activeAnimationsLookup.delete(node);\n    }\n\n    /**\n     * This fn returns false if any of the following is true:\n     * a) animations on any parent element are disabled, and animations on the element aren't explicitly allowed\n     * b) a parent element has an ongoing structural animation, and animateChildren is false\n     * c) the element is not a child of the body\n     * d) the element is not a child of the $rootElement\n     */\n    function areAnimationsAllowed(node, parentNode, event) {\n      var bodyNode = $document[0].body;\n      var rootNode = getDomNode($rootElement);\n\n      var bodyNodeDetected = (node === bodyNode) || node.nodeName === 'HTML';\n      var rootNodeDetected = (node === rootNode);\n      var parentAnimationDetected = false;\n      var elementDisabled = disabledElementsLookup.get(node);\n      var animateChildren;\n\n      var parentHost = jqLite.data(node, NG_ANIMATE_PIN_DATA);\n      if (parentHost) {\n        parentNode = getDomNode(parentHost);\n      }\n\n      while (parentNode) {\n        if (!rootNodeDetected) {\n          // angular doesn't want to attempt to animate elements outside of the application\n          // therefore we need to ensure that the rootElement is an ancestor of the current element\n          rootNodeDetected = (parentNode === rootNode);\n        }\n\n        if (parentNode.nodeType !== ELEMENT_NODE) {\n          // no point in inspecting the #document element\n          break;\n        }\n\n        var details = activeAnimationsLookup.get(parentNode) || {};\n        // either an enter, leave or move animation will commence\n        // therefore we can't allow any animations to take place\n        // but if a parent animation is class-based then that's ok\n        if (!parentAnimationDetected) {\n          var parentNodeDisabled = disabledElementsLookup.get(parentNode);\n\n          if (parentNodeDisabled === true && elementDisabled !== false) {\n            // disable animations if the user hasn't explicitly enabled animations on the\n            // current element\n            elementDisabled = true;\n            // element is disabled via parent element, no need to check anything else\n            break;\n          } else if (parentNodeDisabled === false) {\n            elementDisabled = false;\n          }\n          parentAnimationDetected = details.structural;\n        }\n\n        if (isUndefined(animateChildren) || animateChildren === true) {\n          var value = jqLite.data(parentNode, NG_ANIMATE_CHILDREN_DATA);\n          if (isDefined(value)) {\n            animateChildren = value;\n          }\n        }\n\n        // there is no need to continue traversing at this point\n        if (parentAnimationDetected && animateChildren === false) break;\n\n        if (!bodyNodeDetected) {\n          // we also need to ensure that the element is or will be a part of the body element\n          // otherwise it is pointless to even issue an animation to be rendered\n          bodyNodeDetected = (parentNode === bodyNode);\n        }\n\n        if (bodyNodeDetected && rootNodeDetected) {\n          // If both body and root have been found, any other checks are pointless,\n          // as no animation data should live outside the application\n          break;\n        }\n\n        if (!rootNodeDetected) {\n          // If `rootNode` is not detected, check if `parentNode` is pinned to another element\n          parentHost = jqLite.data(parentNode, NG_ANIMATE_PIN_DATA);\n          if (parentHost) {\n            // The pin target element becomes the next parent element\n            parentNode = getDomNode(parentHost);\n            continue;\n          }\n        }\n\n        parentNode = parentNode.parentNode;\n      }\n\n      var allowAnimation = (!parentAnimationDetected || animateChildren) && elementDisabled !== true;\n      return allowAnimation && rootNodeDetected && bodyNodeDetected;\n    }\n\n    function markElementAnimationState(node, state, details) {\n      details = details || {};\n      details.state = state;\n\n      node.setAttribute(NG_ANIMATE_ATTR_NAME, state);\n\n      var oldValue = activeAnimationsLookup.get(node);\n      var newValue = oldValue\n          ? extend(oldValue, details)\n          : details;\n      activeAnimationsLookup.set(node, newValue);\n    }\n  }];\n}];\n\n/* exported $$AnimationProvider */\n\nvar $$AnimationProvider = ['$animateProvider', /** @this */ function($animateProvider) {\n  var NG_ANIMATE_REF_ATTR = 'ng-animate-ref';\n\n  var drivers = this.drivers = [];\n\n  var RUNNER_STORAGE_KEY = '$$animationRunner';\n\n  function setRunner(element, runner) {\n    element.data(RUNNER_STORAGE_KEY, runner);\n  }\n\n  function removeRunner(element) {\n    element.removeData(RUNNER_STORAGE_KEY);\n  }\n\n  function getRunner(element) {\n    return element.data(RUNNER_STORAGE_KEY);\n  }\n\n  this.$get = ['$$jqLite', '$rootScope', '$injector', '$$AnimateRunner', '$$Map', '$$rAFScheduler',\n       function($$jqLite,   $rootScope,   $injector,   $$AnimateRunner,   $$Map,   $$rAFScheduler) {\n\n    var animationQueue = [];\n    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);\n\n    function sortAnimations(animations) {\n      var tree = { children: [] };\n      var i, lookup = new $$Map();\n\n      // this is done first beforehand so that the map\n      // is filled with a list of the elements that will be animated\n      for (i = 0; i < animations.length; i++) {\n        var animation = animations[i];\n        lookup.set(animation.domNode, animations[i] = {\n          domNode: animation.domNode,\n          fn: animation.fn,\n          children: []\n        });\n      }\n\n      for (i = 0; i < animations.length; i++) {\n        processNode(animations[i]);\n      }\n\n      return flatten(tree);\n\n      function processNode(entry) {\n        if (entry.processed) return entry;\n        entry.processed = true;\n\n        var elementNode = entry.domNode;\n        var parentNode = elementNode.parentNode;\n        lookup.set(elementNode, entry);\n\n        var parentEntry;\n        while (parentNode) {\n          parentEntry = lookup.get(parentNode);\n          if (parentEntry) {\n            if (!parentEntry.processed) {\n              parentEntry = processNode(parentEntry);\n            }\n            break;\n          }\n          parentNode = parentNode.parentNode;\n        }\n\n        (parentEntry || tree).children.push(entry);\n        return entry;\n      }\n\n      function flatten(tree) {\n        var result = [];\n        var queue = [];\n        var i;\n\n        for (i = 0; i < tree.children.length; i++) {\n          queue.push(tree.children[i]);\n        }\n\n        var remainingLevelEntries = queue.length;\n        var nextLevelEntries = 0;\n        var row = [];\n\n        for (i = 0; i < queue.length; i++) {\n          var entry = queue[i];\n          if (remainingLevelEntries <= 0) {\n            remainingLevelEntries = nextLevelEntries;\n            nextLevelEntries = 0;\n            result.push(row);\n            row = [];\n          }\n          row.push(entry.fn);\n          entry.children.forEach(function(childEntry) {\n            nextLevelEntries++;\n            queue.push(childEntry);\n          });\n          remainingLevelEntries--;\n        }\n\n        if (row.length) {\n          result.push(row);\n        }\n\n        return result;\n      }\n    }\n\n    // TODO(matsko): document the signature in a better way\n    return function(element, event, options) {\n      options = prepareAnimationOptions(options);\n      var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;\n\n      // there is no animation at the current moment, however\n      // these runner methods will get later updated with the\n      // methods leading into the driver's end/cancel methods\n      // for now they just stop the animation from starting\n      var runner = new $$AnimateRunner({\n        end: function() { close(); },\n        cancel: function() { close(true); }\n      });\n\n      if (!drivers.length) {\n        close();\n        return runner;\n      }\n\n      setRunner(element, runner);\n\n      var classes = mergeClasses(element.attr('class'), mergeClasses(options.addClass, options.removeClass));\n      var tempClasses = options.tempClasses;\n      if (tempClasses) {\n        classes += ' ' + tempClasses;\n        options.tempClasses = null;\n      }\n\n      var prepareClassName;\n      if (isStructural) {\n        prepareClassName = 'ng-' + event + PREPARE_CLASS_SUFFIX;\n        $$jqLite.addClass(element, prepareClassName);\n      }\n\n      animationQueue.push({\n        // this data is used by the postDigest code and passed into\n        // the driver step function\n        element: element,\n        classes: classes,\n        event: event,\n        structural: isStructural,\n        options: options,\n        beforeStart: beforeStart,\n        close: close\n      });\n\n      element.on('$destroy', handleDestroyedElement);\n\n      // we only want there to be one function called within the post digest\n      // block. This way we can group animations for all the animations that\n      // were apart of the same postDigest flush call.\n      if (animationQueue.length > 1) return runner;\n\n      $rootScope.$$postDigest(function() {\n        var animations = [];\n        forEach(animationQueue, function(entry) {\n          // the element was destroyed early on which removed the runner\n          // form its storage. This means we can't animate this element\n          // at all and it already has been closed due to destruction.\n          if (getRunner(entry.element)) {\n            animations.push(entry);\n          } else {\n            entry.close();\n          }\n        });\n\n        // now any future animations will be in another postDigest\n        animationQueue.length = 0;\n\n        var groupedAnimations = groupAnimations(animations);\n        var toBeSortedAnimations = [];\n\n        forEach(groupedAnimations, function(animationEntry) {\n          toBeSortedAnimations.push({\n            domNode: getDomNode(animationEntry.from ? animationEntry.from.element : animationEntry.element),\n            fn: function triggerAnimationStart() {\n              // it's important that we apply the `ng-animate` CSS class and the\n              // temporary classes before we do any driver invoking since these\n              // CSS classes may be required for proper CSS detection.\n              animationEntry.beforeStart();\n\n              var startAnimationFn, closeFn = animationEntry.close;\n\n              // in the event that the element was removed before the digest runs or\n              // during the RAF sequencing then we should not trigger the animation.\n              var targetElement = animationEntry.anchors\n                  ? (animationEntry.from.element || animationEntry.to.element)\n                  : animationEntry.element;\n\n              if (getRunner(targetElement)) {\n                var operation = invokeFirstDriver(animationEntry);\n                if (operation) {\n                  startAnimationFn = operation.start;\n                }\n              }\n\n              if (!startAnimationFn) {\n                closeFn();\n              } else {\n                var animationRunner = startAnimationFn();\n                animationRunner.done(function(status) {\n                  closeFn(!status);\n                });\n                updateAnimationRunners(animationEntry, animationRunner);\n              }\n            }\n          });\n        });\n\n        // we need to sort each of the animations in order of parent to child\n        // relationships. This ensures that the child classes are applied at the\n        // right time.\n        $$rAFScheduler(sortAnimations(toBeSortedAnimations));\n      });\n\n      return runner;\n\n      // TODO(matsko): change to reference nodes\n      function getAnchorNodes(node) {\n        var SELECTOR = '[' + NG_ANIMATE_REF_ATTR + ']';\n        var items = node.hasAttribute(NG_ANIMATE_REF_ATTR)\n              ? [node]\n              : node.querySelectorAll(SELECTOR);\n        var anchors = [];\n        forEach(items, function(node) {\n          var attr = node.getAttribute(NG_ANIMATE_REF_ATTR);\n          if (attr && attr.length) {\n            anchors.push(node);\n          }\n        });\n        return anchors;\n      }\n\n      function groupAnimations(animations) {\n        var preparedAnimations = [];\n        var refLookup = {};\n        forEach(animations, function(animation, index) {\n          var element = animation.element;\n          var node = getDomNode(element);\n          var event = animation.event;\n          var enterOrMove = ['enter', 'move'].indexOf(event) >= 0;\n          var anchorNodes = animation.structural ? getAnchorNodes(node) : [];\n\n          if (anchorNodes.length) {\n            var direction = enterOrMove ? 'to' : 'from';\n\n            forEach(anchorNodes, function(anchor) {\n              var key = anchor.getAttribute(NG_ANIMATE_REF_ATTR);\n              refLookup[key] = refLookup[key] || {};\n              refLookup[key][direction] = {\n                animationID: index,\n                element: jqLite(anchor)\n              };\n            });\n          } else {\n            preparedAnimations.push(animation);\n          }\n        });\n\n        var usedIndicesLookup = {};\n        var anchorGroups = {};\n        forEach(refLookup, function(operations, key) {\n          var from = operations.from;\n          var to = operations.to;\n\n          if (!from || !to) {\n            // only one of these is set therefore we can't have an\n            // anchor animation since all three pieces are required\n            var index = from ? from.animationID : to.animationID;\n            var indexKey = index.toString();\n            if (!usedIndicesLookup[indexKey]) {\n              usedIndicesLookup[indexKey] = true;\n              preparedAnimations.push(animations[index]);\n            }\n            return;\n          }\n\n          var fromAnimation = animations[from.animationID];\n          var toAnimation = animations[to.animationID];\n          var lookupKey = from.animationID.toString();\n          if (!anchorGroups[lookupKey]) {\n            var group = anchorGroups[lookupKey] = {\n              structural: true,\n              beforeStart: function() {\n                fromAnimation.beforeStart();\n                toAnimation.beforeStart();\n              },\n              close: function() {\n                fromAnimation.close();\n                toAnimation.close();\n              },\n              classes: cssClassesIntersection(fromAnimation.classes, toAnimation.classes),\n              from: fromAnimation,\n              to: toAnimation,\n              anchors: [] // TODO(matsko): change to reference nodes\n            };\n\n            // the anchor animations require that the from and to elements both have at least\n            // one shared CSS class which effectively marries the two elements together to use\n            // the same animation driver and to properly sequence the anchor animation.\n            if (group.classes.length) {\n              preparedAnimations.push(group);\n            } else {\n              preparedAnimations.push(fromAnimation);\n              preparedAnimations.push(toAnimation);\n            }\n          }\n\n          anchorGroups[lookupKey].anchors.push({\n            'out': from.element, 'in': to.element\n          });\n        });\n\n        return preparedAnimations;\n      }\n\n      function cssClassesIntersection(a,b) {\n        a = a.split(' ');\n        b = b.split(' ');\n        var matches = [];\n\n        for (var i = 0; i < a.length; i++) {\n          var aa = a[i];\n          if (aa.substring(0,3) === 'ng-') continue;\n\n          for (var j = 0; j < b.length; j++) {\n            if (aa === b[j]) {\n              matches.push(aa);\n              break;\n            }\n          }\n        }\n\n        return matches.join(' ');\n      }\n\n      function invokeFirstDriver(animationDetails) {\n        // we loop in reverse order since the more general drivers (like CSS and JS)\n        // may attempt more elements, but custom drivers are more particular\n        for (var i = drivers.length - 1; i >= 0; i--) {\n          var driverName = drivers[i];\n          var factory = $injector.get(driverName);\n          var driver = factory(animationDetails);\n          if (driver) {\n            return driver;\n          }\n        }\n      }\n\n      function beforeStart() {\n        element.addClass(NG_ANIMATE_CLASSNAME);\n        if (tempClasses) {\n          $$jqLite.addClass(element, tempClasses);\n        }\n        if (prepareClassName) {\n          $$jqLite.removeClass(element, prepareClassName);\n          prepareClassName = null;\n        }\n      }\n\n      function updateAnimationRunners(animation, newRunner) {\n        if (animation.from && animation.to) {\n          update(animation.from.element);\n          update(animation.to.element);\n        } else {\n          update(animation.element);\n        }\n\n        function update(element) {\n          var runner = getRunner(element);\n          if (runner) runner.setHost(newRunner);\n        }\n      }\n\n      function handleDestroyedElement() {\n        var runner = getRunner(element);\n        if (runner && (event !== 'leave' || !options.$$domOperationFired)) {\n          runner.end();\n        }\n      }\n\n      function close(rejected) {\n        element.off('$destroy', handleDestroyedElement);\n        removeRunner(element);\n\n        applyAnimationClasses(element, options);\n        applyAnimationStyles(element, options);\n        options.domOperation();\n\n        if (tempClasses) {\n          $$jqLite.removeClass(element, tempClasses);\n        }\n\n        element.removeClass(NG_ANIMATE_CLASSNAME);\n        runner.complete(!rejected);\n      }\n    };\n  }];\n}];\n\n/**\n * @ngdoc directive\n * @name ngAnimateSwap\n * @restrict A\n * @scope\n *\n * @description\n *\n * ngAnimateSwap is a animation-oriented directive that allows for the container to\n * be removed and entered in whenever the associated expression changes. A\n * common usecase for this directive is a rotating banner or slider component which\n * contains one image being present at a time. When the active image changes\n * then the old image will perform a `leave` animation and the new element\n * will be inserted via an `enter` animation.\n *\n * @animations\n * | Animation                        | Occurs                               |\n * |----------------------------------|--------------------------------------|\n * | {@link ng.$animate#enter enter}  | when the new element is inserted to the DOM  |\n * | {@link ng.$animate#leave leave}  | when the old element is removed from the DOM |\n *\n * @example\n * <example name=\"ngAnimateSwap-directive\" module=\"ngAnimateSwapExample\"\n *          deps=\"angular-animate.js\"\n *          animations=\"true\" fixBase=\"true\">\n *   <file name=\"index.html\">\n *     <div class=\"container\" ng-controller=\"AppCtrl\">\n *       <div ng-animate-swap=\"number\" class=\"cell swap-animation\" ng-class=\"colorClass(number)\">\n *         {{ number }}\n *       </div>\n *     </div>\n *   </file>\n *   <file name=\"script.js\">\n *     angular.module('ngAnimateSwapExample', ['ngAnimate'])\n *       .controller('AppCtrl', ['$scope', '$interval', function($scope, $interval) {\n *         $scope.number = 0;\n *         $interval(function() {\n *           $scope.number++;\n *         }, 1000);\n *\n *         var colors = ['red','blue','green','yellow','orange'];\n *         $scope.colorClass = function(number) {\n *           return colors[number % colors.length];\n *         };\n *       }]);\n *   </file>\n *  <file name=\"animations.css\">\n *  .container {\n *    height:250px;\n *    width:250px;\n *    position:relative;\n *    overflow:hidden;\n *    border:2px solid black;\n *  }\n *  .container .cell {\n *    font-size:150px;\n *    text-align:center;\n *    line-height:250px;\n *    position:absolute;\n *    top:0;\n *    left:0;\n *    right:0;\n *    border-bottom:2px solid black;\n *  }\n *  .swap-animation.ng-enter, .swap-animation.ng-leave {\n *    transition:0.5s linear all;\n *  }\n *  .swap-animation.ng-enter {\n *    top:-250px;\n *  }\n *  .swap-animation.ng-enter-active {\n *    top:0px;\n *  }\n *  .swap-animation.ng-leave {\n *    top:0px;\n *  }\n *  .swap-animation.ng-leave-active {\n *    top:250px;\n *  }\n *  .red { background:red; }\n *  .green { background:green; }\n *  .blue { background:blue; }\n *  .yellow { background:yellow; }\n *  .orange { background:orange; }\n *  </file>\n * </example>\n */\nvar ngAnimateSwapDirective = ['$animate', '$rootScope', function($animate, $rootScope) {\n  return {\n    restrict: 'A',\n    transclude: 'element',\n    terminal: true,\n    priority: 600, // we use 600 here to ensure that the directive is caught before others\n    link: function(scope, $element, attrs, ctrl, $transclude) {\n      var previousElement, previousScope;\n      scope.$watchCollection(attrs.ngAnimateSwap || attrs['for'], function(value) {\n        if (previousElement) {\n          $animate.leave(previousElement);\n        }\n        if (previousScope) {\n          previousScope.$destroy();\n          previousScope = null;\n        }\n        if (value || value === 0) {\n          previousScope = scope.$new();\n          $transclude(previousScope, function(element) {\n            previousElement = element;\n            $animate.enter(element, null, $element);\n          });\n        }\n      });\n    }\n  };\n}];\n\n/**\n * @ngdoc module\n * @name ngAnimate\n * @description\n *\n * The `ngAnimate` module provides support for CSS-based animations (keyframes and transitions) as well as JavaScript-based animations via\n * callback hooks. Animations are not enabled by default, however, by including `ngAnimate` the animation hooks are enabled for an Angular app.\n *\n * ## Usage\n * Simply put, there are two ways to make use of animations when ngAnimate is used: by using **CSS** and **JavaScript**. The former works purely based\n * using CSS (by using matching CSS selectors/styles) and the latter triggers animations that are registered via `module.animation()`. For\n * both CSS and JS animations the sole requirement is to have a matching `CSS class` that exists both in the registered animation and within\n * the HTML element that the animation will be triggered on.\n *\n * ## Directive Support\n * The following directives are \"animation aware\":\n *\n * | Directive                                                                                                | Supported Animations                                                     |\n * |----------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------|\n * | {@link ng.directive:ngRepeat#animations ngRepeat}                                                        | enter, leave and move                                                    |\n * | {@link ngRoute.directive:ngView#animations ngView}                                                       | enter and leave                                                          |\n * | {@link ng.directive:ngInclude#animations ngInclude}                                                      | enter and leave                                                          |\n * | {@link ng.directive:ngSwitch#animations ngSwitch}                                                        | enter and leave                                                          |\n * | {@link ng.directive:ngIf#animations ngIf}                                                                | enter and leave                                                          |\n * | {@link ng.directive:ngClass#animations ngClass}                                                          | add and remove (the CSS class(es) present)                               |\n * | {@link ng.directive:ngShow#animations ngShow} & {@link ng.directive:ngHide#animations ngHide}            | add and remove (the ng-hide class value)                                 |\n * | {@link ng.directive:form#animations form} & {@link ng.directive:ngModel#animations ngModel}    | add and remove (dirty, pristine, valid, invalid & all other validations) |\n * | {@link module:ngMessages#animations ngMessages}                                                          | add and remove (ng-active & ng-inactive)                                 |\n * | {@link module:ngMessages#animations ngMessage}                                                           | enter and leave                                                          |\n *\n * (More information can be found by visiting each the documentation associated with each directive.)\n *\n * ## CSS-based Animations\n *\n * CSS-based animations with ngAnimate are unique since they require no JavaScript code at all. By using a CSS class that we reference between our HTML\n * and CSS code we can create an animation that will be picked up by Angular when an underlying directive performs an operation.\n *\n * The example below shows how an `enter` animation can be made possible on an element using `ng-if`:\n *\n * ```html\n * <div ng-if=\"bool\" class=\"fade\">\n *    Fade me in out\n * </div>\n * <button ng-click=\"bool=true\">Fade In!</button>\n * <button ng-click=\"bool=false\">Fade Out!</button>\n * ```\n *\n * Notice the CSS class **fade**? We can now create the CSS transition code that references this class:\n *\n * ```css\n * /&#42; The starting CSS styles for the enter animation &#42;/\n * .fade.ng-enter {\n *   transition:0.5s linear all;\n *   opacity:0;\n * }\n *\n * /&#42; The finishing CSS styles for the enter animation &#42;/\n * .fade.ng-enter.ng-enter-active {\n *   opacity:1;\n * }\n * ```\n *\n * The key thing to remember here is that, depending on the animation event (which each of the directives above trigger depending on what's going on) two\n * generated CSS classes will be applied to the element; in the example above we have `.ng-enter` and `.ng-enter-active`. For CSS transitions, the transition\n * code **must** be defined within the starting CSS class (in this case `.ng-enter`). The destination class is what the transition will animate towards.\n *\n * If for example we wanted to create animations for `leave` and `move` (ngRepeat triggers move) then we can do so using the same CSS naming conventions:\n *\n * ```css\n * /&#42; now the element will fade out before it is removed from the DOM &#42;/\n * .fade.ng-leave {\n *   transition:0.5s linear all;\n *   opacity:1;\n * }\n * .fade.ng-leave.ng-leave-active {\n *   opacity:0;\n * }\n * ```\n *\n * We can also make use of **CSS Keyframes** by referencing the keyframe animation within the starting CSS class:\n *\n * ```css\n * /&#42; there is no need to define anything inside of the destination\n * CSS class since the keyframe will take charge of the animation &#42;/\n * .fade.ng-leave {\n *   animation: my_fade_animation 0.5s linear;\n *   -webkit-animation: my_fade_animation 0.5s linear;\n * }\n *\n * @keyframes my_fade_animation {\n *   from { opacity:1; }\n *   to { opacity:0; }\n * }\n *\n * @-webkit-keyframes my_fade_animation {\n *   from { opacity:1; }\n *   to { opacity:0; }\n * }\n * ```\n *\n * Feel free also mix transitions and keyframes together as well as any other CSS classes on the same element.\n *\n * ### CSS Class-based Animations\n *\n * Class-based animations (animations that are triggered via `ngClass`, `ngShow`, `ngHide` and some other directives) have a slightly different\n * naming convention. Class-based animations are basic enough that a standard transition or keyframe can be referenced on the class being added\n * and removed.\n *\n * For example if we wanted to do a CSS animation for `ngHide` then we place an animation on the `.ng-hide` CSS class:\n *\n * ```html\n * <div ng-show=\"bool\" class=\"fade\">\n *   Show and hide me\n * </div>\n * <button ng-click=\"bool=!bool\">Toggle</button>\n *\n * <style>\n * .fade.ng-hide {\n *   transition:0.5s linear all;\n *   opacity:0;\n * }\n * </style>\n * ```\n *\n * All that is going on here with ngShow/ngHide behind the scenes is the `.ng-hide` class is added/removed (when the hidden state is valid). Since\n * ngShow and ngHide are animation aware then we can match up a transition and ngAnimate handles the rest.\n *\n * In addition the addition and removal of the CSS class, ngAnimate also provides two helper methods that we can use to further decorate the animation\n * with CSS styles.\n *\n * ```html\n * <div ng-class=\"{on:onOff}\" class=\"highlight\">\n *   Highlight this box\n * </div>\n * <button ng-click=\"onOff=!onOff\">Toggle</button>\n *\n * <style>\n * .highlight {\n *   transition:0.5s linear all;\n * }\n * .highlight.on-add {\n *   background:white;\n * }\n * .highlight.on {\n *   background:yellow;\n * }\n * .highlight.on-remove {\n *   background:black;\n * }\n * </style>\n * ```\n *\n * We can also make use of CSS keyframes by placing them within the CSS classes.\n *\n *\n * ### CSS Staggering Animations\n * A Staggering animation is a collection of animations that are issued with a slight delay in between each successive operation resulting in a\n * curtain-like effect. The ngAnimate module (versions >=1.2) supports staggering animations and the stagger effect can be\n * performed by creating a **ng-EVENT-stagger** CSS class and attaching that class to the base CSS class used for\n * the animation. The style property expected within the stagger class can either be a **transition-delay** or an\n * **animation-delay** property (or both if your animation contains both transitions and keyframe animations).\n *\n * ```css\n * .my-animation.ng-enter {\n *   /&#42; standard transition code &#42;/\n *   transition: 1s linear all;\n *   opacity:0;\n * }\n * .my-animation.ng-enter-stagger {\n *   /&#42; this will have a 100ms delay between each successive leave animation &#42;/\n *   transition-delay: 0.1s;\n *\n *   /&#42; As of 1.4.4, this must always be set: it signals ngAnimate\n *     to not accidentally inherit a delay property from another CSS class &#42;/\n *   transition-duration: 0s;\n *\n *   /&#42; if you are using animations instead of transitions you should configure as follows:\n *     animation-delay: 0.1s;\n *     animation-duration: 0s; &#42;/\n * }\n * .my-animation.ng-enter.ng-enter-active {\n *   /&#42; standard transition styles &#42;/\n *   opacity:1;\n * }\n * ```\n *\n * Staggering animations work by default in ngRepeat (so long as the CSS class is defined). Outside of ngRepeat, to use staggering animations\n * on your own, they can be triggered by firing multiple calls to the same event on $animate. However, the restrictions surrounding this\n * are that each of the elements must have the same CSS className value as well as the same parent element. A stagger operation\n * will also be reset if one or more animation frames have passed since the multiple calls to `$animate` were fired.\n *\n * The following code will issue the **ng-leave-stagger** event on the element provided:\n *\n * ```js\n * var kids = parent.children();\n *\n * $animate.leave(kids[0]); //stagger index=0\n * $animate.leave(kids[1]); //stagger index=1\n * $animate.leave(kids[2]); //stagger index=2\n * $animate.leave(kids[3]); //stagger index=3\n * $animate.leave(kids[4]); //stagger index=4\n *\n * window.requestAnimationFrame(function() {\n *   //stagger has reset itself\n *   $animate.leave(kids[5]); //stagger index=0\n *   $animate.leave(kids[6]); //stagger index=1\n *\n *   $scope.$digest();\n * });\n * ```\n *\n * Stagger animations are currently only supported within CSS-defined animations.\n *\n * ### The `ng-animate` CSS class\n *\n * When ngAnimate is animating an element it will apply the `ng-animate` CSS class to the element for the duration of the animation.\n * This is a temporary CSS class and it will be removed once the animation is over (for both JavaScript and CSS-based animations).\n *\n * Therefore, animations can be applied to an element using this temporary class directly via CSS.\n *\n * ```css\n * .zipper.ng-animate {\n *   transition:0.5s linear all;\n * }\n * .zipper.ng-enter {\n *   opacity:0;\n * }\n * .zipper.ng-enter.ng-enter-active {\n *   opacity:1;\n * }\n * .zipper.ng-leave {\n *   opacity:1;\n * }\n * .zipper.ng-leave.ng-leave-active {\n *   opacity:0;\n * }\n * ```\n *\n * (Note that the `ng-animate` CSS class is reserved and it cannot be applied on an element directly since ngAnimate will always remove\n * the CSS class once an animation has completed.)\n *\n *\n * ### The `ng-[event]-prepare` class\n *\n * This is a special class that can be used to prevent unwanted flickering / flash of content before\n * the actual animation starts. The class is added as soon as an animation is initialized, but removed\n * before the actual animation starts (after waiting for a $digest).\n * It is also only added for *structural* animations (`enter`, `move`, and `leave`).\n *\n * In practice, flickering can appear when nesting elements with structural animations such as `ngIf`\n * into elements that have class-based animations such as `ngClass`.\n *\n * ```html\n * <div ng-class=\"{red: myProp}\">\n *   <div ng-class=\"{blue: myProp}\">\n *     <div class=\"message\" ng-if=\"myProp\"></div>\n *   </div>\n * </div>\n * ```\n *\n * It is possible that during the `enter` animation, the `.message` div will be briefly visible before it starts animating.\n * In that case, you can add styles to the CSS that make sure the element stays hidden before the animation starts:\n *\n * ```css\n * .message.ng-enter-prepare {\n *   opacity: 0;\n * }\n *\n * ```\n *\n * ## JavaScript-based Animations\n *\n * ngAnimate also allows for animations to be consumed by JavaScript code. The approach is similar to CSS-based animations (where there is a shared\n * CSS class that is referenced in our HTML code) but in addition we need to register the JavaScript animation on the module. By making use of the\n * `module.animation()` module function we can register the animation.\n *\n * Let's see an example of a enter/leave animation using `ngRepeat`:\n *\n * ```html\n * <div ng-repeat=\"item in items\" class=\"slide\">\n *   {{ item }}\n * </div>\n * ```\n *\n * See the **slide** CSS class? Let's use that class to define an animation that we'll structure in our module code by using `module.animation`:\n *\n * ```js\n * myModule.animation('.slide', [function() {\n *   return {\n *     // make note that other events (like addClass/removeClass)\n *     // have different function input parameters\n *     enter: function(element, doneFn) {\n *       jQuery(element).fadeIn(1000, doneFn);\n *\n *       // remember to call doneFn so that angular\n *       // knows that the animation has concluded\n *     },\n *\n *     move: function(element, doneFn) {\n *       jQuery(element).fadeIn(1000, doneFn);\n *     },\n *\n *     leave: function(element, doneFn) {\n *       jQuery(element).fadeOut(1000, doneFn);\n *     }\n *   }\n * }]);\n * ```\n *\n * The nice thing about JS-based animations is that we can inject other services and make use of advanced animation libraries such as\n * greensock.js and velocity.js.\n *\n * If our animation code class-based (meaning that something like `ngClass`, `ngHide` and `ngShow` triggers it) then we can still define\n * our animations inside of the same registered animation, however, the function input arguments are a bit different:\n *\n * ```html\n * <div ng-class=\"color\" class=\"colorful\">\n *   this box is moody\n * </div>\n * <button ng-click=\"color='red'\">Change to red</button>\n * <button ng-click=\"color='blue'\">Change to blue</button>\n * <button ng-click=\"color='green'\">Change to green</button>\n * ```\n *\n * ```js\n * myModule.animation('.colorful', [function() {\n *   return {\n *     addClass: function(element, className, doneFn) {\n *       // do some cool animation and call the doneFn\n *     },\n *     removeClass: function(element, className, doneFn) {\n *       // do some cool animation and call the doneFn\n *     },\n *     setClass: function(element, addedClass, removedClass, doneFn) {\n *       // do some cool animation and call the doneFn\n *     }\n *   }\n * }]);\n * ```\n *\n * ## CSS + JS Animations Together\n *\n * AngularJS 1.4 and higher has taken steps to make the amalgamation of CSS and JS animations more flexible. However, unlike earlier versions of Angular,\n * defining CSS and JS animations to work off of the same CSS class will not work anymore. Therefore the example below will only result in **JS animations taking\n * charge of the animation**:\n *\n * ```html\n * <div ng-if=\"bool\" class=\"slide\">\n *   Slide in and out\n * </div>\n * ```\n *\n * ```js\n * myModule.animation('.slide', [function() {\n *   return {\n *     enter: function(element, doneFn) {\n *       jQuery(element).slideIn(1000, doneFn);\n *     }\n *   }\n * }]);\n * ```\n *\n * ```css\n * .slide.ng-enter {\n *   transition:0.5s linear all;\n *   transform:translateY(-100px);\n * }\n * .slide.ng-enter.ng-enter-active {\n *   transform:translateY(0);\n * }\n * ```\n *\n * Does this mean that CSS and JS animations cannot be used together? Do JS-based animations always have higher priority? We can make up for the\n * lack of CSS animations by using the `$animateCss` service to trigger our own tweaked-out, CSS-based animations directly from\n * our own JS-based animation code:\n *\n * ```js\n * myModule.animation('.slide', ['$animateCss', function($animateCss) {\n *   return {\n *     enter: function(element) {\n*        // this will trigger `.slide.ng-enter` and `.slide.ng-enter-active`.\n *       return $animateCss(element, {\n *         event: 'enter',\n *         structural: true\n *       });\n *     }\n *   }\n * }]);\n * ```\n *\n * The nice thing here is that we can save bandwidth by sticking to our CSS-based animation code and we don't need to rely on a 3rd-party animation framework.\n *\n * The `$animateCss` service is very powerful since we can feed in all kinds of extra properties that will be evaluated and fed into a CSS transition or\n * keyframe animation. For example if we wanted to animate the height of an element while adding and removing classes then we can do so by providing that\n * data into `$animateCss` directly:\n *\n * ```js\n * myModule.animation('.slide', ['$animateCss', function($animateCss) {\n *   return {\n *     enter: function(element) {\n *       return $animateCss(element, {\n *         event: 'enter',\n *         structural: true,\n *         addClass: 'maroon-setting',\n *         from: { height:0 },\n *         to: { height: 200 }\n *       });\n *     }\n *   }\n * }]);\n * ```\n *\n * Now we can fill in the rest via our transition CSS code:\n *\n * ```css\n * /&#42; the transition tells ngAnimate to make the animation happen &#42;/\n * .slide.ng-enter { transition:0.5s linear all; }\n *\n * /&#42; this extra CSS class will be absorbed into the transition\n * since the $animateCss code is adding the class &#42;/\n * .maroon-setting { background:red; }\n * ```\n *\n * And `$animateCss` will figure out the rest. Just make sure to have the `done()` callback fire the `doneFn` function to signal when the animation is over.\n *\n * To learn more about what's possible be sure to visit the {@link ngAnimate.$animateCss $animateCss service}.\n *\n * ## Animation Anchoring (via `ng-animate-ref`)\n *\n * ngAnimate in AngularJS 1.4 comes packed with the ability to cross-animate elements between\n * structural areas of an application (like views) by pairing up elements using an attribute\n * called `ng-animate-ref`.\n *\n * Let's say for example we have two views that are managed by `ng-view` and we want to show\n * that there is a relationship between two components situated in within these views. By using the\n * `ng-animate-ref` attribute we can identify that the two components are paired together and we\n * can then attach an animation, which is triggered when the view changes.\n *\n * Say for example we have the following template code:\n *\n * ```html\n * \x3c!-- index.html --\x3e\n * <div ng-view class=\"view-animation\">\n * </div>\n *\n * \x3c!-- home.html --\x3e\n * <a href=\"#/banner-page\">\n *   <img src=\"./banner.jpg\" class=\"banner\" ng-animate-ref=\"banner\">\n * </a>\n *\n * \x3c!-- banner-page.html --\x3e\n * <img src=\"./banner.jpg\" class=\"banner\" ng-animate-ref=\"banner\">\n * ```\n *\n * Now, when the view changes (once the link is clicked), ngAnimate will examine the\n * HTML contents to see if there is a match reference between any components in the view\n * that is leaving and the view that is entering. It will scan both the view which is being\n * removed (leave) and inserted (enter) to see if there are any paired DOM elements that\n * contain a matching ref value.\n *\n * The two images match since they share the same ref value. ngAnimate will now create a\n * transport element (which is a clone of the first image element) and it will then attempt\n * to animate to the position of the second image element in the next view. For the animation to\n * work a special CSS class called `ng-anchor` will be added to the transported element.\n *\n * We can now attach a transition onto the `.banner.ng-anchor` CSS class and then\n * ngAnimate will handle the entire transition for us as well as the addition and removal of\n * any changes of CSS classes between the elements:\n *\n * ```css\n * .banner.ng-anchor {\n *   /&#42; this animation will last for 1 second since there are\n *          two phases to the animation (an `in` and an `out` phase) &#42;/\n *   transition:0.5s linear all;\n * }\n * ```\n *\n * We also **must** include animations for the views that are being entered and removed\n * (otherwise anchoring wouldn't be possible since the new view would be inserted right away).\n *\n * ```css\n * .view-animation.ng-enter, .view-animation.ng-leave {\n *   transition:0.5s linear all;\n *   position:fixed;\n *   left:0;\n *   top:0;\n *   width:100%;\n * }\n * .view-animation.ng-enter {\n *   transform:translateX(100%);\n * }\n * .view-animation.ng-leave,\n * .view-animation.ng-enter.ng-enter-active {\n *   transform:translateX(0%);\n * }\n * .view-animation.ng-leave.ng-leave-active {\n *   transform:translateX(-100%);\n * }\n * ```\n *\n * Now we can jump back to the anchor animation. When the animation happens, there are two stages that occur:\n * an `out` and an `in` stage. The `out` stage happens first and that is when the element is animated away\n * from its origin. Once that animation is over then the `in` stage occurs which animates the\n * element to its destination. The reason why there are two animations is to give enough time\n * for the enter animation on the new element to be ready.\n *\n * The example above sets up a transition for both the in and out phases, but we can also target the out or\n * in phases directly via `ng-anchor-out` and `ng-anchor-in`.\n *\n * ```css\n * .banner.ng-anchor-out {\n *   transition: 0.5s linear all;\n *\n *   /&#42; the scale will be applied during the out animation,\n *          but will be animated away when the in animation runs &#42;/\n *   transform: scale(1.2);\n * }\n *\n * .banner.ng-anchor-in {\n *   transition: 1s linear all;\n * }\n * ```\n *\n *\n *\n *\n * ### Anchoring Demo\n *\n  <example module=\"anchoringExample\"\n           name=\"anchoringExample\"\n           id=\"anchoringExample\"\n           deps=\"angular-animate.js;angular-route.js\"\n           animations=\"true\">\n    <file name=\"index.html\">\n      <a href=\"#!/\">Home</a>\n      <hr />\n      <div class=\"view-container\">\n        <div ng-view class=\"view\"></div>\n      </div>\n    </file>\n    <file name=\"script.js\">\n      angular.module('anchoringExample', ['ngAnimate', 'ngRoute'])\n        .config(['$routeProvider', function($routeProvider) {\n          $routeProvider.when('/', {\n            templateUrl: 'home.html',\n            controller: 'HomeController as home'\n          });\n          $routeProvider.when('/profile/:id', {\n            templateUrl: 'profile.html',\n            controller: 'ProfileController as profile'\n          });\n        }])\n        .run(['$rootScope', function($rootScope) {\n          $rootScope.records = [\n            { id: 1, title: 'Miss Beulah Roob' },\n            { id: 2, title: 'Trent Morissette' },\n            { id: 3, title: 'Miss Ava Pouros' },\n            { id: 4, title: 'Rod Pouros' },\n            { id: 5, title: 'Abdul Rice' },\n            { id: 6, title: 'Laurie Rutherford Sr.' },\n            { id: 7, title: 'Nakia McLaughlin' },\n            { id: 8, title: 'Jordon Blanda DVM' },\n            { id: 9, title: 'Rhoda Hand' },\n            { id: 10, title: 'Alexandrea Sauer' }\n          ];\n        }])\n        .controller('HomeController', [function() {\n          //empty\n        }])\n        .controller('ProfileController', ['$rootScope', '$routeParams',\n            function ProfileController($rootScope, $routeParams) {\n          var index = parseInt($routeParams.id, 10);\n          var record = $rootScope.records[index - 1];\n\n          this.title = record.title;\n          this.id = record.id;\n        }]);\n    </file>\n    <file name=\"home.html\">\n      <h2>Welcome to the home page</h1>\n      <p>Please click on an element</p>\n      <a class=\"record\"\n         ng-href=\"#!/profile/{{ record.id }}\"\n         ng-animate-ref=\"{{ record.id }}\"\n         ng-repeat=\"record in records\">\n        {{ record.title }}\n      </a>\n    </file>\n    <file name=\"profile.html\">\n      <div class=\"profile record\" ng-animate-ref=\"{{ profile.id }}\">\n        {{ profile.title }}\n      </div>\n    </file>\n    <file name=\"animations.css\">\n      .record {\n        display:block;\n        font-size:20px;\n      }\n      .profile {\n        background:black;\n        color:white;\n        font-size:100px;\n      }\n      .view-container {\n        position:relative;\n      }\n      .view-container > .view.ng-animate {\n        position:absolute;\n        top:0;\n        left:0;\n        width:100%;\n        min-height:500px;\n      }\n      .view.ng-enter, .view.ng-leave,\n      .record.ng-anchor {\n        transition:0.5s linear all;\n      }\n      .view.ng-enter {\n        transform:translateX(100%);\n      }\n      .view.ng-enter.ng-enter-active, .view.ng-leave {\n        transform:translateX(0%);\n      }\n      .view.ng-leave.ng-leave-active {\n        transform:translateX(-100%);\n      }\n      .record.ng-anchor-out {\n        background:red;\n      }\n    </file>\n  </example>\n *\n * ### How is the element transported?\n *\n * When an anchor animation occurs, ngAnimate will clone the starting element and position it exactly where the starting\n * element is located on screen via absolute positioning. The cloned element will be placed inside of the root element\n * of the application (where ng-app was defined) and all of the CSS classes of the starting element will be applied. The\n * element will then animate into the `out` and `in` animations and will eventually reach the coordinates and match\n * the dimensions of the destination element. During the entire animation a CSS class of `.ng-animate-shim` will be applied\n * to both the starting and destination elements in order to hide them from being visible (the CSS styling for the class\n * is: `visibility:hidden`). Once the anchor reaches its destination then it will be removed and the destination element\n * will become visible since the shim class will be removed.\n *\n * ### How is the morphing handled?\n *\n * CSS Anchoring relies on transitions and keyframes and the internal code is intelligent enough to figure out\n * what CSS classes differ between the starting element and the destination element. These different CSS classes\n * will be added/removed on the anchor element and a transition will be applied (the transition that is provided\n * in the anchor class). Long story short, ngAnimate will figure out what classes to add and remove which will\n * make the transition of the element as smooth and automatic as possible. Be sure to use simple CSS classes that\n * do not rely on DOM nesting structure so that the anchor element appears the same as the starting element (since\n * the cloned element is placed inside of root element which is likely close to the body element).\n *\n * Note that if the root element is on the `<html>` element then the cloned node will be placed inside of body.\n *\n *\n * ## Using $animate in your directive code\n *\n * So far we've explored how to feed in animations into an Angular application, but how do we trigger animations within our own directives in our application?\n * By injecting the `$animate` service into our directive code, we can trigger structural and class-based hooks which can then be consumed by animations. Let's\n * imagine we have a greeting box that shows and hides itself when the data changes\n *\n * ```html\n * <greeting-box active=\"onOrOff\">Hi there</greeting-box>\n * ```\n *\n * ```js\n * ngModule.directive('greetingBox', ['$animate', function($animate) {\n *   return function(scope, element, attrs) {\n *     attrs.$observe('active', function(value) {\n *       value ? $animate.addClass(element, 'on') : $animate.removeClass(element, 'on');\n *     });\n *   });\n * }]);\n * ```\n *\n * Now the `on` CSS class is added and removed on the greeting box component. Now if we add a CSS class on top of the greeting box element\n * in our HTML code then we can trigger a CSS or JS animation to happen.\n *\n * ```css\n * /&#42; normally we would create a CSS class to reference on the element &#42;/\n * greeting-box.on { transition:0.5s linear all; background:green; color:white; }\n * ```\n *\n * The `$animate` service contains a variety of other methods like `enter`, `leave`, `animate` and `setClass`. To learn more about what's\n * possible be sure to visit the {@link ng.$animate $animate service API page}.\n *\n *\n * ## Callbacks and Promises\n *\n * When `$animate` is called it returns a promise that can be used to capture when the animation has ended. Therefore if we were to trigger\n * an animation (within our directive code) then we can continue performing directive and scope related activities after the animation has\n * ended by chaining onto the returned promise that animation method returns.\n *\n * ```js\n * // somewhere within the depths of the directive\n * $animate.enter(element, parent).then(function() {\n *   //the animation has completed\n * });\n * ```\n *\n * (Note that earlier versions of Angular prior to v1.4 required the promise code to be wrapped using `$scope.$apply(...)`. This is not the case\n * anymore.)\n *\n * In addition to the animation promise, we can also make use of animation-related callbacks within our directives and controller code by registering\n * an event listener using the `$animate` service. Let's say for example that an animation was triggered on our view\n * routing controller to hook into that:\n *\n * ```js\n * ngModule.controller('HomePageController', ['$animate', function($animate) {\n *   $animate.on('enter', ngViewElement, function(element) {\n *     // the animation for this route has completed\n *   }]);\n * }])\n * ```\n *\n * (Note that you will need to trigger a digest within the callback to get angular to notice any scope-related changes.)\n */\n\nvar copy;\nvar extend;\nvar forEach;\nvar isArray;\nvar isDefined;\nvar isElement;\nvar isFunction;\nvar isObject;\nvar isString;\nvar isUndefined;\nvar jqLite;\nvar noop;\n\n/**\n * @ngdoc service\n * @name $animate\n * @kind object\n *\n * @description\n * The ngAnimate `$animate` service documentation is the same for the core `$animate` service.\n *\n * Click here {@link ng.$animate to learn more about animations with `$animate`}.\n */\nangular.module('ngAnimate', [], function initAngularHelpers() {\n  // Access helpers from angular core.\n  // Do it inside a `config` block to ensure `window.angular` is available.\n  noop        = angular.noop;\n  copy        = angular.copy;\n  extend      = angular.extend;\n  jqLite      = angular.element;\n  forEach     = angular.forEach;\n  isArray     = angular.isArray;\n  isString    = angular.isString;\n  isObject    = angular.isObject;\n  isUndefined = angular.isUndefined;\n  isDefined   = angular.isDefined;\n  isFunction  = angular.isFunction;\n  isElement   = angular.isElement;\n})\n  .info({ angularVersion: '1.6.8' })\n  .directive('ngAnimateSwap', ngAnimateSwapDirective)\n\n  .directive('ngAnimateChildren', $$AnimateChildrenDirective)\n  .factory('$$rAFScheduler', $$rAFSchedulerFactory)\n\n  .provider('$$animateQueue', $$AnimateQueueProvider)\n  .provider('$$animation', $$AnimationProvider)\n\n  .provider('$animateCss', $AnimateCssProvider)\n  .provider('$$animateCssDriver', $$AnimateCssDriverProvider)\n\n  .provider('$$animateJs', $$AnimateJsProvider)\n  .provider('$$animateJsDriver', $$AnimateJsDriverProvider);\n\n\n})(window, window.angular);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FuZ3VsYXItYW5pbWF0ZS9hbmd1bGFyLWFuaW1hdGUuanM/Yzk5NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIEFuZ3VsYXJKUyB2MS42LjhcbiAqIChjKSAyMDEwLTIwMTcgR29vZ2xlLCBJbmMuIGh0dHA6Ly9hbmd1bGFyanMub3JnXG4gKiBMaWNlbnNlOiBNSVRcbiAqL1xuKGZ1bmN0aW9uKHdpbmRvdywgYW5ndWxhcikgeyd1c2Ugc3RyaWN0JztcblxudmFyIEVMRU1FTlRfTk9ERSA9IDE7XG52YXIgQ09NTUVOVF9OT0RFID0gODtcblxudmFyIEFERF9DTEFTU19TVUZGSVggPSAnLWFkZCc7XG52YXIgUkVNT1ZFX0NMQVNTX1NVRkZJWCA9ICctcmVtb3ZlJztcbnZhciBFVkVOVF9DTEFTU19QUkVGSVggPSAnbmctJztcbnZhciBBQ1RJVkVfQ0xBU1NfU1VGRklYID0gJy1hY3RpdmUnO1xudmFyIFBSRVBBUkVfQ0xBU1NfU1VGRklYID0gJy1wcmVwYXJlJztcblxudmFyIE5HX0FOSU1BVEVfQ0xBU1NOQU1FID0gJ25nLWFuaW1hdGUnO1xudmFyIE5HX0FOSU1BVEVfQ0hJTERSRU5fREFUQSA9ICckJG5nQW5pbWF0ZUNoaWxkcmVuJztcblxuLy8gRGV0ZWN0IHByb3BlciB0cmFuc2l0aW9uZW5kL2FuaW1hdGlvbmVuZCBldmVudCBuYW1lcy5cbnZhciBDU1NfUFJFRklYID0gJycsIFRSQU5TSVRJT05fUFJPUCwgVFJBTlNJVElPTkVORF9FVkVOVCwgQU5JTUFUSU9OX1BST1AsIEFOSU1BVElPTkVORF9FVkVOVDtcblxuLy8gSWYgdW5wcmVmaXhlZCBldmVudHMgYXJlIG5vdCBzdXBwb3J0ZWQgYnV0IHdlYmtpdC1wcmVmaXhlZCBhcmUsIHVzZSB0aGUgbGF0dGVyLlxuLy8gT3RoZXJ3aXNlLCBqdXN0IHVzZSBXM0MgbmFtZXMsIGJyb3dzZXJzIG5vdCBzdXBwb3J0aW5nIHRoZW0gYXQgYWxsIHdpbGwganVzdCBpZ25vcmUgdGhlbS5cbi8vIE5vdGU6IENocm9tZSBpbXBsZW1lbnRzIGB3aW5kb3cub253ZWJraXRhbmltYXRpb25lbmRgIGFuZCBkb2Vzbid0IGltcGxlbWVudCBgd2luZG93Lm9uYW5pbWF0aW9uZW5kYFxuLy8gYnV0IGF0IHRoZSBzYW1lIHRpbWUgZGlzcGF0Y2hlcyB0aGUgYGFuaW1hdGlvbmVuZGAgZXZlbnQgYW5kIG5vdCBgd2Via2l0QW5pbWF0aW9uRW5kYC5cbi8vIFJlZ2lzdGVyIGJvdGggZXZlbnRzIGluIGNhc2UgYHdpbmRvdy5vbmFuaW1hdGlvbmVuZGAgaXMgbm90IHN1cHBvcnRlZCBiZWNhdXNlIG9mIHRoYXQsXG4vLyBkbyB0aGUgc2FtZSBmb3IgYHRyYW5zaXRpb25lbmRgIGFzIFNhZmFyaSBpcyBsaWtlbHkgdG8gZXhoaWJpdCBzaW1pbGFyIGJlaGF2aW9yLlxuLy8gQWxzbywgdGhlIG9ubHkgbW9kZXJuIGJyb3dzZXIgdGhhdCB1c2VzIHZlbmRvciBwcmVmaXhlcyBmb3IgdHJhbnNpdGlvbnMva2V5ZnJhbWVzIGlzIHdlYmtpdFxuLy8gdGhlcmVmb3JlIHRoZXJlIGlzIG5vIHJlYXNvbiB0byB0ZXN0IGFueW1vcmUgZm9yIG90aGVyIHZlbmRvciBwcmVmaXhlczpcbi8vIGh0dHA6Ly9jYW5pdXNlLmNvbS8jc2VhcmNoPXRyYW5zaXRpb25cbmlmICgod2luZG93Lm9udHJhbnNpdGlvbmVuZCA9PT0gdW5kZWZpbmVkKSAmJiAod2luZG93Lm9ud2Via2l0dHJhbnNpdGlvbmVuZCAhPT0gdW5kZWZpbmVkKSkge1xuICBDU1NfUFJFRklYID0gJy13ZWJraXQtJztcbiAgVFJBTlNJVElPTl9QUk9QID0gJ1dlYmtpdFRyYW5zaXRpb24nO1xuICBUUkFOU0lUSU9ORU5EX0VWRU5UID0gJ3dlYmtpdFRyYW5zaXRpb25FbmQgdHJhbnNpdGlvbmVuZCc7XG59IGVsc2Uge1xuICBUUkFOU0lUSU9OX1BST1AgPSAndHJhbnNpdGlvbic7XG4gIFRSQU5TSVRJT05FTkRfRVZFTlQgPSAndHJhbnNpdGlvbmVuZCc7XG59XG5cbmlmICgod2luZG93Lm9uYW5pbWF0aW9uZW5kID09PSB1bmRlZmluZWQpICYmICh3aW5kb3cub253ZWJraXRhbmltYXRpb25lbmQgIT09IHVuZGVmaW5lZCkpIHtcbiAgQ1NTX1BSRUZJWCA9ICctd2Via2l0LSc7XG4gIEFOSU1BVElPTl9QUk9QID0gJ1dlYmtpdEFuaW1hdGlvbic7XG4gIEFOSU1BVElPTkVORF9FVkVOVCA9ICd3ZWJraXRBbmltYXRpb25FbmQgYW5pbWF0aW9uZW5kJztcbn0gZWxzZSB7XG4gIEFOSU1BVElPTl9QUk9QID0gJ2FuaW1hdGlvbic7XG4gIEFOSU1BVElPTkVORF9FVkVOVCA9ICdhbmltYXRpb25lbmQnO1xufVxuXG52YXIgRFVSQVRJT05fS0VZID0gJ0R1cmF0aW9uJztcbnZhciBQUk9QRVJUWV9LRVkgPSAnUHJvcGVydHknO1xudmFyIERFTEFZX0tFWSA9ICdEZWxheSc7XG52YXIgVElNSU5HX0tFWSA9ICdUaW1pbmdGdW5jdGlvbic7XG52YXIgQU5JTUFUSU9OX0lURVJBVElPTl9DT1VOVF9LRVkgPSAnSXRlcmF0aW9uQ291bnQnO1xudmFyIEFOSU1BVElPTl9QTEFZU1RBVEVfS0VZID0gJ1BsYXlTdGF0ZSc7XG52YXIgU0FGRV9GQVNUX0ZPUldBUkRfRFVSQVRJT05fVkFMVUUgPSA5OTk5O1xuXG52YXIgQU5JTUFUSU9OX0RFTEFZX1BST1AgPSBBTklNQVRJT05fUFJPUCArIERFTEFZX0tFWTtcbnZhciBBTklNQVRJT05fRFVSQVRJT05fUFJPUCA9IEFOSU1BVElPTl9QUk9QICsgRFVSQVRJT05fS0VZO1xudmFyIFRSQU5TSVRJT05fREVMQVlfUFJPUCA9IFRSQU5TSVRJT05fUFJPUCArIERFTEFZX0tFWTtcbnZhciBUUkFOU0lUSU9OX0RVUkFUSU9OX1BST1AgPSBUUkFOU0lUSU9OX1BST1AgKyBEVVJBVElPTl9LRVk7XG5cbnZhciBuZ01pbkVyciA9IGFuZ3VsYXIuJCRtaW5FcnIoJ25nJyk7XG5mdW5jdGlvbiBhc3NlcnRBcmcoYXJnLCBuYW1lLCByZWFzb24pIHtcbiAgaWYgKCFhcmcpIHtcbiAgICB0aHJvdyBuZ01pbkVycignYXJlcScsICdBcmd1bWVudCBcXCd7MH1cXCcgaXMgezF9JywgKG5hbWUgfHwgJz8nKSwgKHJlYXNvbiB8fCAncmVxdWlyZWQnKSk7XG4gIH1cbiAgcmV0dXJuIGFyZztcbn1cblxuZnVuY3Rpb24gbWVyZ2VDbGFzc2VzKGEsYikge1xuICBpZiAoIWEgJiYgIWIpIHJldHVybiAnJztcbiAgaWYgKCFhKSByZXR1cm4gYjtcbiAgaWYgKCFiKSByZXR1cm4gYTtcbiAgaWYgKGlzQXJyYXkoYSkpIGEgPSBhLmpvaW4oJyAnKTtcbiAgaWYgKGlzQXJyYXkoYikpIGIgPSBiLmpvaW4oJyAnKTtcbiAgcmV0dXJuIGEgKyAnICcgKyBiO1xufVxuXG5mdW5jdGlvbiBwYWNrYWdlU3R5bGVzKG9wdGlvbnMpIHtcbiAgdmFyIHN0eWxlcyA9IHt9O1xuICBpZiAob3B0aW9ucyAmJiAob3B0aW9ucy50byB8fCBvcHRpb25zLmZyb20pKSB7XG4gICAgc3R5bGVzLnRvID0gb3B0aW9ucy50bztcbiAgICBzdHlsZXMuZnJvbSA9IG9wdGlvbnMuZnJvbTtcbiAgfVxuICByZXR1cm4gc3R5bGVzO1xufVxuXG5mdW5jdGlvbiBwZW5kQ2xhc3NlcyhjbGFzc2VzLCBmaXgsIGlzUHJlZml4KSB7XG4gIHZhciBjbGFzc05hbWUgPSAnJztcbiAgY2xhc3NlcyA9IGlzQXJyYXkoY2xhc3NlcylcbiAgICAgID8gY2xhc3Nlc1xuICAgICAgOiBjbGFzc2VzICYmIGlzU3RyaW5nKGNsYXNzZXMpICYmIGNsYXNzZXMubGVuZ3RoXG4gICAgICAgICAgPyBjbGFzc2VzLnNwbGl0KC9cXHMrLylcbiAgICAgICAgICA6IFtdO1xuICBmb3JFYWNoKGNsYXNzZXMsIGZ1bmN0aW9uKGtsYXNzLCBpKSB7XG4gICAgaWYgKGtsYXNzICYmIGtsYXNzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNsYXNzTmFtZSArPSAoaSA+IDApID8gJyAnIDogJyc7XG4gICAgICBjbGFzc05hbWUgKz0gaXNQcmVmaXggPyBmaXggKyBrbGFzc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDoga2xhc3MgKyBmaXg7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGNsYXNzTmFtZTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlRnJvbUFycmF5KGFyciwgdmFsKSB7XG4gIHZhciBpbmRleCA9IGFyci5pbmRleE9mKHZhbCk7XG4gIGlmICh2YWwgPj0gMCkge1xuICAgIGFyci5zcGxpY2UoaW5kZXgsIDEpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0cmlwQ29tbWVudHNGcm9tRWxlbWVudChlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50IGluc3RhbmNlb2YganFMaXRlKSB7XG4gICAgc3dpdGNoIChlbGVtZW50Lmxlbmd0aCkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gZWxlbWVudDtcblxuICAgICAgY2FzZSAxOlxuICAgICAgICAvLyB0aGVyZSBpcyBubyBwb2ludCBvZiBzdHJpcHBpbmcgYW55dGhpbmcgaWYgdGhlIGVsZW1lbnRcbiAgICAgICAgLy8gaXMgdGhlIG9ubHkgZWxlbWVudCB3aXRoaW4gdGhlIGpxTGl0ZSB3cmFwcGVyLlxuICAgICAgICAvLyAoaXQncyBpbXBvcnRhbnQgdGhhdCB3ZSByZXRhaW4gdGhlIGVsZW1lbnQgaW5zdGFuY2UuKVxuICAgICAgICBpZiAoZWxlbWVudFswXS5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBqcUxpdGUoZXh0cmFjdEVsZW1lbnROb2RlKGVsZW1lbnQpKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZWxlbWVudC5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFKSB7XG4gICAgcmV0dXJuIGpxTGl0ZShlbGVtZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBleHRyYWN0RWxlbWVudE5vZGUoZWxlbWVudCkge1xuICBpZiAoIWVsZW1lbnRbMF0pIHJldHVybiBlbGVtZW50O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWxtID0gZWxlbWVudFtpXTtcbiAgICBpZiAoZWxtLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUpIHtcbiAgICAgIHJldHVybiBlbG07XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uICQkYWRkQ2xhc3MoJCRqcUxpdGUsIGVsZW1lbnQsIGNsYXNzTmFtZSkge1xuICBmb3JFYWNoKGVsZW1lbnQsIGZ1bmN0aW9uKGVsbSkge1xuICAgICQkanFMaXRlLmFkZENsYXNzKGVsbSwgY2xhc3NOYW1lKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uICQkcmVtb3ZlQ2xhc3MoJCRqcUxpdGUsIGVsZW1lbnQsIGNsYXNzTmFtZSkge1xuICBmb3JFYWNoKGVsZW1lbnQsIGZ1bmN0aW9uKGVsbSkge1xuICAgICQkanFMaXRlLnJlbW92ZUNsYXNzKGVsbSwgY2xhc3NOYW1lKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGFwcGx5QW5pbWF0aW9uQ2xhc3Nlc0ZhY3RvcnkoJCRqcUxpdGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5hZGRDbGFzcykge1xuICAgICAgJCRhZGRDbGFzcygkJGpxTGl0ZSwgZWxlbWVudCwgb3B0aW9ucy5hZGRDbGFzcyk7XG4gICAgICBvcHRpb25zLmFkZENsYXNzID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMucmVtb3ZlQ2xhc3MpIHtcbiAgICAgICQkcmVtb3ZlQ2xhc3MoJCRqcUxpdGUsIGVsZW1lbnQsIG9wdGlvbnMucmVtb3ZlQ2xhc3MpO1xuICAgICAgb3B0aW9ucy5yZW1vdmVDbGFzcyA9IG51bGw7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBwcmVwYXJlQW5pbWF0aW9uT3B0aW9ucyhvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBpZiAoIW9wdGlvbnMuJCRwcmVwYXJlZCkge1xuICAgIHZhciBkb21PcGVyYXRpb24gPSBvcHRpb25zLmRvbU9wZXJhdGlvbiB8fCBub29wO1xuICAgIG9wdGlvbnMuZG9tT3BlcmF0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICBvcHRpb25zLiQkZG9tT3BlcmF0aW9uRmlyZWQgPSB0cnVlO1xuICAgICAgZG9tT3BlcmF0aW9uKCk7XG4gICAgICBkb21PcGVyYXRpb24gPSBub29wO1xuICAgIH07XG4gICAgb3B0aW9ucy4kJHByZXBhcmVkID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gb3B0aW9ucztcbn1cblxuZnVuY3Rpb24gYXBwbHlBbmltYXRpb25TdHlsZXMoZWxlbWVudCwgb3B0aW9ucykge1xuICBhcHBseUFuaW1hdGlvbkZyb21TdHlsZXMoZWxlbWVudCwgb3B0aW9ucyk7XG4gIGFwcGx5QW5pbWF0aW9uVG9TdHlsZXMoZWxlbWVudCwgb3B0aW9ucyk7XG59XG5cbmZ1bmN0aW9uIGFwcGx5QW5pbWF0aW9uRnJvbVN0eWxlcyhlbGVtZW50LCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLmZyb20pIHtcbiAgICBlbGVtZW50LmNzcyhvcHRpb25zLmZyb20pO1xuICAgIG9wdGlvbnMuZnJvbSA9IG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlBbmltYXRpb25Ub1N0eWxlcyhlbGVtZW50LCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLnRvKSB7XG4gICAgZWxlbWVudC5jc3Mob3B0aW9ucy50byk7XG4gICAgb3B0aW9ucy50byA9IG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWVyZ2VBbmltYXRpb25EZXRhaWxzKGVsZW1lbnQsIG9sZEFuaW1hdGlvbiwgbmV3QW5pbWF0aW9uKSB7XG4gIHZhciB0YXJnZXQgPSBvbGRBbmltYXRpb24ub3B0aW9ucyB8fCB7fTtcbiAgdmFyIG5ld09wdGlvbnMgPSBuZXdBbmltYXRpb24ub3B0aW9ucyB8fCB7fTtcblxuICB2YXIgdG9BZGQgPSAodGFyZ2V0LmFkZENsYXNzIHx8ICcnKSArICcgJyArIChuZXdPcHRpb25zLmFkZENsYXNzIHx8ICcnKTtcbiAgdmFyIHRvUmVtb3ZlID0gKHRhcmdldC5yZW1vdmVDbGFzcyB8fCAnJykgKyAnICcgKyAobmV3T3B0aW9ucy5yZW1vdmVDbGFzcyB8fCAnJyk7XG4gIHZhciBjbGFzc2VzID0gcmVzb2x2ZUVsZW1lbnRDbGFzc2VzKGVsZW1lbnQuYXR0cignY2xhc3MnKSwgdG9BZGQsIHRvUmVtb3ZlKTtcblxuICBpZiAobmV3T3B0aW9ucy5wcmVwYXJhdGlvbkNsYXNzZXMpIHtcbiAgICB0YXJnZXQucHJlcGFyYXRpb25DbGFzc2VzID0gY29uY2F0V2l0aFNwYWNlKG5ld09wdGlvbnMucHJlcGFyYXRpb25DbGFzc2VzLCB0YXJnZXQucHJlcGFyYXRpb25DbGFzc2VzKTtcbiAgICBkZWxldGUgbmV3T3B0aW9ucy5wcmVwYXJhdGlvbkNsYXNzZXM7XG4gIH1cblxuICAvLyBub29wIGlzIGJhc2ljYWxseSB3aGVuIHRoZXJlIGlzIG5vIGNhbGxiYWNrOyBvdGhlcndpc2Ugc29tZXRoaW5nIGhhcyBiZWVuIHNldFxuICB2YXIgcmVhbERvbU9wZXJhdGlvbiA9IHRhcmdldC5kb21PcGVyYXRpb24gIT09IG5vb3AgPyB0YXJnZXQuZG9tT3BlcmF0aW9uIDogbnVsbDtcblxuICBleHRlbmQodGFyZ2V0LCBuZXdPcHRpb25zKTtcblxuICAvLyBUT0RPKG1hdHNrbyBvciBzcmVlcmFtdSk6IHByb3BlciBmaXggaXMgdG8gbWFpbnRhaW4gYWxsIGFuaW1hdGlvbiBjYWxsYmFjayBpbiBhcnJheSBhbmQgY2FsbCBhdCBsYXN0LGJ1dCBub3cgb25seSBsZWF2ZSBoYXMgdGhlIGNhbGxiYWNrIHNvIG5vIGlzc3VlIHdpdGggdGhpcy5cbiAgaWYgKHJlYWxEb21PcGVyYXRpb24pIHtcbiAgICB0YXJnZXQuZG9tT3BlcmF0aW9uID0gcmVhbERvbU9wZXJhdGlvbjtcbiAgfVxuXG4gIGlmIChjbGFzc2VzLmFkZENsYXNzKSB7XG4gICAgdGFyZ2V0LmFkZENsYXNzID0gY2xhc3Nlcy5hZGRDbGFzcztcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQuYWRkQ2xhc3MgPSBudWxsO1xuICB9XG5cbiAgaWYgKGNsYXNzZXMucmVtb3ZlQ2xhc3MpIHtcbiAgICB0YXJnZXQucmVtb3ZlQ2xhc3MgPSBjbGFzc2VzLnJlbW92ZUNsYXNzO1xuICB9IGVsc2Uge1xuICAgIHRhcmdldC5yZW1vdmVDbGFzcyA9IG51bGw7XG4gIH1cblxuICBvbGRBbmltYXRpb24uYWRkQ2xhc3MgPSB0YXJnZXQuYWRkQ2xhc3M7XG4gIG9sZEFuaW1hdGlvbi5yZW1vdmVDbGFzcyA9IHRhcmdldC5yZW1vdmVDbGFzcztcblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiByZXNvbHZlRWxlbWVudENsYXNzZXMoZXhpc3RpbmcsIHRvQWRkLCB0b1JlbW92ZSkge1xuICB2YXIgQUREX0NMQVNTID0gMTtcbiAgdmFyIFJFTU9WRV9DTEFTUyA9IC0xO1xuXG4gIHZhciBmbGFncyA9IHt9O1xuICBleGlzdGluZyA9IHNwbGl0Q2xhc3Nlc1RvTG9va3VwKGV4aXN0aW5nKTtcblxuICB0b0FkZCA9IHNwbGl0Q2xhc3Nlc1RvTG9va3VwKHRvQWRkKTtcbiAgZm9yRWFjaCh0b0FkZCwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgIGZsYWdzW2tleV0gPSBBRERfQ0xBU1M7XG4gIH0pO1xuXG4gIHRvUmVtb3ZlID0gc3BsaXRDbGFzc2VzVG9Mb29rdXAodG9SZW1vdmUpO1xuICBmb3JFYWNoKHRvUmVtb3ZlLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgZmxhZ3Nba2V5XSA9IGZsYWdzW2tleV0gPT09IEFERF9DTEFTUyA/IG51bGwgOiBSRU1PVkVfQ0xBU1M7XG4gIH0pO1xuXG4gIHZhciBjbGFzc2VzID0ge1xuICAgIGFkZENsYXNzOiAnJyxcbiAgICByZW1vdmVDbGFzczogJydcbiAgfTtcblxuICBmb3JFYWNoKGZsYWdzLCBmdW5jdGlvbih2YWwsIGtsYXNzKSB7XG4gICAgdmFyIHByb3AsIGFsbG93O1xuICAgIGlmICh2YWwgPT09IEFERF9DTEFTUykge1xuICAgICAgcHJvcCA9ICdhZGRDbGFzcyc7XG4gICAgICBhbGxvdyA9ICFleGlzdGluZ1trbGFzc10gfHwgZXhpc3Rpbmdba2xhc3MgKyBSRU1PVkVfQ0xBU1NfU1VGRklYXTtcbiAgICB9IGVsc2UgaWYgKHZhbCA9PT0gUkVNT1ZFX0NMQVNTKSB7XG4gICAgICBwcm9wID0gJ3JlbW92ZUNsYXNzJztcbiAgICAgIGFsbG93ID0gZXhpc3Rpbmdba2xhc3NdIHx8IGV4aXN0aW5nW2tsYXNzICsgQUREX0NMQVNTX1NVRkZJWF07XG4gICAgfVxuICAgIGlmIChhbGxvdykge1xuICAgICAgaWYgKGNsYXNzZXNbcHJvcF0ubGVuZ3RoKSB7XG4gICAgICAgIGNsYXNzZXNbcHJvcF0gKz0gJyAnO1xuICAgICAgfVxuICAgICAgY2xhc3Nlc1twcm9wXSArPSBrbGFzcztcbiAgICB9XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIHNwbGl0Q2xhc3Nlc1RvTG9va3VwKGNsYXNzZXMpIHtcbiAgICBpZiAoaXNTdHJpbmcoY2xhc3NlcykpIHtcbiAgICAgIGNsYXNzZXMgPSBjbGFzc2VzLnNwbGl0KCcgJyk7XG4gICAgfVxuXG4gICAgdmFyIG9iaiA9IHt9O1xuICAgIGZvckVhY2goY2xhc3NlcywgZnVuY3Rpb24oa2xhc3MpIHtcbiAgICAgIC8vIHNvbWV0aW1lcyB0aGUgc3BsaXQgbGVhdmVzIGVtcHR5IHN0cmluZyB2YWx1ZXNcbiAgICAgIC8vIGluY2FzZSBleHRyYSBzcGFjZXMgd2VyZSBhcHBsaWVkIHRvIHRoZSBvcHRpb25zXG4gICAgICBpZiAoa2xhc3MubGVuZ3RoKSB7XG4gICAgICAgIG9ialtrbGFzc10gPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICByZXR1cm4gY2xhc3Nlcztcbn1cblxuZnVuY3Rpb24gZ2V0RG9tTm9kZShlbGVtZW50KSB7XG4gIHJldHVybiAoZWxlbWVudCBpbnN0YW5jZW9mIGpxTGl0ZSkgPyBlbGVtZW50WzBdIDogZWxlbWVudDtcbn1cblxuZnVuY3Rpb24gYXBwbHlHZW5lcmF0ZWRQcmVwYXJhdGlvbkNsYXNzZXMoZWxlbWVudCwgZXZlbnQsIG9wdGlvbnMpIHtcbiAgdmFyIGNsYXNzZXMgPSAnJztcbiAgaWYgKGV2ZW50KSB7XG4gICAgY2xhc3NlcyA9IHBlbmRDbGFzc2VzKGV2ZW50LCBFVkVOVF9DTEFTU19QUkVGSVgsIHRydWUpO1xuICB9XG4gIGlmIChvcHRpb25zLmFkZENsYXNzKSB7XG4gICAgY2xhc3NlcyA9IGNvbmNhdFdpdGhTcGFjZShjbGFzc2VzLCBwZW5kQ2xhc3NlcyhvcHRpb25zLmFkZENsYXNzLCBBRERfQ0xBU1NfU1VGRklYKSk7XG4gIH1cbiAgaWYgKG9wdGlvbnMucmVtb3ZlQ2xhc3MpIHtcbiAgICBjbGFzc2VzID0gY29uY2F0V2l0aFNwYWNlKGNsYXNzZXMsIHBlbmRDbGFzc2VzKG9wdGlvbnMucmVtb3ZlQ2xhc3MsIFJFTU9WRV9DTEFTU19TVUZGSVgpKTtcbiAgfVxuICBpZiAoY2xhc3Nlcy5sZW5ndGgpIHtcbiAgICBvcHRpb25zLnByZXBhcmF0aW9uQ2xhc3NlcyA9IGNsYXNzZXM7XG4gICAgZWxlbWVudC5hZGRDbGFzcyhjbGFzc2VzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjbGVhckdlbmVyYXRlZENsYXNzZXMoZWxlbWVudCwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucy5wcmVwYXJhdGlvbkNsYXNzZXMpIHtcbiAgICBlbGVtZW50LnJlbW92ZUNsYXNzKG9wdGlvbnMucHJlcGFyYXRpb25DbGFzc2VzKTtcbiAgICBvcHRpb25zLnByZXBhcmF0aW9uQ2xhc3NlcyA9IG51bGw7XG4gIH1cbiAgaWYgKG9wdGlvbnMuYWN0aXZlQ2xhc3Nlcykge1xuICAgIGVsZW1lbnQucmVtb3ZlQ2xhc3Mob3B0aW9ucy5hY3RpdmVDbGFzc2VzKTtcbiAgICBvcHRpb25zLmFjdGl2ZUNsYXNzZXMgPSBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIGJsb2NrVHJhbnNpdGlvbnMobm9kZSwgZHVyYXRpb24pIHtcbiAgLy8gd2UgdXNlIGEgbmVnYXRpdmUgZGVsYXkgdmFsdWUgc2luY2UgaXQgcGVyZm9ybXMgYmxvY2tpbmdcbiAgLy8geWV0IGl0IGRvZXNuJ3Qga2lsbCBhbnkgZXhpc3RpbmcgdHJhbnNpdGlvbnMgcnVubmluZyBvbiB0aGVcbiAgLy8gc2FtZSBlbGVtZW50IHdoaWNoIG1ha2VzIHRoaXMgc2FmZSBmb3IgY2xhc3MtYmFzZWQgYW5pbWF0aW9uc1xuICB2YXIgdmFsdWUgPSBkdXJhdGlvbiA/ICctJyArIGR1cmF0aW9uICsgJ3MnIDogJyc7XG4gIGFwcGx5SW5saW5lU3R5bGUobm9kZSwgW1RSQU5TSVRJT05fREVMQVlfUFJPUCwgdmFsdWVdKTtcbiAgcmV0dXJuIFtUUkFOU0lUSU9OX0RFTEFZX1BST1AsIHZhbHVlXTtcbn1cblxuZnVuY3Rpb24gYmxvY2tLZXlmcmFtZUFuaW1hdGlvbnMobm9kZSwgYXBwbHlCbG9jaykge1xuICB2YXIgdmFsdWUgPSBhcHBseUJsb2NrID8gJ3BhdXNlZCcgOiAnJztcbiAgdmFyIGtleSA9IEFOSU1BVElPTl9QUk9QICsgQU5JTUFUSU9OX1BMQVlTVEFURV9LRVk7XG4gIGFwcGx5SW5saW5lU3R5bGUobm9kZSwgW2tleSwgdmFsdWVdKTtcbiAgcmV0dXJuIFtrZXksIHZhbHVlXTtcbn1cblxuZnVuY3Rpb24gYXBwbHlJbmxpbmVTdHlsZShub2RlLCBzdHlsZVR1cGxlKSB7XG4gIHZhciBwcm9wID0gc3R5bGVUdXBsZVswXTtcbiAgdmFyIHZhbHVlID0gc3R5bGVUdXBsZVsxXTtcbiAgbm9kZS5zdHlsZVtwcm9wXSA9IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBjb25jYXRXaXRoU3BhY2UoYSxiKSB7XG4gIGlmICghYSkgcmV0dXJuIGI7XG4gIGlmICghYikgcmV0dXJuIGE7XG4gIHJldHVybiBhICsgJyAnICsgYjtcbn1cblxudmFyICQkckFGU2NoZWR1bGVyRmFjdG9yeSA9IFsnJCRyQUYnLCBmdW5jdGlvbigkJHJBRikge1xuICB2YXIgcXVldWUsIGNhbmNlbEZuO1xuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlcih0YXNrcykge1xuICAgIC8vIHdlIG1ha2UgYSBjb3B5IHNpbmNlIFJBRlNjaGVkdWxlciBtdXRhdGVzIHRoZSBzdGF0ZVxuICAgIC8vIG9mIHRoZSBwYXNzZWQgaW4gYXJyYXkgdmFyaWFibGUgYW5kIHRoaXMgd291bGQgYmUgZGlmZmljdWx0XG4gICAgLy8gdG8gdHJhY2sgZG93biBvbiB0aGUgb3V0c2lkZSBjb2RlXG4gICAgcXVldWUgPSBxdWV1ZS5jb25jYXQodGFza3MpO1xuICAgIG5leHRUaWNrKCk7XG4gIH1cblxuICBxdWV1ZSA9IHNjaGVkdWxlci5xdWV1ZSA9IFtdO1xuXG4gIC8qIHdhaXRVbnRpbFF1aWV0IGRvZXMgdHdvIHRoaW5nczpcbiAgICogMS4gSXQgd2lsbCBydW4gdGhlIEZJTkFMIGBmbmAgdmFsdWUgb25seSB3aGVuIGFuIHVuY2FuY2VsZWQgUkFGIGhhcyBwYXNzZWQgdGhyb3VnaFxuICAgKiAyLiBJdCB3aWxsIGRlbGF5IHRoZSBuZXh0IHdhdmUgb2YgdGFza3MgZnJvbSBydW5uaW5nIHVudGlsIHRoZSBxdWlldCBgZm5gIGhhcyBydW4uXG4gICAqXG4gICAqIFRoZSBtb3RpdmF0aW9uIGhlcmUgaXMgdGhhdCBhbmltYXRpb24gY29kZSBjYW4gcmVxdWVzdCBtb3JlIHRpbWUgZnJvbSB0aGUgc2NoZWR1bGVyXG4gICAqIGJlZm9yZSB0aGUgbmV4dCB3YXZlIHJ1bnMuIFRoaXMgYWxsb3dzIGZvciBjZXJ0YWluIERPTSBwcm9wZXJ0aWVzIHN1Y2ggYXMgY2xhc3NlcyB0b1xuICAgKiBiZSByZXNvbHZlZCBpbiB0aW1lIGZvciB0aGUgbmV4dCBhbmltYXRpb24gdG8gcnVuLlxuICAgKi9cbiAgc2NoZWR1bGVyLndhaXRVbnRpbFF1aWV0ID0gZnVuY3Rpb24oZm4pIHtcbiAgICBpZiAoY2FuY2VsRm4pIGNhbmNlbEZuKCk7XG5cbiAgICBjYW5jZWxGbiA9ICQkckFGKGZ1bmN0aW9uKCkge1xuICAgICAgY2FuY2VsRm4gPSBudWxsO1xuICAgICAgZm4oKTtcbiAgICAgIG5leHRUaWNrKCk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIHNjaGVkdWxlcjtcblxuICBmdW5jdGlvbiBuZXh0VGljaygpIHtcbiAgICBpZiAoIXF1ZXVlLmxlbmd0aCkgcmV0dXJuO1xuXG4gICAgdmFyIGl0ZW1zID0gcXVldWUuc2hpZnQoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpdGVtc1tpXSgpO1xuICAgIH1cblxuICAgIGlmICghY2FuY2VsRm4pIHtcbiAgICAgICQkckFGKGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIWNhbmNlbEZuKSBuZXh0VGljaygpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59XTtcblxuLyoqXG4gKiBAbmdkb2MgZGlyZWN0aXZlXG4gKiBAbmFtZSBuZ0FuaW1hdGVDaGlsZHJlblxuICogQHJlc3RyaWN0IEFFXG4gKiBAZWxlbWVudCBBTllcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqXG4gKiBuZ0FuaW1hdGVDaGlsZHJlbiBhbGxvd3MgeW91IHRvIHNwZWNpZnkgdGhhdCBjaGlsZHJlbiBvZiB0aGlzIGVsZW1lbnQgc2hvdWxkIGFuaW1hdGUgZXZlbiBpZiBhbnlcbiAqIG9mIHRoZSBjaGlsZHJlbidzIHBhcmVudHMgYXJlIGN1cnJlbnRseSBhbmltYXRpbmcuIEJ5IGRlZmF1bHQsIHdoZW4gYW4gZWxlbWVudCBoYXMgYW4gYWN0aXZlIGBlbnRlcmAsIGBsZWF2ZWAsIG9yIGBtb3ZlYFxuICogKHN0cnVjdHVyYWwpIGFuaW1hdGlvbiwgY2hpbGQgZWxlbWVudHMgdGhhdCBhbHNvIGhhdmUgYW4gYWN0aXZlIHN0cnVjdHVyYWwgYW5pbWF0aW9uIGFyZSBub3QgYW5pbWF0ZWQuXG4gKlxuICogTm90ZSB0aGF0IGV2ZW4gaWYgYG5nQW5pbWF0ZUNoaWxkcmVuYCBpcyBzZXQsIG5vIGNoaWxkIGFuaW1hdGlvbnMgd2lsbCBydW4gd2hlbiB0aGUgcGFyZW50IGVsZW1lbnQgaXMgcmVtb3ZlZCBmcm9tIHRoZSBET00gKGBsZWF2ZWAgYW5pbWF0aW9uKS5cbiAqXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5nQW5pbWF0ZUNoaWxkcmVuIElmIHRoZSB2YWx1ZSBpcyBlbXB0eSwgYHRydWVgIG9yIGBvbmAsXG4gKiAgICAgdGhlbiBjaGlsZCBhbmltYXRpb25zIGFyZSBhbGxvd2VkLiBJZiB0aGUgdmFsdWUgaXMgYGZhbHNlYCwgY2hpbGQgYW5pbWF0aW9ucyBhcmUgbm90IGFsbG93ZWQuXG4gKlxuICogQGV4YW1wbGVcbiAqIDxleGFtcGxlIG1vZHVsZT1cIm5nQW5pbWF0ZUNoaWxkcmVuXCIgbmFtZT1cIm5nQW5pbWF0ZUNoaWxkcmVuXCIgZGVwcz1cImFuZ3VsYXItYW5pbWF0ZS5qc1wiIGFuaW1hdGlvbnM9XCJ0cnVlXCI+XG4gICAgIDxmaWxlIG5hbWU9XCJpbmRleC5odG1sXCI+XG4gICAgICAgPGRpdiBuZy1jb250cm9sbGVyPVwiTWFpbkNvbnRyb2xsZXIgYXMgbWFpblwiPlxuICAgICAgICAgPGxhYmVsPlNob3cgY29udGFpbmVyPyA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgbmctbW9kZWw9XCJtYWluLmVudGVyRWxlbWVudFwiIC8+PC9sYWJlbD5cbiAgICAgICAgIDxsYWJlbD5BbmltYXRlIGNoaWxkcmVuPyA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgbmctbW9kZWw9XCJtYWluLmFuaW1hdGVDaGlsZHJlblwiIC8+PC9sYWJlbD5cbiAgICAgICAgIDxocj5cbiAgICAgICAgIDxkaXYgbmctYW5pbWF0ZS1jaGlsZHJlbj1cInt7bWFpbi5hbmltYXRlQ2hpbGRyZW59fVwiPlxuICAgICAgICAgICA8ZGl2IG5nLWlmPVwibWFpbi5lbnRlckVsZW1lbnRcIiBjbGFzcz1cImNvbnRhaW5lclwiPlxuICAgICAgICAgICAgIExpc3Qgb2YgaXRlbXM6XG4gICAgICAgICAgICAgPGRpdiBuZy1yZXBlYXQ9XCJpdGVtIGluIFswLCAxLCAyLCAzXVwiIGNsYXNzPVwiaXRlbVwiPkl0ZW0ge3tpdGVtfX08L2Rpdj5cbiAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICA8L2Rpdj5cbiAgICAgICA8L2Rpdj5cbiAgICAgPC9maWxlPlxuICAgICA8ZmlsZSBuYW1lPVwiYW5pbWF0aW9ucy5jc3NcIj5cblxuICAgICAgLmNvbnRhaW5lci5uZy1lbnRlcixcbiAgICAgIC5jb250YWluZXIubmctbGVhdmUge1xuICAgICAgICB0cmFuc2l0aW9uOiBhbGwgZWFzZSAxLjVzO1xuICAgICAgfVxuXG4gICAgICAuY29udGFpbmVyLm5nLWVudGVyLFxuICAgICAgLmNvbnRhaW5lci5uZy1sZWF2ZS1hY3RpdmUge1xuICAgICAgICBvcGFjaXR5OiAwO1xuICAgICAgfVxuXG4gICAgICAuY29udGFpbmVyLm5nLWxlYXZlLFxuICAgICAgLmNvbnRhaW5lci5uZy1lbnRlci1hY3RpdmUge1xuICAgICAgICBvcGFjaXR5OiAxO1xuICAgICAgfVxuXG4gICAgICAuaXRlbSB7XG4gICAgICAgIGJhY2tncm91bmQ6IGZpcmVicmljaztcbiAgICAgICAgY29sb3I6ICNGRkY7XG4gICAgICAgIG1hcmdpbi1ib3R0b206IDEwcHg7XG4gICAgICB9XG5cbiAgICAgIC5pdGVtLm5nLWVudGVyLFxuICAgICAgLml0ZW0ubmctbGVhdmUge1xuICAgICAgICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMS41cyBlYXNlO1xuICAgICAgfVxuXG4gICAgICAuaXRlbS5uZy1lbnRlciB7XG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCg1MHB4KTtcbiAgICAgIH1cblxuICAgICAgLml0ZW0ubmctZW50ZXItYWN0aXZlIHtcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDApO1xuICAgICAgfVxuICAgIDwvZmlsZT5cbiAgICA8ZmlsZSBuYW1lPVwic2NyaXB0LmpzXCI+XG4gICAgICBhbmd1bGFyLm1vZHVsZSgnbmdBbmltYXRlQ2hpbGRyZW4nLCBbJ25nQW5pbWF0ZSddKVxuICAgICAgICAuY29udHJvbGxlcignTWFpbkNvbnRyb2xsZXInLCBmdW5jdGlvbiBNYWluQ29udHJvbGxlcigpIHtcbiAgICAgICAgICB0aGlzLmFuaW1hdGVDaGlsZHJlbiA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuZW50ZXJFbGVtZW50ID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgIDwvZmlsZT5cbiAgPC9leGFtcGxlPlxuICovXG52YXIgJCRBbmltYXRlQ2hpbGRyZW5EaXJlY3RpdmUgPSBbJyRpbnRlcnBvbGF0ZScsIGZ1bmN0aW9uKCRpbnRlcnBvbGF0ZSkge1xuICByZXR1cm4ge1xuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycykge1xuICAgICAgdmFyIHZhbCA9IGF0dHJzLm5nQW5pbWF0ZUNoaWxkcmVuO1xuICAgICAgaWYgKGlzU3RyaW5nKHZhbCkgJiYgdmFsLmxlbmd0aCA9PT0gMCkgeyAvL2VtcHR5IGF0dHJpYnV0ZVxuICAgICAgICBlbGVtZW50LmRhdGEoTkdfQU5JTUFURV9DSElMRFJFTl9EQVRBLCB0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEludGVycG9sYXRlIGFuZCBzZXQgdGhlIHZhbHVlLCBzbyB0aGF0IGl0IGlzIGF2YWlsYWJsZSB0b1xuICAgICAgICAvLyBhbmltYXRpb25zIHRoYXQgcnVuIHJpZ2h0IGFmdGVyIGNvbXBpbGF0aW9uXG4gICAgICAgIHNldERhdGEoJGludGVycG9sYXRlKHZhbCkoc2NvcGUpKTtcbiAgICAgICAgYXR0cnMuJG9ic2VydmUoJ25nQW5pbWF0ZUNoaWxkcmVuJywgc2V0RGF0YSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHNldERhdGEodmFsdWUpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZSA9PT0gJ29uJyB8fCB2YWx1ZSA9PT0gJ3RydWUnO1xuICAgICAgICBlbGVtZW50LmRhdGEoTkdfQU5JTUFURV9DSElMRFJFTl9EQVRBLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufV07XG5cbi8qIGV4cG9ydGVkICRBbmltYXRlQ3NzUHJvdmlkZXIgKi9cblxudmFyIEFOSU1BVEVfVElNRVJfS0VZID0gJyQkYW5pbWF0ZUNzcyc7XG5cbi8qKlxuICogQG5nZG9jIHNlcnZpY2VcbiAqIEBuYW1lICRhbmltYXRlQ3NzXG4gKiBAa2luZCBvYmplY3RcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIFRoZSBgJGFuaW1hdGVDc3NgIHNlcnZpY2UgaXMgYSB1c2VmdWwgdXRpbGl0eSB0byB0cmlnZ2VyIGN1c3RvbWl6ZWQgQ1NTLWJhc2VkIHRyYW5zaXRpb25zL2tleWZyYW1lc1xuICogZnJvbSBhIEphdmFTY3JpcHQtYmFzZWQgYW5pbWF0aW9uIG9yIGRpcmVjdGx5IGZyb20gYSBkaXJlY3RpdmUuIFRoZSBwdXJwb3NlIG9mIGAkYW5pbWF0ZUNzc2AgaXMgTk9UXG4gKiB0byBzaWRlLXN0ZXAgaG93IGAkYW5pbWF0ZWAgYW5kIG5nQW5pbWF0ZSB3b3JrLCBidXQgdGhlIGdvYWwgaXMgdG8gYWxsb3cgcHJlLWV4aXN0aW5nIGFuaW1hdGlvbnMgb3JcbiAqIGRpcmVjdGl2ZXMgdG8gY3JlYXRlIG1vcmUgY29tcGxleCBhbmltYXRpb25zIHRoYXQgY2FuIGJlIHB1cmVseSBkcml2ZW4gdXNpbmcgQ1NTIGNvZGUuXG4gKlxuICogTm90ZSB0aGF0IG9ubHkgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IENTUyB0cmFuc2l0aW9ucyBhbmQvb3Iga2V5ZnJhbWUgYW5pbWF0aW9ucyBhcmUgY2FwYWJsZSBvZlxuICogcmVuZGVyaW5nIGFuaW1hdGlvbnMgdHJpZ2dlcmVkIHZpYSBgJGFuaW1hdGVDc3NgIChiYWQgbmV3cyBmb3IgSUU5IGFuZCBsb3dlcikuXG4gKlxuICogIyMgR2VuZXJhbCBVc2VcbiAqIE9uY2UgYWdhaW4sIGAkYW5pbWF0ZUNzc2AgaXMgZGVzaWduZWQgdG8gYmUgdXNlZCBpbnNpZGUgb2YgYSByZWdpc3RlcmVkIEphdmFTY3JpcHQgYW5pbWF0aW9uIHRoYXRcbiAqIGlzIHBvd2VyZWQgYnkgbmdBbmltYXRlLiBJdCBpcyBwb3NzaWJsZSB0byB1c2UgYCRhbmltYXRlQ3NzYCBkaXJlY3RseSBpbnNpZGUgb2YgYSBkaXJlY3RpdmUsIGhvd2V2ZXIsXG4gKiBhbnkgYXV0b21hdGljIGNvbnRyb2wgb3ZlciBjYW5jZWxsaW5nIGFuaW1hdGlvbnMgYW5kL29yIHByZXZlbnRpbmcgYW5pbWF0aW9ucyBmcm9tIGJlaW5nIHJ1biBvblxuICogY2hpbGQgZWxlbWVudHMgd2lsbCBub3QgYmUgaGFuZGxlZCBieSBBbmd1bGFyLiBGb3IgdGhpcyB0byB3b3JrIGFzIGV4cGVjdGVkLCBwbGVhc2UgdXNlIGAkYW5pbWF0ZWAgdG9cbiAqIHRyaWdnZXIgdGhlIGFuaW1hdGlvbiBhbmQgdGhlbiBzZXR1cCBhIEphdmFTY3JpcHQgYW5pbWF0aW9uIHRoYXQgaW5qZWN0cyBgJGFuaW1hdGVDc3NgIHRvIHRyaWdnZXJcbiAqIHRoZSBDU1MgYW5pbWF0aW9uLlxuICpcbiAqIFRoZSBleGFtcGxlIGJlbG93IHNob3dzIGhvdyB3ZSBjYW4gY3JlYXRlIGEgZm9sZGluZyBhbmltYXRpb24gb24gYW4gZWxlbWVudCB1c2luZyBgbmctaWZgOlxuICpcbiAqIGBgYGh0bWxcbiAqIDwhLS0gbm90aWNlIHRoZSBgZm9sZC1hbmltYXRpb25gIENTUyBjbGFzcyAtLT5cbiAqIDxkaXYgbmctaWY9XCJvbk9mZlwiIGNsYXNzPVwiZm9sZC1hbmltYXRpb25cIj5cbiAqICAgVGhpcyBlbGVtZW50IHdpbGwgZ28gQk9PTVxuICogPC9kaXY+XG4gKiA8YnV0dG9uIG5nLWNsaWNrPVwib25PZmY9dHJ1ZVwiPkZvbGQgSW48L2J1dHRvbj5cbiAqIGBgYFxuICpcbiAqIE5vdyB3ZSBjcmVhdGUgdGhlICoqSmF2YVNjcmlwdCBhbmltYXRpb24qKiB0aGF0IHdpbGwgdHJpZ2dlciB0aGUgQ1NTIHRyYW5zaXRpb246XG4gKlxuICogYGBganNcbiAqIG5nTW9kdWxlLmFuaW1hdGlvbignLmZvbGQtYW5pbWF0aW9uJywgWyckYW5pbWF0ZUNzcycsIGZ1bmN0aW9uKCRhbmltYXRlQ3NzKSB7XG4gKiAgIHJldHVybiB7XG4gKiAgICAgZW50ZXI6IGZ1bmN0aW9uKGVsZW1lbnQsIGRvbmVGbikge1xuICogICAgICAgdmFyIGhlaWdodCA9IGVsZW1lbnRbMF0ub2Zmc2V0SGVpZ2h0O1xuICogICAgICAgcmV0dXJuICRhbmltYXRlQ3NzKGVsZW1lbnQsIHtcbiAqICAgICAgICAgZnJvbTogeyBoZWlnaHQ6JzBweCcgfSxcbiAqICAgICAgICAgdG86IHsgaGVpZ2h0OmhlaWdodCArICdweCcgfSxcbiAqICAgICAgICAgZHVyYXRpb246IDEgLy8gb25lIHNlY29uZFxuICogICAgICAgfSk7XG4gKiAgICAgfVxuICogICB9XG4gKiB9XSk7XG4gKiBgYGBcbiAqXG4gKiAjIyBNb3JlIEFkdmFuY2VkIFVzZXNcbiAqXG4gKiBgJGFuaW1hdGVDc3NgIGlzIHRoZSB1bmRlcmx5aW5nIGNvZGUgdGhhdCBuZ0FuaW1hdGUgdXNlcyB0byBwb3dlciAqKkNTUy1iYXNlZCBhbmltYXRpb25zKiogYmVoaW5kIHRoZSBzY2VuZXMuIFRoZXJlZm9yZSBDU1MgaG9va3NcbiAqIGxpa2UgYC5uZy1FVkVOVGAsIGAubmctRVZFTlQtYWN0aXZlYCwgYC5uZy1FVkVOVC1zdGFnZ2VyYCBhcmUgYWxsIGZlYXR1cmVzIHRoYXQgY2FuIGJlIHRyaWdnZXJlZCB1c2luZyBgJGFuaW1hdGVDc3NgIHZpYSBKYXZhU2NyaXB0IGNvZGUuXG4gKlxuICogVGhpcyBhbHNvIG1lYW5zIHRoYXQganVzdCBhYm91dCBhbnkgY29tYmluYXRpb24gb2YgYWRkaW5nIGNsYXNzZXMsIHJlbW92aW5nIGNsYXNzZXMsIHNldHRpbmcgc3R5bGVzLCBkeW5hbWljYWxseSBzZXR0aW5nIGEga2V5ZnJhbWUgYW5pbWF0aW9uLFxuICogYXBwbHlpbmcgYSBoYXJkY29kZWQgZHVyYXRpb24gb3IgZGVsYXkgdmFsdWUsIGNoYW5naW5nIHRoZSBhbmltYXRpb24gZWFzaW5nIG9yIGFwcGx5aW5nIGEgc3RhZ2dlciBhbmltYXRpb24gYXJlIGFsbCBvcHRpb25zIHRoYXQgd29yayB3aXRoXG4gKiBgJGFuaW1hdGVDc3NgLiBUaGUgc2VydmljZSBpdHNlbGYgaXMgc21hcnQgZW5vdWdoIHRvIGZpZ3VyZSBvdXQgdGhlIGNvbWJpbmF0aW9uIG9mIG9wdGlvbnMgYW5kIGV4YW1pbmUgdGhlIGVsZW1lbnQgc3R5bGluZyBwcm9wZXJ0aWVzIGluIG9yZGVyXG4gKiB0byBwcm92aWRlIGEgd29ya2luZyBhbmltYXRpb24gdGhhdCB3aWxsIHJ1biBpbiBDU1MuXG4gKlxuICogVGhlIGV4YW1wbGUgYmVsb3cgc2hvd2Nhc2VzIGEgbW9yZSBhZHZhbmNlZCB2ZXJzaW9uIG9mIHRoZSBgLmZvbGQtYW5pbWF0aW9uYCBmcm9tIHRoZSBleGFtcGxlIGFib3ZlOlxuICpcbiAqIGBgYGpzXG4gKiBuZ01vZHVsZS5hbmltYXRpb24oJy5mb2xkLWFuaW1hdGlvbicsIFsnJGFuaW1hdGVDc3MnLCBmdW5jdGlvbigkYW5pbWF0ZUNzcykge1xuICogICByZXR1cm4ge1xuICogICAgIGVudGVyOiBmdW5jdGlvbihlbGVtZW50LCBkb25lRm4pIHtcbiAqICAgICAgIHZhciBoZWlnaHQgPSBlbGVtZW50WzBdLm9mZnNldEhlaWdodDtcbiAqICAgICAgIHJldHVybiAkYW5pbWF0ZUNzcyhlbGVtZW50LCB7XG4gKiAgICAgICAgIGFkZENsYXNzOiAncmVkIGxhcmdlLXRleHQgcHVsc2UtdHdpY2UnLFxuICogICAgICAgICBlYXNpbmc6ICdlYXNlLW91dCcsXG4gKiAgICAgICAgIGZyb206IHsgaGVpZ2h0OicwcHgnIH0sXG4gKiAgICAgICAgIHRvOiB7IGhlaWdodDpoZWlnaHQgKyAncHgnIH0sXG4gKiAgICAgICAgIGR1cmF0aW9uOiAxIC8vIG9uZSBzZWNvbmRcbiAqICAgICAgIH0pO1xuICogICAgIH1cbiAqICAgfVxuICogfV0pO1xuICogYGBgXG4gKlxuICogU2luY2Ugd2UncmUgYWRkaW5nL3JlbW92aW5nIENTUyBjbGFzc2VzIHRoZW4gdGhlIENTUyB0cmFuc2l0aW9uIHdpbGwgYWxzbyBwaWNrIHRob3NlIHVwOlxuICpcbiAqIGBgYGNzc1xuICogLyYjNDI7IHNpbmNlIGEgaGFyZGNvZGVkIGR1cmF0aW9uIHZhbHVlIG9mIDEgd2FzIHByb3ZpZGVkIGluIHRoZSBKYXZhU2NyaXB0IGFuaW1hdGlvbiBjb2RlLFxuICogdGhlIENTUyBjbGFzc2VzIGJlbG93IHdpbGwgYmUgdHJhbnNpdGlvbmVkIGRlc3BpdGUgdGhlbSBiZWluZyBkZWZpbmVkIGFzIHJlZ3VsYXIgQ1NTIGNsYXNzZXMgJiM0MjsvXG4gKiAucmVkIHsgYmFja2dyb3VuZDpyZWQ7IH1cbiAqIC5sYXJnZS10ZXh0IHsgZm9udC1zaXplOjIwcHg7IH1cbiAqXG4gKiAvJiM0Mjsgd2UgY2FuIGFsc28gdXNlIGEga2V5ZnJhbWUgYW5pbWF0aW9uIGFuZCAkYW5pbWF0ZUNzcyB3aWxsIG1ha2UgaXQgd29yayBhbG9uZ3NpZGUgdGhlIHRyYW5zaXRpb24gJiM0MjsvXG4gKiAucHVsc2UtdHdpY2Uge1xuICogICBhbmltYXRpb246IDAuNXMgcHVsc2UgbGluZWFyIDI7XG4gKiAgIC13ZWJraXQtYW5pbWF0aW9uOiAwLjVzIHB1bHNlIGxpbmVhciAyO1xuICogfVxuICpcbiAqIEBrZXlmcmFtZXMgcHVsc2Uge1xuICogICBmcm9tIHsgdHJhbnNmb3JtOiBzY2FsZSgwLjUpOyB9XG4gKiAgIHRvIHsgdHJhbnNmb3JtOiBzY2FsZSgxLjUpOyB9XG4gKiB9XG4gKlxuICogQC13ZWJraXQta2V5ZnJhbWVzIHB1bHNlIHtcbiAqICAgZnJvbSB7IC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZSgwLjUpOyB9XG4gKiAgIHRvIHsgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlKDEuNSk7IH1cbiAqIH1cbiAqIGBgYFxuICpcbiAqIEdpdmVuIHRoaXMgY29tcGxleCBjb21iaW5hdGlvbiBvZiBDU1MgY2xhc3Nlcywgc3R5bGVzIGFuZCBvcHRpb25zLCBgJGFuaW1hdGVDc3NgIHdpbGwgZmlndXJlIGV2ZXJ5dGhpbmcgb3V0IGFuZCBtYWtlIHRoZSBhbmltYXRpb24gaGFwcGVuLlxuICpcbiAqICMjIEhvdyB0aGUgT3B0aW9ucyBhcmUgaGFuZGxlZFxuICpcbiAqIGAkYW5pbWF0ZUNzc2AgaXMgdmVyeSB2ZXJzYXRpbGUgYW5kIGludGVsbGlnZW50IHdoZW4gaXQgY29tZXMgdG8gZmlndXJpbmcgb3V0IHdoYXQgY29uZmlndXJhdGlvbnMgdG8gYXBwbHkgdG8gdGhlIGVsZW1lbnQgdG8gZW5zdXJlIHRoZSBhbmltYXRpb25cbiAqIHdvcmtzIHdpdGggdGhlIG9wdGlvbnMgcHJvdmlkZWQuIFNheSBmb3IgZXhhbXBsZSB3ZSB3ZXJlIGFkZGluZyBhIGNsYXNzIHRoYXQgY29udGFpbmVkIGEga2V5ZnJhbWUgdmFsdWUgYW5kIHdlIHdhbnRlZCB0byBhbHNvIGFuaW1hdGUgc29tZSBpbmxpbmVcbiAqIHN0eWxlcyB1c2luZyB0aGUgYGZyb21gIGFuZCBgdG9gIHByb3BlcnRpZXMuXG4gKlxuICogYGBganNcbiAqIHZhciBhbmltYXRvciA9ICRhbmltYXRlQ3NzKGVsZW1lbnQsIHtcbiAqICAgZnJvbTogeyBiYWNrZ3JvdW5kOidyZWQnIH0sXG4gKiAgIHRvOiB7IGJhY2tncm91bmQ6J2JsdWUnIH1cbiAqIH0pO1xuICogYW5pbWF0b3Iuc3RhcnQoKTtcbiAqIGBgYFxuICpcbiAqIGBgYGNzc1xuICogLnJvdGF0aW5nLWFuaW1hdGlvbiB7XG4gKiAgIGFuaW1hdGlvbjowLjVzIHJvdGF0ZSBsaW5lYXI7XG4gKiAgIC13ZWJraXQtYW5pbWF0aW9uOjAuNXMgcm90YXRlIGxpbmVhcjtcbiAqIH1cbiAqXG4gKiBAa2V5ZnJhbWVzIHJvdGF0ZSB7XG4gKiAgIGZyb20geyB0cmFuc2Zvcm06IHJvdGF0ZSgwZGVnKTsgfVxuICogICB0byB7IHRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7IH1cbiAqIH1cbiAqXG4gKiBALXdlYmtpdC1rZXlmcmFtZXMgcm90YXRlIHtcbiAqICAgZnJvbSB7IC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7IH1cbiAqICAgdG8geyAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7IH1cbiAqIH1cbiAqIGBgYFxuICpcbiAqIFRoZSBtaXNzaW5nIHBpZWNlcyBoZXJlIGFyZSB0aGF0IHdlIGRvIG5vdCBoYXZlIGEgdHJhbnNpdGlvbiBzZXQgKHdpdGhpbiB0aGUgQ1NTIGNvZGUgbm9yIHdpdGhpbiB0aGUgYCRhbmltYXRlQ3NzYCBvcHRpb25zKSBhbmQgdGhlIGR1cmF0aW9uIG9mIHRoZSBhbmltYXRpb24gaXNcbiAqIGdvaW5nIHRvIGJlIGRldGVjdGVkIGZyb20gd2hhdCB0aGUga2V5ZnJhbWUgc3R5bGVzIG9uIHRoZSBDU1MgY2xhc3MgYXJlLiBJbiB0aGlzIGV2ZW50LCBgJGFuaW1hdGVDc3NgIHdpbGwgYXV0b21hdGljYWxseSBjcmVhdGUgYW4gaW5saW5lIHRyYW5zaXRpb25cbiAqIHN0eWxlIG1hdGNoaW5nIHRoZSBkdXJhdGlvbiBkZXRlY3RlZCBmcm9tIHRoZSBrZXlmcmFtZSBzdHlsZSAod2hpY2ggaXMgcHJlc2VudCBpbiB0aGUgQ1NTIGNsYXNzIHRoYXQgaXMgYmVpbmcgYWRkZWQpIGFuZCB0aGVuIHByZXBhcmUgYm90aCB0aGUgdHJhbnNpdGlvblxuICogYW5kIGtleWZyYW1lIGFuaW1hdGlvbnMgdG8gcnVuIGluIHBhcmFsbGVsIG9uIHRoZSBlbGVtZW50LiBUaGVuIHdoZW4gdGhlIGFuaW1hdGlvbiBpcyB1bmRlcndheSB0aGUgcHJvdmlkZWQgYGZyb21gIGFuZCBgdG9gIENTUyBzdHlsZXMgd2lsbCBiZSBhcHBsaWVkXG4gKiBhbmQgc3ByZWFkIGFjcm9zcyB0aGUgdHJhbnNpdGlvbiBhbmQga2V5ZnJhbWUgYW5pbWF0aW9uLlxuICpcbiAqICMjIFdoYXQgaXMgcmV0dXJuZWRcbiAqXG4gKiBgJGFuaW1hdGVDc3NgIHdvcmtzIGluIHR3byBzdGFnZXM6IGEgcHJlcGFyYXRpb24gcGhhc2UgYW5kIGFuIGFuaW1hdGlvbiBwaGFzZS4gVGhlcmVmb3JlIHdoZW4gYCRhbmltYXRlQ3NzYCBpcyBmaXJzdCBjYWxsZWQgaXQgd2lsbCBOT1QgYWN0dWFsbHlcbiAqIHN0YXJ0IHRoZSBhbmltYXRpb24uIEFsbCB0aGF0IGlzIGdvaW5nIG9uIGhlcmUgaXMgdGhhdCB0aGUgZWxlbWVudCBpcyBiZWluZyBwcmVwYXJlZCBmb3IgdGhlIGFuaW1hdGlvbiAod2hpY2ggbWVhbnMgdGhhdCB0aGUgZ2VuZXJhdGVkIENTUyBjbGFzc2VzIGFyZVxuICogYWRkZWQgYW5kIHJlbW92ZWQgb24gdGhlIGVsZW1lbnQpLiBPbmNlIGAkYW5pbWF0ZUNzc2AgaXMgY2FsbGVkIGl0IHdpbGwgcmV0dXJuIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiBgYGBqc1xuICogdmFyIGFuaW1hdG9yID0gJGFuaW1hdGVDc3MoZWxlbWVudCwgeyAuLi4gfSk7XG4gKiBgYGBcbiAqXG4gKiBOb3cgd2hhdCBkbyB0aGUgY29udGVudHMgb2Ygb3VyIGBhbmltYXRvcmAgdmFyaWFibGUgbG9vayBsaWtlOlxuICpcbiAqIGBgYGpzXG4gKiB7XG4gKiAgIC8vIHN0YXJ0cyB0aGUgYW5pbWF0aW9uXG4gKiAgIHN0YXJ0OiBGdW5jdGlvbixcbiAqXG4gKiAgIC8vIGVuZHMgKGFib3J0cykgdGhlIGFuaW1hdGlvblxuICogICBlbmQ6IEZ1bmN0aW9uXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBUbyBhY3R1YWxseSBzdGFydCB0aGUgYW5pbWF0aW9uIHdlIG5lZWQgdG8gcnVuIGBhbmltYXRpb24uc3RhcnQoKWAgd2hpY2ggd2lsbCB0aGVuIHJldHVybiBhIHByb21pc2UgdGhhdCB3ZSBjYW4gaG9vayBpbnRvIHRvIGRldGVjdCB3aGVuIHRoZSBhbmltYXRpb24gZW5kcy5cbiAqIElmIHdlIGNob29zZSBub3QgdG8gcnVuIHRoZSBhbmltYXRpb24gdGhlbiB3ZSBNVVNUIHJ1biBgYW5pbWF0aW9uLmVuZCgpYCB0byBwZXJmb3JtIGEgY2xlYW51cCBvbiB0aGUgZWxlbWVudCAoc2luY2Ugc29tZSBDU1MgY2xhc3NlcyBhbmQgc3R5bGVzIG1heSBoYXZlIGJlZW5cbiAqIGFwcGxpZWQgdG8gdGhlIGVsZW1lbnQgZHVyaW5nIHRoZSBwcmVwYXJhdGlvbiBwaGFzZSkuIE5vdGUgdGhhdCBhbGwgb3RoZXIgcHJvcGVydGllcyBzdWNoIGFzIGR1cmF0aW9uLCBkZWxheSwgdHJhbnNpdGlvbnMgYW5kIGtleWZyYW1lcyBhcmUganVzdCBwcm9wZXJ0aWVzXG4gKiBhbmQgdGhhdCBjaGFuZ2luZyB0aGVtIHdpbGwgbm90IHJlY29uZmlndXJlIHRoZSBwYXJhbWV0ZXJzIG9mIHRoZSBhbmltYXRpb24uXG4gKlxuICogIyMjIHJ1bm5lci5kb25lKCkgdnMgcnVubmVyLnRoZW4oKVxuICogSXQgaXMgZG9jdW1lbnRlZCB0aGF0IGBhbmltYXRpb24uc3RhcnQoKWAgd2lsbCByZXR1cm4gYSBwcm9taXNlIG9iamVjdCBhbmQgdGhpcyBpcyB0cnVlLCBob3dldmVyLCB0aGVyZSBpcyBhbHNvIGFuIGFkZGl0aW9uYWwgbWV0aG9kIGF2YWlsYWJsZSBvbiB0aGVcbiAqIHJ1bm5lciBjYWxsZWQgYC5kb25lKGNhbGxiYWNrRm4pYC4gVGhlIGRvbmUgbWV0aG9kIHdvcmtzIHRoZSBzYW1lIGFzIGAuZmluYWxseShjYWxsYmFja0ZuKWAsIGhvd2V2ZXIsIGl0IGRvZXMgKipub3QgdHJpZ2dlciBhIGRpZ2VzdCB0byBvY2N1cioqLlxuICogVGhlcmVmb3JlLCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucywgaXQncyBhbHdheXMgYmVzdCB0byB1c2UgYHJ1bm5lci5kb25lKGNhbGxiYWNrKWAgaW5zdGVhZCBvZiBgcnVubmVyLnRoZW4oKWAsIGBydW5uZXIuY2F0Y2goKWAgb3IgYHJ1bm5lci5maW5hbGx5KClgXG4gKiB1bmxlc3MgeW91IHJlYWxseSBuZWVkIGEgZGlnZXN0IHRvIGtpY2sgb2ZmIGFmdGVyd2FyZHMuXG4gKlxuICogS2VlcCBpbiBtaW5kIHRoYXQsIHRvIG1ha2UgdGhpcyBlYXNpZXIsIG5nQW5pbWF0ZSBoYXMgdHdlYWtlZCB0aGUgSlMgYW5pbWF0aW9ucyBBUEkgdG8gcmVjb2duaXplIHdoZW4gYSBydW5uZXIgaW5zdGFuY2UgaXMgcmV0dXJuZWQgZnJvbSAkYW5pbWF0ZUNzc1xuICogKHNvIHRoZXJlIGlzIG5vIG5lZWQgdG8gY2FsbCBgcnVubmVyLmRvbmUoZG9uZUZuKWAgaW5zaWRlIG9mIHlvdXIgSmF2YVNjcmlwdCBhbmltYXRpb24gY29kZSkuXG4gKiBDaGVjayB0aGUge0BsaW5rIG5nQW5pbWF0ZS4kYW5pbWF0ZUNzcyN1c2FnZSBhbmltYXRpb24gY29kZSBhYm92ZX0gdG8gc2VlIGhvdyB0aGlzIHdvcmtzLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gZWxlbWVudCB0aGUgZWxlbWVudCB0aGF0IHdpbGwgYmUgYW5pbWF0ZWRcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIHRoZSBhbmltYXRpb24tcmVsYXRlZCBvcHRpb25zIHRoYXQgd2lsbCBiZSBhcHBsaWVkIGR1cmluZyB0aGUgYW5pbWF0aW9uXG4gKlxuICogKiBgZXZlbnRgIC0gVGhlIERPTSBldmVudCAoZS5nLiBlbnRlciwgbGVhdmUsIG1vdmUpLiBXaGVuIHVzZWQsIGEgZ2VuZXJhdGVkIENTUyBjbGFzcyBvZiBgbmctRVZFTlRgIGFuZCBgbmctRVZFTlQtYWN0aXZlYCB3aWxsIGJlIGFwcGxpZWRcbiAqIHRvIHRoZSBlbGVtZW50IGR1cmluZyB0aGUgYW5pbWF0aW9uLiBNdWx0aXBsZSBldmVudHMgY2FuIGJlIHByb3ZpZGVkIHdoZW4gc3BhY2VzIGFyZSB1c2VkIGFzIGEgc2VwYXJhdG9yLiAoTm90ZSB0aGF0IHRoaXMgd2lsbCBub3QgcGVyZm9ybSBhbnkgRE9NIG9wZXJhdGlvbi4pXG4gKiAqIGBzdHJ1Y3R1cmFsYCAtIEluZGljYXRlcyB0aGF0IHRoZSBgbmctYCBwcmVmaXggd2lsbCBiZSBhZGRlZCB0byB0aGUgZXZlbnQgY2xhc3MuIFNldHRpbmcgdG8gYGZhbHNlYCBvciBvbWl0dGluZyB3aWxsIHR1cm4gYG5nLUVWRU5UYCBhbmRcbiAqIGBuZy1FVkVOVC1hY3RpdmVgIGluIGBFVkVOVGAgYW5kIGBFVkVOVC1hY3RpdmVgLiBVbnVzZWQgaWYgYGV2ZW50YCBpcyBvbWl0dGVkLlxuICogKiBgZWFzaW5nYCAtIFRoZSBDU1MgZWFzaW5nIHZhbHVlIHRoYXQgd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSB0cmFuc2l0aW9uIG9yIGtleWZyYW1lIGFuaW1hdGlvbiAob3IgYm90aCkuXG4gKiAqIGB0cmFuc2l0aW9uU3R5bGVgIC0gVGhlIHJhdyBDU1MgdHJhbnNpdGlvbiBzdHlsZSB0aGF0IHdpbGwgYmUgdXNlZCAoZS5nLiBgMXMgbGluZWFyIGFsbGApLlxuICogKiBga2V5ZnJhbWVTdHlsZWAgLSBUaGUgcmF3IENTUyBrZXlmcmFtZSBhbmltYXRpb24gc3R5bGUgdGhhdCB3aWxsIGJlIHVzZWQgKGUuZy4gYDFzIG15X2FuaW1hdGlvbiBsaW5lYXJgKS5cbiAqICogYGZyb21gIC0gVGhlIHN0YXJ0aW5nIENTUyBzdHlsZXMgKGEga2V5L3ZhbHVlIG9iamVjdCkgdGhhdCB3aWxsIGJlIGFwcGxpZWQgYXQgdGhlIHN0YXJ0IG9mIHRoZSBhbmltYXRpb24uXG4gKiAqIGB0b2AgLSBUaGUgZW5kaW5nIENTUyBzdHlsZXMgKGEga2V5L3ZhbHVlIG9iamVjdCkgdGhhdCB3aWxsIGJlIGFwcGxpZWQgYWNyb3NzIHRoZSBhbmltYXRpb24gdmlhIGEgQ1NTIHRyYW5zaXRpb24uXG4gKiAqIGBhZGRDbGFzc2AgLSBBIHNwYWNlIHNlcGFyYXRlZCBsaXN0IG9mIENTUyBjbGFzc2VzIHRoYXQgd2lsbCBiZSBhZGRlZCB0byB0aGUgZWxlbWVudCBhbmQgc3ByZWFkIGFjcm9zcyB0aGUgYW5pbWF0aW9uLlxuICogKiBgcmVtb3ZlQ2xhc3NgIC0gQSBzcGFjZSBzZXBhcmF0ZWQgbGlzdCBvZiBDU1MgY2xhc3NlcyB0aGF0IHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBlbGVtZW50IGFuZCBzcHJlYWQgYWNyb3NzIHRoZSBhbmltYXRpb24uXG4gKiAqIGBkdXJhdGlvbmAgLSBBIG51bWJlciB2YWx1ZSByZXByZXNlbnRpbmcgdGhlIHRvdGFsIGR1cmF0aW9uIG9mIHRoZSB0cmFuc2l0aW9uIGFuZC9vciBrZXlmcmFtZSAobm90ZSB0aGF0IGEgdmFsdWUgb2YgMSBpcyAxMDAwbXMpLiBJZiBhIHZhbHVlIG9mIGAwYFxuICogaXMgcHJvdmlkZWQgdGhlbiB0aGUgYW5pbWF0aW9uIHdpbGwgYmUgc2tpcHBlZCBlbnRpcmVseS5cbiAqICogYGRlbGF5YCAtIEEgbnVtYmVyIHZhbHVlIHJlcHJlc2VudGluZyB0aGUgdG90YWwgZGVsYXkgb2YgdGhlIHRyYW5zaXRpb24gYW5kL29yIGtleWZyYW1lIChub3RlIHRoYXQgYSB2YWx1ZSBvZiAxIGlzIDEwMDBtcykuIElmIGEgdmFsdWUgb2YgYHRydWVgIGlzXG4gKiB1c2VkIHRoZW4gd2hhdGV2ZXIgZGVsYXkgdmFsdWUgaXMgZGV0ZWN0ZWQgZnJvbSB0aGUgQ1NTIGNsYXNzZXMgd2lsbCBiZSBtaXJyb3JlZCBvbiB0aGUgZWxlbWVudHMgc3R5bGVzIChlLmcuIGJ5IHNldHRpbmcgZGVsYXkgdHJ1ZSB0aGVuIHRoZSBzdHlsZSB2YWx1ZVxuICogb2YgdGhlIGVsZW1lbnQgd2lsbCBiZSBgdHJhbnNpdGlvbi1kZWxheTogREVURUNURURfVkFMVUVgKS4gVXNpbmcgYHRydWVgIGlzIHVzZWZ1bCB3aGVuIHlvdSB3YW50IHRoZSBDU1MgY2xhc3NlcyBhbmQgaW5saW5lIHN0eWxlcyB0byBhbGwgc2hhcmUgdGhlIHNhbWVcbiAqIENTUyBkZWxheSB2YWx1ZS5cbiAqICogYHN0YWdnZXJgIC0gQSBudW1lcmljIHRpbWUgdmFsdWUgcmVwcmVzZW50aW5nIHRoZSBkZWxheSBiZXR3ZWVuIHN1Y2Nlc3NpdmVseSBhbmltYXRlZCBlbGVtZW50c1xuICogKHtAbGluayBuZ0FuaW1hdGUjY3NzLXN0YWdnZXJpbmctYW5pbWF0aW9ucyBDbGljayBoZXJlIHRvIGxlYXJuIGhvdyBDU1MtYmFzZWQgc3RhZ2dlcmluZyB3b3JrcyBpbiBuZ0FuaW1hdGUufSlcbiAqICogYHN0YWdnZXJJbmRleGAgLSBUaGUgbnVtZXJpYyBpbmRleCByZXByZXNlbnRpbmcgdGhlIHN0YWdnZXIgaXRlbSAoZS5nLiBhIHZhbHVlIG9mIDUgaXMgZXF1YWwgdG8gdGhlIHNpeHRoIGl0ZW0gaW4gdGhlIHN0YWdnZXI7IHRoZXJlZm9yZSB3aGVuIGFcbiAqICAgYHN0YWdnZXJgIG9wdGlvbiB2YWx1ZSBvZiBgMC4xYCBpcyB1c2VkIHRoZW4gdGhlcmUgd2lsbCBiZSBhIHN0YWdnZXIgZGVsYXkgb2YgYDYwMG1zYClcbiAqICogYGFwcGx5Q2xhc3Nlc0Vhcmx5YCAtIFdoZXRoZXIgb3Igbm90IHRoZSBjbGFzc2VzIGJlaW5nIGFkZGVkIG9yIHJlbW92ZWQgd2lsbCBiZSB1c2VkIHdoZW4gZGV0ZWN0aW5nIHRoZSBhbmltYXRpb24uIFRoaXMgaXMgc2V0IGJ5IGAkYW5pbWF0ZWAgd2hlbiBlbnRlci9sZWF2ZS9tb3ZlIGFuaW1hdGlvbnMgYXJlIGZpcmVkIHRvIGVuc3VyZSB0aGF0IHRoZSBDU1MgY2xhc3NlcyBhcmUgcmVzb2x2ZWQgaW4gdGltZS4gKE5vdGUgdGhhdCB0aGlzIHdpbGwgcHJldmVudCBhbnkgdHJhbnNpdGlvbnMgZnJvbSBvY2N1cnJpbmcgb24gdGhlIGNsYXNzZXMgYmVpbmcgYWRkZWQgYW5kIHJlbW92ZWQuKVxuICogKiBgY2xlYW51cFN0eWxlc2AgLSBXaGV0aGVyIG9yIG5vdCB0aGUgcHJvdmlkZWQgYGZyb21gIGFuZCBgdG9gIHN0eWxlcyB3aWxsIGJlIHJlbW92ZWQgb25jZVxuICogICAgdGhlIGFuaW1hdGlvbiBpcyBjbG9zZWQuIFRoaXMgaXMgdXNlZnVsIGZvciB3aGVuIHRoZSBzdHlsZXMgYXJlIHVzZWQgcHVyZWx5IGZvciB0aGUgc2FrZSBvZlxuICogICAgdGhlIGFuaW1hdGlvbiBhbmQgZG8gbm90IGhhdmUgYSBsYXN0aW5nIHZpc3VhbCBlZmZlY3Qgb24gdGhlIGVsZW1lbnQgKGUuZy4gYSBjb2xsYXBzZSBhbmQgb3BlbiBhbmltYXRpb24pLlxuICogICAgQnkgZGVmYXVsdCB0aGlzIHZhbHVlIGlzIHNldCB0byBgZmFsc2VgLlxuICpcbiAqIEByZXR1cm4ge29iamVjdH0gYW4gb2JqZWN0IHdpdGggc3RhcnQgYW5kIGVuZCBtZXRob2RzIGFuZCBkZXRhaWxzIGFib3V0IHRoZSBhbmltYXRpb24uXG4gKlxuICogKiBgc3RhcnRgIC0gVGhlIG1ldGhvZCB0byBzdGFydCB0aGUgYW5pbWF0aW9uLiBUaGlzIHdpbGwgcmV0dXJuIGEgYFByb21pc2VgIHdoZW4gY2FsbGVkLlxuICogKiBgZW5kYCAtIFRoaXMgbWV0aG9kIHdpbGwgY2FuY2VsIHRoZSBhbmltYXRpb24gYW5kIHJlbW92ZSBhbGwgYXBwbGllZCBDU1MgY2xhc3NlcyBhbmQgc3R5bGVzLlxuICovXG52YXIgT05FX1NFQ09ORCA9IDEwMDA7XG5cbnZhciBFTEFQU0VEX1RJTUVfTUFYX0RFQ0lNQUxfUExBQ0VTID0gMztcbnZhciBDTE9TSU5HX1RJTUVfQlVGRkVSID0gMS41O1xuXG52YXIgREVURUNUX0NTU19QUk9QRVJUSUVTID0ge1xuICB0cmFuc2l0aW9uRHVyYXRpb246ICAgICAgVFJBTlNJVElPTl9EVVJBVElPTl9QUk9QLFxuICB0cmFuc2l0aW9uRGVsYXk6ICAgICAgICAgVFJBTlNJVElPTl9ERUxBWV9QUk9QLFxuICB0cmFuc2l0aW9uUHJvcGVydHk6ICAgICAgVFJBTlNJVElPTl9QUk9QICsgUFJPUEVSVFlfS0VZLFxuICBhbmltYXRpb25EdXJhdGlvbjogICAgICAgQU5JTUFUSU9OX0RVUkFUSU9OX1BST1AsXG4gIGFuaW1hdGlvbkRlbGF5OiAgICAgICAgICBBTklNQVRJT05fREVMQVlfUFJPUCxcbiAgYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQ6IEFOSU1BVElPTl9QUk9QICsgQU5JTUFUSU9OX0lURVJBVElPTl9DT1VOVF9LRVlcbn07XG5cbnZhciBERVRFQ1RfU1RBR0dFUl9DU1NfUFJPUEVSVElFUyA9IHtcbiAgdHJhbnNpdGlvbkR1cmF0aW9uOiAgICAgIFRSQU5TSVRJT05fRFVSQVRJT05fUFJPUCxcbiAgdHJhbnNpdGlvbkRlbGF5OiAgICAgICAgIFRSQU5TSVRJT05fREVMQVlfUFJPUCxcbiAgYW5pbWF0aW9uRHVyYXRpb246ICAgICAgIEFOSU1BVElPTl9EVVJBVElPTl9QUk9QLFxuICBhbmltYXRpb25EZWxheTogICAgICAgICAgQU5JTUFUSU9OX0RFTEFZX1BST1Bcbn07XG5cbmZ1bmN0aW9uIGdldENzc0tleWZyYW1lRHVyYXRpb25TdHlsZShkdXJhdGlvbikge1xuICByZXR1cm4gW0FOSU1BVElPTl9EVVJBVElPTl9QUk9QLCBkdXJhdGlvbiArICdzJ107XG59XG5cbmZ1bmN0aW9uIGdldENzc0RlbGF5U3R5bGUoZGVsYXksIGlzS2V5ZnJhbWVBbmltYXRpb24pIHtcbiAgdmFyIHByb3AgPSBpc0tleWZyYW1lQW5pbWF0aW9uID8gQU5JTUFUSU9OX0RFTEFZX1BST1AgOiBUUkFOU0lUSU9OX0RFTEFZX1BST1A7XG4gIHJldHVybiBbcHJvcCwgZGVsYXkgKyAncyddO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlQ3NzU3R5bGVzKCR3aW5kb3csIGVsZW1lbnQsIHByb3BlcnRpZXMpIHtcbiAgdmFyIHN0eWxlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZhciBkZXRlY3RlZFN0eWxlcyA9ICR3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KSB8fCB7fTtcbiAgZm9yRWFjaChwcm9wZXJ0aWVzLCBmdW5jdGlvbihmb3JtYWxTdHlsZU5hbWUsIGFjdHVhbFN0eWxlTmFtZSkge1xuICAgIHZhciB2YWwgPSBkZXRlY3RlZFN0eWxlc1tmb3JtYWxTdHlsZU5hbWVdO1xuICAgIGlmICh2YWwpIHtcbiAgICAgIHZhciBjID0gdmFsLmNoYXJBdCgwKTtcblxuICAgICAgLy8gb25seSBudW1lcmljYWwtYmFzZWQgdmFsdWVzIGhhdmUgYSBuZWdhdGl2ZSBzaWduIG9yIGRpZ2l0IGFzIHRoZSBmaXJzdCB2YWx1ZVxuICAgICAgaWYgKGMgPT09ICctJyB8fCBjID09PSAnKycgfHwgYyA+PSAwKSB7XG4gICAgICAgIHZhbCA9IHBhcnNlTWF4VGltZSh2YWwpO1xuICAgICAgfVxuXG4gICAgICAvLyBieSBzZXR0aW5nIHRoaXMgdG8gbnVsbCBpbiB0aGUgZXZlbnQgdGhhdCB0aGUgZGVsYXkgaXMgbm90IHNldCBvciBpcyBzZXQgZGlyZWN0bHkgYXMgMFxuICAgICAgLy8gdGhlbiB3ZSBjYW4gc3RpbGwgYWxsb3cgZm9yIG5lZ2F0aXZlIHZhbHVlcyB0byBiZSB1c2VkIGxhdGVyIG9uIGFuZCBub3QgbWlzdGFrZSB0aGlzXG4gICAgICAvLyB2YWx1ZSBmb3IgYmVpbmcgZ3JlYXRlciB0aGFuIGFueSBvdGhlciBuZWdhdGl2ZSB2YWx1ZS5cbiAgICAgIGlmICh2YWwgPT09IDApIHtcbiAgICAgICAgdmFsID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHN0eWxlc1thY3R1YWxTdHlsZU5hbWVdID0gdmFsO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHN0eWxlcztcbn1cblxuZnVuY3Rpb24gcGFyc2VNYXhUaW1lKHN0cikge1xuICB2YXIgbWF4VmFsdWUgPSAwO1xuICB2YXIgdmFsdWVzID0gc3RyLnNwbGl0KC9cXHMqLFxccyovKTtcbiAgZm9yRWFjaCh2YWx1ZXMsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgLy8gaXQncyBhbHdheXMgc2FmZSB0byBjb25zaWRlciBvbmx5IHNlY29uZCB2YWx1ZXMgYW5kIG9taXQgYG1zYCB2YWx1ZXMgc2luY2VcbiAgICAvLyBnZXRDb21wdXRlZFN0eWxlIHdpbGwgYWx3YXlzIGhhbmRsZSB0aGUgY29udmVyc2lvbiBmb3IgdXNcbiAgICBpZiAodmFsdWUuY2hhckF0KHZhbHVlLmxlbmd0aCAtIDEpID09PSAncycpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDAsIHZhbHVlLmxlbmd0aCAtIDEpO1xuICAgIH1cbiAgICB2YWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpIHx8IDA7XG4gICAgbWF4VmFsdWUgPSBtYXhWYWx1ZSA/IE1hdGgubWF4KHZhbHVlLCBtYXhWYWx1ZSkgOiB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiBtYXhWYWx1ZTtcbn1cblxuZnVuY3Rpb24gdHJ1dGh5VGltaW5nVmFsdWUodmFsKSB7XG4gIHJldHVybiB2YWwgPT09IDAgfHwgdmFsICE9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldENzc1RyYW5zaXRpb25EdXJhdGlvblN0eWxlKGR1cmF0aW9uLCBhcHBseU9ubHlEdXJhdGlvbikge1xuICB2YXIgc3R5bGUgPSBUUkFOU0lUSU9OX1BST1A7XG4gIHZhciB2YWx1ZSA9IGR1cmF0aW9uICsgJ3MnO1xuICBpZiAoYXBwbHlPbmx5RHVyYXRpb24pIHtcbiAgICBzdHlsZSArPSBEVVJBVElPTl9LRVk7XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgKz0gJyBsaW5lYXIgYWxsJztcbiAgfVxuICByZXR1cm4gW3N0eWxlLCB2YWx1ZV07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxvY2FsQ2FjaGVMb29rdXAoKSB7XG4gIHZhciBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHJldHVybiB7XG4gICAgZmx1c2g6IGZ1bmN0aW9uKCkge1xuICAgICAgY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH0sXG5cbiAgICBjb3VudDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICB2YXIgZW50cnkgPSBjYWNoZVtrZXldO1xuICAgICAgcmV0dXJuIGVudHJ5ID8gZW50cnkudG90YWwgOiAwO1xuICAgIH0sXG5cbiAgICBnZXQ6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgdmFyIGVudHJ5ID0gY2FjaGVba2V5XTtcbiAgICAgIHJldHVybiBlbnRyeSAmJiBlbnRyeS52YWx1ZTtcbiAgICB9LFxuXG4gICAgcHV0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICBpZiAoIWNhY2hlW2tleV0pIHtcbiAgICAgICAgY2FjaGVba2V5XSA9IHsgdG90YWw6IDEsIHZhbHVlOiB2YWx1ZSB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FjaGVba2V5XS50b3RhbCsrO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuLy8gd2UgZG8gbm90IHJlYXNzaWduIGFuIGFscmVhZHkgcHJlc2VudCBzdHlsZSB2YWx1ZSBzaW5jZVxuLy8gaWYgd2UgZGV0ZWN0IHRoZSBzdHlsZSBwcm9wZXJ0eSB2YWx1ZSBhZ2FpbiB3ZSBtYXkgYmVcbi8vIGRldGVjdGluZyBzdHlsZXMgdGhhdCB3ZXJlIGFkZGVkIHZpYSB0aGUgYGZyb21gIHN0eWxlcy5cbi8vIFdlIG1ha2UgdXNlIG9mIGBpc0RlZmluZWRgIGhlcmUgc2luY2UgYW4gZW1wdHkgc3RyaW5nXG4vLyBvciBudWxsIHZhbHVlICh3aGljaCBpcyB3aGF0IGdldFByb3BlcnR5VmFsdWUgd2lsbCByZXR1cm5cbi8vIGZvciBhIG5vbi1leGlzdGluZyBzdHlsZSkgd2lsbCBzdGlsbCBiZSBtYXJrZWQgYXMgYSB2YWxpZFxuLy8gdmFsdWUgZm9yIHRoZSBzdHlsZSAoYSBmYWxzeSB2YWx1ZSBpbXBsaWVzIHRoYXQgdGhlIHN0eWxlXG4vLyBpcyB0byBiZSByZW1vdmVkIGF0IHRoZSBlbmQgb2YgdGhlIGFuaW1hdGlvbikuIElmIHdlIGhhZCBhIHNpbXBsZVxuLy8gXCJPUlwiIHN0YXRlbWVudCB0aGVuIGl0IHdvdWxkIG5vdCBiZSBlbm91Z2ggdG8gY2F0Y2ggdGhhdC5cbmZ1bmN0aW9uIHJlZ2lzdGVyUmVzdG9yYWJsZVN0eWxlcyhiYWNrdXAsIG5vZGUsIHByb3BlcnRpZXMpIHtcbiAgZm9yRWFjaChwcm9wZXJ0aWVzLCBmdW5jdGlvbihwcm9wKSB7XG4gICAgYmFja3VwW3Byb3BdID0gaXNEZWZpbmVkKGJhY2t1cFtwcm9wXSlcbiAgICAgICAgPyBiYWNrdXBbcHJvcF1cbiAgICAgICAgOiBub2RlLnN0eWxlLmdldFByb3BlcnR5VmFsdWUocHJvcCk7XG4gIH0pO1xufVxuXG52YXIgJEFuaW1hdGVDc3NQcm92aWRlciA9IFsnJGFuaW1hdGVQcm92aWRlcicsIC8qKiBAdGhpcyAqLyBmdW5jdGlvbigkYW5pbWF0ZVByb3ZpZGVyKSB7XG4gIHZhciBnY3NMb29rdXAgPSBjcmVhdGVMb2NhbENhY2hlTG9va3VwKCk7XG4gIHZhciBnY3NTdGFnZ2VyTG9va3VwID0gY3JlYXRlTG9jYWxDYWNoZUxvb2t1cCgpO1xuXG4gIHRoaXMuJGdldCA9IFsnJHdpbmRvdycsICckJGpxTGl0ZScsICckJEFuaW1hdGVSdW5uZXInLCAnJHRpbWVvdXQnLFxuICAgICAgICAgICAgICAgJyQkZm9yY2VSZWZsb3cnLCAnJHNuaWZmZXInLCAnJCRyQUZTY2hlZHVsZXInLCAnJCRhbmltYXRlUXVldWUnLFxuICAgICAgIGZ1bmN0aW9uKCR3aW5kb3csICAgJCRqcUxpdGUsICAgJCRBbmltYXRlUnVubmVyLCAgICR0aW1lb3V0LFxuICAgICAgICAgICAgICAgICQkZm9yY2VSZWZsb3csICAgJHNuaWZmZXIsICAgJCRyQUZTY2hlZHVsZXIsICQkYW5pbWF0ZVF1ZXVlKSB7XG5cbiAgICB2YXIgYXBwbHlBbmltYXRpb25DbGFzc2VzID0gYXBwbHlBbmltYXRpb25DbGFzc2VzRmFjdG9yeSgkJGpxTGl0ZSk7XG5cbiAgICB2YXIgcGFyZW50Q291bnRlciA9IDA7XG4gICAgZnVuY3Rpb24gZ2NzSGFzaEZuKG5vZGUsIGV4dHJhQ2xhc3Nlcykge1xuICAgICAgdmFyIEtFWSA9ICckJG5nQW5pbWF0ZVBhcmVudEtleSc7XG4gICAgICB2YXIgcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgIHZhciBwYXJlbnRJRCA9IHBhcmVudE5vZGVbS0VZXSB8fCAocGFyZW50Tm9kZVtLRVldID0gKytwYXJlbnRDb3VudGVyKTtcbiAgICAgIHJldHVybiBwYXJlbnRJRCArICctJyArIG5vZGUuZ2V0QXR0cmlidXRlKCdjbGFzcycpICsgJy0nICsgZXh0cmFDbGFzc2VzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbXB1dGVDYWNoZWRDc3NTdHlsZXMobm9kZSwgY2xhc3NOYW1lLCBjYWNoZUtleSwgcHJvcGVydGllcykge1xuICAgICAgdmFyIHRpbWluZ3MgPSBnY3NMb29rdXAuZ2V0KGNhY2hlS2V5KTtcblxuICAgICAgaWYgKCF0aW1pbmdzKSB7XG4gICAgICAgIHRpbWluZ3MgPSBjb21wdXRlQ3NzU3R5bGVzKCR3aW5kb3csIG5vZGUsIHByb3BlcnRpZXMpO1xuICAgICAgICBpZiAodGltaW5ncy5hbmltYXRpb25JdGVyYXRpb25Db3VudCA9PT0gJ2luZmluaXRlJykge1xuICAgICAgICAgIHRpbWluZ3MuYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQgPSAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHdlIGtlZXAgcHV0dGluZyB0aGlzIGluIG11bHRpcGxlIHRpbWVzIGV2ZW4gdGhvdWdoIHRoZSB2YWx1ZSBhbmQgdGhlIGNhY2hlS2V5IGFyZSB0aGUgc2FtZVxuICAgICAgLy8gYmVjYXVzZSB3ZSdyZSBrZWVwaW5nIGFuIGludGVybmFsIHRhbGx5IG9mIGhvdyBtYW55IGR1cGxpY2F0ZSBhbmltYXRpb25zIGFyZSBkZXRlY3RlZC5cbiAgICAgIGdjc0xvb2t1cC5wdXQoY2FjaGVLZXksIHRpbWluZ3MpO1xuICAgICAgcmV0dXJuIHRpbWluZ3M7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcHV0ZUNhY2hlZENzc1N0YWdnZXJTdHlsZXMobm9kZSwgY2xhc3NOYW1lLCBjYWNoZUtleSwgcHJvcGVydGllcykge1xuICAgICAgdmFyIHN0YWdnZXI7XG5cbiAgICAgIC8vIGlmIHdlIGhhdmUgb25lIG9yIG1vcmUgZXhpc3RpbmcgbWF0Y2hlcyBvZiBtYXRjaGluZyBlbGVtZW50c1xuICAgICAgLy8gY29udGFpbmluZyB0aGUgc2FtZSBwYXJlbnQgKyBDU1Mgc3R5bGVzICh3aGljaCBpcyBob3cgY2FjaGVLZXkgd29ya3MpXG4gICAgICAvLyB0aGVuIHN0YWdnZXJpbmcgaXMgcG9zc2libGVcbiAgICAgIGlmIChnY3NMb29rdXAuY291bnQoY2FjaGVLZXkpID4gMCkge1xuICAgICAgICBzdGFnZ2VyID0gZ2NzU3RhZ2dlckxvb2t1cC5nZXQoY2FjaGVLZXkpO1xuXG4gICAgICAgIGlmICghc3RhZ2dlcikge1xuICAgICAgICAgIHZhciBzdGFnZ2VyQ2xhc3NOYW1lID0gcGVuZENsYXNzZXMoY2xhc3NOYW1lLCAnLXN0YWdnZXInKTtcblxuICAgICAgICAgICQkanFMaXRlLmFkZENsYXNzKG5vZGUsIHN0YWdnZXJDbGFzc05hbWUpO1xuXG4gICAgICAgICAgc3RhZ2dlciA9IGNvbXB1dGVDc3NTdHlsZXMoJHdpbmRvdywgbm9kZSwgcHJvcGVydGllcyk7XG5cbiAgICAgICAgICAvLyBmb3JjZSB0aGUgY29udmVyc2lvbiBvZiBhIG51bGwgdmFsdWUgdG8gemVybyBpbmNhc2Ugbm90IHNldFxuICAgICAgICAgIHN0YWdnZXIuYW5pbWF0aW9uRHVyYXRpb24gPSBNYXRoLm1heChzdGFnZ2VyLmFuaW1hdGlvbkR1cmF0aW9uLCAwKTtcbiAgICAgICAgICBzdGFnZ2VyLnRyYW5zaXRpb25EdXJhdGlvbiA9IE1hdGgubWF4KHN0YWdnZXIudHJhbnNpdGlvbkR1cmF0aW9uLCAwKTtcblxuICAgICAgICAgICQkanFMaXRlLnJlbW92ZUNsYXNzKG5vZGUsIHN0YWdnZXJDbGFzc05hbWUpO1xuXG4gICAgICAgICAgZ2NzU3RhZ2dlckxvb2t1cC5wdXQoY2FjaGVLZXksIHN0YWdnZXIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdGFnZ2VyIHx8IHt9O1xuICAgIH1cblxuICAgIHZhciByYWZXYWl0UXVldWUgPSBbXTtcbiAgICBmdW5jdGlvbiB3YWl0VW50aWxRdWlldChjYWxsYmFjaykge1xuICAgICAgcmFmV2FpdFF1ZXVlLnB1c2goY2FsbGJhY2spO1xuICAgICAgJCRyQUZTY2hlZHVsZXIud2FpdFVudGlsUXVpZXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIGdjc0xvb2t1cC5mbHVzaCgpO1xuICAgICAgICBnY3NTdGFnZ2VyTG9va3VwLmZsdXNoKCk7XG5cbiAgICAgICAgLy8gRE8gTk9UIFJFTU9WRSBUSElTIExJTkUgT1IgUkVGQUNUT1IgT1VUIFRIRSBgcGFnZVdpZHRoYCB2YXJpYWJsZS5cbiAgICAgICAgLy8gUExFQVNFIEVYQU1JTkUgVEhFIGAkJGZvcmNlUmVmbG93YCBzZXJ2aWNlIHRvIHVuZGVyc3RhbmQgd2h5LlxuICAgICAgICB2YXIgcGFnZVdpZHRoID0gJCRmb3JjZVJlZmxvdygpO1xuXG4gICAgICAgIC8vIHdlIHVzZSBhIGZvciBsb29wIHRvIGVuc3VyZSB0aGF0IGlmIHRoZSBxdWV1ZSBpcyBjaGFuZ2VkXG4gICAgICAgIC8vIGR1cmluZyB0aGlzIGxvb3BpbmcgdGhlbiBpdCB3aWxsIGNvbnNpZGVyIG5ldyByZXF1ZXN0c1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhZldhaXRRdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHJhZldhaXRRdWV1ZVtpXShwYWdlV2lkdGgpO1xuICAgICAgICB9XG4gICAgICAgIHJhZldhaXRRdWV1ZS5sZW5ndGggPSAwO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcHV0ZVRpbWluZ3Mobm9kZSwgY2xhc3NOYW1lLCBjYWNoZUtleSkge1xuICAgICAgdmFyIHRpbWluZ3MgPSBjb21wdXRlQ2FjaGVkQ3NzU3R5bGVzKG5vZGUsIGNsYXNzTmFtZSwgY2FjaGVLZXksIERFVEVDVF9DU1NfUFJPUEVSVElFUyk7XG4gICAgICB2YXIgYUQgPSB0aW1pbmdzLmFuaW1hdGlvbkRlbGF5O1xuICAgICAgdmFyIHREID0gdGltaW5ncy50cmFuc2l0aW9uRGVsYXk7XG4gICAgICB0aW1pbmdzLm1heERlbGF5ID0gYUQgJiYgdERcbiAgICAgICAgICA/IE1hdGgubWF4KGFELCB0RClcbiAgICAgICAgICA6IChhRCB8fCB0RCk7XG4gICAgICB0aW1pbmdzLm1heER1cmF0aW9uID0gTWF0aC5tYXgoXG4gICAgICAgICAgdGltaW5ncy5hbmltYXRpb25EdXJhdGlvbiAqIHRpbWluZ3MuYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQsXG4gICAgICAgICAgdGltaW5ncy50cmFuc2l0aW9uRHVyYXRpb24pO1xuXG4gICAgICByZXR1cm4gdGltaW5ncztcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gaW5pdChlbGVtZW50LCBpbml0aWFsT3B0aW9ucykge1xuICAgICAgLy8gYWxsIG9mIHRoZSBhbmltYXRpb24gZnVuY3Rpb25zIHNob3VsZCBjcmVhdGVcbiAgICAgIC8vIGEgY29weSBvZiB0aGUgb3B0aW9ucyBkYXRhLCBob3dldmVyLCBpZiBhXG4gICAgICAvLyBwYXJlbnQgc2VydmljZSBoYXMgYWxyZWFkeSBjcmVhdGVkIGEgY29weSB0aGVuXG4gICAgICAvLyB3ZSBzaG91bGQgc3RpY2sgdG8gdXNpbmcgdGhhdFxuICAgICAgdmFyIG9wdGlvbnMgPSBpbml0aWFsT3B0aW9ucyB8fCB7fTtcbiAgICAgIGlmICghb3B0aW9ucy4kJHByZXBhcmVkKSB7XG4gICAgICAgIG9wdGlvbnMgPSBwcmVwYXJlQW5pbWF0aW9uT3B0aW9ucyhjb3B5KG9wdGlvbnMpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3RvcmVTdHlsZXMgPSB7fTtcbiAgICAgIHZhciBub2RlID0gZ2V0RG9tTm9kZShlbGVtZW50KTtcbiAgICAgIGlmICghbm9kZVxuICAgICAgICAgIHx8ICFub2RlLnBhcmVudE5vZGVcbiAgICAgICAgICB8fCAhJCRhbmltYXRlUXVldWUuZW5hYmxlZCgpKSB7XG4gICAgICAgIHJldHVybiBjbG9zZUFuZFJldHVybk5vb3BBbmltYXRvcigpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdGVtcG9yYXJ5U3R5bGVzID0gW107XG4gICAgICB2YXIgY2xhc3NlcyA9IGVsZW1lbnQuYXR0cignY2xhc3MnKTtcbiAgICAgIHZhciBzdHlsZXMgPSBwYWNrYWdlU3R5bGVzKG9wdGlvbnMpO1xuICAgICAgdmFyIGFuaW1hdGlvbkNsb3NlZDtcbiAgICAgIHZhciBhbmltYXRpb25QYXVzZWQ7XG4gICAgICB2YXIgYW5pbWF0aW9uQ29tcGxldGVkO1xuICAgICAgdmFyIHJ1bm5lcjtcbiAgICAgIHZhciBydW5uZXJIb3N0O1xuICAgICAgdmFyIG1heERlbGF5O1xuICAgICAgdmFyIG1heERlbGF5VGltZTtcbiAgICAgIHZhciBtYXhEdXJhdGlvbjtcbiAgICAgIHZhciBtYXhEdXJhdGlvblRpbWU7XG4gICAgICB2YXIgc3RhcnRUaW1lO1xuICAgICAgdmFyIGV2ZW50cyA9IFtdO1xuXG4gICAgICBpZiAob3B0aW9ucy5kdXJhdGlvbiA9PT0gMCB8fCAoISRzbmlmZmVyLmFuaW1hdGlvbnMgJiYgISRzbmlmZmVyLnRyYW5zaXRpb25zKSkge1xuICAgICAgICByZXR1cm4gY2xvc2VBbmRSZXR1cm5Ob29wQW5pbWF0b3IoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG1ldGhvZCA9IG9wdGlvbnMuZXZlbnQgJiYgaXNBcnJheShvcHRpb25zLmV2ZW50KVxuICAgICAgICAgICAgPyBvcHRpb25zLmV2ZW50LmpvaW4oJyAnKVxuICAgICAgICAgICAgOiBvcHRpb25zLmV2ZW50O1xuXG4gICAgICB2YXIgaXNTdHJ1Y3R1cmFsID0gbWV0aG9kICYmIG9wdGlvbnMuc3RydWN0dXJhbDtcbiAgICAgIHZhciBzdHJ1Y3R1cmFsQ2xhc3NOYW1lID0gJyc7XG4gICAgICB2YXIgYWRkUmVtb3ZlQ2xhc3NOYW1lID0gJyc7XG5cbiAgICAgIGlmIChpc1N0cnVjdHVyYWwpIHtcbiAgICAgICAgc3RydWN0dXJhbENsYXNzTmFtZSA9IHBlbmRDbGFzc2VzKG1ldGhvZCwgRVZFTlRfQ0xBU1NfUFJFRklYLCB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAobWV0aG9kKSB7XG4gICAgICAgIHN0cnVjdHVyYWxDbGFzc05hbWUgPSBtZXRob2Q7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmFkZENsYXNzKSB7XG4gICAgICAgIGFkZFJlbW92ZUNsYXNzTmFtZSArPSBwZW5kQ2xhc3NlcyhvcHRpb25zLmFkZENsYXNzLCBBRERfQ0xBU1NfU1VGRklYKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMucmVtb3ZlQ2xhc3MpIHtcbiAgICAgICAgaWYgKGFkZFJlbW92ZUNsYXNzTmFtZS5sZW5ndGgpIHtcbiAgICAgICAgICBhZGRSZW1vdmVDbGFzc05hbWUgKz0gJyAnO1xuICAgICAgICB9XG4gICAgICAgIGFkZFJlbW92ZUNsYXNzTmFtZSArPSBwZW5kQ2xhc3NlcyhvcHRpb25zLnJlbW92ZUNsYXNzLCBSRU1PVkVfQ0xBU1NfU1VGRklYKTtcbiAgICAgIH1cblxuICAgICAgLy8gdGhlcmUgbWF5IGJlIGEgc2l0dWF0aW9uIHdoZXJlIGEgc3RydWN0dXJhbCBhbmltYXRpb24gaXMgY29tYmluZWQgdG9nZXRoZXJcbiAgICAgIC8vIHdpdGggQ1NTIGNsYXNzZXMgdGhhdCBuZWVkIHRvIHJlc29sdmUgYmVmb3JlIHRoZSBhbmltYXRpb24gaXMgY29tcHV0ZWQuXG4gICAgICAvLyBIb3dldmVyIHRoaXMgbWVhbnMgdGhhdCB0aGVyZSBpcyBubyBleHBsaWNpdCBDU1MgY29kZSB0byBibG9jayB0aGUgYW5pbWF0aW9uXG4gICAgICAvLyBmcm9tIGhhcHBlbmluZyAoYnkgc2V0dGluZyAwcyBub25lIGluIHRoZSBjbGFzcyBuYW1lKS4gSWYgdGhpcyBpcyB0aGUgY2FzZVxuICAgICAgLy8gd2UgbmVlZCB0byBhcHBseSB0aGUgY2xhc3NlcyBiZWZvcmUgdGhlIGZpcnN0IHJBRiBzbyB3ZSBrbm93IHRvIGNvbnRpbnVlIGlmXG4gICAgICAvLyB0aGVyZSBhY3R1YWxseSBpcyBhIGRldGVjdGVkIHRyYW5zaXRpb24gb3Iga2V5ZnJhbWUgYW5pbWF0aW9uXG4gICAgICBpZiAob3B0aW9ucy5hcHBseUNsYXNzZXNFYXJseSAmJiBhZGRSZW1vdmVDbGFzc05hbWUubGVuZ3RoKSB7XG4gICAgICAgIGFwcGx5QW5pbWF0aW9uQ2xhc3NlcyhlbGVtZW50LCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHByZXBhcmF0aW9uQ2xhc3NlcyA9IFtzdHJ1Y3R1cmFsQ2xhc3NOYW1lLCBhZGRSZW1vdmVDbGFzc05hbWVdLmpvaW4oJyAnKS50cmltKCk7XG4gICAgICB2YXIgZnVsbENsYXNzTmFtZSA9IGNsYXNzZXMgKyAnICcgKyBwcmVwYXJhdGlvbkNsYXNzZXM7XG4gICAgICB2YXIgYWN0aXZlQ2xhc3NlcyA9IHBlbmRDbGFzc2VzKHByZXBhcmF0aW9uQ2xhc3NlcywgQUNUSVZFX0NMQVNTX1NVRkZJWCk7XG4gICAgICB2YXIgaGFzVG9TdHlsZXMgPSBzdHlsZXMudG8gJiYgT2JqZWN0LmtleXMoc3R5bGVzLnRvKS5sZW5ndGggPiAwO1xuICAgICAgdmFyIGNvbnRhaW5zS2V5ZnJhbWVBbmltYXRpb24gPSAob3B0aW9ucy5rZXlmcmFtZVN0eWxlIHx8ICcnKS5sZW5ndGggPiAwO1xuXG4gICAgICAvLyB0aGVyZSBpcyBubyB3YXkgd2UgY2FuIHRyaWdnZXIgYW4gYW5pbWF0aW9uIGlmIG5vIHN0eWxlcyBhbmRcbiAgICAgIC8vIG5vIGNsYXNzZXMgYXJlIGJlaW5nIGFwcGxpZWQgd2hpY2ggd291bGQgdGhlbiB0cmlnZ2VyIGEgdHJhbnNpdGlvbixcbiAgICAgIC8vIHVubGVzcyB0aGVyZSBhIGlzIHJhdyBrZXlmcmFtZSB2YWx1ZSB0aGF0IGlzIGFwcGxpZWQgdG8gdGhlIGVsZW1lbnQuXG4gICAgICBpZiAoIWNvbnRhaW5zS2V5ZnJhbWVBbmltYXRpb25cbiAgICAgICAgICAgJiYgIWhhc1RvU3R5bGVzXG4gICAgICAgICAgICYmICFwcmVwYXJhdGlvbkNsYXNzZXMpIHtcbiAgICAgICAgcmV0dXJuIGNsb3NlQW5kUmV0dXJuTm9vcEFuaW1hdG9yKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjYWNoZUtleSwgc3RhZ2dlcjtcbiAgICAgIGlmIChvcHRpb25zLnN0YWdnZXIgPiAwKSB7XG4gICAgICAgIHZhciBzdGFnZ2VyVmFsID0gcGFyc2VGbG9hdChvcHRpb25zLnN0YWdnZXIpO1xuICAgICAgICBzdGFnZ2VyID0ge1xuICAgICAgICAgIHRyYW5zaXRpb25EZWxheTogc3RhZ2dlclZhbCxcbiAgICAgICAgICBhbmltYXRpb25EZWxheTogc3RhZ2dlclZhbCxcbiAgICAgICAgICB0cmFuc2l0aW9uRHVyYXRpb246IDAsXG4gICAgICAgICAgYW5pbWF0aW9uRHVyYXRpb246IDBcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhY2hlS2V5ID0gZ2NzSGFzaEZuKG5vZGUsIGZ1bGxDbGFzc05hbWUpO1xuICAgICAgICBzdGFnZ2VyID0gY29tcHV0ZUNhY2hlZENzc1N0YWdnZXJTdHlsZXMobm9kZSwgcHJlcGFyYXRpb25DbGFzc2VzLCBjYWNoZUtleSwgREVURUNUX1NUQUdHRVJfQ1NTX1BST1BFUlRJRVMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIW9wdGlvbnMuJCRza2lwUHJlcGFyYXRpb25DbGFzc2VzKSB7XG4gICAgICAgICQkanFMaXRlLmFkZENsYXNzKGVsZW1lbnQsIHByZXBhcmF0aW9uQ2xhc3Nlcyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBhcHBseU9ubHlEdXJhdGlvbjtcblxuICAgICAgaWYgKG9wdGlvbnMudHJhbnNpdGlvblN0eWxlKSB7XG4gICAgICAgIHZhciB0cmFuc2l0aW9uU3R5bGUgPSBbVFJBTlNJVElPTl9QUk9QLCBvcHRpb25zLnRyYW5zaXRpb25TdHlsZV07XG4gICAgICAgIGFwcGx5SW5saW5lU3R5bGUobm9kZSwgdHJhbnNpdGlvblN0eWxlKTtcbiAgICAgICAgdGVtcG9yYXJ5U3R5bGVzLnB1c2godHJhbnNpdGlvblN0eWxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMuZHVyYXRpb24gPj0gMCkge1xuICAgICAgICBhcHBseU9ubHlEdXJhdGlvbiA9IG5vZGUuc3R5bGVbVFJBTlNJVElPTl9QUk9QXS5sZW5ndGggPiAwO1xuICAgICAgICB2YXIgZHVyYXRpb25TdHlsZSA9IGdldENzc1RyYW5zaXRpb25EdXJhdGlvblN0eWxlKG9wdGlvbnMuZHVyYXRpb24sIGFwcGx5T25seUR1cmF0aW9uKTtcblxuICAgICAgICAvLyB3ZSBzZXQgdGhlIGR1cmF0aW9uIHNvIHRoYXQgaXQgd2lsbCBiZSBwaWNrZWQgdXAgYnkgZ2V0Q29tcHV0ZWRTdHlsZSBsYXRlclxuICAgICAgICBhcHBseUlubGluZVN0eWxlKG5vZGUsIGR1cmF0aW9uU3R5bGUpO1xuICAgICAgICB0ZW1wb3JhcnlTdHlsZXMucHVzaChkdXJhdGlvblN0eWxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMua2V5ZnJhbWVTdHlsZSkge1xuICAgICAgICB2YXIga2V5ZnJhbWVTdHlsZSA9IFtBTklNQVRJT05fUFJPUCwgb3B0aW9ucy5rZXlmcmFtZVN0eWxlXTtcbiAgICAgICAgYXBwbHlJbmxpbmVTdHlsZShub2RlLCBrZXlmcmFtZVN0eWxlKTtcbiAgICAgICAgdGVtcG9yYXJ5U3R5bGVzLnB1c2goa2V5ZnJhbWVTdHlsZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBpdGVtSW5kZXggPSBzdGFnZ2VyXG4gICAgICAgICAgPyBvcHRpb25zLnN0YWdnZXJJbmRleCA+PSAwXG4gICAgICAgICAgICAgID8gb3B0aW9ucy5zdGFnZ2VySW5kZXhcbiAgICAgICAgICAgICAgOiBnY3NMb29rdXAuY291bnQoY2FjaGVLZXkpXG4gICAgICAgICAgOiAwO1xuXG4gICAgICB2YXIgaXNGaXJzdCA9IGl0ZW1JbmRleCA9PT0gMDtcblxuICAgICAgLy8gdGhpcyBpcyBhIHByZS1lbXB0aXZlIHdheSBvZiBmb3JjaW5nIHRoZSBzZXR1cCBjbGFzc2VzIHRvIGJlIGFkZGVkIGFuZCBhcHBsaWVkIElOU1RBTlRMWVxuICAgICAgLy8gd2l0aG91dCBjYXVzaW5nIGFueSBjb21iaW5hdGlvbiBvZiB0cmFuc2l0aW9ucyB0byBraWNrIGluLiBCeSBhZGRpbmcgYSBuZWdhdGl2ZSBkZWxheSB2YWx1ZVxuICAgICAgLy8gaXQgZm9yY2VzIHRoZSBzZXR1cCBjbGFzcycgdHJhbnNpdGlvbiB0byBlbmQgaW1tZWRpYXRlbHkuIFdlIGxhdGVyIHRoZW4gcmVtb3ZlIHRoZSBuZWdhdGl2ZVxuICAgICAgLy8gdHJhbnNpdGlvbiBkZWxheSB0byBhbGxvdyBmb3IgdGhlIHRyYW5zaXRpb24gdG8gbmF0dXJhbGx5IGRvIGl0J3MgdGhpbmcuIFRoZSBiZWF1dHkgaGVyZSBpc1xuICAgICAgLy8gdGhhdCBpZiB0aGVyZSBpcyBubyB0cmFuc2l0aW9uIGRlZmluZWQgdGhlbiBub3RoaW5nIHdpbGwgaGFwcGVuIGFuZCB0aGlzIHdpbGwgYWxzbyBhbGxvd1xuICAgICAgLy8gb3RoZXIgdHJhbnNpdGlvbnMgdG8gYmUgc3RhY2tlZCBvbiB0b3Agb2YgZWFjaCBvdGhlciB3aXRob3V0IGFueSBjaG9wcGluZyB0aGVtIG91dC5cbiAgICAgIGlmIChpc0ZpcnN0ICYmICFvcHRpb25zLnNraXBCbG9ja2luZykge1xuICAgICAgICBibG9ja1RyYW5zaXRpb25zKG5vZGUsIFNBRkVfRkFTVF9GT1JXQVJEX0RVUkFUSU9OX1ZBTFVFKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRpbWluZ3MgPSBjb21wdXRlVGltaW5ncyhub2RlLCBmdWxsQ2xhc3NOYW1lLCBjYWNoZUtleSk7XG4gICAgICB2YXIgcmVsYXRpdmVEZWxheSA9IHRpbWluZ3MubWF4RGVsYXk7XG4gICAgICBtYXhEZWxheSA9IE1hdGgubWF4KHJlbGF0aXZlRGVsYXksIDApO1xuICAgICAgbWF4RHVyYXRpb24gPSB0aW1pbmdzLm1heER1cmF0aW9uO1xuXG4gICAgICB2YXIgZmxhZ3MgPSB7fTtcbiAgICAgIGZsYWdzLmhhc1RyYW5zaXRpb25zICAgICAgICAgID0gdGltaW5ncy50cmFuc2l0aW9uRHVyYXRpb24gPiAwO1xuICAgICAgZmxhZ3MuaGFzQW5pbWF0aW9ucyAgICAgICAgICAgPSB0aW1pbmdzLmFuaW1hdGlvbkR1cmF0aW9uID4gMDtcbiAgICAgIGZsYWdzLmhhc1RyYW5zaXRpb25BbGwgICAgICAgID0gZmxhZ3MuaGFzVHJhbnNpdGlvbnMgJiYgdGltaW5ncy50cmFuc2l0aW9uUHJvcGVydHkgPT09ICdhbGwnO1xuICAgICAgZmxhZ3MuYXBwbHlUcmFuc2l0aW9uRHVyYXRpb24gPSBoYXNUb1N0eWxlcyAmJiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGZsYWdzLmhhc1RyYW5zaXRpb25zICYmICFmbGFncy5oYXNUcmFuc2l0aW9uQWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCAoZmxhZ3MuaGFzQW5pbWF0aW9ucyAmJiAhZmxhZ3MuaGFzVHJhbnNpdGlvbnMpKTtcbiAgICAgIGZsYWdzLmFwcGx5QW5pbWF0aW9uRHVyYXRpb24gID0gb3B0aW9ucy5kdXJhdGlvbiAmJiBmbGFncy5oYXNBbmltYXRpb25zO1xuICAgICAgZmxhZ3MuYXBwbHlUcmFuc2l0aW9uRGVsYXkgICAgPSB0cnV0aHlUaW1pbmdWYWx1ZShvcHRpb25zLmRlbGF5KSAmJiAoZmxhZ3MuYXBwbHlUcmFuc2l0aW9uRHVyYXRpb24gfHwgZmxhZ3MuaGFzVHJhbnNpdGlvbnMpO1xuICAgICAgZmxhZ3MuYXBwbHlBbmltYXRpb25EZWxheSAgICAgPSB0cnV0aHlUaW1pbmdWYWx1ZShvcHRpb25zLmRlbGF5KSAmJiBmbGFncy5oYXNBbmltYXRpb25zO1xuICAgICAgZmxhZ3MucmVjYWxjdWxhdGVUaW1pbmdTdHlsZXMgPSBhZGRSZW1vdmVDbGFzc05hbWUubGVuZ3RoID4gMDtcblxuICAgICAgaWYgKGZsYWdzLmFwcGx5VHJhbnNpdGlvbkR1cmF0aW9uIHx8IGZsYWdzLmFwcGx5QW5pbWF0aW9uRHVyYXRpb24pIHtcbiAgICAgICAgbWF4RHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uID8gcGFyc2VGbG9hdChvcHRpb25zLmR1cmF0aW9uKSA6IG1heER1cmF0aW9uO1xuXG4gICAgICAgIGlmIChmbGFncy5hcHBseVRyYW5zaXRpb25EdXJhdGlvbikge1xuICAgICAgICAgIGZsYWdzLmhhc1RyYW5zaXRpb25zID0gdHJ1ZTtcbiAgICAgICAgICB0aW1pbmdzLnRyYW5zaXRpb25EdXJhdGlvbiA9IG1heER1cmF0aW9uO1xuICAgICAgICAgIGFwcGx5T25seUR1cmF0aW9uID0gbm9kZS5zdHlsZVtUUkFOU0lUSU9OX1BST1AgKyBQUk9QRVJUWV9LRVldLmxlbmd0aCA+IDA7XG4gICAgICAgICAgdGVtcG9yYXJ5U3R5bGVzLnB1c2goZ2V0Q3NzVHJhbnNpdGlvbkR1cmF0aW9uU3R5bGUobWF4RHVyYXRpb24sIGFwcGx5T25seUR1cmF0aW9uKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmxhZ3MuYXBwbHlBbmltYXRpb25EdXJhdGlvbikge1xuICAgICAgICAgIGZsYWdzLmhhc0FuaW1hdGlvbnMgPSB0cnVlO1xuICAgICAgICAgIHRpbWluZ3MuYW5pbWF0aW9uRHVyYXRpb24gPSBtYXhEdXJhdGlvbjtcbiAgICAgICAgICB0ZW1wb3JhcnlTdHlsZXMucHVzaChnZXRDc3NLZXlmcmFtZUR1cmF0aW9uU3R5bGUobWF4RHVyYXRpb24pKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobWF4RHVyYXRpb24gPT09IDAgJiYgIWZsYWdzLnJlY2FsY3VsYXRlVGltaW5nU3R5bGVzKSB7XG4gICAgICAgIHJldHVybiBjbG9zZUFuZFJldHVybk5vb3BBbmltYXRvcigpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5kZWxheSAhPSBudWxsKSB7XG4gICAgICAgIHZhciBkZWxheVN0eWxlO1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVsYXkgIT09ICdib29sZWFuJykge1xuICAgICAgICAgIGRlbGF5U3R5bGUgPSBwYXJzZUZsb2F0KG9wdGlvbnMuZGVsYXkpO1xuICAgICAgICAgIC8vIG51bWJlciBpbiBvcHRpb25zLmRlbGF5IG1lYW5zIHdlIGhhdmUgdG8gcmVjYWxjdWxhdGUgdGhlIGRlbGF5IGZvciB0aGUgY2xvc2luZyB0aW1lb3V0XG4gICAgICAgICAgbWF4RGVsYXkgPSBNYXRoLm1heChkZWxheVN0eWxlLCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmbGFncy5hcHBseVRyYW5zaXRpb25EZWxheSkge1xuICAgICAgICAgIHRlbXBvcmFyeVN0eWxlcy5wdXNoKGdldENzc0RlbGF5U3R5bGUoZGVsYXlTdHlsZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZsYWdzLmFwcGx5QW5pbWF0aW9uRGVsYXkpIHtcbiAgICAgICAgICB0ZW1wb3JhcnlTdHlsZXMucHVzaChnZXRDc3NEZWxheVN0eWxlKGRlbGF5U3R5bGUsIHRydWUpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyB3ZSBuZWVkIHRvIHJlY2FsY3VsYXRlIHRoZSBkZWxheSB2YWx1ZSBzaW5jZSB3ZSB1c2VkIGEgcHJlLWVtcHRpdmUgbmVnYXRpdmVcbiAgICAgIC8vIGRlbGF5IHZhbHVlIGFuZCB0aGUgZGVsYXkgdmFsdWUgaXMgcmVxdWlyZWQgZm9yIHRoZSBmaW5hbCBldmVudCBjaGVja2luZy4gVGhpc1xuICAgICAgLy8gcHJvcGVydHkgd2lsbCBlbnN1cmUgdGhhdCB0aGlzIHdpbGwgaGFwcGVuIGFmdGVyIHRoZSBSQUYgcGhhc2UgaGFzIHBhc3NlZC5cbiAgICAgIGlmIChvcHRpb25zLmR1cmF0aW9uID09IG51bGwgJiYgdGltaW5ncy50cmFuc2l0aW9uRHVyYXRpb24gPiAwKSB7XG4gICAgICAgIGZsYWdzLnJlY2FsY3VsYXRlVGltaW5nU3R5bGVzID0gZmxhZ3MucmVjYWxjdWxhdGVUaW1pbmdTdHlsZXMgfHwgaXNGaXJzdDtcbiAgICAgIH1cblxuICAgICAgbWF4RGVsYXlUaW1lID0gbWF4RGVsYXkgKiBPTkVfU0VDT05EO1xuICAgICAgbWF4RHVyYXRpb25UaW1lID0gbWF4RHVyYXRpb24gKiBPTkVfU0VDT05EO1xuICAgICAgaWYgKCFvcHRpb25zLnNraXBCbG9ja2luZykge1xuICAgICAgICBmbGFncy5ibG9ja1RyYW5zaXRpb24gPSB0aW1pbmdzLnRyYW5zaXRpb25EdXJhdGlvbiA+IDA7XG4gICAgICAgIGZsYWdzLmJsb2NrS2V5ZnJhbWVBbmltYXRpb24gPSB0aW1pbmdzLmFuaW1hdGlvbkR1cmF0aW9uID4gMCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhZ2dlci5hbmltYXRpb25EZWxheSA+IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWdnZXIuYW5pbWF0aW9uRHVyYXRpb24gPT09IDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmZyb20pIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuY2xlYW51cFN0eWxlcykge1xuICAgICAgICAgIHJlZ2lzdGVyUmVzdG9yYWJsZVN0eWxlcyhyZXN0b3JlU3R5bGVzLCBub2RlLCBPYmplY3Qua2V5cyhvcHRpb25zLmZyb20pKTtcbiAgICAgICAgfVxuICAgICAgICBhcHBseUFuaW1hdGlvbkZyb21TdHlsZXMoZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChmbGFncy5ibG9ja1RyYW5zaXRpb24gfHwgZmxhZ3MuYmxvY2tLZXlmcmFtZUFuaW1hdGlvbikge1xuICAgICAgICBhcHBseUJsb2NraW5nKG1heER1cmF0aW9uKTtcbiAgICAgIH0gZWxzZSBpZiAoIW9wdGlvbnMuc2tpcEJsb2NraW5nKSB7XG4gICAgICAgIGJsb2NrVHJhbnNpdGlvbnMobm9kZSwgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICAvLyBUT0RPKG1hdHNrbyk6IGZvciAxLjUgY2hhbmdlIHRoaXMgY29kZSB0byBoYXZlIGFuIGFuaW1hdG9yIG9iamVjdCBmb3IgYmV0dGVyIGRlYnVnZ2luZ1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJCR3aWxsQW5pbWF0ZTogdHJ1ZSxcbiAgICAgICAgZW5kOiBlbmRGbixcbiAgICAgICAgc3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmIChhbmltYXRpb25DbG9zZWQpIHJldHVybjtcblxuICAgICAgICAgIHJ1bm5lckhvc3QgPSB7XG4gICAgICAgICAgICBlbmQ6IGVuZEZuLFxuICAgICAgICAgICAgY2FuY2VsOiBjYW5jZWxGbixcbiAgICAgICAgICAgIHJlc3VtZTogbnVsbCwgLy90aGlzIHdpbGwgYmUgc2V0IGR1cmluZyB0aGUgc3RhcnQoKSBwaGFzZVxuICAgICAgICAgICAgcGF1c2U6IG51bGxcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgcnVubmVyID0gbmV3ICQkQW5pbWF0ZVJ1bm5lcihydW5uZXJIb3N0KTtcblxuICAgICAgICAgIHdhaXRVbnRpbFF1aWV0KHN0YXJ0KTtcblxuICAgICAgICAgIC8vIHdlIGRvbid0IGhhdmUgYWNjZXNzIHRvIHBhdXNlL3Jlc3VtZSB0aGUgYW5pbWF0aW9uXG4gICAgICAgICAgLy8gc2luY2UgaXQgaGFzbid0IHJ1biB5ZXQuIEFuaW1hdGVSdW5uZXIgd2lsbCB0aGVyZWZvcmVcbiAgICAgICAgICAvLyBzZXQgbm9vcCBmdW5jdGlvbnMgZm9yIHJlc3VtZSBhbmQgcGF1c2UgYW5kIHRoZXkgd2lsbFxuICAgICAgICAgIC8vIGxhdGVyIGJlIG92ZXJyaWRkZW4gb25jZSB0aGUgYW5pbWF0aW9uIGlzIHRyaWdnZXJlZFxuICAgICAgICAgIHJldHVybiBydW5uZXI7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGZ1bmN0aW9uIGVuZEZuKCkge1xuICAgICAgICBjbG9zZSgpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjYW5jZWxGbigpIHtcbiAgICAgICAgY2xvc2UodHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNsb3NlKHJlamVjdGVkKSB7XG4gICAgICAgIC8vIGlmIHRoZSBwcm9taXNlIGhhcyBiZWVuIGNhbGxlZCBhbHJlYWR5IHRoZW4gd2Ugc2hvdWxkbid0IGNsb3NlXG4gICAgICAgIC8vIHRoZSBhbmltYXRpb24gYWdhaW5cbiAgICAgICAgaWYgKGFuaW1hdGlvbkNsb3NlZCB8fCAoYW5pbWF0aW9uQ29tcGxldGVkICYmIGFuaW1hdGlvblBhdXNlZCkpIHJldHVybjtcbiAgICAgICAgYW5pbWF0aW9uQ2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgYW5pbWF0aW9uUGF1c2VkID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKCFvcHRpb25zLiQkc2tpcFByZXBhcmF0aW9uQ2xhc3Nlcykge1xuICAgICAgICAgICQkanFMaXRlLnJlbW92ZUNsYXNzKGVsZW1lbnQsIHByZXBhcmF0aW9uQ2xhc3Nlcyk7XG4gICAgICAgIH1cbiAgICAgICAgJCRqcUxpdGUucmVtb3ZlQ2xhc3MoZWxlbWVudCwgYWN0aXZlQ2xhc3Nlcyk7XG5cbiAgICAgICAgYmxvY2tLZXlmcmFtZUFuaW1hdGlvbnMobm9kZSwgZmFsc2UpO1xuICAgICAgICBibG9ja1RyYW5zaXRpb25zKG5vZGUsIGZhbHNlKTtcblxuICAgICAgICBmb3JFYWNoKHRlbXBvcmFyeVN0eWxlcywgZnVuY3Rpb24oZW50cnkpIHtcbiAgICAgICAgICAvLyBUaGVyZSBpcyBvbmx5IG9uZSB3YXkgdG8gcmVtb3ZlIGlubGluZSBzdHlsZSBwcm9wZXJ0aWVzIGVudGlyZWx5IGZyb20gZWxlbWVudHMuXG4gICAgICAgICAgLy8gQnkgdXNpbmcgYHJlbW92ZVByb3BlcnR5YCB0aGlzIHdvcmtzLCBidXQgd2UgbmVlZCB0byBjb252ZXJ0IGNhbWVsLWNhc2VkIENTU1xuICAgICAgICAgIC8vIHN0eWxlcyBkb3duIHRvIGh5cGhlbmF0ZWQgdmFsdWVzLlxuICAgICAgICAgIG5vZGUuc3R5bGVbZW50cnlbMF1dID0gJyc7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGFwcGx5QW5pbWF0aW9uQ2xhc3NlcyhlbGVtZW50LCBvcHRpb25zKTtcbiAgICAgICAgYXBwbHlBbmltYXRpb25TdHlsZXMoZWxlbWVudCwgb3B0aW9ucyk7XG5cbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHJlc3RvcmVTdHlsZXMpLmxlbmd0aCkge1xuICAgICAgICAgIGZvckVhY2gocmVzdG9yZVN0eWxlcywgZnVuY3Rpb24odmFsdWUsIHByb3ApIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICBub2RlLnN0eWxlLnNldFByb3BlcnR5KHByb3AsIHZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5vZGUuc3R5bGUucmVtb3ZlUHJvcGVydHkocHJvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aGUgcmVhc29uIHdoeSB3ZSBoYXZlIHRoaXMgb3B0aW9uIGlzIHRvIGFsbG93IGEgc3luY2hyb25vdXMgY2xvc2luZyBjYWxsYmFja1xuICAgICAgICAvLyB0aGF0IGlzIGZpcmVkIGFzIFNPT04gYXMgdGhlIGFuaW1hdGlvbiBlbmRzICh3aGVuIHRoZSBDU1MgaXMgcmVtb3ZlZCkgb3IgaWZcbiAgICAgICAgLy8gdGhlIGFuaW1hdGlvbiBuZXZlciB0YWtlcyBvZmYgYXQgYWxsLiBBIGdvb2QgZXhhbXBsZSBpcyBhIGxlYXZlIGFuaW1hdGlvbiBzaW5jZVxuICAgICAgICAvLyB0aGUgZWxlbWVudCBtdXN0IGJlIHJlbW92ZWQganVzdCBhZnRlciB0aGUgYW5pbWF0aW9uIGlzIG92ZXIgb3IgZWxzZSB0aGUgZWxlbWVudFxuICAgICAgICAvLyB3aWxsIGFwcGVhciBvbiBzY3JlZW4gZm9yIG9uZSBhbmltYXRpb24gZnJhbWUgY2F1c2luZyBhbiBvdmVyYmVhcmluZyBmbGlja2VyLlxuICAgICAgICBpZiAob3B0aW9ucy5vbkRvbmUpIHtcbiAgICAgICAgICBvcHRpb25zLm9uRG9uZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50cyAmJiBldmVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgLy8gUmVtb3ZlIHRoZSB0cmFuc2l0aW9uZW5kIC8gYW5pbWF0aW9uZW5kIGxpc3RlbmVyKHMpXG4gICAgICAgICAgZWxlbWVudC5vZmYoZXZlbnRzLmpvaW4oJyAnKSwgb25BbmltYXRpb25Qcm9ncmVzcyk7XG4gICAgICAgIH1cblxuICAgICAgICAvL0NhbmNlbCB0aGUgZmFsbGJhY2sgY2xvc2luZyB0aW1lb3V0IGFuZCByZW1vdmUgdGhlIHRpbWVyIGRhdGFcbiAgICAgICAgdmFyIGFuaW1hdGlvblRpbWVyRGF0YSA9IGVsZW1lbnQuZGF0YShBTklNQVRFX1RJTUVSX0tFWSk7XG4gICAgICAgIGlmIChhbmltYXRpb25UaW1lckRhdGEpIHtcbiAgICAgICAgICAkdGltZW91dC5jYW5jZWwoYW5pbWF0aW9uVGltZXJEYXRhWzBdLnRpbWVyKTtcbiAgICAgICAgICBlbGVtZW50LnJlbW92ZURhdGEoQU5JTUFURV9USU1FUl9LRVkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdGhlIHByZXBhcmF0aW9uIGZ1bmN0aW9uIGZhaWxzIHRoZW4gdGhlIHByb21pc2UgaXMgbm90IHNldHVwXG4gICAgICAgIGlmIChydW5uZXIpIHtcbiAgICAgICAgICBydW5uZXIuY29tcGxldGUoIXJlamVjdGVkKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBhcHBseUJsb2NraW5nKGR1cmF0aW9uKSB7XG4gICAgICAgIGlmIChmbGFncy5ibG9ja1RyYW5zaXRpb24pIHtcbiAgICAgICAgICBibG9ja1RyYW5zaXRpb25zKG5vZGUsIGR1cmF0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmbGFncy5ibG9ja0tleWZyYW1lQW5pbWF0aW9uKSB7XG4gICAgICAgICAgYmxvY2tLZXlmcmFtZUFuaW1hdGlvbnMobm9kZSwgISFkdXJhdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY2xvc2VBbmRSZXR1cm5Ob29wQW5pbWF0b3IoKSB7XG4gICAgICAgIHJ1bm5lciA9IG5ldyAkJEFuaW1hdGVSdW5uZXIoe1xuICAgICAgICAgIGVuZDogZW5kRm4sXG4gICAgICAgICAgY2FuY2VsOiBjYW5jZWxGblxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBzaG91bGQgZmx1c2ggdGhlIGNhY2hlIGFuaW1hdGlvblxuICAgICAgICB3YWl0VW50aWxRdWlldChub29wKTtcbiAgICAgICAgY2xvc2UoKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICQkd2lsbEFuaW1hdGU6IGZhbHNlLFxuICAgICAgICAgIHN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBydW5uZXI7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbmQ6IGVuZEZuXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIG9uQW5pbWF0aW9uUHJvZ3Jlc3MoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHZhciBldiA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQgfHwgZXZlbnQ7XG5cbiAgICAgICAgaWYgKGV2LnRhcmdldCAhPT0gbm9kZSkge1xuICAgICAgICAgIC8vIFNpbmNlIFRyYW5zaXRpb25FdmVudCAvIEFuaW1hdGlvbkV2ZW50IGJ1YmJsZSB1cCxcbiAgICAgICAgICAvLyB3ZSBoYXZlIHRvIGlnbm9yZSBldmVudHMgYnkgZmluaXNoZWQgY2hpbGQgYW5pbWF0aW9uc1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHdlIG5vdyBhbHdheXMgdXNlIGBEYXRlLm5vdygpYCBkdWUgdG8gdGhlIHJlY2VudCBjaGFuZ2VzIHdpdGhcbiAgICAgICAgLy8gZXZlbnQudGltZVN0YW1wIGluIEZpcmVmb3gsIFdlYmtpdCBhbmQgQ2hyb21lIChzZWUgIzEzNDk0IGZvciBtb3JlIGluZm8pXG4gICAgICAgIHZhciB0aW1lU3RhbXAgPSBldi4kbWFudWFsVGltZVN0YW1wIHx8IERhdGUubm93KCk7XG5cbiAgICAgICAgLyogRmlyZWZveCAob3IgcG9zc2libHkganVzdCBHZWNrbykgbGlrZXMgdG8gbm90IHJvdW5kIHZhbHVlcyB1cFxuICAgICAgICAgKiB3aGVuIGEgbXMgbWVhc3VyZW1lbnQgaXMgdXNlZCBmb3IgdGhlIGFuaW1hdGlvbiAqL1xuICAgICAgICB2YXIgZWxhcHNlZFRpbWUgPSBwYXJzZUZsb2F0KGV2LmVsYXBzZWRUaW1lLnRvRml4ZWQoRUxBUFNFRF9USU1FX01BWF9ERUNJTUFMX1BMQUNFUykpO1xuXG4gICAgICAgIC8qICRtYW51YWxUaW1lU3RhbXAgaXMgYSBtb2NrZWQgdGltZVN0YW1wIHZhbHVlIHdoaWNoIGlzIHNldFxuICAgICAgICAgKiB3aXRoaW4gYnJvd3NlclRyaWdnZXIoKS4gVGhpcyBpcyBvbmx5IGhlcmUgc28gdGhhdCB0ZXN0cyBjYW5cbiAgICAgICAgICogbW9jayBhbmltYXRpb25zIHByb3Blcmx5LiBSZWFsIGV2ZW50cyBmYWxsYmFjayB0byBldmVudC50aW1lU3RhbXAsXG4gICAgICAgICAqIG9yLCBpZiB0aGV5IGRvbid0LCB0aGVuIGEgdGltZVN0YW1wIGlzIGF1dG9tYXRpY2FsbHkgY3JlYXRlZCBmb3IgdGhlbS5cbiAgICAgICAgICogV2UncmUgY2hlY2tpbmcgdG8gc2VlIGlmIHRoZSB0aW1lU3RhbXAgc3VycGFzc2VzIHRoZSBleHBlY3RlZCBkZWxheSxcbiAgICAgICAgICogYnV0IHdlJ3JlIHVzaW5nIGVsYXBzZWRUaW1lIGluc3RlYWQgb2YgdGhlIHRpbWVTdGFtcCBvbiB0aGUgMm5kXG4gICAgICAgICAqIHByZS1jb25kaXRpb24gc2luY2UgYW5pbWF0aW9uUGF1c2VkcyBzb21ldGltZXMgY2xvc2Ugb2ZmIGVhcmx5ICovXG4gICAgICAgIGlmIChNYXRoLm1heCh0aW1lU3RhbXAgLSBzdGFydFRpbWUsIDApID49IG1heERlbGF5VGltZSAmJiBlbGFwc2VkVGltZSA+PSBtYXhEdXJhdGlvbikge1xuICAgICAgICAgIC8vIHdlIHNldCB0aGlzIGZsYWcgdG8gZW5zdXJlIHRoYXQgaWYgdGhlIHRyYW5zaXRpb24gaXMgcGF1c2VkIHRoZW4sIHdoZW4gcmVzdW1lZCxcbiAgICAgICAgICAvLyB0aGUgYW5pbWF0aW9uIHdpbGwgYXV0b21hdGljYWxseSBjbG9zZSBpdHNlbGYgc2luY2UgdHJhbnNpdGlvbnMgY2Fubm90IGJlIHBhdXNlZC5cbiAgICAgICAgICBhbmltYXRpb25Db21wbGV0ZWQgPSB0cnVlO1xuICAgICAgICAgIGNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gc3RhcnQoKSB7XG4gICAgICAgIGlmIChhbmltYXRpb25DbG9zZWQpIHJldHVybjtcbiAgICAgICAgaWYgKCFub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGV2ZW4gdGhvdWdoIHdlIG9ubHkgcGF1c2Uga2V5ZnJhbWUgYW5pbWF0aW9ucyBoZXJlIHRoZSBwYXVzZSBmbGFnXG4gICAgICAgIC8vIHdpbGwgc3RpbGwgaGFwcGVuIHdoZW4gdHJhbnNpdGlvbnMgYXJlIHVzZWQuIE9ubHkgdGhlIHRyYW5zaXRpb24gd2lsbFxuICAgICAgICAvLyBub3QgYmUgcGF1c2VkIHNpbmNlIHRoYXQgaXMgbm90IHBvc3NpYmxlLiBJZiB0aGUgYW5pbWF0aW9uIGVuZHMgd2hlblxuICAgICAgICAvLyBwYXVzZWQgdGhlbiBpdCB3aWxsIG5vdCBjb21wbGV0ZSB1bnRpbCB1bnBhdXNlZCBvciBjYW5jZWxsZWQuXG4gICAgICAgIHZhciBwbGF5UGF1c2UgPSBmdW5jdGlvbihwbGF5QW5pbWF0aW9uKSB7XG4gICAgICAgICAgaWYgKCFhbmltYXRpb25Db21wbGV0ZWQpIHtcbiAgICAgICAgICAgIGFuaW1hdGlvblBhdXNlZCA9ICFwbGF5QW5pbWF0aW9uO1xuICAgICAgICAgICAgaWYgKHRpbWluZ3MuYW5pbWF0aW9uRHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYmxvY2tLZXlmcmFtZUFuaW1hdGlvbnMobm9kZSwgYW5pbWF0aW9uUGF1c2VkKTtcbiAgICAgICAgICAgICAgaWYgKGFuaW1hdGlvblBhdXNlZCkge1xuICAgICAgICAgICAgICAgIHRlbXBvcmFyeVN0eWxlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZW1vdmVGcm9tQXJyYXkodGVtcG9yYXJ5U3R5bGVzLCB2YWx1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGFuaW1hdGlvblBhdXNlZCAmJiBwbGF5QW5pbWF0aW9uKSB7XG4gICAgICAgICAgICBhbmltYXRpb25QYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGNsb3NlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIGNoZWNraW5nIHRoZSBzdGFnZ2VyIGR1cmF0aW9uIHByZXZlbnRzIGFuIGFjY2lkZW50YWxseSBjYXNjYWRlIG9mIHRoZSBDU1MgZGVsYXkgc3R5bGVcbiAgICAgICAgLy8gYmVpbmcgaW5oZXJpdGVkIGZyb20gdGhlIHBhcmVudC4gSWYgdGhlIHRyYW5zaXRpb24gZHVyYXRpb24gaXMgemVybyB0aGVuIHdlIGNhbiBzYWZlbHlcbiAgICAgICAgLy8gcmVseSB0aGF0IHRoZSBkZWxheSB2YWx1ZSBpcyBhbiBpbnRlbnRpb25hbCBzdGFnZ2VyIGRlbGF5IHN0eWxlLlxuICAgICAgICB2YXIgbWF4U3RhZ2dlciA9IGl0ZW1JbmRleCA+IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAmJiAoKHRpbWluZ3MudHJhbnNpdGlvbkR1cmF0aW9uICYmIHN0YWdnZXIudHJhbnNpdGlvbkR1cmF0aW9uID09PSAwKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0aW1pbmdzLmFuaW1hdGlvbkR1cmF0aW9uICYmIHN0YWdnZXIuYW5pbWF0aW9uRHVyYXRpb24gPT09IDApKVxuICAgICAgICAgICAgICAgICAgICAgICAgICYmIE1hdGgubWF4KHN0YWdnZXIuYW5pbWF0aW9uRGVsYXksIHN0YWdnZXIudHJhbnNpdGlvbkRlbGF5KTtcbiAgICAgICAgaWYgKG1heFN0YWdnZXIpIHtcbiAgICAgICAgICAkdGltZW91dCh0cmlnZ2VyQW5pbWF0aW9uU3RhcnQsXG4gICAgICAgICAgICAgICAgICAgTWF0aC5mbG9vcihtYXhTdGFnZ2VyICogaXRlbUluZGV4ICogT05FX1NFQ09ORCksXG4gICAgICAgICAgICAgICAgICAgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyaWdnZXJBbmltYXRpb25TdGFydCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGhpcyB3aWxsIGRlY29yYXRlIHRoZSBleGlzdGluZyBwcm9taXNlIHJ1bm5lciB3aXRoIHBhdXNlL3Jlc3VtZSBtZXRob2RzXG4gICAgICAgIHJ1bm5lckhvc3QucmVzdW1lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcGxheVBhdXNlKHRydWUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJ1bm5lckhvc3QucGF1c2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBwbGF5UGF1c2UoZmFsc2UpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZ1bmN0aW9uIHRyaWdnZXJBbmltYXRpb25TdGFydCgpIHtcbiAgICAgICAgICAvLyBqdXN0IGluY2FzZSBhIHN0YWdnZXIgYW5pbWF0aW9uIGtpY2tzIGluIHdoZW4gdGhlIGFuaW1hdGlvblxuICAgICAgICAgIC8vIGl0c2VsZiB3YXMgY2FuY2VsbGVkIGVudGlyZWx5XG4gICAgICAgICAgaWYgKGFuaW1hdGlvbkNsb3NlZCkgcmV0dXJuO1xuXG4gICAgICAgICAgYXBwbHlCbG9ja2luZyhmYWxzZSk7XG5cbiAgICAgICAgICBmb3JFYWNoKHRlbXBvcmFyeVN0eWxlcywgZnVuY3Rpb24oZW50cnkpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBlbnRyeVswXTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGVudHJ5WzFdO1xuICAgICAgICAgICAgbm9kZS5zdHlsZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBhcHBseUFuaW1hdGlvbkNsYXNzZXMoZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgICAgICAgJCRqcUxpdGUuYWRkQ2xhc3MoZWxlbWVudCwgYWN0aXZlQ2xhc3Nlcyk7XG5cbiAgICAgICAgICBpZiAoZmxhZ3MucmVjYWxjdWxhdGVUaW1pbmdTdHlsZXMpIHtcbiAgICAgICAgICAgIGZ1bGxDbGFzc05hbWUgPSBub2RlLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSArICcgJyArIHByZXBhcmF0aW9uQ2xhc3NlcztcbiAgICAgICAgICAgIGNhY2hlS2V5ID0gZ2NzSGFzaEZuKG5vZGUsIGZ1bGxDbGFzc05hbWUpO1xuXG4gICAgICAgICAgICB0aW1pbmdzID0gY29tcHV0ZVRpbWluZ3Mobm9kZSwgZnVsbENsYXNzTmFtZSwgY2FjaGVLZXkpO1xuICAgICAgICAgICAgcmVsYXRpdmVEZWxheSA9IHRpbWluZ3MubWF4RGVsYXk7XG4gICAgICAgICAgICBtYXhEZWxheSA9IE1hdGgubWF4KHJlbGF0aXZlRGVsYXksIDApO1xuICAgICAgICAgICAgbWF4RHVyYXRpb24gPSB0aW1pbmdzLm1heER1cmF0aW9uO1xuXG4gICAgICAgICAgICBpZiAobWF4RHVyYXRpb24gPT09IDApIHtcbiAgICAgICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmbGFncy5oYXNUcmFuc2l0aW9ucyA9IHRpbWluZ3MudHJhbnNpdGlvbkR1cmF0aW9uID4gMDtcbiAgICAgICAgICAgIGZsYWdzLmhhc0FuaW1hdGlvbnMgPSB0aW1pbmdzLmFuaW1hdGlvbkR1cmF0aW9uID4gMDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZmxhZ3MuYXBwbHlBbmltYXRpb25EZWxheSkge1xuICAgICAgICAgICAgcmVsYXRpdmVEZWxheSA9IHR5cGVvZiBvcHRpb25zLmRlbGF5ICE9PSAnYm9vbGVhbicgJiYgdHJ1dGh5VGltaW5nVmFsdWUob3B0aW9ucy5kZWxheSlcbiAgICAgICAgICAgICAgICAgID8gcGFyc2VGbG9hdChvcHRpb25zLmRlbGF5KVxuICAgICAgICAgICAgICAgICAgOiByZWxhdGl2ZURlbGF5O1xuXG4gICAgICAgICAgICBtYXhEZWxheSA9IE1hdGgubWF4KHJlbGF0aXZlRGVsYXksIDApO1xuICAgICAgICAgICAgdGltaW5ncy5hbmltYXRpb25EZWxheSA9IHJlbGF0aXZlRGVsYXk7XG4gICAgICAgICAgICBkZWxheVN0eWxlID0gZ2V0Q3NzRGVsYXlTdHlsZShyZWxhdGl2ZURlbGF5LCB0cnVlKTtcbiAgICAgICAgICAgIHRlbXBvcmFyeVN0eWxlcy5wdXNoKGRlbGF5U3R5bGUpO1xuICAgICAgICAgICAgbm9kZS5zdHlsZVtkZWxheVN0eWxlWzBdXSA9IGRlbGF5U3R5bGVbMV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbWF4RGVsYXlUaW1lID0gbWF4RGVsYXkgKiBPTkVfU0VDT05EO1xuICAgICAgICAgIG1heER1cmF0aW9uVGltZSA9IG1heER1cmF0aW9uICogT05FX1NFQ09ORDtcblxuICAgICAgICAgIGlmIChvcHRpb25zLmVhc2luZykge1xuICAgICAgICAgICAgdmFyIGVhc2VQcm9wLCBlYXNlVmFsID0gb3B0aW9ucy5lYXNpbmc7XG4gICAgICAgICAgICBpZiAoZmxhZ3MuaGFzVHJhbnNpdGlvbnMpIHtcbiAgICAgICAgICAgICAgZWFzZVByb3AgPSBUUkFOU0lUSU9OX1BST1AgKyBUSU1JTkdfS0VZO1xuICAgICAgICAgICAgICB0ZW1wb3JhcnlTdHlsZXMucHVzaChbZWFzZVByb3AsIGVhc2VWYWxdKTtcbiAgICAgICAgICAgICAgbm9kZS5zdHlsZVtlYXNlUHJvcF0gPSBlYXNlVmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZsYWdzLmhhc0FuaW1hdGlvbnMpIHtcbiAgICAgICAgICAgICAgZWFzZVByb3AgPSBBTklNQVRJT05fUFJPUCArIFRJTUlOR19LRVk7XG4gICAgICAgICAgICAgIHRlbXBvcmFyeVN0eWxlcy5wdXNoKFtlYXNlUHJvcCwgZWFzZVZhbF0pO1xuICAgICAgICAgICAgICBub2RlLnN0eWxlW2Vhc2VQcm9wXSA9IGVhc2VWYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRpbWluZ3MudHJhbnNpdGlvbkR1cmF0aW9uKSB7XG4gICAgICAgICAgICBldmVudHMucHVzaChUUkFOU0lUSU9ORU5EX0VWRU5UKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodGltaW5ncy5hbmltYXRpb25EdXJhdGlvbikge1xuICAgICAgICAgICAgZXZlbnRzLnB1c2goQU5JTUFUSU9ORU5EX0VWRU5UKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgIHZhciB0aW1lclRpbWUgPSBtYXhEZWxheVRpbWUgKyBDTE9TSU5HX1RJTUVfQlVGRkVSICogbWF4RHVyYXRpb25UaW1lO1xuICAgICAgICAgIHZhciBlbmRUaW1lID0gc3RhcnRUaW1lICsgdGltZXJUaW1lO1xuXG4gICAgICAgICAgdmFyIGFuaW1hdGlvbnNEYXRhID0gZWxlbWVudC5kYXRhKEFOSU1BVEVfVElNRVJfS0VZKSB8fCBbXTtcbiAgICAgICAgICB2YXIgc2V0dXBGYWxsYmFja1RpbWVyID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoYW5pbWF0aW9uc0RhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudFRpbWVyRGF0YSA9IGFuaW1hdGlvbnNEYXRhWzBdO1xuICAgICAgICAgICAgc2V0dXBGYWxsYmFja1RpbWVyID0gZW5kVGltZSA+IGN1cnJlbnRUaW1lckRhdGEuZXhwZWN0ZWRFbmRUaW1lO1xuICAgICAgICAgICAgaWYgKHNldHVwRmFsbGJhY2tUaW1lcikge1xuICAgICAgICAgICAgICAkdGltZW91dC5jYW5jZWwoY3VycmVudFRpbWVyRGF0YS50aW1lcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhbmltYXRpb25zRGF0YS5wdXNoKGNsb3NlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2V0dXBGYWxsYmFja1RpbWVyKSB7XG4gICAgICAgICAgICB2YXIgdGltZXIgPSAkdGltZW91dChvbkFuaW1hdGlvbkV4cGlyZWQsIHRpbWVyVGltZSwgZmFsc2UpO1xuICAgICAgICAgICAgYW5pbWF0aW9uc0RhdGFbMF0gPSB7XG4gICAgICAgICAgICAgIHRpbWVyOiB0aW1lcixcbiAgICAgICAgICAgICAgZXhwZWN0ZWRFbmRUaW1lOiBlbmRUaW1lXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYW5pbWF0aW9uc0RhdGEucHVzaChjbG9zZSk7XG4gICAgICAgICAgICBlbGVtZW50LmRhdGEoQU5JTUFURV9USU1FUl9LRVksIGFuaW1hdGlvbnNEYXRhKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZXZlbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgZWxlbWVudC5vbihldmVudHMuam9pbignICcpLCBvbkFuaW1hdGlvblByb2dyZXNzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob3B0aW9ucy50bykge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuY2xlYW51cFN0eWxlcykge1xuICAgICAgICAgICAgICByZWdpc3RlclJlc3RvcmFibGVTdHlsZXMocmVzdG9yZVN0eWxlcywgbm9kZSwgT2JqZWN0LmtleXMob3B0aW9ucy50bykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXBwbHlBbmltYXRpb25Ub1N0eWxlcyhlbGVtZW50LCBvcHRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBvbkFuaW1hdGlvbkV4cGlyZWQoKSB7XG4gICAgICAgICAgdmFyIGFuaW1hdGlvbnNEYXRhID0gZWxlbWVudC5kYXRhKEFOSU1BVEVfVElNRVJfS0VZKTtcblxuICAgICAgICAgIC8vIHRoaXMgd2lsbCBiZSBmYWxzZSBpbiB0aGUgZXZlbnQgdGhhdCB0aGUgZWxlbWVudCB3YXNcbiAgICAgICAgICAvLyByZW1vdmVkIGZyb20gdGhlIERPTSAodmlhIGEgbGVhdmUgYW5pbWF0aW9uIG9yIHNvbWV0aGluZ1xuICAgICAgICAgIC8vIHNpbWlsYXIpXG4gICAgICAgICAgaWYgKGFuaW1hdGlvbnNEYXRhKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFuaW1hdGlvbnNEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGFuaW1hdGlvbnNEYXRhW2ldKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbGVtZW50LnJlbW92ZURhdGEoQU5JTUFURV9USU1FUl9LRVkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1dO1xufV07XG5cbnZhciAkJEFuaW1hdGVDc3NEcml2ZXJQcm92aWRlciA9IFsnJCRhbmltYXRpb25Qcm92aWRlcicsIC8qKiBAdGhpcyAqLyBmdW5jdGlvbigkJGFuaW1hdGlvblByb3ZpZGVyKSB7XG4gICQkYW5pbWF0aW9uUHJvdmlkZXIuZHJpdmVycy5wdXNoKCckJGFuaW1hdGVDc3NEcml2ZXInKTtcblxuICB2YXIgTkdfQU5JTUFURV9TSElNX0NMQVNTX05BTUUgPSAnbmctYW5pbWF0ZS1zaGltJztcbiAgdmFyIE5HX0FOSU1BVEVfQU5DSE9SX0NMQVNTX05BTUUgPSAnbmctYW5jaG9yJztcblxuICB2YXIgTkdfT1VUX0FOQ0hPUl9DTEFTU19OQU1FID0gJ25nLWFuY2hvci1vdXQnO1xuICB2YXIgTkdfSU5fQU5DSE9SX0NMQVNTX05BTUUgPSAnbmctYW5jaG9yLWluJztcblxuICBmdW5jdGlvbiBpc0RvY3VtZW50RnJhZ21lbnQobm9kZSkge1xuICAgIHJldHVybiBub2RlLnBhcmVudE5vZGUgJiYgbm9kZS5wYXJlbnROb2RlLm5vZGVUeXBlID09PSAxMTtcbiAgfVxuXG4gIHRoaXMuJGdldCA9IFsnJGFuaW1hdGVDc3MnLCAnJHJvb3RTY29wZScsICckJEFuaW1hdGVSdW5uZXInLCAnJHJvb3RFbGVtZW50JywgJyRzbmlmZmVyJywgJyQkanFMaXRlJywgJyRkb2N1bWVudCcsXG4gICAgICAgZnVuY3Rpb24oJGFuaW1hdGVDc3MsICAgJHJvb3RTY29wZSwgICAkJEFuaW1hdGVSdW5uZXIsICAgJHJvb3RFbGVtZW50LCAgICRzbmlmZmVyLCAgICQkanFMaXRlLCAgICRkb2N1bWVudCkge1xuXG4gICAgLy8gb25seSBicm93c2VycyB0aGF0IHN1cHBvcnQgdGhlc2UgcHJvcGVydGllcyBjYW4gcmVuZGVyIGFuaW1hdGlvbnNcbiAgICBpZiAoISRzbmlmZmVyLmFuaW1hdGlvbnMgJiYgISRzbmlmZmVyLnRyYW5zaXRpb25zKSByZXR1cm4gbm9vcDtcblxuICAgIHZhciBib2R5Tm9kZSA9ICRkb2N1bWVudFswXS5ib2R5O1xuICAgIHZhciByb290Tm9kZSA9IGdldERvbU5vZGUoJHJvb3RFbGVtZW50KTtcblxuICAgIHZhciByb290Qm9keUVsZW1lbnQgPSBqcUxpdGUoXG4gICAgICAvLyB0aGlzIGlzIHRvIGF2b2lkIHVzaW5nIHNvbWV0aGluZyB0aGF0IGV4aXN0cyBvdXRzaWRlIG9mIHRoZSBib2R5XG4gICAgICAvLyB3ZSBhbHNvIHNwZWNpYWwgY2FzZSB0aGUgZG9jIGZyYWdtZW50IGNhc2UgYmVjYXVzZSBvdXIgdW5pdCB0ZXN0IGNvZGVcbiAgICAgIC8vIGFwcGVuZHMgdGhlICRyb290RWxlbWVudCB0byB0aGUgYm9keSBhZnRlciB0aGUgYXBwIGhhcyBiZWVuIGJvb3RzdHJhcHBlZFxuICAgICAgaXNEb2N1bWVudEZyYWdtZW50KHJvb3ROb2RlKSB8fCBib2R5Tm9kZS5jb250YWlucyhyb290Tm9kZSkgPyByb290Tm9kZSA6IGJvZHlOb2RlXG4gICAgKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiBpbml0RHJpdmVyRm4oYW5pbWF0aW9uRGV0YWlscykge1xuICAgICAgcmV0dXJuIGFuaW1hdGlvbkRldGFpbHMuZnJvbSAmJiBhbmltYXRpb25EZXRhaWxzLnRvXG4gICAgICAgICAgPyBwcmVwYXJlRnJvbVRvQW5jaG9yQW5pbWF0aW9uKGFuaW1hdGlvbkRldGFpbHMuZnJvbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uRGV0YWlscy50byxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uRGV0YWlscy5jbGFzc2VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25EZXRhaWxzLmFuY2hvcnMpXG4gICAgICAgICAgOiBwcmVwYXJlUmVndWxhckFuaW1hdGlvbihhbmltYXRpb25EZXRhaWxzKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZmlsdGVyQ3NzQ2xhc3NlcyhjbGFzc2VzKSB7XG4gICAgICAvL3JlbW92ZSBhbGwgdGhlIGBuZy1gIHN0dWZmXG4gICAgICByZXR1cm4gY2xhc3Nlcy5yZXBsYWNlKC9cXGJuZy1cXFMrXFxiL2csICcnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRVbmlxdWVWYWx1ZXMoYSwgYikge1xuICAgICAgaWYgKGlzU3RyaW5nKGEpKSBhID0gYS5zcGxpdCgnICcpO1xuICAgICAgaWYgKGlzU3RyaW5nKGIpKSBiID0gYi5zcGxpdCgnICcpO1xuICAgICAgcmV0dXJuIGEuZmlsdGVyKGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICByZXR1cm4gYi5pbmRleE9mKHZhbCkgPT09IC0xO1xuICAgICAgfSkuam9pbignICcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByZXBhcmVBbmNob3JlZEFuaW1hdGlvbihjbGFzc2VzLCBvdXRBbmNob3IsIGluQW5jaG9yKSB7XG4gICAgICB2YXIgY2xvbmUgPSBqcUxpdGUoZ2V0RG9tTm9kZShvdXRBbmNob3IpLmNsb25lTm9kZSh0cnVlKSk7XG4gICAgICB2YXIgc3RhcnRpbmdDbGFzc2VzID0gZmlsdGVyQ3NzQ2xhc3NlcyhnZXRDbGFzc1ZhbChjbG9uZSkpO1xuXG4gICAgICBvdXRBbmNob3IuYWRkQ2xhc3MoTkdfQU5JTUFURV9TSElNX0NMQVNTX05BTUUpO1xuICAgICAgaW5BbmNob3IuYWRkQ2xhc3MoTkdfQU5JTUFURV9TSElNX0NMQVNTX05BTUUpO1xuXG4gICAgICBjbG9uZS5hZGRDbGFzcyhOR19BTklNQVRFX0FOQ0hPUl9DTEFTU19OQU1FKTtcblxuICAgICAgcm9vdEJvZHlFbGVtZW50LmFwcGVuZChjbG9uZSk7XG5cbiAgICAgIHZhciBhbmltYXRvckluLCBhbmltYXRvck91dCA9IHByZXBhcmVPdXRBbmltYXRpb24oKTtcblxuICAgICAgLy8gdGhlIHVzZXIgbWF5IG5vdCBlbmQgdXAgdXNpbmcgdGhlIGBvdXRgIGFuaW1hdGlvbiBhbmRcbiAgICAgIC8vIG9ubHkgbWFraW5nIHVzZSBvZiB0aGUgYGluYCBhbmltYXRpb24gb3IgdmljZS12ZXJzYS5cbiAgICAgIC8vIEluIGVpdGhlciBjYXNlIHdlIHNob3VsZCBhbGxvdyB0aGlzIGFuZCBub3QgYXNzdW1lIHRoZVxuICAgICAgLy8gYW5pbWF0aW9uIGlzIG92ZXIgdW5sZXNzIGJvdGggYW5pbWF0aW9ucyBhcmUgbm90IHVzZWQuXG4gICAgICBpZiAoIWFuaW1hdG9yT3V0KSB7XG4gICAgICAgIGFuaW1hdG9ySW4gPSBwcmVwYXJlSW5BbmltYXRpb24oKTtcbiAgICAgICAgaWYgKCFhbmltYXRvckluKSB7XG4gICAgICAgICAgcmV0dXJuIGVuZCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBzdGFydGluZ0FuaW1hdG9yID0gYW5pbWF0b3JPdXQgfHwgYW5pbWF0b3JJbjtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBydW5uZXI7XG5cbiAgICAgICAgICB2YXIgY3VycmVudEFuaW1hdGlvbiA9IHN0YXJ0aW5nQW5pbWF0b3Iuc3RhcnQoKTtcbiAgICAgICAgICBjdXJyZW50QW5pbWF0aW9uLmRvbmUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjdXJyZW50QW5pbWF0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIGlmICghYW5pbWF0b3JJbikge1xuICAgICAgICAgICAgICBhbmltYXRvckluID0gcHJlcGFyZUluQW5pbWF0aW9uKCk7XG4gICAgICAgICAgICAgIGlmIChhbmltYXRvckluKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudEFuaW1hdGlvbiA9IGFuaW1hdG9ySW4uc3RhcnQoKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50QW5pbWF0aW9uLmRvbmUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICBjdXJyZW50QW5pbWF0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgIGVuZCgpO1xuICAgICAgICAgICAgICAgICAgcnVubmVyLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRBbmltYXRpb247XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGluIHRoZSBldmVudCB0aGF0IHRoZXJlIGlzIG5vIGBpbmAgYW5pbWF0aW9uXG4gICAgICAgICAgICBlbmQoKTtcbiAgICAgICAgICAgIHJ1bm5lci5jb21wbGV0ZSgpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcnVubmVyID0gbmV3ICQkQW5pbWF0ZVJ1bm5lcih7XG4gICAgICAgICAgICBlbmQ6IGVuZEZuLFxuICAgICAgICAgICAgY2FuY2VsOiBlbmRGblxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcmV0dXJuIHJ1bm5lcjtcblxuICAgICAgICAgIGZ1bmN0aW9uIGVuZEZuKCkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRBbmltYXRpb24pIHtcbiAgICAgICAgICAgICAgY3VycmVudEFuaW1hdGlvbi5lbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGZ1bmN0aW9uIGNhbGN1bGF0ZUFuY2hvclN0eWxlcyhhbmNob3IpIHtcbiAgICAgICAgdmFyIHN0eWxlcyA9IHt9O1xuXG4gICAgICAgIHZhciBjb29yZHMgPSBnZXREb21Ob2RlKGFuY2hvcikuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgLy8gd2UgaXRlcmF0ZSBkaXJlY3RseSBzaW5jZSBzYWZhcmkgbWVzc2VzIHVwIGFuZCBkb2Vzbid0IHJldHVyblxuICAgICAgICAvLyBhbGwgdGhlIGtleXMgZm9yIHRoZSBjb29yZHMgb2JqZWN0IHdoZW4gaXRlcmF0ZWRcbiAgICAgICAgZm9yRWFjaChbJ3dpZHRoJywnaGVpZ2h0JywndG9wJywnbGVmdCddLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBjb29yZHNba2V5XTtcbiAgICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgICAgY2FzZSAndG9wJzpcbiAgICAgICAgICAgICAgdmFsdWUgKz0gYm9keU5vZGUuc2Nyb2xsVG9wO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgICB2YWx1ZSArPSBib2R5Tm9kZS5zY3JvbGxMZWZ0O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgc3R5bGVzW2tleV0gPSBNYXRoLmZsb29yKHZhbHVlKSArICdweCc7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc3R5bGVzO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBwcmVwYXJlT3V0QW5pbWF0aW9uKCkge1xuICAgICAgICB2YXIgYW5pbWF0b3IgPSAkYW5pbWF0ZUNzcyhjbG9uZSwge1xuICAgICAgICAgIGFkZENsYXNzOiBOR19PVVRfQU5DSE9SX0NMQVNTX05BTUUsXG4gICAgICAgICAgZGVsYXk6IHRydWUsXG4gICAgICAgICAgZnJvbTogY2FsY3VsYXRlQW5jaG9yU3R5bGVzKG91dEFuY2hvcilcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gcmVhZCB0aGUgY29tbWVudCB3aXRoaW4gYHByZXBhcmVSZWd1bGFyQW5pbWF0aW9uYCB0byB1bmRlcnN0YW5kXG4gICAgICAgIC8vIHdoeSB0aGlzIGNoZWNrIGlzIG5lY2Vzc2FyeVxuICAgICAgICByZXR1cm4gYW5pbWF0b3IuJCR3aWxsQW5pbWF0ZSA/IGFuaW1hdG9yIDogbnVsbDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2V0Q2xhc3NWYWwoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gZWxlbWVudC5hdHRyKCdjbGFzcycpIHx8ICcnO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBwcmVwYXJlSW5BbmltYXRpb24oKSB7XG4gICAgICAgIHZhciBlbmRpbmdDbGFzc2VzID0gZmlsdGVyQ3NzQ2xhc3NlcyhnZXRDbGFzc1ZhbChpbkFuY2hvcikpO1xuICAgICAgICB2YXIgdG9BZGQgPSBnZXRVbmlxdWVWYWx1ZXMoZW5kaW5nQ2xhc3Nlcywgc3RhcnRpbmdDbGFzc2VzKTtcbiAgICAgICAgdmFyIHRvUmVtb3ZlID0gZ2V0VW5pcXVlVmFsdWVzKHN0YXJ0aW5nQ2xhc3NlcywgZW5kaW5nQ2xhc3Nlcyk7XG5cbiAgICAgICAgdmFyIGFuaW1hdG9yID0gJGFuaW1hdGVDc3MoY2xvbmUsIHtcbiAgICAgICAgICB0bzogY2FsY3VsYXRlQW5jaG9yU3R5bGVzKGluQW5jaG9yKSxcbiAgICAgICAgICBhZGRDbGFzczogTkdfSU5fQU5DSE9SX0NMQVNTX05BTUUgKyAnICcgKyB0b0FkZCxcbiAgICAgICAgICByZW1vdmVDbGFzczogTkdfT1VUX0FOQ0hPUl9DTEFTU19OQU1FICsgJyAnICsgdG9SZW1vdmUsXG4gICAgICAgICAgZGVsYXk6IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gcmVhZCB0aGUgY29tbWVudCB3aXRoaW4gYHByZXBhcmVSZWd1bGFyQW5pbWF0aW9uYCB0byB1bmRlcnN0YW5kXG4gICAgICAgIC8vIHdoeSB0aGlzIGNoZWNrIGlzIG5lY2Vzc2FyeVxuICAgICAgICByZXR1cm4gYW5pbWF0b3IuJCR3aWxsQW5pbWF0ZSA/IGFuaW1hdG9yIDogbnVsbDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZW5kKCkge1xuICAgICAgICBjbG9uZS5yZW1vdmUoKTtcbiAgICAgICAgb3V0QW5jaG9yLnJlbW92ZUNsYXNzKE5HX0FOSU1BVEVfU0hJTV9DTEFTU19OQU1FKTtcbiAgICAgICAgaW5BbmNob3IucmVtb3ZlQ2xhc3MoTkdfQU5JTUFURV9TSElNX0NMQVNTX05BTUUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByZXBhcmVGcm9tVG9BbmNob3JBbmltYXRpb24oZnJvbSwgdG8sIGNsYXNzZXMsIGFuY2hvcnMpIHtcbiAgICAgIHZhciBmcm9tQW5pbWF0aW9uID0gcHJlcGFyZVJlZ3VsYXJBbmltYXRpb24oZnJvbSwgbm9vcCk7XG4gICAgICB2YXIgdG9BbmltYXRpb24gPSBwcmVwYXJlUmVndWxhckFuaW1hdGlvbih0bywgbm9vcCk7XG5cbiAgICAgIHZhciBhbmNob3JBbmltYXRpb25zID0gW107XG4gICAgICBmb3JFYWNoKGFuY2hvcnMsIGZ1bmN0aW9uKGFuY2hvcikge1xuICAgICAgICB2YXIgb3V0RWxlbWVudCA9IGFuY2hvclsnb3V0J107XG4gICAgICAgIHZhciBpbkVsZW1lbnQgPSBhbmNob3JbJ2luJ107XG4gICAgICAgIHZhciBhbmltYXRvciA9IHByZXBhcmVBbmNob3JlZEFuaW1hdGlvbihjbGFzc2VzLCBvdXRFbGVtZW50LCBpbkVsZW1lbnQpO1xuICAgICAgICBpZiAoYW5pbWF0b3IpIHtcbiAgICAgICAgICBhbmNob3JBbmltYXRpb25zLnB1c2goYW5pbWF0b3IpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gbm8gcG9pbnQgaW4gZG9pbmcgYW55dGhpbmcgd2hlbiB0aGVyZSBhcmUgbm8gZWxlbWVudHMgdG8gYW5pbWF0ZVxuICAgICAgaWYgKCFmcm9tQW5pbWF0aW9uICYmICF0b0FuaW1hdGlvbiAmJiBhbmNob3JBbmltYXRpb25zLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGFuaW1hdGlvblJ1bm5lcnMgPSBbXTtcblxuICAgICAgICAgIGlmIChmcm9tQW5pbWF0aW9uKSB7XG4gICAgICAgICAgICBhbmltYXRpb25SdW5uZXJzLnB1c2goZnJvbUFuaW1hdGlvbi5zdGFydCgpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodG9BbmltYXRpb24pIHtcbiAgICAgICAgICAgIGFuaW1hdGlvblJ1bm5lcnMucHVzaCh0b0FuaW1hdGlvbi5zdGFydCgpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3JFYWNoKGFuY2hvckFuaW1hdGlvbnMsIGZ1bmN0aW9uKGFuaW1hdGlvbikge1xuICAgICAgICAgICAgYW5pbWF0aW9uUnVubmVycy5wdXNoKGFuaW1hdGlvbi5zdGFydCgpKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBydW5uZXIgPSBuZXcgJCRBbmltYXRlUnVubmVyKHtcbiAgICAgICAgICAgIGVuZDogZW5kRm4sXG4gICAgICAgICAgICBjYW5jZWw6IGVuZEZuIC8vIENTUy1kcml2ZW4gYW5pbWF0aW9ucyBjYW5ub3QgYmUgY2FuY2VsbGVkLCBvbmx5IGVuZGVkXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAkJEFuaW1hdGVSdW5uZXIuYWxsKGFuaW1hdGlvblJ1bm5lcnMsIGZ1bmN0aW9uKHN0YXR1cykge1xuICAgICAgICAgICAgcnVubmVyLmNvbXBsZXRlKHN0YXR1cyk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICByZXR1cm4gcnVubmVyO1xuXG4gICAgICAgICAgZnVuY3Rpb24gZW5kRm4oKSB7XG4gICAgICAgICAgICBmb3JFYWNoKGFuaW1hdGlvblJ1bm5lcnMsIGZ1bmN0aW9uKHJ1bm5lcikge1xuICAgICAgICAgICAgICBydW5uZXIuZW5kKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJlcGFyZVJlZ3VsYXJBbmltYXRpb24oYW5pbWF0aW9uRGV0YWlscykge1xuICAgICAgdmFyIGVsZW1lbnQgPSBhbmltYXRpb25EZXRhaWxzLmVsZW1lbnQ7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFuaW1hdGlvbkRldGFpbHMub3B0aW9ucyB8fCB7fTtcblxuICAgICAgaWYgKGFuaW1hdGlvbkRldGFpbHMuc3RydWN0dXJhbCkge1xuICAgICAgICBvcHRpb25zLmV2ZW50ID0gYW5pbWF0aW9uRGV0YWlscy5ldmVudDtcbiAgICAgICAgb3B0aW9ucy5zdHJ1Y3R1cmFsID0gdHJ1ZTtcbiAgICAgICAgb3B0aW9ucy5hcHBseUNsYXNzZXNFYXJseSA9IHRydWU7XG5cbiAgICAgICAgLy8gd2Ugc3BlY2lhbCBjYXNlIHRoZSBsZWF2ZSBhbmltYXRpb24gc2luY2Ugd2Ugd2FudCB0byBlbnN1cmUgdGhhdFxuICAgICAgICAvLyB0aGUgZWxlbWVudCBpcyByZW1vdmVkIGFzIHNvb24gYXMgdGhlIGFuaW1hdGlvbiBpcyBvdmVyLiBPdGhlcndpc2VcbiAgICAgICAgLy8gYSBmbGlja2VyIG1pZ2h0IGFwcGVhciBvciB0aGUgZWxlbWVudCBtYXkgbm90IGJlIHJlbW92ZWQgYXQgYWxsXG4gICAgICAgIGlmIChhbmltYXRpb25EZXRhaWxzLmV2ZW50ID09PSAnbGVhdmUnKSB7XG4gICAgICAgICAgb3B0aW9ucy5vbkRvbmUgPSBvcHRpb25zLmRvbU9wZXJhdGlvbjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBXZSBhc3NpZ24gdGhlIHByZXBhcmF0aW9uQ2xhc3NlcyBhcyB0aGUgYWN0dWFsIGFuaW1hdGlvbiBldmVudCBzaW5jZVxuICAgICAgLy8gdGhlIGludGVybmFscyBvZiAkYW5pbWF0ZUNzcyB3aWxsIGp1c3Qgc3VmZml4IHRoZSBldmVudCB0b2tlbiB2YWx1ZXNcbiAgICAgIC8vIHdpdGggYC1hY3RpdmVgIHRvIHRyaWdnZXIgdGhlIGFuaW1hdGlvbi5cbiAgICAgIGlmIChvcHRpb25zLnByZXBhcmF0aW9uQ2xhc3Nlcykge1xuICAgICAgICBvcHRpb25zLmV2ZW50ID0gY29uY2F0V2l0aFNwYWNlKG9wdGlvbnMuZXZlbnQsIG9wdGlvbnMucHJlcGFyYXRpb25DbGFzc2VzKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGFuaW1hdG9yID0gJGFuaW1hdGVDc3MoZWxlbWVudCwgb3B0aW9ucyk7XG5cbiAgICAgIC8vIHRoZSBkcml2ZXIgbG9va3VwIGNvZGUgaW5zaWRlIG9mICQkYW5pbWF0aW9uIGF0dGVtcHRzIHRvIHNwYXduIGFcbiAgICAgIC8vIGRyaXZlciBvbmUgYnkgb25lIHVudGlsIGEgZHJpdmVyIHJldHVybnMgYS4kJHdpbGxBbmltYXRlIGFuaW1hdG9yIG9iamVjdC5cbiAgICAgIC8vICRhbmltYXRlQ3NzIHdpbGwgYWx3YXlzIHJldHVybiBhbiBvYmplY3QsIGhvd2V2ZXIsIGl0IHdpbGwgcGFzcyBpblxuICAgICAgLy8gYSBmbGFnIGFzIGEgaGludCBhcyB0byB3aGV0aGVyIGFuIGFuaW1hdGlvbiB3YXMgZGV0ZWN0ZWQgb3Igbm90XG4gICAgICByZXR1cm4gYW5pbWF0b3IuJCR3aWxsQW5pbWF0ZSA/IGFuaW1hdG9yIDogbnVsbDtcbiAgICB9XG4gIH1dO1xufV07XG5cbi8vIFRPRE8obWF0c2tvKTogdXNlIGNhY2hpbmcgaGVyZSB0byBzcGVlZCB0aGluZ3MgdXAgZm9yIGRldGVjdGlvblxuLy8gVE9ETyhtYXRza28pOiBhZGQgZG9jdW1lbnRhdGlvblxuLy8gIGJ5IHRoZSB0aW1lLi4uXG5cbnZhciAkJEFuaW1hdGVKc1Byb3ZpZGVyID0gWyckYW5pbWF0ZVByb3ZpZGVyJywgLyoqIEB0aGlzICovIGZ1bmN0aW9uKCRhbmltYXRlUHJvdmlkZXIpIHtcbiAgdGhpcy4kZ2V0ID0gWyckaW5qZWN0b3InLCAnJCRBbmltYXRlUnVubmVyJywgJyQkanFMaXRlJyxcbiAgICAgICBmdW5jdGlvbigkaW5qZWN0b3IsICAgJCRBbmltYXRlUnVubmVyLCAgICQkanFMaXRlKSB7XG5cbiAgICB2YXIgYXBwbHlBbmltYXRpb25DbGFzc2VzID0gYXBwbHlBbmltYXRpb25DbGFzc2VzRmFjdG9yeSgkJGpxTGl0ZSk7XG4gICAgICAgICAvLyAkYW5pbWF0ZUpzKGVsZW1lbnQsICdlbnRlcicpO1xuICAgIHJldHVybiBmdW5jdGlvbihlbGVtZW50LCBldmVudCwgY2xhc3Nlcywgb3B0aW9ucykge1xuICAgICAgdmFyIGFuaW1hdGlvbkNsb3NlZCA9IGZhbHNlO1xuXG4gICAgICAvLyB0aGUgYGNsYXNzZXNgIGFyZ3VtZW50IGlzIG9wdGlvbmFsIGFuZCBpZiBpdCBpcyBub3QgdXNlZFxuICAgICAgLy8gdGhlbiB0aGUgY2xhc3NlcyB3aWxsIGJlIHJlc29sdmVkIGZyb20gdGhlIGVsZW1lbnQncyBjbGFzc05hbWVcbiAgICAgIC8vIHByb3BlcnR5IGFzIHdlbGwgYXMgb3B0aW9ucy5hZGRDbGFzcy9vcHRpb25zLnJlbW92ZUNsYXNzLlxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMgJiYgaXNPYmplY3QoY2xhc3NlcykpIHtcbiAgICAgICAgb3B0aW9ucyA9IGNsYXNzZXM7XG4gICAgICAgIGNsYXNzZXMgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBvcHRpb25zID0gcHJlcGFyZUFuaW1hdGlvbk9wdGlvbnMob3B0aW9ucyk7XG4gICAgICBpZiAoIWNsYXNzZXMpIHtcbiAgICAgICAgY2xhc3NlcyA9IGVsZW1lbnQuYXR0cignY2xhc3MnKSB8fCAnJztcbiAgICAgICAgaWYgKG9wdGlvbnMuYWRkQ2xhc3MpIHtcbiAgICAgICAgICBjbGFzc2VzICs9ICcgJyArIG9wdGlvbnMuYWRkQ2xhc3M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMucmVtb3ZlQ2xhc3MpIHtcbiAgICAgICAgICBjbGFzc2VzICs9ICcgJyArIG9wdGlvbnMucmVtb3ZlQ2xhc3M7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGNsYXNzZXNUb0FkZCA9IG9wdGlvbnMuYWRkQ2xhc3M7XG4gICAgICB2YXIgY2xhc3Nlc1RvUmVtb3ZlID0gb3B0aW9ucy5yZW1vdmVDbGFzcztcblxuICAgICAgLy8gdGhlIGxvb2t1cEFuaW1hdGlvbnMgZnVuY3Rpb24gcmV0dXJucyBhIHNlcmllcyBvZiBhbmltYXRpb24gb2JqZWN0cyB0aGF0IGFyZVxuICAgICAgLy8gbWF0Y2hlZCB1cCB3aXRoIG9uZSBvciBtb3JlIG9mIHRoZSBDU1MgY2xhc3Nlcy4gVGhlc2UgYW5pbWF0aW9uIG9iamVjdHMgYXJlXG4gICAgICAvLyBkZWZpbmVkIHZpYSB0aGUgbW9kdWxlLmFuaW1hdGlvbiBmYWN0b3J5IGZ1bmN0aW9uLiBJZiBub3RoaW5nIGlzIGRldGVjdGVkIHRoZW5cbiAgICAgIC8vIHdlIGRvbid0IHJldHVybiBhbnl0aGluZyB3aGljaCB0aGVuIG1ha2VzICRhbmltYXRpb24gcXVlcnkgdGhlIG5leHQgZHJpdmVyLlxuICAgICAgdmFyIGFuaW1hdGlvbnMgPSBsb29rdXBBbmltYXRpb25zKGNsYXNzZXMpO1xuICAgICAgdmFyIGJlZm9yZSwgYWZ0ZXI7XG4gICAgICBpZiAoYW5pbWF0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGFmdGVyRm4sIGJlZm9yZUZuO1xuICAgICAgICBpZiAoZXZlbnQgPT09ICdsZWF2ZScpIHtcbiAgICAgICAgICBiZWZvcmVGbiA9ICdsZWF2ZSc7XG4gICAgICAgICAgYWZ0ZXJGbiA9ICdhZnRlckxlYXZlJzsgLy8gVE9ETyhtYXRza28pOiBnZXQgcmlkIG9mIHRoaXNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBiZWZvcmVGbiA9ICdiZWZvcmUnICsgZXZlbnQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBldmVudC5zdWJzdHIoMSk7XG4gICAgICAgICAgYWZ0ZXJGbiA9IGV2ZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV2ZW50ICE9PSAnZW50ZXInICYmIGV2ZW50ICE9PSAnbW92ZScpIHtcbiAgICAgICAgICBiZWZvcmUgPSBwYWNrYWdlQW5pbWF0aW9ucyhlbGVtZW50LCBldmVudCwgb3B0aW9ucywgYW5pbWF0aW9ucywgYmVmb3JlRm4pO1xuICAgICAgICB9XG4gICAgICAgIGFmdGVyICA9IHBhY2thZ2VBbmltYXRpb25zKGVsZW1lbnQsIGV2ZW50LCBvcHRpb25zLCBhbmltYXRpb25zLCBhZnRlckZuKTtcbiAgICAgIH1cblxuICAgICAgLy8gbm8gbWF0Y2hpbmcgYW5pbWF0aW9uc1xuICAgICAgaWYgKCFiZWZvcmUgJiYgIWFmdGVyKSByZXR1cm47XG5cbiAgICAgIGZ1bmN0aW9uIGFwcGx5T3B0aW9ucygpIHtcbiAgICAgICAgb3B0aW9ucy5kb21PcGVyYXRpb24oKTtcbiAgICAgICAgYXBwbHlBbmltYXRpb25DbGFzc2VzKGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgICAgYW5pbWF0aW9uQ2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgYXBwbHlPcHRpb25zKCk7XG4gICAgICAgIGFwcGx5QW5pbWF0aW9uU3R5bGVzKGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcnVubmVyO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAkJHdpbGxBbmltYXRlOiB0cnVlLFxuICAgICAgICBlbmQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmIChydW5uZXIpIHtcbiAgICAgICAgICAgIHJ1bm5lci5lbmQoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgICAgIHJ1bm5lciA9IG5ldyAkJEFuaW1hdGVSdW5uZXIoKTtcbiAgICAgICAgICAgIHJ1bm5lci5jb21wbGV0ZSh0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJ1bm5lcjtcbiAgICAgICAgfSxcbiAgICAgICAgc3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmIChydW5uZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBydW5uZXI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcnVubmVyID0gbmV3ICQkQW5pbWF0ZVJ1bm5lcigpO1xuICAgICAgICAgIHZhciBjbG9zZUFjdGl2ZUFuaW1hdGlvbnM7XG4gICAgICAgICAgdmFyIGNoYWluID0gW107XG5cbiAgICAgICAgICBpZiAoYmVmb3JlKSB7XG4gICAgICAgICAgICBjaGFpbi5wdXNoKGZ1bmN0aW9uKGZuKSB7XG4gICAgICAgICAgICAgIGNsb3NlQWN0aXZlQW5pbWF0aW9ucyA9IGJlZm9yZShmbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY2hhaW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICBjaGFpbi5wdXNoKGZ1bmN0aW9uKGZuKSB7XG4gICAgICAgICAgICAgIGFwcGx5T3B0aW9ucygpO1xuICAgICAgICAgICAgICBmbih0cnVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcHBseU9wdGlvbnMoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYWZ0ZXIpIHtcbiAgICAgICAgICAgIGNoYWluLnB1c2goZnVuY3Rpb24oZm4pIHtcbiAgICAgICAgICAgICAgY2xvc2VBY3RpdmVBbmltYXRpb25zID0gYWZ0ZXIoZm4pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcnVubmVyLnNldEhvc3Qoe1xuICAgICAgICAgICAgZW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgZW5kQW5pbWF0aW9ucygpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNhbmNlbDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGVuZEFuaW1hdGlvbnModHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAkJEFuaW1hdGVSdW5uZXIuY2hhaW4oY2hhaW4sIG9uQ29tcGxldGUpO1xuICAgICAgICAgIHJldHVybiBydW5uZXI7XG5cbiAgICAgICAgICBmdW5jdGlvbiBvbkNvbXBsZXRlKHN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIGNsb3NlKHN1Y2Nlc3MpO1xuICAgICAgICAgICAgcnVubmVyLmNvbXBsZXRlKHN1Y2Nlc3MpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZ1bmN0aW9uIGVuZEFuaW1hdGlvbnMoY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICBpZiAoIWFuaW1hdGlvbkNsb3NlZCkge1xuICAgICAgICAgICAgICAoY2xvc2VBY3RpdmVBbmltYXRpb25zIHx8IG5vb3ApKGNhbmNlbGxlZCk7XG4gICAgICAgICAgICAgIG9uQ29tcGxldGUoY2FuY2VsbGVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGZ1bmN0aW9uIGV4ZWN1dGVBbmltYXRpb25GbihmbiwgZWxlbWVudCwgZXZlbnQsIG9wdGlvbnMsIG9uRG9uZSkge1xuICAgICAgICB2YXIgYXJncztcbiAgICAgICAgc3dpdGNoIChldmVudCkge1xuICAgICAgICAgIGNhc2UgJ2FuaW1hdGUnOlxuICAgICAgICAgICAgYXJncyA9IFtlbGVtZW50LCBvcHRpb25zLmZyb20sIG9wdGlvbnMudG8sIG9uRG9uZV07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3NldENsYXNzJzpcbiAgICAgICAgICAgIGFyZ3MgPSBbZWxlbWVudCwgY2xhc3Nlc1RvQWRkLCBjbGFzc2VzVG9SZW1vdmUsIG9uRG9uZV07XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2FkZENsYXNzJzpcbiAgICAgICAgICAgIGFyZ3MgPSBbZWxlbWVudCwgY2xhc3Nlc1RvQWRkLCBvbkRvbmVdO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdyZW1vdmVDbGFzcyc6XG4gICAgICAgICAgICBhcmdzID0gW2VsZW1lbnQsIGNsYXNzZXNUb1JlbW92ZSwgb25Eb25lXTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGFyZ3MgPSBbZWxlbWVudCwgb25Eb25lXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgYXJncy5wdXNoKG9wdGlvbnMpO1xuXG4gICAgICAgIHZhciB2YWx1ZSA9IGZuLmFwcGx5KGZuLCBhcmdzKTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKGlzRnVuY3Rpb24odmFsdWUuc3RhcnQpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnN0YXJ0KCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgJCRBbmltYXRlUnVubmVyKSB7XG4gICAgICAgICAgICB2YWx1ZS5kb25lKG9uRG9uZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgICAgICAgLy8gb3B0aW9uYWwgb25FbmQgLyBvbkNhbmNlbCBjYWxsYmFja1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub29wO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBncm91cEV2ZW50ZWRBbmltYXRpb25zKGVsZW1lbnQsIGV2ZW50LCBvcHRpb25zLCBhbmltYXRpb25zLCBmbk5hbWUpIHtcbiAgICAgICAgdmFyIG9wZXJhdGlvbnMgPSBbXTtcbiAgICAgICAgZm9yRWFjaChhbmltYXRpb25zLCBmdW5jdGlvbihhbmkpIHtcbiAgICAgICAgICB2YXIgYW5pbWF0aW9uID0gYW5pW2ZuTmFtZV07XG4gICAgICAgICAgaWYgKCFhbmltYXRpb24pIHJldHVybjtcblxuICAgICAgICAgIC8vIG5vdGUgdGhhdCBhbGwgb2YgdGhlc2UgYW5pbWF0aW9ucyB3aWxsIHJ1biBpbiBwYXJhbGxlbFxuICAgICAgICAgIG9wZXJhdGlvbnMucHVzaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBydW5uZXI7XG4gICAgICAgICAgICB2YXIgZW5kUHJvZ3Jlc3NDYjtcblxuICAgICAgICAgICAgdmFyIHJlc29sdmVkID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgb25BbmltYXRpb25Db21wbGV0ZSA9IGZ1bmN0aW9uKHJlamVjdGVkKSB7XG4gICAgICAgICAgICAgIGlmICghcmVzb2x2ZWQpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgKGVuZFByb2dyZXNzQ2IgfHwgbm9vcCkocmVqZWN0ZWQpO1xuICAgICAgICAgICAgICAgIHJ1bm5lci5jb21wbGV0ZSghcmVqZWN0ZWQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBydW5uZXIgPSBuZXcgJCRBbmltYXRlUnVubmVyKHtcbiAgICAgICAgICAgICAgZW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBvbkFuaW1hdGlvbkNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGNhbmNlbDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgb25BbmltYXRpb25Db21wbGV0ZSh0cnVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGVuZFByb2dyZXNzQ2IgPSBleGVjdXRlQW5pbWF0aW9uRm4oYW5pbWF0aW9uLCBlbGVtZW50LCBldmVudCwgb3B0aW9ucywgZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgICAgIHZhciBjYW5jZWxsZWQgPSByZXN1bHQgPT09IGZhbHNlO1xuICAgICAgICAgICAgICBvbkFuaW1hdGlvbkNvbXBsZXRlKGNhbmNlbGxlZCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHJ1bm5lcjtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG9wZXJhdGlvbnM7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHBhY2thZ2VBbmltYXRpb25zKGVsZW1lbnQsIGV2ZW50LCBvcHRpb25zLCBhbmltYXRpb25zLCBmbk5hbWUpIHtcbiAgICAgICAgdmFyIG9wZXJhdGlvbnMgPSBncm91cEV2ZW50ZWRBbmltYXRpb25zKGVsZW1lbnQsIGV2ZW50LCBvcHRpb25zLCBhbmltYXRpb25zLCBmbk5hbWUpO1xuICAgICAgICBpZiAob3BlcmF0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB2YXIgYSwgYjtcbiAgICAgICAgICBpZiAoZm5OYW1lID09PSAnYmVmb3JlU2V0Q2xhc3MnKSB7XG4gICAgICAgICAgICBhID0gZ3JvdXBFdmVudGVkQW5pbWF0aW9ucyhlbGVtZW50LCAncmVtb3ZlQ2xhc3MnLCBvcHRpb25zLCBhbmltYXRpb25zLCAnYmVmb3JlUmVtb3ZlQ2xhc3MnKTtcbiAgICAgICAgICAgIGIgPSBncm91cEV2ZW50ZWRBbmltYXRpb25zKGVsZW1lbnQsICdhZGRDbGFzcycsIG9wdGlvbnMsIGFuaW1hdGlvbnMsICdiZWZvcmVBZGRDbGFzcycpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZm5OYW1lID09PSAnc2V0Q2xhc3MnKSB7XG4gICAgICAgICAgICBhID0gZ3JvdXBFdmVudGVkQW5pbWF0aW9ucyhlbGVtZW50LCAncmVtb3ZlQ2xhc3MnLCBvcHRpb25zLCBhbmltYXRpb25zLCAncmVtb3ZlQ2xhc3MnKTtcbiAgICAgICAgICAgIGIgPSBncm91cEV2ZW50ZWRBbmltYXRpb25zKGVsZW1lbnQsICdhZGRDbGFzcycsIG9wdGlvbnMsIGFuaW1hdGlvbnMsICdhZGRDbGFzcycpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChhKSB7XG4gICAgICAgICAgICBvcGVyYXRpb25zID0gb3BlcmF0aW9ucy5jb25jYXQoYSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChiKSB7XG4gICAgICAgICAgICBvcGVyYXRpb25zID0gb3BlcmF0aW9ucy5jb25jYXQoYik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wZXJhdGlvbnMubGVuZ3RoID09PSAwKSByZXR1cm47XG5cbiAgICAgICAgLy8gVE9ETyhtYXRza28pOiBhZGQgZG9jdW1lbnRhdGlvblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gc3RhcnRBbmltYXRpb24oY2FsbGJhY2spIHtcbiAgICAgICAgICB2YXIgcnVubmVycyA9IFtdO1xuICAgICAgICAgIGlmIChvcGVyYXRpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgZm9yRWFjaChvcGVyYXRpb25zLCBmdW5jdGlvbihhbmltYXRlRm4pIHtcbiAgICAgICAgICAgICAgcnVubmVycy5wdXNoKGFuaW1hdGVGbigpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChydW5uZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgJCRBbmltYXRlUnVubmVyLmFsbChydW5uZXJzLCBjYWxsYmFjayk7XG4gICAgICAgICAgfSAgZWxzZSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBlbmRGbihyZWplY3QpIHtcbiAgICAgICAgICAgIGZvckVhY2gocnVubmVycywgZnVuY3Rpb24ocnVubmVyKSB7XG4gICAgICAgICAgICAgIGlmIChyZWplY3QpIHtcbiAgICAgICAgICAgICAgICBydW5uZXIuY2FuY2VsKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcnVubmVyLmVuZCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBsb29rdXBBbmltYXRpb25zKGNsYXNzZXMpIHtcbiAgICAgIGNsYXNzZXMgPSBpc0FycmF5KGNsYXNzZXMpID8gY2xhc3NlcyA6IGNsYXNzZXMuc3BsaXQoJyAnKTtcbiAgICAgIHZhciBtYXRjaGVzID0gW10sIGZsYWdNYXAgPSB7fTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xhc3Nlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIga2xhc3MgPSBjbGFzc2VzW2ldLFxuICAgICAgICAgICAgYW5pbWF0aW9uRmFjdG9yeSA9ICRhbmltYXRlUHJvdmlkZXIuJCRyZWdpc3RlcmVkQW5pbWF0aW9uc1trbGFzc107XG4gICAgICAgIGlmIChhbmltYXRpb25GYWN0b3J5ICYmICFmbGFnTWFwW2tsYXNzXSkge1xuICAgICAgICAgIG1hdGNoZXMucHVzaCgkaW5qZWN0b3IuZ2V0KGFuaW1hdGlvbkZhY3RvcnkpKTtcbiAgICAgICAgICBmbGFnTWFwW2tsYXNzXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRjaGVzO1xuICAgIH1cbiAgfV07XG59XTtcblxudmFyICQkQW5pbWF0ZUpzRHJpdmVyUHJvdmlkZXIgPSBbJyQkYW5pbWF0aW9uUHJvdmlkZXInLCAvKiogQHRoaXMgKi8gZnVuY3Rpb24oJCRhbmltYXRpb25Qcm92aWRlcikge1xuICAkJGFuaW1hdGlvblByb3ZpZGVyLmRyaXZlcnMucHVzaCgnJCRhbmltYXRlSnNEcml2ZXInKTtcbiAgdGhpcy4kZ2V0ID0gWyckJGFuaW1hdGVKcycsICckJEFuaW1hdGVSdW5uZXInLCBmdW5jdGlvbigkJGFuaW1hdGVKcywgJCRBbmltYXRlUnVubmVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGluaXREcml2ZXJGbihhbmltYXRpb25EZXRhaWxzKSB7XG4gICAgICBpZiAoYW5pbWF0aW9uRGV0YWlscy5mcm9tICYmIGFuaW1hdGlvbkRldGFpbHMudG8pIHtcbiAgICAgICAgdmFyIGZyb21BbmltYXRpb24gPSBwcmVwYXJlQW5pbWF0aW9uKGFuaW1hdGlvbkRldGFpbHMuZnJvbSk7XG4gICAgICAgIHZhciB0b0FuaW1hdGlvbiA9IHByZXBhcmVBbmltYXRpb24oYW5pbWF0aW9uRGV0YWlscy50byk7XG4gICAgICAgIGlmICghZnJvbUFuaW1hdGlvbiAmJiAhdG9BbmltYXRpb24pIHJldHVybjtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBhbmltYXRpb25SdW5uZXJzID0gW107XG5cbiAgICAgICAgICAgIGlmIChmcm9tQW5pbWF0aW9uKSB7XG4gICAgICAgICAgICAgIGFuaW1hdGlvblJ1bm5lcnMucHVzaChmcm9tQW5pbWF0aW9uLnN0YXJ0KCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodG9BbmltYXRpb24pIHtcbiAgICAgICAgICAgICAgYW5pbWF0aW9uUnVubmVycy5wdXNoKHRvQW5pbWF0aW9uLnN0YXJ0KCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAkJEFuaW1hdGVSdW5uZXIuYWxsKGFuaW1hdGlvblJ1bm5lcnMsIGRvbmUpO1xuXG4gICAgICAgICAgICB2YXIgcnVubmVyID0gbmV3ICQkQW5pbWF0ZVJ1bm5lcih7XG4gICAgICAgICAgICAgIGVuZDogZW5kRm5GYWN0b3J5KCksXG4gICAgICAgICAgICAgIGNhbmNlbDogZW5kRm5GYWN0b3J5KClcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gcnVubmVyO1xuXG4gICAgICAgICAgICBmdW5jdGlvbiBlbmRGbkZhY3RvcnkoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBmb3JFYWNoKGFuaW1hdGlvblJ1bm5lcnMsIGZ1bmN0aW9uKHJ1bm5lcikge1xuICAgICAgICAgICAgICAgICAgLy8gYXQgdGhpcyBwb2ludCB3ZSBjYW5ub3QgY2FuY2VsIGFuaW1hdGlvbnMgZm9yIGdyb3VwcyBqdXN0IHlldC4gMS41K1xuICAgICAgICAgICAgICAgICAgcnVubmVyLmVuZCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBkb25lKHN0YXR1cykge1xuICAgICAgICAgICAgICBydW5uZXIuY29tcGxldGUoc3RhdHVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcHJlcGFyZUFuaW1hdGlvbihhbmltYXRpb25EZXRhaWxzKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gcHJlcGFyZUFuaW1hdGlvbihhbmltYXRpb25EZXRhaWxzKSB7XG4gICAgICAvLyBUT0RPKG1hdHNrbyk6IG1ha2Ugc3VyZSB0byBjaGVjayBmb3IgZ3JvdXBlZCBhbmltYXRpb25zIGFuZCBkZWxlZ2F0ZSBkb3duIHRvIG5vcm1hbCBhbmltYXRpb25zXG4gICAgICB2YXIgZWxlbWVudCA9IGFuaW1hdGlvbkRldGFpbHMuZWxlbWVudDtcbiAgICAgIHZhciBldmVudCA9IGFuaW1hdGlvbkRldGFpbHMuZXZlbnQ7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFuaW1hdGlvbkRldGFpbHMub3B0aW9ucztcbiAgICAgIHZhciBjbGFzc2VzID0gYW5pbWF0aW9uRGV0YWlscy5jbGFzc2VzO1xuICAgICAgcmV0dXJuICQkYW5pbWF0ZUpzKGVsZW1lbnQsIGV2ZW50LCBjbGFzc2VzLCBvcHRpb25zKTtcbiAgICB9XG4gIH1dO1xufV07XG5cbnZhciBOR19BTklNQVRFX0FUVFJfTkFNRSA9ICdkYXRhLW5nLWFuaW1hdGUnO1xudmFyIE5HX0FOSU1BVEVfUElOX0RBVEEgPSAnJG5nQW5pbWF0ZVBpbic7XG52YXIgJCRBbmltYXRlUXVldWVQcm92aWRlciA9IFsnJGFuaW1hdGVQcm92aWRlcicsIC8qKiBAdGhpcyAqLyBmdW5jdGlvbigkYW5pbWF0ZVByb3ZpZGVyKSB7XG4gIHZhciBQUkVfRElHRVNUX1NUQVRFID0gMTtcbiAgdmFyIFJVTk5JTkdfU1RBVEUgPSAyO1xuICB2YXIgT05FX1NQQUNFID0gJyAnO1xuXG4gIHZhciBydWxlcyA9IHRoaXMucnVsZXMgPSB7XG4gICAgc2tpcDogW10sXG4gICAgY2FuY2VsOiBbXSxcbiAgICBqb2luOiBbXVxuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VUcnV0aHlDc3NDbGFzc01hcChjbGFzc1N0cmluZykge1xuICAgIGlmICghY2xhc3NTdHJpbmcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBrZXlzID0gY2xhc3NTdHJpbmcuc3BsaXQoT05FX1NQQUNFKTtcbiAgICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgIGZvckVhY2goa2V5cywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICBtYXBba2V5XSA9IHRydWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIG1hcDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhc01hdGNoaW5nQ2xhc3NlcyhuZXdDbGFzc1N0cmluZywgY3VycmVudENsYXNzU3RyaW5nKSB7XG4gICAgaWYgKG5ld0NsYXNzU3RyaW5nICYmIGN1cnJlbnRDbGFzc1N0cmluZykge1xuICAgICAgdmFyIGN1cnJlbnRDbGFzc01hcCA9IG1ha2VUcnV0aHlDc3NDbGFzc01hcChjdXJyZW50Q2xhc3NTdHJpbmcpO1xuICAgICAgcmV0dXJuIG5ld0NsYXNzU3RyaW5nLnNwbGl0KE9ORV9TUEFDRSkuc29tZShmdW5jdGlvbihjbGFzc05hbWUpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRDbGFzc01hcFtjbGFzc05hbWVdO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNBbGxvd2VkKHJ1bGVUeXBlLCBjdXJyZW50QW5pbWF0aW9uLCBwcmV2aW91c0FuaW1hdGlvbikge1xuICAgIHJldHVybiBydWxlc1tydWxlVHlwZV0uc29tZShmdW5jdGlvbihmbikge1xuICAgICAgcmV0dXJuIGZuKGN1cnJlbnRBbmltYXRpb24sIHByZXZpb3VzQW5pbWF0aW9uKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhc0FuaW1hdGlvbkNsYXNzZXMoYW5pbWF0aW9uLCBhbmQpIHtcbiAgICB2YXIgYSA9IChhbmltYXRpb24uYWRkQ2xhc3MgfHwgJycpLmxlbmd0aCA+IDA7XG4gICAgdmFyIGIgPSAoYW5pbWF0aW9uLnJlbW92ZUNsYXNzIHx8ICcnKS5sZW5ndGggPiAwO1xuICAgIHJldHVybiBhbmQgPyBhICYmIGIgOiBhIHx8IGI7XG4gIH1cblxuICBydWxlcy5qb2luLnB1c2goZnVuY3Rpb24obmV3QW5pbWF0aW9uLCBjdXJyZW50QW5pbWF0aW9uKSB7XG4gICAgLy8gaWYgdGhlIG5ldyBhbmltYXRpb24gaXMgY2xhc3MtYmFzZWQgdGhlbiB3ZSBjYW4ganVzdCB0YWNrIHRoYXQgb25cbiAgICByZXR1cm4gIW5ld0FuaW1hdGlvbi5zdHJ1Y3R1cmFsICYmIGhhc0FuaW1hdGlvbkNsYXNzZXMobmV3QW5pbWF0aW9uKTtcbiAgfSk7XG5cbiAgcnVsZXMuc2tpcC5wdXNoKGZ1bmN0aW9uKG5ld0FuaW1hdGlvbiwgY3VycmVudEFuaW1hdGlvbikge1xuICAgIC8vIHRoZXJlIGlzIG5vIG5lZWQgdG8gYW5pbWF0ZSBhbnl0aGluZyBpZiBubyBjbGFzc2VzIGFyZSBiZWluZyBhZGRlZCBhbmRcbiAgICAvLyB0aGVyZSBpcyBubyBzdHJ1Y3R1cmFsIGFuaW1hdGlvbiB0aGF0IHdpbGwgYmUgdHJpZ2dlcmVkXG4gICAgcmV0dXJuICFuZXdBbmltYXRpb24uc3RydWN0dXJhbCAmJiAhaGFzQW5pbWF0aW9uQ2xhc3NlcyhuZXdBbmltYXRpb24pO1xuICB9KTtcblxuICBydWxlcy5za2lwLnB1c2goZnVuY3Rpb24obmV3QW5pbWF0aW9uLCBjdXJyZW50QW5pbWF0aW9uKSB7XG4gICAgLy8gd2h5IHNob3VsZCB3ZSB0cmlnZ2VyIGEgbmV3IHN0cnVjdHVyYWwgYW5pbWF0aW9uIGlmIHRoZSBlbGVtZW50IHdpbGxcbiAgICAvLyBiZSByZW1vdmVkIGZyb20gdGhlIERPTSBhbnl3YXk/XG4gICAgcmV0dXJuIGN1cnJlbnRBbmltYXRpb24uZXZlbnQgPT09ICdsZWF2ZScgJiYgbmV3QW5pbWF0aW9uLnN0cnVjdHVyYWw7XG4gIH0pO1xuXG4gIHJ1bGVzLnNraXAucHVzaChmdW5jdGlvbihuZXdBbmltYXRpb24sIGN1cnJlbnRBbmltYXRpb24pIHtcbiAgICAvLyBpZiB0aGVyZSBpcyBhbiBvbmdvaW5nIGN1cnJlbnQgYW5pbWF0aW9uIHRoZW4gZG9uJ3QgZXZlbiBib3RoZXIgcnVubmluZyB0aGUgY2xhc3MtYmFzZWQgYW5pbWF0aW9uXG4gICAgcmV0dXJuIGN1cnJlbnRBbmltYXRpb24uc3RydWN0dXJhbCAmJiBjdXJyZW50QW5pbWF0aW9uLnN0YXRlID09PSBSVU5OSU5HX1NUQVRFICYmICFuZXdBbmltYXRpb24uc3RydWN0dXJhbDtcbiAgfSk7XG5cbiAgcnVsZXMuY2FuY2VsLnB1c2goZnVuY3Rpb24obmV3QW5pbWF0aW9uLCBjdXJyZW50QW5pbWF0aW9uKSB7XG4gICAgLy8gdGhlcmUgY2FuIG5ldmVyIGJlIHR3byBzdHJ1Y3R1cmFsIGFuaW1hdGlvbnMgcnVubmluZyBhdCB0aGUgc2FtZSB0aW1lXG4gICAgcmV0dXJuIGN1cnJlbnRBbmltYXRpb24uc3RydWN0dXJhbCAmJiBuZXdBbmltYXRpb24uc3RydWN0dXJhbDtcbiAgfSk7XG5cbiAgcnVsZXMuY2FuY2VsLnB1c2goZnVuY3Rpb24obmV3QW5pbWF0aW9uLCBjdXJyZW50QW5pbWF0aW9uKSB7XG4gICAgLy8gaWYgdGhlIHByZXZpb3VzIGFuaW1hdGlvbiBpcyBhbHJlYWR5IHJ1bm5pbmcsIGJ1dCB0aGUgbmV3IGFuaW1hdGlvbiB3aWxsXG4gICAgLy8gYmUgdHJpZ2dlcmVkLCBidXQgdGhlIG5ldyBhbmltYXRpb24gaXMgc3RydWN0dXJhbFxuICAgIHJldHVybiBjdXJyZW50QW5pbWF0aW9uLnN0YXRlID09PSBSVU5OSU5HX1NUQVRFICYmIG5ld0FuaW1hdGlvbi5zdHJ1Y3R1cmFsO1xuICB9KTtcblxuICBydWxlcy5jYW5jZWwucHVzaChmdW5jdGlvbihuZXdBbmltYXRpb24sIGN1cnJlbnRBbmltYXRpb24pIHtcbiAgICAvLyBjYW5jZWwgdGhlIGFuaW1hdGlvbiBpZiBjbGFzc2VzIGFkZGVkIC8gcmVtb3ZlZCBpbiBib3RoIGFuaW1hdGlvbiBjYW5jZWwgZWFjaCBvdGhlciBvdXQsXG4gICAgLy8gYnV0IG9ubHkgaWYgdGhlIGN1cnJlbnQgYW5pbWF0aW9uIGlzbid0IHN0cnVjdHVyYWxcblxuICAgIGlmIChjdXJyZW50QW5pbWF0aW9uLnN0cnVjdHVyYWwpIHJldHVybiBmYWxzZTtcblxuICAgIHZhciBuQSA9IG5ld0FuaW1hdGlvbi5hZGRDbGFzcztcbiAgICB2YXIgblIgPSBuZXdBbmltYXRpb24ucmVtb3ZlQ2xhc3M7XG4gICAgdmFyIGNBID0gY3VycmVudEFuaW1hdGlvbi5hZGRDbGFzcztcbiAgICB2YXIgY1IgPSBjdXJyZW50QW5pbWF0aW9uLnJlbW92ZUNsYXNzO1xuXG4gICAgLy8gZWFybHkgZGV0ZWN0aW9uIHRvIHNhdmUgdGhlIGdsb2JhbCBDUFUgc2hvcnRhZ2UgOilcbiAgICBpZiAoKGlzVW5kZWZpbmVkKG5BKSAmJiBpc1VuZGVmaW5lZChuUikpIHx8IChpc1VuZGVmaW5lZChjQSkgJiYgaXNVbmRlZmluZWQoY1IpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBoYXNNYXRjaGluZ0NsYXNzZXMobkEsIGNSKSB8fCBoYXNNYXRjaGluZ0NsYXNzZXMoblIsIGNBKTtcbiAgfSk7XG5cbiAgdGhpcy4kZ2V0ID0gWyckJHJBRicsICckcm9vdFNjb3BlJywgJyRyb290RWxlbWVudCcsICckZG9jdW1lbnQnLCAnJCRNYXAnLFxuICAgICAgICAgICAgICAgJyQkYW5pbWF0aW9uJywgJyQkQW5pbWF0ZVJ1bm5lcicsICckdGVtcGxhdGVSZXF1ZXN0JywgJyQkanFMaXRlJywgJyQkZm9yY2VSZWZsb3cnLFxuICAgICAgICAgICAgICAgJyQkaXNEb2N1bWVudEhpZGRlbicsXG4gICAgICAgZnVuY3Rpb24oJCRyQUYsICAgJHJvb3RTY29wZSwgICAkcm9vdEVsZW1lbnQsICAgJGRvY3VtZW50LCAgICQkTWFwLFxuICAgICAgICAgICAgICAgICQkYW5pbWF0aW9uLCAgICQkQW5pbWF0ZVJ1bm5lciwgICAkdGVtcGxhdGVSZXF1ZXN0LCAgICQkanFMaXRlLCAgICQkZm9yY2VSZWZsb3csXG4gICAgICAgICAgICAgICAgJCRpc0RvY3VtZW50SGlkZGVuKSB7XG5cbiAgICB2YXIgYWN0aXZlQW5pbWF0aW9uc0xvb2t1cCA9IG5ldyAkJE1hcCgpO1xuICAgIHZhciBkaXNhYmxlZEVsZW1lbnRzTG9va3VwID0gbmV3ICQkTWFwKCk7XG4gICAgdmFyIGFuaW1hdGlvbnNFbmFibGVkID0gbnVsbDtcblxuICAgIGZ1bmN0aW9uIHBvc3REaWdlc3RUYXNrRmFjdG9yeSgpIHtcbiAgICAgIHZhciBwb3N0RGlnZXN0Q2FsbGVkID0gZmFsc2U7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oZm4pIHtcbiAgICAgICAgLy8gd2Ugb25seSBpc3N1ZSBhIGNhbGwgdG8gcG9zdERpZ2VzdCBiZWZvcmVcbiAgICAgICAgLy8gaXQgaGFzIGZpcnN0IHBhc3NlZC4gVGhpcyBwcmV2ZW50cyBhbnkgY2FsbGJhY2tzXG4gICAgICAgIC8vIGZyb20gbm90IGZpcmluZyBvbmNlIHRoZSBhbmltYXRpb24gaGFzIGNvbXBsZXRlZFxuICAgICAgICAvLyBzaW5jZSBpdCB3aWxsIGJlIG91dCBvZiB0aGUgZGlnZXN0IGN5Y2xlLlxuICAgICAgICBpZiAocG9zdERpZ2VzdENhbGxlZCkge1xuICAgICAgICAgIGZuKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgJHJvb3RTY29wZS4kJHBvc3REaWdlc3QoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBwb3N0RGlnZXN0Q2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gV2FpdCB1bnRpbCBhbGwgZGlyZWN0aXZlIGFuZCByb3V0ZS1yZWxhdGVkIHRlbXBsYXRlcyBhcmUgZG93bmxvYWRlZCBhbmRcbiAgICAvLyBjb21waWxlZC4gVGhlICR0ZW1wbGF0ZVJlcXVlc3QudG90YWxQZW5kaW5nUmVxdWVzdHMgdmFyaWFibGUga2VlcHMgdHJhY2sgb2ZcbiAgICAvLyBhbGwgb2YgdGhlIHJlbW90ZSB0ZW1wbGF0ZXMgYmVpbmcgY3VycmVudGx5IGRvd25sb2FkZWQuIElmIHRoZXJlIGFyZSBub1xuICAgIC8vIHRlbXBsYXRlcyBjdXJyZW50bHkgZG93bmxvYWRpbmcgdGhlbiB0aGUgd2F0Y2hlciB3aWxsIHN0aWxsIGZpcmUgYW55d2F5LlxuICAgIHZhciBkZXJlZ2lzdGVyV2F0Y2ggPSAkcm9vdFNjb3BlLiR3YXRjaChcbiAgICAgIGZ1bmN0aW9uKCkgeyByZXR1cm4gJHRlbXBsYXRlUmVxdWVzdC50b3RhbFBlbmRpbmdSZXF1ZXN0cyA9PT0gMDsgfSxcbiAgICAgIGZ1bmN0aW9uKGlzRW1wdHkpIHtcbiAgICAgICAgaWYgKCFpc0VtcHR5KSByZXR1cm47XG4gICAgICAgIGRlcmVnaXN0ZXJXYXRjaCgpO1xuXG4gICAgICAgIC8vIE5vdyB0aGF0IGFsbCB0ZW1wbGF0ZXMgaGF2ZSBiZWVuIGRvd25sb2FkZWQsICRhbmltYXRlIHdpbGwgd2FpdCB1bnRpbFxuICAgICAgICAvLyB0aGUgcG9zdCBkaWdlc3QgcXVldWUgaXMgZW1wdHkgYmVmb3JlIGVuYWJsaW5nIGFuaW1hdGlvbnMuIEJ5IGhhdmluZyB0d29cbiAgICAgICAgLy8gY2FsbHMgdG8gJHBvc3REaWdlc3QgY2FsbHMgd2UgY2FuIGVuc3VyZSB0aGF0IHRoZSBmbGFnIGlzIGVuYWJsZWQgYXQgdGhlXG4gICAgICAgIC8vIHZlcnkgZW5kIG9mIHRoZSBwb3N0IGRpZ2VzdCBxdWV1ZS4gU2luY2UgYWxsIG9mIHRoZSBhbmltYXRpb25zIGluICRhbmltYXRlXG4gICAgICAgIC8vIHVzZSAkcG9zdERpZ2VzdCwgaXQncyBpbXBvcnRhbnQgdGhhdCB0aGUgY29kZSBiZWxvdyBleGVjdXRlcyBhdCB0aGUgZW5kLlxuICAgICAgICAvLyBUaGlzIGJhc2ljYWxseSBtZWFucyB0aGF0IHRoZSBwYWdlIGlzIGZ1bGx5IGRvd25sb2FkZWQgYW5kIGNvbXBpbGVkIGJlZm9yZVxuICAgICAgICAvLyBhbnkgYW5pbWF0aW9ucyBhcmUgdHJpZ2dlcmVkLlxuICAgICAgICAkcm9vdFNjb3BlLiQkcG9zdERpZ2VzdChmdW5jdGlvbigpIHtcbiAgICAgICAgICAkcm9vdFNjb3BlLiQkcG9zdERpZ2VzdChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIHdlIGNoZWNrIGZvciBudWxsIGRpcmVjdGx5IGluIHRoZSBldmVudCB0aGF0IHRoZSBhcHBsaWNhdGlvbiBhbHJlYWR5IGNhbGxlZFxuICAgICAgICAgICAgLy8gLmVuYWJsZWQoKSB3aXRoIHdoYXRldmVyIGFyZ3VtZW50cyB0aGF0IGl0IHByb3ZpZGVkIGl0IHdpdGhcbiAgICAgICAgICAgIGlmIChhbmltYXRpb25zRW5hYmxlZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICBhbmltYXRpb25zRW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICk7XG5cbiAgICB2YXIgY2FsbGJhY2tSZWdpc3RyeSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAvLyByZW1lbWJlciB0aGF0IHRoZSBgY3VzdG9tRmlsdGVyYC9gY2xhc3NOYW1lRmlsdGVyYCBhcmUgc2V0IGR1cmluZyB0aGVcbiAgICAvLyBwcm92aWRlci9jb25maWcgc3RhZ2UgdGhlcmVmb3JlIHdlIGNhbiBvcHRpbWl6ZSBoZXJlIGFuZCBzZXR1cCBoZWxwZXIgZnVuY3Rpb25zXG4gICAgdmFyIGN1c3RvbUZpbHRlciA9ICRhbmltYXRlUHJvdmlkZXIuY3VzdG9tRmlsdGVyKCk7XG4gICAgdmFyIGNsYXNzTmFtZUZpbHRlciA9ICRhbmltYXRlUHJvdmlkZXIuY2xhc3NOYW1lRmlsdGVyKCk7XG4gICAgdmFyIHJldHVyblRydWUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRydWU7IH07XG5cbiAgICB2YXIgaXNBbmltYXRhYmxlQnlGaWx0ZXIgPSBjdXN0b21GaWx0ZXIgfHwgcmV0dXJuVHJ1ZTtcbiAgICB2YXIgaXNBbmltYXRhYmxlQ2xhc3NOYW1lID0gIWNsYXNzTmFtZUZpbHRlciA/IHJldHVyblRydWUgOiBmdW5jdGlvbihub2RlLCBvcHRpb25zKSB7XG4gICAgICB2YXIgY2xhc3NOYW1lID0gW25vZGUuZ2V0QXR0cmlidXRlKCdjbGFzcycpLCBvcHRpb25zLmFkZENsYXNzLCBvcHRpb25zLnJlbW92ZUNsYXNzXS5qb2luKCcgJyk7XG4gICAgICByZXR1cm4gY2xhc3NOYW1lRmlsdGVyLnRlc3QoY2xhc3NOYW1lKTtcbiAgICB9O1xuXG4gICAgdmFyIGFwcGx5QW5pbWF0aW9uQ2xhc3NlcyA9IGFwcGx5QW5pbWF0aW9uQ2xhc3Nlc0ZhY3RvcnkoJCRqcUxpdGUpO1xuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplQW5pbWF0aW9uRGV0YWlscyhlbGVtZW50LCBhbmltYXRpb24pIHtcbiAgICAgIHJldHVybiBtZXJnZUFuaW1hdGlvbkRldGFpbHMoZWxlbWVudCwgYW5pbWF0aW9uLCB7fSk7XG4gICAgfVxuXG4gICAgLy8gSUU5LTExIGhhcyBubyBtZXRob2QgXCJjb250YWluc1wiIGluIFNWRyBlbGVtZW50IGFuZCBpbiBOb2RlLnByb3RvdHlwZS4gQnVnICMxMDI1OS5cbiAgICB2YXIgY29udGFpbnMgPSB3aW5kb3cuTm9kZS5wcm90b3R5cGUuY29udGFpbnMgfHwgLyoqIEB0aGlzICovIGZ1bmN0aW9uKGFyZykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWJpdHdpc2VcbiAgICAgIHJldHVybiB0aGlzID09PSBhcmcgfHwgISEodGhpcy5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihhcmcpICYgMTYpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBmaW5kQ2FsbGJhY2tzKHRhcmdldFBhcmVudE5vZGUsIHRhcmdldE5vZGUsIGV2ZW50KSB7XG4gICAgICB2YXIgbWF0Y2hlcyA9IFtdO1xuICAgICAgdmFyIGVudHJpZXMgPSBjYWxsYmFja1JlZ2lzdHJ5W2V2ZW50XTtcbiAgICAgIGlmIChlbnRyaWVzKSB7XG4gICAgICAgIGZvckVhY2goZW50cmllcywgZnVuY3Rpb24oZW50cnkpIHtcbiAgICAgICAgICBpZiAoY29udGFpbnMuY2FsbChlbnRyeS5ub2RlLCB0YXJnZXROb2RlKSkge1xuICAgICAgICAgICAgbWF0Y2hlcy5wdXNoKGVudHJ5LmNhbGxiYWNrKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGV2ZW50ID09PSAnbGVhdmUnICYmIGNvbnRhaW5zLmNhbGwoZW50cnkubm9kZSwgdGFyZ2V0UGFyZW50Tm9kZSkpIHtcbiAgICAgICAgICAgIG1hdGNoZXMucHVzaChlbnRyeS5jYWxsYmFjayk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG1hdGNoZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZmlsdGVyRnJvbVJlZ2lzdHJ5KGxpc3QsIG1hdGNoQ29udGFpbmVyLCBtYXRjaENhbGxiYWNrKSB7XG4gICAgICB2YXIgY29udGFpbmVyTm9kZSA9IGV4dHJhY3RFbGVtZW50Tm9kZShtYXRjaENvbnRhaW5lcik7XG4gICAgICByZXR1cm4gbGlzdC5maWx0ZXIoZnVuY3Rpb24oZW50cnkpIHtcbiAgICAgICAgdmFyIGlzTWF0Y2ggPSBlbnRyeS5ub2RlID09PSBjb250YWluZXJOb2RlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoIW1hdGNoQ2FsbGJhY2sgfHwgZW50cnkuY2FsbGJhY2sgPT09IG1hdGNoQ2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gIWlzTWF0Y2g7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhbnVwRXZlbnRMaXN0ZW5lcnMocGhhc2UsIG5vZGUpIHtcbiAgICAgIGlmIChwaGFzZSA9PT0gJ2Nsb3NlJyAmJiAhbm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgIC8vIElmIHRoZSBlbGVtZW50IGlzIG5vdCBhdHRhY2hlZCB0byBhIHBhcmVudE5vZGUsIGl0IGhhcyBiZWVuIHJlbW92ZWQgYnlcbiAgICAgICAgLy8gdGhlIGRvbU9wZXJhdGlvbiwgYW5kIHdlIGNhbiBzYWZlbHkgcmVtb3ZlIHRoZSBldmVudCBjYWxsYmFja3NcbiAgICAgICAgJGFuaW1hdGUub2ZmKG5vZGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciAkYW5pbWF0ZSA9IHtcbiAgICAgIG9uOiBmdW5jdGlvbihldmVudCwgY29udGFpbmVyLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgbm9kZSA9IGV4dHJhY3RFbGVtZW50Tm9kZShjb250YWluZXIpO1xuICAgICAgICBjYWxsYmFja1JlZ2lzdHJ5W2V2ZW50XSA9IGNhbGxiYWNrUmVnaXN0cnlbZXZlbnRdIHx8IFtdO1xuICAgICAgICBjYWxsYmFja1JlZ2lzdHJ5W2V2ZW50XS5wdXNoKHtcbiAgICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBSZW1vdmUgdGhlIGNhbGxiYWNrIHdoZW4gdGhlIGVsZW1lbnQgaXMgcmVtb3ZlZCBmcm9tIHRoZSBET01cbiAgICAgICAganFMaXRlKGNvbnRhaW5lcikub24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGFuaW1hdGlvbkRldGFpbHMgPSBhY3RpdmVBbmltYXRpb25zTG9va3VwLmdldChub2RlKTtcblxuICAgICAgICAgIGlmICghYW5pbWF0aW9uRGV0YWlscykge1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBhbiBhbmltYXRpb24gb25nb2luZywgdGhlIGNhbGxiYWNrIGNhbGxpbmcgY29kZSB3aWxsIHJlbW92ZVxuICAgICAgICAgICAgLy8gdGhlIGV2ZW50IGxpc3RlbmVycy4gSWYgd2UnZCByZW1vdmUgaGVyZSwgdGhlIGNhbGxiYWNrcyB3b3VsZCBiZSByZW1vdmVkXG4gICAgICAgICAgICAvLyBiZWZvcmUgdGhlIGFuaW1hdGlvbiBlbmRzXG4gICAgICAgICAgICAkYW5pbWF0ZS5vZmYoZXZlbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LFxuXG4gICAgICBvZmY6IGZ1bmN0aW9uKGV2ZW50LCBjb250YWluZXIsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxICYmICFpc1N0cmluZyhhcmd1bWVudHNbMF0pKSB7XG4gICAgICAgICAgY29udGFpbmVyID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgIGZvciAodmFyIGV2ZW50VHlwZSBpbiBjYWxsYmFja1JlZ2lzdHJ5KSB7XG4gICAgICAgICAgICBjYWxsYmFja1JlZ2lzdHJ5W2V2ZW50VHlwZV0gPSBmaWx0ZXJGcm9tUmVnaXN0cnkoY2FsbGJhY2tSZWdpc3RyeVtldmVudFR5cGVdLCBjb250YWluZXIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbnRyaWVzID0gY2FsbGJhY2tSZWdpc3RyeVtldmVudF07XG4gICAgICAgIGlmICghZW50cmllcykgcmV0dXJuO1xuXG4gICAgICAgIGNhbGxiYWNrUmVnaXN0cnlbZXZlbnRdID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gMVxuICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICA6IGZpbHRlckZyb21SZWdpc3RyeShlbnRyaWVzLCBjb250YWluZXIsIGNhbGxiYWNrKTtcbiAgICAgIH0sXG5cbiAgICAgIHBpbjogZnVuY3Rpb24oZWxlbWVudCwgcGFyZW50RWxlbWVudCkge1xuICAgICAgICBhc3NlcnRBcmcoaXNFbGVtZW50KGVsZW1lbnQpLCAnZWxlbWVudCcsICdub3QgYW4gZWxlbWVudCcpO1xuICAgICAgICBhc3NlcnRBcmcoaXNFbGVtZW50KHBhcmVudEVsZW1lbnQpLCAncGFyZW50RWxlbWVudCcsICdub3QgYW4gZWxlbWVudCcpO1xuICAgICAgICBlbGVtZW50LmRhdGEoTkdfQU5JTUFURV9QSU5fREFUQSwgcGFyZW50RWxlbWVudCk7XG4gICAgICB9LFxuXG4gICAgICBwdXNoOiBmdW5jdGlvbihlbGVtZW50LCBldmVudCwgb3B0aW9ucywgZG9tT3BlcmF0aW9uKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICBvcHRpb25zLmRvbU9wZXJhdGlvbiA9IGRvbU9wZXJhdGlvbjtcbiAgICAgICAgcmV0dXJuIHF1ZXVlQW5pbWF0aW9uKGVsZW1lbnQsIGV2ZW50LCBvcHRpb25zKTtcbiAgICAgIH0sXG5cbiAgICAgIC8vIHRoaXMgbWV0aG9kIGhhcyBmb3VyIHNpZ25hdHVyZXM6XG4gICAgICAvLyAgKCkgLSBnbG9iYWwgZ2V0dGVyXG4gICAgICAvLyAgKGJvb2wpIC0gZ2xvYmFsIHNldHRlclxuICAgICAgLy8gIChlbGVtZW50KSAtIGVsZW1lbnQgZ2V0dGVyXG4gICAgICAvLyAgKGVsZW1lbnQsIGJvb2wpIC0gZWxlbWVudCBzZXR0ZXI8RjM3PlxuICAgICAgZW5hYmxlZDogZnVuY3Rpb24oZWxlbWVudCwgYm9vbCkge1xuICAgICAgICB2YXIgYXJnQ291bnQgPSBhcmd1bWVudHMubGVuZ3RoO1xuXG4gICAgICAgIGlmIChhcmdDb3VudCA9PT0gMCkge1xuICAgICAgICAgIC8vICgpIC0gR2xvYmFsIGdldHRlclxuICAgICAgICAgIGJvb2wgPSAhIWFuaW1hdGlvbnNFbmFibGVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBoYXNFbGVtZW50ID0gaXNFbGVtZW50KGVsZW1lbnQpO1xuXG4gICAgICAgICAgaWYgKCFoYXNFbGVtZW50KSB7XG4gICAgICAgICAgICAvLyAoYm9vbCkgLSBHbG9iYWwgc2V0dGVyXG4gICAgICAgICAgICBib29sID0gYW5pbWF0aW9uc0VuYWJsZWQgPSAhIWVsZW1lbnQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gZ2V0RG9tTm9kZShlbGVtZW50KTtcblxuICAgICAgICAgICAgaWYgKGFyZ0NvdW50ID09PSAxKSB7XG4gICAgICAgICAgICAgIC8vIChlbGVtZW50KSAtIEVsZW1lbnQgZ2V0dGVyXG4gICAgICAgICAgICAgIGJvb2wgPSAhZGlzYWJsZWRFbGVtZW50c0xvb2t1cC5nZXQobm9kZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyAoZWxlbWVudCwgYm9vbCkgLSBFbGVtZW50IHNldHRlclxuICAgICAgICAgICAgICBkaXNhYmxlZEVsZW1lbnRzTG9va3VwLnNldChub2RlLCAhYm9vbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJvb2w7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiAkYW5pbWF0ZTtcblxuICAgIGZ1bmN0aW9uIHF1ZXVlQW5pbWF0aW9uKG9yaWdpbmFsRWxlbWVudCwgZXZlbnQsIGluaXRpYWxPcHRpb25zKSB7XG4gICAgICAvLyB3ZSBhbHdheXMgbWFrZSBhIGNvcHkgb2YgdGhlIG9wdGlvbnMgc2luY2VcbiAgICAgIC8vIHRoZXJlIHNob3VsZCBuZXZlciBiZSBhbnkgc2lkZSBlZmZlY3RzIG9uXG4gICAgICAvLyB0aGUgaW5wdXQgZGF0YSB3aGVuIHJ1bm5pbmcgYCRhbmltYXRlQ3NzYC5cbiAgICAgIHZhciBvcHRpb25zID0gY29weShpbml0aWFsT3B0aW9ucyk7XG5cbiAgICAgIHZhciBlbGVtZW50ID0gc3RyaXBDb21tZW50c0Zyb21FbGVtZW50KG9yaWdpbmFsRWxlbWVudCk7XG4gICAgICB2YXIgbm9kZSA9IGdldERvbU5vZGUoZWxlbWVudCk7XG4gICAgICB2YXIgcGFyZW50Tm9kZSA9IG5vZGUgJiYgbm9kZS5wYXJlbnROb2RlO1xuXG4gICAgICBvcHRpb25zID0gcHJlcGFyZUFuaW1hdGlvbk9wdGlvbnMob3B0aW9ucyk7XG5cbiAgICAgIC8vIHdlIGNyZWF0ZSBhIGZha2UgcnVubmVyIHdpdGggYSB3b3JraW5nIHByb21pc2UuXG4gICAgICAvLyBUaGVzZSBtZXRob2RzIHdpbGwgYmVjb21lIGF2YWlsYWJsZSBhZnRlciB0aGUgZGlnZXN0IGhhcyBwYXNzZWRcbiAgICAgIHZhciBydW5uZXIgPSBuZXcgJCRBbmltYXRlUnVubmVyKCk7XG5cbiAgICAgIC8vIHRoaXMgaXMgdXNlZCB0byB0cmlnZ2VyIGNhbGxiYWNrcyBpbiBwb3N0RGlnZXN0IG1vZGVcbiAgICAgIHZhciBydW5Jbk5leHRQb3N0RGlnZXN0T3JOb3cgPSBwb3N0RGlnZXN0VGFza0ZhY3RvcnkoKTtcblxuICAgICAgaWYgKGlzQXJyYXkob3B0aW9ucy5hZGRDbGFzcykpIHtcbiAgICAgICAgb3B0aW9ucy5hZGRDbGFzcyA9IG9wdGlvbnMuYWRkQ2xhc3Muam9pbignICcpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5hZGRDbGFzcyAmJiAhaXNTdHJpbmcob3B0aW9ucy5hZGRDbGFzcykpIHtcbiAgICAgICAgb3B0aW9ucy5hZGRDbGFzcyA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0FycmF5KG9wdGlvbnMucmVtb3ZlQ2xhc3MpKSB7XG4gICAgICAgIG9wdGlvbnMucmVtb3ZlQ2xhc3MgPSBvcHRpb25zLnJlbW92ZUNsYXNzLmpvaW4oJyAnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbnMucmVtb3ZlQ2xhc3MgJiYgIWlzU3RyaW5nKG9wdGlvbnMucmVtb3ZlQ2xhc3MpKSB7XG4gICAgICAgIG9wdGlvbnMucmVtb3ZlQ2xhc3MgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9ucy5mcm9tICYmICFpc09iamVjdChvcHRpb25zLmZyb20pKSB7XG4gICAgICAgIG9wdGlvbnMuZnJvbSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLnRvICYmICFpc09iamVjdChvcHRpb25zLnRvKSkge1xuICAgICAgICBvcHRpb25zLnRvID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgYW5pbWF0aW9ucyBhcmUgaGFyZC1kaXNhYmxlZCBmb3IgdGhlIHdob2xlIGFwcGxpY2F0aW9uIHRoZXJlIGlzIG5vIG5lZWQgdG8gY29udGludWUuXG4gICAgICAvLyBUaGVyZSBhcmUgYWxzbyBzaXR1YXRpb25zIHdoZXJlIGEgZGlyZWN0aXZlIGlzc3VlcyBhbiBhbmltYXRpb24gZm9yIGEganFMaXRlIHdyYXBwZXIgdGhhdFxuICAgICAgLy8gY29udGFpbnMgb25seSBjb21tZW50IG5vZGVzLiBJbiB0aGlzIGNhc2UsIHRoZXJlIGlzIG5vIHdheSB3ZSBjYW4gcGVyZm9ybSBhbiBhbmltYXRpb24uXG4gICAgICBpZiAoIWFuaW1hdGlvbnNFbmFibGVkIHx8XG4gICAgICAgICAgIW5vZGUgfHxcbiAgICAgICAgICAhaXNBbmltYXRhYmxlQnlGaWx0ZXIobm9kZSwgZXZlbnQsIGluaXRpYWxPcHRpb25zKSB8fFxuICAgICAgICAgICFpc0FuaW1hdGFibGVDbGFzc05hbWUobm9kZSwgb3B0aW9ucykpIHtcbiAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgcmV0dXJuIHJ1bm5lcjtcbiAgICAgIH1cblxuICAgICAgdmFyIGlzU3RydWN0dXJhbCA9IFsnZW50ZXInLCAnbW92ZScsICdsZWF2ZSddLmluZGV4T2YoZXZlbnQpID49IDA7XG5cbiAgICAgIHZhciBkb2N1bWVudEhpZGRlbiA9ICQkaXNEb2N1bWVudEhpZGRlbigpO1xuXG4gICAgICAvLyBUaGlzIGlzIGEgaGFyZCBkaXNhYmxlIG9mIGFsbCBhbmltYXRpb25zIHRoZSBlbGVtZW50IGl0c2VsZiwgdGhlcmVmb3JlICB0aGVyZSBpcyBubyBuZWVkIHRvXG4gICAgICAvLyBjb250aW51ZSBmdXJ0aGVyIHBhc3QgdGhpcyBwb2ludCBpZiBub3QgZW5hYmxlZFxuICAgICAgLy8gQW5pbWF0aW9ucyBhcmUgYWxzbyBkaXNhYmxlZCBpZiB0aGUgZG9jdW1lbnQgaXMgY3VycmVudGx5IGhpZGRlbiAocGFnZSBpcyBub3QgdmlzaWJsZVxuICAgICAgLy8gdG8gdGhlIHVzZXIpLCBiZWNhdXNlIGJyb3dzZXJzIHNsb3cgZG93biBvciBkbyBub3QgZmx1c2ggY2FsbHMgdG8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgICB2YXIgc2tpcEFuaW1hdGlvbnMgPSBkb2N1bWVudEhpZGRlbiB8fCBkaXNhYmxlZEVsZW1lbnRzTG9va3VwLmdldChub2RlKTtcbiAgICAgIHZhciBleGlzdGluZ0FuaW1hdGlvbiA9ICghc2tpcEFuaW1hdGlvbnMgJiYgYWN0aXZlQW5pbWF0aW9uc0xvb2t1cC5nZXQobm9kZSkpIHx8IHt9O1xuICAgICAgdmFyIGhhc0V4aXN0aW5nQW5pbWF0aW9uID0gISFleGlzdGluZ0FuaW1hdGlvbi5zdGF0ZTtcblxuICAgICAgLy8gdGhlcmUgaXMgbm8gcG9pbnQgaW4gdHJhdmVyc2luZyB0aGUgc2FtZSBjb2xsZWN0aW9uIG9mIHBhcmVudCBhbmNlc3RvcnMgaWYgYSBmb2xsb3d1cFxuICAgICAgLy8gYW5pbWF0aW9uIHdpbGwgYmUgcnVuIG9uIHRoZSBzYW1lIGVsZW1lbnQgdGhhdCBhbHJlYWR5IGRpZCBhbGwgdGhhdCBjaGVja2luZyB3b3JrXG4gICAgICBpZiAoIXNraXBBbmltYXRpb25zICYmICghaGFzRXhpc3RpbmdBbmltYXRpb24gfHwgZXhpc3RpbmdBbmltYXRpb24uc3RhdGUgIT09IFBSRV9ESUdFU1RfU1RBVEUpKSB7XG4gICAgICAgIHNraXBBbmltYXRpb25zID0gIWFyZUFuaW1hdGlvbnNBbGxvd2VkKG5vZGUsIHBhcmVudE5vZGUsIGV2ZW50KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNraXBBbmltYXRpb25zKSB7XG4gICAgICAgIC8vIENhbGxiYWNrcyBzaG91bGQgZmlyZSBldmVuIGlmIHRoZSBkb2N1bWVudCBpcyBoaWRkZW4gKHJlZ3Jlc3Npb24gZml4IGZvciBpc3N1ZSAjMTQxMjApXG4gICAgICAgIGlmIChkb2N1bWVudEhpZGRlbikgbm90aWZ5UHJvZ3Jlc3MocnVubmVyLCBldmVudCwgJ3N0YXJ0Jyk7XG4gICAgICAgIGNsb3NlKCk7XG4gICAgICAgIGlmIChkb2N1bWVudEhpZGRlbikgbm90aWZ5UHJvZ3Jlc3MocnVubmVyLCBldmVudCwgJ2Nsb3NlJyk7XG4gICAgICAgIHJldHVybiBydW5uZXI7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc1N0cnVjdHVyYWwpIHtcbiAgICAgICAgY2xvc2VDaGlsZEFuaW1hdGlvbnMobm9kZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXdBbmltYXRpb24gPSB7XG4gICAgICAgIHN0cnVjdHVyYWw6IGlzU3RydWN0dXJhbCxcbiAgICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgICBhZGRDbGFzczogb3B0aW9ucy5hZGRDbGFzcyxcbiAgICAgICAgcmVtb3ZlQ2xhc3M6IG9wdGlvbnMucmVtb3ZlQ2xhc3MsXG4gICAgICAgIGNsb3NlOiBjbG9zZSxcbiAgICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgICAgcnVubmVyOiBydW5uZXJcbiAgICAgIH07XG5cbiAgICAgIGlmIChoYXNFeGlzdGluZ0FuaW1hdGlvbikge1xuICAgICAgICB2YXIgc2tpcEFuaW1hdGlvbkZsYWcgPSBpc0FsbG93ZWQoJ3NraXAnLCBuZXdBbmltYXRpb24sIGV4aXN0aW5nQW5pbWF0aW9uKTtcbiAgICAgICAgaWYgKHNraXBBbmltYXRpb25GbGFnKSB7XG4gICAgICAgICAgaWYgKGV4aXN0aW5nQW5pbWF0aW9uLnN0YXRlID09PSBSVU5OSU5HX1NUQVRFKSB7XG4gICAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHJ1bm5lcjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWVyZ2VBbmltYXRpb25EZXRhaWxzKGVsZW1lbnQsIGV4aXN0aW5nQW5pbWF0aW9uLCBuZXdBbmltYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIGV4aXN0aW5nQW5pbWF0aW9uLnJ1bm5lcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNhbmNlbEFuaW1hdGlvbkZsYWcgPSBpc0FsbG93ZWQoJ2NhbmNlbCcsIG5ld0FuaW1hdGlvbiwgZXhpc3RpbmdBbmltYXRpb24pO1xuICAgICAgICBpZiAoY2FuY2VsQW5pbWF0aW9uRmxhZykge1xuICAgICAgICAgIGlmIChleGlzdGluZ0FuaW1hdGlvbi5zdGF0ZSA9PT0gUlVOTklOR19TVEFURSkge1xuICAgICAgICAgICAgLy8gdGhpcyB3aWxsIGVuZCB0aGUgYW5pbWF0aW9uIHJpZ2h0IGF3YXkgYW5kIGl0IGlzIHNhZmVcbiAgICAgICAgICAgIC8vIHRvIGRvIHNvIHNpbmNlIHRoZSBhbmltYXRpb24gaXMgYWxyZWFkeSBydW5uaW5nIGFuZCB0aGVcbiAgICAgICAgICAgIC8vIHJ1bm5lciBjYWxsYmFjayBjb2RlIHdpbGwgcnVuIGluIGFzeW5jXG4gICAgICAgICAgICBleGlzdGluZ0FuaW1hdGlvbi5ydW5uZXIuZW5kKCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChleGlzdGluZ0FuaW1hdGlvbi5zdHJ1Y3R1cmFsKSB7XG4gICAgICAgICAgICAvLyB0aGlzIG1lYW5zIHRoYXQgdGhlIGFuaW1hdGlvbiBpcyBxdWV1ZWQgaW50byBhIGRpZ2VzdCwgYnV0XG4gICAgICAgICAgICAvLyBoYXNuJ3Qgc3RhcnRlZCB5ZXQuIFRoZXJlZm9yZSBpdCBpcyBzYWZlIHRvIHJ1biB0aGUgY2xvc2VcbiAgICAgICAgICAgIC8vIG1ldGhvZCB3aGljaCB3aWxsIGNhbGwgdGhlIHJ1bm5lciBtZXRob2RzIGluIGFzeW5jLlxuICAgICAgICAgICAgZXhpc3RpbmdBbmltYXRpb24uY2xvc2UoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdGhpcyB3aWxsIG1lcmdlIHRoZSBuZXcgYW5pbWF0aW9uIG9wdGlvbnMgaW50byBleGlzdGluZyBhbmltYXRpb24gb3B0aW9uc1xuICAgICAgICAgICAgbWVyZ2VBbmltYXRpb25EZXRhaWxzKGVsZW1lbnQsIGV4aXN0aW5nQW5pbWF0aW9uLCBuZXdBbmltYXRpb24pO1xuXG4gICAgICAgICAgICByZXR1cm4gZXhpc3RpbmdBbmltYXRpb24ucnVubmVyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBhIGpvaW5lZCBhbmltYXRpb24gbWVhbnMgdGhhdCB0aGlzIGFuaW1hdGlvbiB3aWxsIHRha2Ugb3ZlciB0aGUgZXhpc3Rpbmcgb25lXG4gICAgICAgICAgLy8gc28gYW4gZXhhbXBsZSB3b3VsZCBpbnZvbHZlIGEgbGVhdmUgYW5pbWF0aW9uIHRha2luZyBvdmVyIGFuIGVudGVyLiBUaGVuIHdoZW5cbiAgICAgICAgICAvLyB0aGUgcG9zdERpZ2VzdCBraWNrcyBpbiB0aGUgZW50ZXIgd2lsbCBiZSBpZ25vcmVkLlxuICAgICAgICAgIHZhciBqb2luQW5pbWF0aW9uRmxhZyA9IGlzQWxsb3dlZCgnam9pbicsIG5ld0FuaW1hdGlvbiwgZXhpc3RpbmdBbmltYXRpb24pO1xuICAgICAgICAgIGlmIChqb2luQW5pbWF0aW9uRmxhZykge1xuICAgICAgICAgICAgaWYgKGV4aXN0aW5nQW5pbWF0aW9uLnN0YXRlID09PSBSVU5OSU5HX1NUQVRFKSB7XG4gICAgICAgICAgICAgIG5vcm1hbGl6ZUFuaW1hdGlvbkRldGFpbHMoZWxlbWVudCwgbmV3QW5pbWF0aW9uKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGFwcGx5R2VuZXJhdGVkUHJlcGFyYXRpb25DbGFzc2VzKGVsZW1lbnQsIGlzU3RydWN0dXJhbCA/IGV2ZW50IDogbnVsbCwgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgICAgZXZlbnQgPSBuZXdBbmltYXRpb24uZXZlbnQgPSBleGlzdGluZ0FuaW1hdGlvbi5ldmVudDtcbiAgICAgICAgICAgICAgb3B0aW9ucyA9IG1lcmdlQW5pbWF0aW9uRGV0YWlscyhlbGVtZW50LCBleGlzdGluZ0FuaW1hdGlvbiwgbmV3QW5pbWF0aW9uKTtcblxuICAgICAgICAgICAgICAvL3dlIHJldHVybiB0aGUgc2FtZSBydW5uZXIgc2luY2Ugb25seSB0aGUgb3B0aW9uIHZhbHVlcyBvZiB0aGlzIGFuaW1hdGlvbiB3aWxsXG4gICAgICAgICAgICAgIC8vYmUgZmVkIGludG8gdGhlIGBleGlzdGluZ0FuaW1hdGlvbmAuXG4gICAgICAgICAgICAgIHJldHVybiBleGlzdGluZ0FuaW1hdGlvbi5ydW5uZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBub3JtYWxpemF0aW9uIGluIHRoaXMgY2FzZSBtZWFucyB0aGF0IGl0IHJlbW92ZXMgcmVkdW5kYW50IENTUyBjbGFzc2VzIHRoYXRcbiAgICAgICAgLy8gYWxyZWFkeSBleGlzdCAoYWRkQ2xhc3MpIG9yIGRvIG5vdCBleGlzdCAocmVtb3ZlQ2xhc3MpIG9uIHRoZSBlbGVtZW50XG4gICAgICAgIG5vcm1hbGl6ZUFuaW1hdGlvbkRldGFpbHMoZWxlbWVudCwgbmV3QW5pbWF0aW9uKTtcbiAgICAgIH1cblxuICAgICAgLy8gd2hlbiB0aGUgb3B0aW9ucyBhcmUgbWVyZ2VkIGFuZCBjbGVhbmVkIHVwIHdlIG1heSBlbmQgdXAgbm90IGhhdmluZyB0byBkb1xuICAgICAgLy8gYW4gYW5pbWF0aW9uIGF0IGFsbCwgdGhlcmVmb3JlIHdlIHNob3VsZCBjaGVjayB0aGlzIGJlZm9yZSBpc3N1aW5nIGEgcG9zdFxuICAgICAgLy8gZGlnZXN0IGNhbGxiYWNrLiBTdHJ1Y3R1cmFsIGFuaW1hdGlvbnMgd2lsbCBhbHdheXMgcnVuIG5vIG1hdHRlciB3aGF0LlxuICAgICAgdmFyIGlzVmFsaWRBbmltYXRpb24gPSBuZXdBbmltYXRpb24uc3RydWN0dXJhbDtcbiAgICAgIGlmICghaXNWYWxpZEFuaW1hdGlvbikge1xuICAgICAgICAvLyBhbmltYXRlIChmcm9tL3RvKSBjYW4gYmUgcXVpY2tseSBjaGVja2VkIGZpcnN0LCBvdGhlcndpc2Ugd2UgY2hlY2sgaWYgYW55IGNsYXNzZXMgYXJlIHByZXNlbnRcbiAgICAgICAgaXNWYWxpZEFuaW1hdGlvbiA9IChuZXdBbmltYXRpb24uZXZlbnQgPT09ICdhbmltYXRlJyAmJiBPYmplY3Qua2V5cyhuZXdBbmltYXRpb24ub3B0aW9ucy50byB8fCB7fSkubGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCBoYXNBbmltYXRpb25DbGFzc2VzKG5ld0FuaW1hdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNWYWxpZEFuaW1hdGlvbikge1xuICAgICAgICBjbG9zZSgpO1xuICAgICAgICBjbGVhckVsZW1lbnRBbmltYXRpb25TdGF0ZShub2RlKTtcbiAgICAgICAgcmV0dXJuIHJ1bm5lcjtcbiAgICAgIH1cblxuICAgICAgLy8gdGhlIGNvdW50ZXIga2VlcHMgdHJhY2sgb2YgY2FuY2VsbGVkIGFuaW1hdGlvbnNcbiAgICAgIHZhciBjb3VudGVyID0gKGV4aXN0aW5nQW5pbWF0aW9uLmNvdW50ZXIgfHwgMCkgKyAxO1xuICAgICAgbmV3QW5pbWF0aW9uLmNvdW50ZXIgPSBjb3VudGVyO1xuXG4gICAgICBtYXJrRWxlbWVudEFuaW1hdGlvblN0YXRlKG5vZGUsIFBSRV9ESUdFU1RfU1RBVEUsIG5ld0FuaW1hdGlvbik7XG5cbiAgICAgICRyb290U2NvcGUuJCRwb3N0RGlnZXN0KGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBJdCBpcyBwb3NzaWJsZSB0aGF0IHRoZSBET00gbm9kZXMgaW5zaWRlIGBvcmlnaW5hbEVsZW1lbnRgIGhhdmUgYmVlbiByZXBsYWNlZC4gVGhpcyBjYW5cbiAgICAgICAgLy8gaGFwcGVuIGlmIHRoZSBhbmltYXRlZCBlbGVtZW50IGlzIGEgdHJhbnNjbHVkZWQgY2xvbmUgYW5kIGFsc28gaGFzIGEgYHRlbXBsYXRlVXJsYFxuICAgICAgICAvLyBkaXJlY3RpdmUgb24gaXQuIFRoZXJlZm9yZSwgd2UgbXVzdCByZWNyZWF0ZSBgZWxlbWVudGAgaW4gb3JkZXIgdG8gaW50ZXJhY3Qgd2l0aCB0aGVcbiAgICAgICAgLy8gYWN0dWFsIERPTSBub2Rlcy5cbiAgICAgICAgLy8gTm90ZTogV2Ugc3RpbGwgbmVlZCB0byB1c2UgdGhlIG9sZCBgbm9kZWAgZm9yIGNlcnRhaW4gdGhpbmdzLCBzdWNoIGFzIGxvb2tpbmcgdXAgaW5cbiAgICAgICAgLy8gICAgICAgSGFzaE1hcHMgd2hlcmUgaXQgd2FzIHVzZWQgYXMgdGhlIGtleS5cblxuICAgICAgICBlbGVtZW50ID0gc3RyaXBDb21tZW50c0Zyb21FbGVtZW50KG9yaWdpbmFsRWxlbWVudCk7XG5cbiAgICAgICAgdmFyIGFuaW1hdGlvbkRldGFpbHMgPSBhY3RpdmVBbmltYXRpb25zTG9va3VwLmdldChub2RlKTtcbiAgICAgICAgdmFyIGFuaW1hdGlvbkNhbmNlbGxlZCA9ICFhbmltYXRpb25EZXRhaWxzO1xuICAgICAgICBhbmltYXRpb25EZXRhaWxzID0gYW5pbWF0aW9uRGV0YWlscyB8fCB7fTtcblxuICAgICAgICAvLyBpZiBhZGRDbGFzcy9yZW1vdmVDbGFzcyBpcyBjYWxsZWQgYmVmb3JlIHNvbWV0aGluZyBsaWtlIGVudGVyIHRoZW4gdGhlXG4gICAgICAgIC8vIHJlZ2lzdGVyZWQgcGFyZW50IGVsZW1lbnQgbWF5IG5vdCBiZSBwcmVzZW50LiBUaGUgY29kZSBiZWxvdyB3aWxsIGVuc3VyZVxuICAgICAgICAvLyB0aGF0IGEgZmluYWwgdmFsdWUgZm9yIHBhcmVudCBlbGVtZW50IGlzIG9idGFpbmVkXG4gICAgICAgIHZhciBwYXJlbnRFbGVtZW50ID0gZWxlbWVudC5wYXJlbnQoKSB8fCBbXTtcblxuICAgICAgICAvLyBhbmltYXRlL3N0cnVjdHVyYWwvY2xhc3MtYmFzZWQgYW5pbWF0aW9ucyBhbGwgaGF2ZSByZXF1aXJlbWVudHMuIE90aGVyd2lzZSB0aGVyZVxuICAgICAgICAvLyBpcyBubyBwb2ludCBpbiBwZXJmb3JtaW5nIGFuIGFuaW1hdGlvbi4gVGhlIHBhcmVudCBub2RlIG11c3QgYWxzbyBiZSBzZXQuXG4gICAgICAgIHZhciBpc1ZhbGlkQW5pbWF0aW9uID0gcGFyZW50RWxlbWVudC5sZW5ndGggPiAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIChhbmltYXRpb25EZXRhaWxzLmV2ZW50ID09PSAnYW5pbWF0ZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IGFuaW1hdGlvbkRldGFpbHMuc3RydWN0dXJhbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgaGFzQW5pbWF0aW9uQ2xhc3NlcyhhbmltYXRpb25EZXRhaWxzKSk7XG5cbiAgICAgICAgLy8gdGhpcyBtZWFucyB0aGF0IHRoZSBwcmV2aW91cyBhbmltYXRpb24gd2FzIGNhbmNlbGxlZFxuICAgICAgICAvLyBldmVuIGlmIHRoZSBmb2xsb3ctdXAgYW5pbWF0aW9uIGlzIHRoZSBzYW1lIGV2ZW50XG4gICAgICAgIGlmIChhbmltYXRpb25DYW5jZWxsZWQgfHwgYW5pbWF0aW9uRGV0YWlscy5jb3VudGVyICE9PSBjb3VudGVyIHx8ICFpc1ZhbGlkQW5pbWF0aW9uKSB7XG4gICAgICAgICAgLy8gaWYgYW5vdGhlciBhbmltYXRpb24gZGlkIG5vdCB0YWtlIG92ZXIgdGhlbiB3ZSBuZWVkXG4gICAgICAgICAgLy8gdG8gbWFrZSBzdXJlIHRoYXQgdGhlIGRvbU9wZXJhdGlvbiBhbmQgb3B0aW9ucyBhcmVcbiAgICAgICAgICAvLyBoYW5kbGVkIGFjY29yZGluZ2x5XG4gICAgICAgICAgaWYgKGFuaW1hdGlvbkNhbmNlbGxlZCkge1xuICAgICAgICAgICAgYXBwbHlBbmltYXRpb25DbGFzc2VzKGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgYXBwbHlBbmltYXRpb25TdHlsZXMoZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gaWYgdGhlIGV2ZW50IGNoYW5nZWQgZnJvbSBzb21ldGhpbmcgbGlrZSBlbnRlciB0byBsZWF2ZSB0aGVuIHdlIGRvXG4gICAgICAgICAgLy8gaXQsIG90aGVyd2lzZSBpZiBpdCdzIHRoZSBzYW1lIHRoZW4gdGhlIGVuZCByZXN1bHQgd2lsbCBiZSB0aGUgc2FtZSB0b29cbiAgICAgICAgICBpZiAoYW5pbWF0aW9uQ2FuY2VsbGVkIHx8IChpc1N0cnVjdHVyYWwgJiYgYW5pbWF0aW9uRGV0YWlscy5ldmVudCAhPT0gZXZlbnQpKSB7XG4gICAgICAgICAgICBvcHRpb25zLmRvbU9wZXJhdGlvbigpO1xuICAgICAgICAgICAgcnVubmVyLmVuZCgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGluIHRoZSBldmVudCB0aGF0IHRoZSBlbGVtZW50IGFuaW1hdGlvbiB3YXMgbm90IGNhbmNlbGxlZCBvciBhIGZvbGxvdy11cCBhbmltYXRpb25cbiAgICAgICAgICAvLyBpc24ndCBhbGxvd2VkIHRvIGFuaW1hdGUgZnJvbSBoZXJlIHRoZW4gd2UgbmVlZCB0byBjbGVhciB0aGUgc3RhdGUgb2YgdGhlIGVsZW1lbnRcbiAgICAgICAgICAvLyBzbyB0aGF0IGFueSBmdXR1cmUgYW5pbWF0aW9ucyB3b24ndCByZWFkIHRoZSBleHBpcmVkIGFuaW1hdGlvbiBkYXRhLlxuICAgICAgICAgIGlmICghaXNWYWxpZEFuaW1hdGlvbikge1xuICAgICAgICAgICAgY2xlYXJFbGVtZW50QW5pbWF0aW9uU3RhdGUobm9kZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGhpcyBjb21iaW5lZCBtdWx0aXBsZSBjbGFzcyB0byBhZGRDbGFzcyAvIHJlbW92ZUNsYXNzIGludG8gYSBzZXRDbGFzcyBldmVudFxuICAgICAgICAvLyBzbyBsb25nIGFzIGEgc3RydWN0dXJhbCBldmVudCBkaWQgbm90IHRha2Ugb3ZlciB0aGUgYW5pbWF0aW9uXG4gICAgICAgIGV2ZW50ID0gIWFuaW1hdGlvbkRldGFpbHMuc3RydWN0dXJhbCAmJiBoYXNBbmltYXRpb25DbGFzc2VzKGFuaW1hdGlvbkRldGFpbHMsIHRydWUpXG4gICAgICAgICAgICA/ICdzZXRDbGFzcydcbiAgICAgICAgICAgIDogYW5pbWF0aW9uRGV0YWlscy5ldmVudDtcblxuICAgICAgICBtYXJrRWxlbWVudEFuaW1hdGlvblN0YXRlKG5vZGUsIFJVTk5JTkdfU1RBVEUpO1xuICAgICAgICB2YXIgcmVhbFJ1bm5lciA9ICQkYW5pbWF0aW9uKGVsZW1lbnQsIGV2ZW50LCBhbmltYXRpb25EZXRhaWxzLm9wdGlvbnMpO1xuXG4gICAgICAgIC8vIHRoaXMgd2lsbCB1cGRhdGUgdGhlIHJ1bm5lcidzIGZsb3ctY29udHJvbCBldmVudHMgYmFzZWQgb25cbiAgICAgICAgLy8gdGhlIGByZWFsUnVubmVyYCBvYmplY3QuXG4gICAgICAgIHJ1bm5lci5zZXRIb3N0KHJlYWxSdW5uZXIpO1xuICAgICAgICBub3RpZnlQcm9ncmVzcyhydW5uZXIsIGV2ZW50LCAnc3RhcnQnLCB7fSk7XG5cbiAgICAgICAgcmVhbFJ1bm5lci5kb25lKGZ1bmN0aW9uKHN0YXR1cykge1xuICAgICAgICAgIGNsb3NlKCFzdGF0dXMpO1xuICAgICAgICAgIHZhciBhbmltYXRpb25EZXRhaWxzID0gYWN0aXZlQW5pbWF0aW9uc0xvb2t1cC5nZXQobm9kZSk7XG4gICAgICAgICAgaWYgKGFuaW1hdGlvbkRldGFpbHMgJiYgYW5pbWF0aW9uRGV0YWlscy5jb3VudGVyID09PSBjb3VudGVyKSB7XG4gICAgICAgICAgICBjbGVhckVsZW1lbnRBbmltYXRpb25TdGF0ZShub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbm90aWZ5UHJvZ3Jlc3MocnVubmVyLCBldmVudCwgJ2Nsb3NlJywge30pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gcnVubmVyO1xuXG4gICAgICBmdW5jdGlvbiBub3RpZnlQcm9ncmVzcyhydW5uZXIsIGV2ZW50LCBwaGFzZSwgZGF0YSkge1xuICAgICAgICBydW5Jbk5leHRQb3N0RGlnZXN0T3JOb3coZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGNhbGxiYWNrcyA9IGZpbmRDYWxsYmFja3MocGFyZW50Tm9kZSwgbm9kZSwgZXZlbnQpO1xuICAgICAgICAgIGlmIChjYWxsYmFja3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBkbyBub3Qgb3B0aW1pemUgdGhpcyBjYWxsIGhlcmUgdG8gUkFGIGJlY2F1c2VcbiAgICAgICAgICAgIC8vIHdlIGRvbid0IGtub3cgaG93IGhlYXZ5IHRoZSBjYWxsYmFjayBjb2RlIGhlcmUgd2lsbFxuICAgICAgICAgICAgLy8gYmUgYW5kIGlmIHRoaXMgY29kZSBpcyBidWZmZXJlZCB0aGVuIHRoaXMgY2FuXG4gICAgICAgICAgICAvLyBsZWFkIHRvIGEgcGVyZm9ybWFuY2UgcmVncmVzc2lvbi5cbiAgICAgICAgICAgICQkckFGKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBmb3JFYWNoKGNhbGxiYWNrcywgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlbGVtZW50LCBwaGFzZSwgZGF0YSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBjbGVhbnVwRXZlbnRMaXN0ZW5lcnMocGhhc2UsIG5vZGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNsZWFudXBFdmVudExpc3RlbmVycyhwaGFzZSwgbm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcnVubmVyLnByb2dyZXNzKGV2ZW50LCBwaGFzZSwgZGF0YSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNsb3NlKHJlamVjdCkge1xuICAgICAgICBjbGVhckdlbmVyYXRlZENsYXNzZXMoZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgICAgIGFwcGx5QW5pbWF0aW9uQ2xhc3NlcyhlbGVtZW50LCBvcHRpb25zKTtcbiAgICAgICAgYXBwbHlBbmltYXRpb25TdHlsZXMoZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgICAgIG9wdGlvbnMuZG9tT3BlcmF0aW9uKCk7XG4gICAgICAgIHJ1bm5lci5jb21wbGV0ZSghcmVqZWN0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbG9zZUNoaWxkQW5pbWF0aW9ucyhub2RlKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBub2RlLnF1ZXJ5U2VsZWN0b3JBbGwoJ1snICsgTkdfQU5JTUFURV9BVFRSX05BTUUgKyAnXScpO1xuICAgICAgZm9yRWFjaChjaGlsZHJlbiwgZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gcGFyc2VJbnQoY2hpbGQuZ2V0QXR0cmlidXRlKE5HX0FOSU1BVEVfQVRUUl9OQU1FKSwgMTApO1xuICAgICAgICB2YXIgYW5pbWF0aW9uRGV0YWlscyA9IGFjdGl2ZUFuaW1hdGlvbnNMb29rdXAuZ2V0KGNoaWxkKTtcbiAgICAgICAgaWYgKGFuaW1hdGlvbkRldGFpbHMpIHtcbiAgICAgICAgICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlIFJVTk5JTkdfU1RBVEU6XG4gICAgICAgICAgICAgIGFuaW1hdGlvbkRldGFpbHMucnVubmVyLmVuZCgpO1xuICAgICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgICAgICBjYXNlIFBSRV9ESUdFU1RfU1RBVEU6XG4gICAgICAgICAgICAgIGFjdGl2ZUFuaW1hdGlvbnNMb29rdXAuZGVsZXRlKGNoaWxkKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhckVsZW1lbnRBbmltYXRpb25TdGF0ZShub2RlKSB7XG4gICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShOR19BTklNQVRFX0FUVFJfTkFNRSk7XG4gICAgICBhY3RpdmVBbmltYXRpb25zTG9va3VwLmRlbGV0ZShub2RlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZuIHJldHVybnMgZmFsc2UgaWYgYW55IG9mIHRoZSBmb2xsb3dpbmcgaXMgdHJ1ZTpcbiAgICAgKiBhKSBhbmltYXRpb25zIG9uIGFueSBwYXJlbnQgZWxlbWVudCBhcmUgZGlzYWJsZWQsIGFuZCBhbmltYXRpb25zIG9uIHRoZSBlbGVtZW50IGFyZW4ndCBleHBsaWNpdGx5IGFsbG93ZWRcbiAgICAgKiBiKSBhIHBhcmVudCBlbGVtZW50IGhhcyBhbiBvbmdvaW5nIHN0cnVjdHVyYWwgYW5pbWF0aW9uLCBhbmQgYW5pbWF0ZUNoaWxkcmVuIGlzIGZhbHNlXG4gICAgICogYykgdGhlIGVsZW1lbnQgaXMgbm90IGEgY2hpbGQgb2YgdGhlIGJvZHlcbiAgICAgKiBkKSB0aGUgZWxlbWVudCBpcyBub3QgYSBjaGlsZCBvZiB0aGUgJHJvb3RFbGVtZW50XG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJlQW5pbWF0aW9uc0FsbG93ZWQobm9kZSwgcGFyZW50Tm9kZSwgZXZlbnQpIHtcbiAgICAgIHZhciBib2R5Tm9kZSA9ICRkb2N1bWVudFswXS5ib2R5O1xuICAgICAgdmFyIHJvb3ROb2RlID0gZ2V0RG9tTm9kZSgkcm9vdEVsZW1lbnQpO1xuXG4gICAgICB2YXIgYm9keU5vZGVEZXRlY3RlZCA9IChub2RlID09PSBib2R5Tm9kZSkgfHwgbm9kZS5ub2RlTmFtZSA9PT0gJ0hUTUwnO1xuICAgICAgdmFyIHJvb3ROb2RlRGV0ZWN0ZWQgPSAobm9kZSA9PT0gcm9vdE5vZGUpO1xuICAgICAgdmFyIHBhcmVudEFuaW1hdGlvbkRldGVjdGVkID0gZmFsc2U7XG4gICAgICB2YXIgZWxlbWVudERpc2FibGVkID0gZGlzYWJsZWRFbGVtZW50c0xvb2t1cC5nZXQobm9kZSk7XG4gICAgICB2YXIgYW5pbWF0ZUNoaWxkcmVuO1xuXG4gICAgICB2YXIgcGFyZW50SG9zdCA9IGpxTGl0ZS5kYXRhKG5vZGUsIE5HX0FOSU1BVEVfUElOX0RBVEEpO1xuICAgICAgaWYgKHBhcmVudEhvc3QpIHtcbiAgICAgICAgcGFyZW50Tm9kZSA9IGdldERvbU5vZGUocGFyZW50SG9zdCk7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChwYXJlbnROb2RlKSB7XG4gICAgICAgIGlmICghcm9vdE5vZGVEZXRlY3RlZCkge1xuICAgICAgICAgIC8vIGFuZ3VsYXIgZG9lc24ndCB3YW50IHRvIGF0dGVtcHQgdG8gYW5pbWF0ZSBlbGVtZW50cyBvdXRzaWRlIG9mIHRoZSBhcHBsaWNhdGlvblxuICAgICAgICAgIC8vIHRoZXJlZm9yZSB3ZSBuZWVkIHRvIGVuc3VyZSB0aGF0IHRoZSByb290RWxlbWVudCBpcyBhbiBhbmNlc3RvciBvZiB0aGUgY3VycmVudCBlbGVtZW50XG4gICAgICAgICAgcm9vdE5vZGVEZXRlY3RlZCA9IChwYXJlbnROb2RlID09PSByb290Tm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyZW50Tm9kZS5ub2RlVHlwZSAhPT0gRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgLy8gbm8gcG9pbnQgaW4gaW5zcGVjdGluZyB0aGUgI2RvY3VtZW50IGVsZW1lbnRcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkZXRhaWxzID0gYWN0aXZlQW5pbWF0aW9uc0xvb2t1cC5nZXQocGFyZW50Tm9kZSkgfHwge307XG4gICAgICAgIC8vIGVpdGhlciBhbiBlbnRlciwgbGVhdmUgb3IgbW92ZSBhbmltYXRpb24gd2lsbCBjb21tZW5jZVxuICAgICAgICAvLyB0aGVyZWZvcmUgd2UgY2FuJ3QgYWxsb3cgYW55IGFuaW1hdGlvbnMgdG8gdGFrZSBwbGFjZVxuICAgICAgICAvLyBidXQgaWYgYSBwYXJlbnQgYW5pbWF0aW9uIGlzIGNsYXNzLWJhc2VkIHRoZW4gdGhhdCdzIG9rXG4gICAgICAgIGlmICghcGFyZW50QW5pbWF0aW9uRGV0ZWN0ZWQpIHtcbiAgICAgICAgICB2YXIgcGFyZW50Tm9kZURpc2FibGVkID0gZGlzYWJsZWRFbGVtZW50c0xvb2t1cC5nZXQocGFyZW50Tm9kZSk7XG5cbiAgICAgICAgICBpZiAocGFyZW50Tm9kZURpc2FibGVkID09PSB0cnVlICYmIGVsZW1lbnREaXNhYmxlZCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIC8vIGRpc2FibGUgYW5pbWF0aW9ucyBpZiB0aGUgdXNlciBoYXNuJ3QgZXhwbGljaXRseSBlbmFibGVkIGFuaW1hdGlvbnMgb24gdGhlXG4gICAgICAgICAgICAvLyBjdXJyZW50IGVsZW1lbnRcbiAgICAgICAgICAgIGVsZW1lbnREaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICAgICAvLyBlbGVtZW50IGlzIGRpc2FibGVkIHZpYSBwYXJlbnQgZWxlbWVudCwgbm8gbmVlZCB0byBjaGVjayBhbnl0aGluZyBlbHNlXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IGVsc2UgaWYgKHBhcmVudE5vZGVEaXNhYmxlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGVsZW1lbnREaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJlbnRBbmltYXRpb25EZXRlY3RlZCA9IGRldGFpbHMuc3RydWN0dXJhbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1VuZGVmaW5lZChhbmltYXRlQ2hpbGRyZW4pIHx8IGFuaW1hdGVDaGlsZHJlbiA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGpxTGl0ZS5kYXRhKHBhcmVudE5vZGUsIE5HX0FOSU1BVEVfQ0hJTERSRU5fREFUQSk7XG4gICAgICAgICAgaWYgKGlzRGVmaW5lZCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGFuaW1hdGVDaGlsZHJlbiA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRoZXJlIGlzIG5vIG5lZWQgdG8gY29udGludWUgdHJhdmVyc2luZyBhdCB0aGlzIHBvaW50XG4gICAgICAgIGlmIChwYXJlbnRBbmltYXRpb25EZXRlY3RlZCAmJiBhbmltYXRlQ2hpbGRyZW4gPT09IGZhbHNlKSBicmVhaztcblxuICAgICAgICBpZiAoIWJvZHlOb2RlRGV0ZWN0ZWQpIHtcbiAgICAgICAgICAvLyB3ZSBhbHNvIG5lZWQgdG8gZW5zdXJlIHRoYXQgdGhlIGVsZW1lbnQgaXMgb3Igd2lsbCBiZSBhIHBhcnQgb2YgdGhlIGJvZHkgZWxlbWVudFxuICAgICAgICAgIC8vIG90aGVyd2lzZSBpdCBpcyBwb2ludGxlc3MgdG8gZXZlbiBpc3N1ZSBhbiBhbmltYXRpb24gdG8gYmUgcmVuZGVyZWRcbiAgICAgICAgICBib2R5Tm9kZURldGVjdGVkID0gKHBhcmVudE5vZGUgPT09IGJvZHlOb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChib2R5Tm9kZURldGVjdGVkICYmIHJvb3ROb2RlRGV0ZWN0ZWQpIHtcbiAgICAgICAgICAvLyBJZiBib3RoIGJvZHkgYW5kIHJvb3QgaGF2ZSBiZWVuIGZvdW5kLCBhbnkgb3RoZXIgY2hlY2tzIGFyZSBwb2ludGxlc3MsXG4gICAgICAgICAgLy8gYXMgbm8gYW5pbWF0aW9uIGRhdGEgc2hvdWxkIGxpdmUgb3V0c2lkZSB0aGUgYXBwbGljYXRpb25cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcm9vdE5vZGVEZXRlY3RlZCkge1xuICAgICAgICAgIC8vIElmIGByb290Tm9kZWAgaXMgbm90IGRldGVjdGVkLCBjaGVjayBpZiBgcGFyZW50Tm9kZWAgaXMgcGlubmVkIHRvIGFub3RoZXIgZWxlbWVudFxuICAgICAgICAgIHBhcmVudEhvc3QgPSBqcUxpdGUuZGF0YShwYXJlbnROb2RlLCBOR19BTklNQVRFX1BJTl9EQVRBKTtcbiAgICAgICAgICBpZiAocGFyZW50SG9zdCkge1xuICAgICAgICAgICAgLy8gVGhlIHBpbiB0YXJnZXQgZWxlbWVudCBiZWNvbWVzIHRoZSBuZXh0IHBhcmVudCBlbGVtZW50XG4gICAgICAgICAgICBwYXJlbnROb2RlID0gZ2V0RG9tTm9kZShwYXJlbnRIb3N0KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudE5vZGU7XG4gICAgICB9XG5cbiAgICAgIHZhciBhbGxvd0FuaW1hdGlvbiA9ICghcGFyZW50QW5pbWF0aW9uRGV0ZWN0ZWQgfHwgYW5pbWF0ZUNoaWxkcmVuKSAmJiBlbGVtZW50RGlzYWJsZWQgIT09IHRydWU7XG4gICAgICByZXR1cm4gYWxsb3dBbmltYXRpb24gJiYgcm9vdE5vZGVEZXRlY3RlZCAmJiBib2R5Tm9kZURldGVjdGVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hcmtFbGVtZW50QW5pbWF0aW9uU3RhdGUobm9kZSwgc3RhdGUsIGRldGFpbHMpIHtcbiAgICAgIGRldGFpbHMgPSBkZXRhaWxzIHx8IHt9O1xuICAgICAgZGV0YWlscy5zdGF0ZSA9IHN0YXRlO1xuXG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShOR19BTklNQVRFX0FUVFJfTkFNRSwgc3RhdGUpO1xuXG4gICAgICB2YXIgb2xkVmFsdWUgPSBhY3RpdmVBbmltYXRpb25zTG9va3VwLmdldChub2RlKTtcbiAgICAgIHZhciBuZXdWYWx1ZSA9IG9sZFZhbHVlXG4gICAgICAgICAgPyBleHRlbmQob2xkVmFsdWUsIGRldGFpbHMpXG4gICAgICAgICAgOiBkZXRhaWxzO1xuICAgICAgYWN0aXZlQW5pbWF0aW9uc0xvb2t1cC5zZXQobm9kZSwgbmV3VmFsdWUpO1xuICAgIH1cbiAgfV07XG59XTtcblxuLyogZXhwb3J0ZWQgJCRBbmltYXRpb25Qcm92aWRlciAqL1xuXG52YXIgJCRBbmltYXRpb25Qcm92aWRlciA9IFsnJGFuaW1hdGVQcm92aWRlcicsIC8qKiBAdGhpcyAqLyBmdW5jdGlvbigkYW5pbWF0ZVByb3ZpZGVyKSB7XG4gIHZhciBOR19BTklNQVRFX1JFRl9BVFRSID0gJ25nLWFuaW1hdGUtcmVmJztcblxuICB2YXIgZHJpdmVycyA9IHRoaXMuZHJpdmVycyA9IFtdO1xuXG4gIHZhciBSVU5ORVJfU1RPUkFHRV9LRVkgPSAnJCRhbmltYXRpb25SdW5uZXInO1xuXG4gIGZ1bmN0aW9uIHNldFJ1bm5lcihlbGVtZW50LCBydW5uZXIpIHtcbiAgICBlbGVtZW50LmRhdGEoUlVOTkVSX1NUT1JBR0VfS0VZLCBydW5uZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlUnVubmVyKGVsZW1lbnQpIHtcbiAgICBlbGVtZW50LnJlbW92ZURhdGEoUlVOTkVSX1NUT1JBR0VfS0VZKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFJ1bm5lcihlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuZGF0YShSVU5ORVJfU1RPUkFHRV9LRVkpO1xuICB9XG5cbiAgdGhpcy4kZ2V0ID0gWyckJGpxTGl0ZScsICckcm9vdFNjb3BlJywgJyRpbmplY3RvcicsICckJEFuaW1hdGVSdW5uZXInLCAnJCRNYXAnLCAnJCRyQUZTY2hlZHVsZXInLFxuICAgICAgIGZ1bmN0aW9uKCQkanFMaXRlLCAgICRyb290U2NvcGUsICAgJGluamVjdG9yLCAgICQkQW5pbWF0ZVJ1bm5lciwgICAkJE1hcCwgICAkJHJBRlNjaGVkdWxlcikge1xuXG4gICAgdmFyIGFuaW1hdGlvblF1ZXVlID0gW107XG4gICAgdmFyIGFwcGx5QW5pbWF0aW9uQ2xhc3NlcyA9IGFwcGx5QW5pbWF0aW9uQ2xhc3Nlc0ZhY3RvcnkoJCRqcUxpdGUpO1xuXG4gICAgZnVuY3Rpb24gc29ydEFuaW1hdGlvbnMoYW5pbWF0aW9ucykge1xuICAgICAgdmFyIHRyZWUgPSB7IGNoaWxkcmVuOiBbXSB9O1xuICAgICAgdmFyIGksIGxvb2t1cCA9IG5ldyAkJE1hcCgpO1xuXG4gICAgICAvLyB0aGlzIGlzIGRvbmUgZmlyc3QgYmVmb3JlaGFuZCBzbyB0aGF0IHRoZSBtYXBcbiAgICAgIC8vIGlzIGZpbGxlZCB3aXRoIGEgbGlzdCBvZiB0aGUgZWxlbWVudHMgdGhhdCB3aWxsIGJlIGFuaW1hdGVkXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgYW5pbWF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYW5pbWF0aW9uID0gYW5pbWF0aW9uc1tpXTtcbiAgICAgICAgbG9va3VwLnNldChhbmltYXRpb24uZG9tTm9kZSwgYW5pbWF0aW9uc1tpXSA9IHtcbiAgICAgICAgICBkb21Ob2RlOiBhbmltYXRpb24uZG9tTm9kZSxcbiAgICAgICAgICBmbjogYW5pbWF0aW9uLmZuLFxuICAgICAgICAgIGNoaWxkcmVuOiBbXVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMDsgaSA8IGFuaW1hdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcHJvY2Vzc05vZGUoYW5pbWF0aW9uc1tpXSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmbGF0dGVuKHRyZWUpO1xuXG4gICAgICBmdW5jdGlvbiBwcm9jZXNzTm9kZShlbnRyeSkge1xuICAgICAgICBpZiAoZW50cnkucHJvY2Vzc2VkKSByZXR1cm4gZW50cnk7XG4gICAgICAgIGVudHJ5LnByb2Nlc3NlZCA9IHRydWU7XG5cbiAgICAgICAgdmFyIGVsZW1lbnROb2RlID0gZW50cnkuZG9tTm9kZTtcbiAgICAgICAgdmFyIHBhcmVudE5vZGUgPSBlbGVtZW50Tm9kZS5wYXJlbnROb2RlO1xuICAgICAgICBsb29rdXAuc2V0KGVsZW1lbnROb2RlLCBlbnRyeSk7XG5cbiAgICAgICAgdmFyIHBhcmVudEVudHJ5O1xuICAgICAgICB3aGlsZSAocGFyZW50Tm9kZSkge1xuICAgICAgICAgIHBhcmVudEVudHJ5ID0gbG9va3VwLmdldChwYXJlbnROb2RlKTtcbiAgICAgICAgICBpZiAocGFyZW50RW50cnkpIHtcbiAgICAgICAgICAgIGlmICghcGFyZW50RW50cnkucHJvY2Vzc2VkKSB7XG4gICAgICAgICAgICAgIHBhcmVudEVudHJ5ID0gcHJvY2Vzc05vZGUocGFyZW50RW50cnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudE5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICAocGFyZW50RW50cnkgfHwgdHJlZSkuY2hpbGRyZW4ucHVzaChlbnRyeSk7XG4gICAgICAgIHJldHVybiBlbnRyeTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZmxhdHRlbih0cmVlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgdmFyIHF1ZXVlID0gW107XG4gICAgICAgIHZhciBpO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0cmVlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgcXVldWUucHVzaCh0cmVlLmNoaWxkcmVuW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZW1haW5pbmdMZXZlbEVudHJpZXMgPSBxdWV1ZS5sZW5ndGg7XG4gICAgICAgIHZhciBuZXh0TGV2ZWxFbnRyaWVzID0gMDtcbiAgICAgICAgdmFyIHJvdyA9IFtdO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBlbnRyeSA9IHF1ZXVlW2ldO1xuICAgICAgICAgIGlmIChyZW1haW5pbmdMZXZlbEVudHJpZXMgPD0gMCkge1xuICAgICAgICAgICAgcmVtYWluaW5nTGV2ZWxFbnRyaWVzID0gbmV4dExldmVsRW50cmllcztcbiAgICAgICAgICAgIG5leHRMZXZlbEVudHJpZXMgPSAwO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gocm93KTtcbiAgICAgICAgICAgIHJvdyA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICByb3cucHVzaChlbnRyeS5mbik7XG4gICAgICAgICAgZW50cnkuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihjaGlsZEVudHJ5KSB7XG4gICAgICAgICAgICBuZXh0TGV2ZWxFbnRyaWVzKys7XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKGNoaWxkRW50cnkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJlbWFpbmluZ0xldmVsRW50cmllcy0tO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJvdy5sZW5ndGgpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChyb3cpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUT0RPKG1hdHNrbyk6IGRvY3VtZW50IHRoZSBzaWduYXR1cmUgaW4gYSBiZXR0ZXIgd2F5XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGVsZW1lbnQsIGV2ZW50LCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gcHJlcGFyZUFuaW1hdGlvbk9wdGlvbnMob3B0aW9ucyk7XG4gICAgICB2YXIgaXNTdHJ1Y3R1cmFsID0gWydlbnRlcicsICdtb3ZlJywgJ2xlYXZlJ10uaW5kZXhPZihldmVudCkgPj0gMDtcblxuICAgICAgLy8gdGhlcmUgaXMgbm8gYW5pbWF0aW9uIGF0IHRoZSBjdXJyZW50IG1vbWVudCwgaG93ZXZlclxuICAgICAgLy8gdGhlc2UgcnVubmVyIG1ldGhvZHMgd2lsbCBnZXQgbGF0ZXIgdXBkYXRlZCB3aXRoIHRoZVxuICAgICAgLy8gbWV0aG9kcyBsZWFkaW5nIGludG8gdGhlIGRyaXZlcidzIGVuZC9jYW5jZWwgbWV0aG9kc1xuICAgICAgLy8gZm9yIG5vdyB0aGV5IGp1c3Qgc3RvcCB0aGUgYW5pbWF0aW9uIGZyb20gc3RhcnRpbmdcbiAgICAgIHZhciBydW5uZXIgPSBuZXcgJCRBbmltYXRlUnVubmVyKHtcbiAgICAgICAgZW5kOiBmdW5jdGlvbigpIHsgY2xvc2UoKTsgfSxcbiAgICAgICAgY2FuY2VsOiBmdW5jdGlvbigpIHsgY2xvc2UodHJ1ZSk7IH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIWRyaXZlcnMubGVuZ3RoKSB7XG4gICAgICAgIGNsb3NlKCk7XG4gICAgICAgIHJldHVybiBydW5uZXI7XG4gICAgICB9XG5cbiAgICAgIHNldFJ1bm5lcihlbGVtZW50LCBydW5uZXIpO1xuXG4gICAgICB2YXIgY2xhc3NlcyA9IG1lcmdlQ2xhc3NlcyhlbGVtZW50LmF0dHIoJ2NsYXNzJyksIG1lcmdlQ2xhc3NlcyhvcHRpb25zLmFkZENsYXNzLCBvcHRpb25zLnJlbW92ZUNsYXNzKSk7XG4gICAgICB2YXIgdGVtcENsYXNzZXMgPSBvcHRpb25zLnRlbXBDbGFzc2VzO1xuICAgICAgaWYgKHRlbXBDbGFzc2VzKSB7XG4gICAgICAgIGNsYXNzZXMgKz0gJyAnICsgdGVtcENsYXNzZXM7XG4gICAgICAgIG9wdGlvbnMudGVtcENsYXNzZXMgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJlcGFyZUNsYXNzTmFtZTtcbiAgICAgIGlmIChpc1N0cnVjdHVyYWwpIHtcbiAgICAgICAgcHJlcGFyZUNsYXNzTmFtZSA9ICduZy0nICsgZXZlbnQgKyBQUkVQQVJFX0NMQVNTX1NVRkZJWDtcbiAgICAgICAgJCRqcUxpdGUuYWRkQ2xhc3MoZWxlbWVudCwgcHJlcGFyZUNsYXNzTmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGFuaW1hdGlvblF1ZXVlLnB1c2goe1xuICAgICAgICAvLyB0aGlzIGRhdGEgaXMgdXNlZCBieSB0aGUgcG9zdERpZ2VzdCBjb2RlIGFuZCBwYXNzZWQgaW50b1xuICAgICAgICAvLyB0aGUgZHJpdmVyIHN0ZXAgZnVuY3Rpb25cbiAgICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgY2xhc3NlczogY2xhc3NlcyxcbiAgICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgICBzdHJ1Y3R1cmFsOiBpc1N0cnVjdHVyYWwsXG4gICAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgIGJlZm9yZVN0YXJ0OiBiZWZvcmVTdGFydCxcbiAgICAgICAgY2xvc2U6IGNsb3NlXG4gICAgICB9KTtcblxuICAgICAgZWxlbWVudC5vbignJGRlc3Ryb3knLCBoYW5kbGVEZXN0cm95ZWRFbGVtZW50KTtcblxuICAgICAgLy8gd2Ugb25seSB3YW50IHRoZXJlIHRvIGJlIG9uZSBmdW5jdGlvbiBjYWxsZWQgd2l0aGluIHRoZSBwb3N0IGRpZ2VzdFxuICAgICAgLy8gYmxvY2suIFRoaXMgd2F5IHdlIGNhbiBncm91cCBhbmltYXRpb25zIGZvciBhbGwgdGhlIGFuaW1hdGlvbnMgdGhhdFxuICAgICAgLy8gd2VyZSBhcGFydCBvZiB0aGUgc2FtZSBwb3N0RGlnZXN0IGZsdXNoIGNhbGwuXG4gICAgICBpZiAoYW5pbWF0aW9uUXVldWUubGVuZ3RoID4gMSkgcmV0dXJuIHJ1bm5lcjtcblxuICAgICAgJHJvb3RTY29wZS4kJHBvc3REaWdlc3QoZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhbmltYXRpb25zID0gW107XG4gICAgICAgIGZvckVhY2goYW5pbWF0aW9uUXVldWUsIGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgICAgICAgLy8gdGhlIGVsZW1lbnQgd2FzIGRlc3Ryb3llZCBlYXJseSBvbiB3aGljaCByZW1vdmVkIHRoZSBydW5uZXJcbiAgICAgICAgICAvLyBmb3JtIGl0cyBzdG9yYWdlLiBUaGlzIG1lYW5zIHdlIGNhbid0IGFuaW1hdGUgdGhpcyBlbGVtZW50XG4gICAgICAgICAgLy8gYXQgYWxsIGFuZCBpdCBhbHJlYWR5IGhhcyBiZWVuIGNsb3NlZCBkdWUgdG8gZGVzdHJ1Y3Rpb24uXG4gICAgICAgICAgaWYgKGdldFJ1bm5lcihlbnRyeS5lbGVtZW50KSkge1xuICAgICAgICAgICAgYW5pbWF0aW9ucy5wdXNoKGVudHJ5KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZW50cnkuY2xvc2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIG5vdyBhbnkgZnV0dXJlIGFuaW1hdGlvbnMgd2lsbCBiZSBpbiBhbm90aGVyIHBvc3REaWdlc3RcbiAgICAgICAgYW5pbWF0aW9uUXVldWUubGVuZ3RoID0gMDtcblxuICAgICAgICB2YXIgZ3JvdXBlZEFuaW1hdGlvbnMgPSBncm91cEFuaW1hdGlvbnMoYW5pbWF0aW9ucyk7XG4gICAgICAgIHZhciB0b0JlU29ydGVkQW5pbWF0aW9ucyA9IFtdO1xuXG4gICAgICAgIGZvckVhY2goZ3JvdXBlZEFuaW1hdGlvbnMsIGZ1bmN0aW9uKGFuaW1hdGlvbkVudHJ5KSB7XG4gICAgICAgICAgdG9CZVNvcnRlZEFuaW1hdGlvbnMucHVzaCh7XG4gICAgICAgICAgICBkb21Ob2RlOiBnZXREb21Ob2RlKGFuaW1hdGlvbkVudHJ5LmZyb20gPyBhbmltYXRpb25FbnRyeS5mcm9tLmVsZW1lbnQgOiBhbmltYXRpb25FbnRyeS5lbGVtZW50KSxcbiAgICAgICAgICAgIGZuOiBmdW5jdGlvbiB0cmlnZ2VyQW5pbWF0aW9uU3RhcnQoKSB7XG4gICAgICAgICAgICAgIC8vIGl0J3MgaW1wb3J0YW50IHRoYXQgd2UgYXBwbHkgdGhlIGBuZy1hbmltYXRlYCBDU1MgY2xhc3MgYW5kIHRoZVxuICAgICAgICAgICAgICAvLyB0ZW1wb3JhcnkgY2xhc3NlcyBiZWZvcmUgd2UgZG8gYW55IGRyaXZlciBpbnZva2luZyBzaW5jZSB0aGVzZVxuICAgICAgICAgICAgICAvLyBDU1MgY2xhc3NlcyBtYXkgYmUgcmVxdWlyZWQgZm9yIHByb3BlciBDU1MgZGV0ZWN0aW9uLlxuICAgICAgICAgICAgICBhbmltYXRpb25FbnRyeS5iZWZvcmVTdGFydCgpO1xuXG4gICAgICAgICAgICAgIHZhciBzdGFydEFuaW1hdGlvbkZuLCBjbG9zZUZuID0gYW5pbWF0aW9uRW50cnkuY2xvc2U7XG5cbiAgICAgICAgICAgICAgLy8gaW4gdGhlIGV2ZW50IHRoYXQgdGhlIGVsZW1lbnQgd2FzIHJlbW92ZWQgYmVmb3JlIHRoZSBkaWdlc3QgcnVucyBvclxuICAgICAgICAgICAgICAvLyBkdXJpbmcgdGhlIFJBRiBzZXF1ZW5jaW5nIHRoZW4gd2Ugc2hvdWxkIG5vdCB0cmlnZ2VyIHRoZSBhbmltYXRpb24uXG4gICAgICAgICAgICAgIHZhciB0YXJnZXRFbGVtZW50ID0gYW5pbWF0aW9uRW50cnkuYW5jaG9yc1xuICAgICAgICAgICAgICAgICAgPyAoYW5pbWF0aW9uRW50cnkuZnJvbS5lbGVtZW50IHx8IGFuaW1hdGlvbkVudHJ5LnRvLmVsZW1lbnQpXG4gICAgICAgICAgICAgICAgICA6IGFuaW1hdGlvbkVudHJ5LmVsZW1lbnQ7XG5cbiAgICAgICAgICAgICAgaWYgKGdldFJ1bm5lcih0YXJnZXRFbGVtZW50KSkge1xuICAgICAgICAgICAgICAgIHZhciBvcGVyYXRpb24gPSBpbnZva2VGaXJzdERyaXZlcihhbmltYXRpb25FbnRyeSk7XG4gICAgICAgICAgICAgICAgaWYgKG9wZXJhdGlvbikge1xuICAgICAgICAgICAgICAgICAgc3RhcnRBbmltYXRpb25GbiA9IG9wZXJhdGlvbi5zdGFydDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIXN0YXJ0QW5pbWF0aW9uRm4pIHtcbiAgICAgICAgICAgICAgICBjbG9zZUZuKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGFuaW1hdGlvblJ1bm5lciA9IHN0YXJ0QW5pbWF0aW9uRm4oKTtcbiAgICAgICAgICAgICAgICBhbmltYXRpb25SdW5uZXIuZG9uZShmdW5jdGlvbihzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgIGNsb3NlRm4oIXN0YXR1cyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdXBkYXRlQW5pbWF0aW9uUnVubmVycyhhbmltYXRpb25FbnRyeSwgYW5pbWF0aW9uUnVubmVyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyB3ZSBuZWVkIHRvIHNvcnQgZWFjaCBvZiB0aGUgYW5pbWF0aW9ucyBpbiBvcmRlciBvZiBwYXJlbnQgdG8gY2hpbGRcbiAgICAgICAgLy8gcmVsYXRpb25zaGlwcy4gVGhpcyBlbnN1cmVzIHRoYXQgdGhlIGNoaWxkIGNsYXNzZXMgYXJlIGFwcGxpZWQgYXQgdGhlXG4gICAgICAgIC8vIHJpZ2h0IHRpbWUuXG4gICAgICAgICQkckFGU2NoZWR1bGVyKHNvcnRBbmltYXRpb25zKHRvQmVTb3J0ZWRBbmltYXRpb25zKSk7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHJ1bm5lcjtcblxuICAgICAgLy8gVE9ETyhtYXRza28pOiBjaGFuZ2UgdG8gcmVmZXJlbmNlIG5vZGVzXG4gICAgICBmdW5jdGlvbiBnZXRBbmNob3JOb2Rlcyhub2RlKSB7XG4gICAgICAgIHZhciBTRUxFQ1RPUiA9ICdbJyArIE5HX0FOSU1BVEVfUkVGX0FUVFIgKyAnXSc7XG4gICAgICAgIHZhciBpdGVtcyA9IG5vZGUuaGFzQXR0cmlidXRlKE5HX0FOSU1BVEVfUkVGX0FUVFIpXG4gICAgICAgICAgICAgID8gW25vZGVdXG4gICAgICAgICAgICAgIDogbm9kZS5xdWVyeVNlbGVjdG9yQWxsKFNFTEVDVE9SKTtcbiAgICAgICAgdmFyIGFuY2hvcnMgPSBbXTtcbiAgICAgICAgZm9yRWFjaChpdGVtcywgZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgIHZhciBhdHRyID0gbm9kZS5nZXRBdHRyaWJ1dGUoTkdfQU5JTUFURV9SRUZfQVRUUik7XG4gICAgICAgICAgaWYgKGF0dHIgJiYgYXR0ci5sZW5ndGgpIHtcbiAgICAgICAgICAgIGFuY2hvcnMucHVzaChub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYW5jaG9ycztcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ3JvdXBBbmltYXRpb25zKGFuaW1hdGlvbnMpIHtcbiAgICAgICAgdmFyIHByZXBhcmVkQW5pbWF0aW9ucyA9IFtdO1xuICAgICAgICB2YXIgcmVmTG9va3VwID0ge307XG4gICAgICAgIGZvckVhY2goYW5pbWF0aW9ucywgZnVuY3Rpb24oYW5pbWF0aW9uLCBpbmRleCkge1xuICAgICAgICAgIHZhciBlbGVtZW50ID0gYW5pbWF0aW9uLmVsZW1lbnQ7XG4gICAgICAgICAgdmFyIG5vZGUgPSBnZXREb21Ob2RlKGVsZW1lbnQpO1xuICAgICAgICAgIHZhciBldmVudCA9IGFuaW1hdGlvbi5ldmVudDtcbiAgICAgICAgICB2YXIgZW50ZXJPck1vdmUgPSBbJ2VudGVyJywgJ21vdmUnXS5pbmRleE9mKGV2ZW50KSA+PSAwO1xuICAgICAgICAgIHZhciBhbmNob3JOb2RlcyA9IGFuaW1hdGlvbi5zdHJ1Y3R1cmFsID8gZ2V0QW5jaG9yTm9kZXMobm9kZSkgOiBbXTtcblxuICAgICAgICAgIGlmIChhbmNob3JOb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBkaXJlY3Rpb24gPSBlbnRlck9yTW92ZSA/ICd0bycgOiAnZnJvbSc7XG5cbiAgICAgICAgICAgIGZvckVhY2goYW5jaG9yTm9kZXMsIGZ1bmN0aW9uKGFuY2hvcikge1xuICAgICAgICAgICAgICB2YXIga2V5ID0gYW5jaG9yLmdldEF0dHJpYnV0ZShOR19BTklNQVRFX1JFRl9BVFRSKTtcbiAgICAgICAgICAgICAgcmVmTG9va3VwW2tleV0gPSByZWZMb29rdXBba2V5XSB8fCB7fTtcbiAgICAgICAgICAgICAgcmVmTG9va3VwW2tleV1bZGlyZWN0aW9uXSA9IHtcbiAgICAgICAgICAgICAgICBhbmltYXRpb25JRDogaW5kZXgsXG4gICAgICAgICAgICAgICAgZWxlbWVudDoganFMaXRlKGFuY2hvcilcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcmVwYXJlZEFuaW1hdGlvbnMucHVzaChhbmltYXRpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHVzZWRJbmRpY2VzTG9va3VwID0ge307XG4gICAgICAgIHZhciBhbmNob3JHcm91cHMgPSB7fTtcbiAgICAgICAgZm9yRWFjaChyZWZMb29rdXAsIGZ1bmN0aW9uKG9wZXJhdGlvbnMsIGtleSkge1xuICAgICAgICAgIHZhciBmcm9tID0gb3BlcmF0aW9ucy5mcm9tO1xuICAgICAgICAgIHZhciB0byA9IG9wZXJhdGlvbnMudG87XG5cbiAgICAgICAgICBpZiAoIWZyb20gfHwgIXRvKSB7XG4gICAgICAgICAgICAvLyBvbmx5IG9uZSBvZiB0aGVzZSBpcyBzZXQgdGhlcmVmb3JlIHdlIGNhbid0IGhhdmUgYW5cbiAgICAgICAgICAgIC8vIGFuY2hvciBhbmltYXRpb24gc2luY2UgYWxsIHRocmVlIHBpZWNlcyBhcmUgcmVxdWlyZWRcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGZyb20gPyBmcm9tLmFuaW1hdGlvbklEIDogdG8uYW5pbWF0aW9uSUQ7XG4gICAgICAgICAgICB2YXIgaW5kZXhLZXkgPSBpbmRleC50b1N0cmluZygpO1xuICAgICAgICAgICAgaWYgKCF1c2VkSW5kaWNlc0xvb2t1cFtpbmRleEtleV0pIHtcbiAgICAgICAgICAgICAgdXNlZEluZGljZXNMb29rdXBbaW5kZXhLZXldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgcHJlcGFyZWRBbmltYXRpb25zLnB1c2goYW5pbWF0aW9uc1tpbmRleF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBmcm9tQW5pbWF0aW9uID0gYW5pbWF0aW9uc1tmcm9tLmFuaW1hdGlvbklEXTtcbiAgICAgICAgICB2YXIgdG9BbmltYXRpb24gPSBhbmltYXRpb25zW3RvLmFuaW1hdGlvbklEXTtcbiAgICAgICAgICB2YXIgbG9va3VwS2V5ID0gZnJvbS5hbmltYXRpb25JRC50b1N0cmluZygpO1xuICAgICAgICAgIGlmICghYW5jaG9yR3JvdXBzW2xvb2t1cEtleV0pIHtcbiAgICAgICAgICAgIHZhciBncm91cCA9IGFuY2hvckdyb3Vwc1tsb29rdXBLZXldID0ge1xuICAgICAgICAgICAgICBzdHJ1Y3R1cmFsOiB0cnVlLFxuICAgICAgICAgICAgICBiZWZvcmVTdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZnJvbUFuaW1hdGlvbi5iZWZvcmVTdGFydCgpO1xuICAgICAgICAgICAgICAgIHRvQW5pbWF0aW9uLmJlZm9yZVN0YXJ0KCk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGNsb3NlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBmcm9tQW5pbWF0aW9uLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgdG9BbmltYXRpb24uY2xvc2UoKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgY2xhc3NlczogY3NzQ2xhc3Nlc0ludGVyc2VjdGlvbihmcm9tQW5pbWF0aW9uLmNsYXNzZXMsIHRvQW5pbWF0aW9uLmNsYXNzZXMpLFxuICAgICAgICAgICAgICBmcm9tOiBmcm9tQW5pbWF0aW9uLFxuICAgICAgICAgICAgICB0bzogdG9BbmltYXRpb24sXG4gICAgICAgICAgICAgIGFuY2hvcnM6IFtdIC8vIFRPRE8obWF0c2tvKTogY2hhbmdlIHRvIHJlZmVyZW5jZSBub2Rlc1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gdGhlIGFuY2hvciBhbmltYXRpb25zIHJlcXVpcmUgdGhhdCB0aGUgZnJvbSBhbmQgdG8gZWxlbWVudHMgYm90aCBoYXZlIGF0IGxlYXN0XG4gICAgICAgICAgICAvLyBvbmUgc2hhcmVkIENTUyBjbGFzcyB3aGljaCBlZmZlY3RpdmVseSBtYXJyaWVzIHRoZSB0d28gZWxlbWVudHMgdG9nZXRoZXIgdG8gdXNlXG4gICAgICAgICAgICAvLyB0aGUgc2FtZSBhbmltYXRpb24gZHJpdmVyIGFuZCB0byBwcm9wZXJseSBzZXF1ZW5jZSB0aGUgYW5jaG9yIGFuaW1hdGlvbi5cbiAgICAgICAgICAgIGlmIChncm91cC5jbGFzc2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICBwcmVwYXJlZEFuaW1hdGlvbnMucHVzaChncm91cCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwcmVwYXJlZEFuaW1hdGlvbnMucHVzaChmcm9tQW5pbWF0aW9uKTtcbiAgICAgICAgICAgICAgcHJlcGFyZWRBbmltYXRpb25zLnB1c2godG9BbmltYXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGFuY2hvckdyb3Vwc1tsb29rdXBLZXldLmFuY2hvcnMucHVzaCh7XG4gICAgICAgICAgICAnb3V0JzogZnJvbS5lbGVtZW50LCAnaW4nOiB0by5lbGVtZW50XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBwcmVwYXJlZEFuaW1hdGlvbnM7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNzc0NsYXNzZXNJbnRlcnNlY3Rpb24oYSxiKSB7XG4gICAgICAgIGEgPSBhLnNwbGl0KCcgJyk7XG4gICAgICAgIGIgPSBiLnNwbGl0KCcgJyk7XG4gICAgICAgIHZhciBtYXRjaGVzID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGFhID0gYVtpXTtcbiAgICAgICAgICBpZiAoYWEuc3Vic3RyaW5nKDAsMykgPT09ICduZy0nKSBjb250aW51ZTtcblxuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYi5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKGFhID09PSBiW2pdKSB7XG4gICAgICAgICAgICAgIG1hdGNoZXMucHVzaChhYSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXRjaGVzLmpvaW4oJyAnKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaW52b2tlRmlyc3REcml2ZXIoYW5pbWF0aW9uRGV0YWlscykge1xuICAgICAgICAvLyB3ZSBsb29wIGluIHJldmVyc2Ugb3JkZXIgc2luY2UgdGhlIG1vcmUgZ2VuZXJhbCBkcml2ZXJzIChsaWtlIENTUyBhbmQgSlMpXG4gICAgICAgIC8vIG1heSBhdHRlbXB0IG1vcmUgZWxlbWVudHMsIGJ1dCBjdXN0b20gZHJpdmVycyBhcmUgbW9yZSBwYXJ0aWN1bGFyXG4gICAgICAgIGZvciAodmFyIGkgPSBkcml2ZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdmFyIGRyaXZlck5hbWUgPSBkcml2ZXJzW2ldO1xuICAgICAgICAgIHZhciBmYWN0b3J5ID0gJGluamVjdG9yLmdldChkcml2ZXJOYW1lKTtcbiAgICAgICAgICB2YXIgZHJpdmVyID0gZmFjdG9yeShhbmltYXRpb25EZXRhaWxzKTtcbiAgICAgICAgICBpZiAoZHJpdmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZHJpdmVyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBiZWZvcmVTdGFydCgpIHtcbiAgICAgICAgZWxlbWVudC5hZGRDbGFzcyhOR19BTklNQVRFX0NMQVNTTkFNRSk7XG4gICAgICAgIGlmICh0ZW1wQ2xhc3Nlcykge1xuICAgICAgICAgICQkanFMaXRlLmFkZENsYXNzKGVsZW1lbnQsIHRlbXBDbGFzc2VzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJlcGFyZUNsYXNzTmFtZSkge1xuICAgICAgICAgICQkanFMaXRlLnJlbW92ZUNsYXNzKGVsZW1lbnQsIHByZXBhcmVDbGFzc05hbWUpO1xuICAgICAgICAgIHByZXBhcmVDbGFzc05hbWUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHVwZGF0ZUFuaW1hdGlvblJ1bm5lcnMoYW5pbWF0aW9uLCBuZXdSdW5uZXIpIHtcbiAgICAgICAgaWYgKGFuaW1hdGlvbi5mcm9tICYmIGFuaW1hdGlvbi50bykge1xuICAgICAgICAgIHVwZGF0ZShhbmltYXRpb24uZnJvbS5lbGVtZW50KTtcbiAgICAgICAgICB1cGRhdGUoYW5pbWF0aW9uLnRvLmVsZW1lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVwZGF0ZShhbmltYXRpb24uZWxlbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiB1cGRhdGUoZWxlbWVudCkge1xuICAgICAgICAgIHZhciBydW5uZXIgPSBnZXRSdW5uZXIoZWxlbWVudCk7XG4gICAgICAgICAgaWYgKHJ1bm5lcikgcnVubmVyLnNldEhvc3QobmV3UnVubmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBoYW5kbGVEZXN0cm95ZWRFbGVtZW50KCkge1xuICAgICAgICB2YXIgcnVubmVyID0gZ2V0UnVubmVyKGVsZW1lbnQpO1xuICAgICAgICBpZiAocnVubmVyICYmIChldmVudCAhPT0gJ2xlYXZlJyB8fCAhb3B0aW9ucy4kJGRvbU9wZXJhdGlvbkZpcmVkKSkge1xuICAgICAgICAgIHJ1bm5lci5lbmQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjbG9zZShyZWplY3RlZCkge1xuICAgICAgICBlbGVtZW50Lm9mZignJGRlc3Ryb3knLCBoYW5kbGVEZXN0cm95ZWRFbGVtZW50KTtcbiAgICAgICAgcmVtb3ZlUnVubmVyKGVsZW1lbnQpO1xuXG4gICAgICAgIGFwcGx5QW5pbWF0aW9uQ2xhc3NlcyhlbGVtZW50LCBvcHRpb25zKTtcbiAgICAgICAgYXBwbHlBbmltYXRpb25TdHlsZXMoZWxlbWVudCwgb3B0aW9ucyk7XG4gICAgICAgIG9wdGlvbnMuZG9tT3BlcmF0aW9uKCk7XG5cbiAgICAgICAgaWYgKHRlbXBDbGFzc2VzKSB7XG4gICAgICAgICAgJCRqcUxpdGUucmVtb3ZlQ2xhc3MoZWxlbWVudCwgdGVtcENsYXNzZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxlbWVudC5yZW1vdmVDbGFzcyhOR19BTklNQVRFX0NMQVNTTkFNRSk7XG4gICAgICAgIHJ1bm5lci5jb21wbGV0ZSghcmVqZWN0ZWQpO1xuICAgICAgfVxuICAgIH07XG4gIH1dO1xufV07XG5cbi8qKlxuICogQG5nZG9jIGRpcmVjdGl2ZVxuICogQG5hbWUgbmdBbmltYXRlU3dhcFxuICogQHJlc3RyaWN0IEFcbiAqIEBzY29wZVxuICpcbiAqIEBkZXNjcmlwdGlvblxuICpcbiAqIG5nQW5pbWF0ZVN3YXAgaXMgYSBhbmltYXRpb24tb3JpZW50ZWQgZGlyZWN0aXZlIHRoYXQgYWxsb3dzIGZvciB0aGUgY29udGFpbmVyIHRvXG4gKiBiZSByZW1vdmVkIGFuZCBlbnRlcmVkIGluIHdoZW5ldmVyIHRoZSBhc3NvY2lhdGVkIGV4cHJlc3Npb24gY2hhbmdlcy4gQVxuICogY29tbW9uIHVzZWNhc2UgZm9yIHRoaXMgZGlyZWN0aXZlIGlzIGEgcm90YXRpbmcgYmFubmVyIG9yIHNsaWRlciBjb21wb25lbnQgd2hpY2hcbiAqIGNvbnRhaW5zIG9uZSBpbWFnZSBiZWluZyBwcmVzZW50IGF0IGEgdGltZS4gV2hlbiB0aGUgYWN0aXZlIGltYWdlIGNoYW5nZXNcbiAqIHRoZW4gdGhlIG9sZCBpbWFnZSB3aWxsIHBlcmZvcm0gYSBgbGVhdmVgIGFuaW1hdGlvbiBhbmQgdGhlIG5ldyBlbGVtZW50XG4gKiB3aWxsIGJlIGluc2VydGVkIHZpYSBhbiBgZW50ZXJgIGFuaW1hdGlvbi5cbiAqXG4gKiBAYW5pbWF0aW9uc1xuICogfCBBbmltYXRpb24gICAgICAgICAgICAgICAgICAgICAgICB8IE9jY3VycyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAqIHwge0BsaW5rIG5nLiRhbmltYXRlI2VudGVyIGVudGVyfSAgfCB3aGVuIHRoZSBuZXcgZWxlbWVudCBpcyBpbnNlcnRlZCB0byB0aGUgRE9NICB8XG4gKiB8IHtAbGluayBuZy4kYW5pbWF0ZSNsZWF2ZSBsZWF2ZX0gIHwgd2hlbiB0aGUgb2xkIGVsZW1lbnQgaXMgcmVtb3ZlZCBmcm9tIHRoZSBET00gfFxuICpcbiAqIEBleGFtcGxlXG4gKiA8ZXhhbXBsZSBuYW1lPVwibmdBbmltYXRlU3dhcC1kaXJlY3RpdmVcIiBtb2R1bGU9XCJuZ0FuaW1hdGVTd2FwRXhhbXBsZVwiXG4gKiAgICAgICAgICBkZXBzPVwiYW5ndWxhci1hbmltYXRlLmpzXCJcbiAqICAgICAgICAgIGFuaW1hdGlvbnM9XCJ0cnVlXCIgZml4QmFzZT1cInRydWVcIj5cbiAqICAgPGZpbGUgbmFtZT1cImluZGV4Lmh0bWxcIj5cbiAqICAgICA8ZGl2IGNsYXNzPVwiY29udGFpbmVyXCIgbmctY29udHJvbGxlcj1cIkFwcEN0cmxcIj5cbiAqICAgICAgIDxkaXYgbmctYW5pbWF0ZS1zd2FwPVwibnVtYmVyXCIgY2xhc3M9XCJjZWxsIHN3YXAtYW5pbWF0aW9uXCIgbmctY2xhc3M9XCJjb2xvckNsYXNzKG51bWJlcilcIj5cbiAqICAgICAgICAge3sgbnVtYmVyIH19XG4gKiAgICAgICA8L2Rpdj5cbiAqICAgICA8L2Rpdj5cbiAqICAgPC9maWxlPlxuICogICA8ZmlsZSBuYW1lPVwic2NyaXB0LmpzXCI+XG4gKiAgICAgYW5ndWxhci5tb2R1bGUoJ25nQW5pbWF0ZVN3YXBFeGFtcGxlJywgWyduZ0FuaW1hdGUnXSlcbiAqICAgICAgIC5jb250cm9sbGVyKCdBcHBDdHJsJywgWyckc2NvcGUnLCAnJGludGVydmFsJywgZnVuY3Rpb24oJHNjb3BlLCAkaW50ZXJ2YWwpIHtcbiAqICAgICAgICAgJHNjb3BlLm51bWJlciA9IDA7XG4gKiAgICAgICAgICRpbnRlcnZhbChmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAkc2NvcGUubnVtYmVyKys7XG4gKiAgICAgICAgIH0sIDEwMDApO1xuICpcbiAqICAgICAgICAgdmFyIGNvbG9ycyA9IFsncmVkJywnYmx1ZScsJ2dyZWVuJywneWVsbG93Jywnb3JhbmdlJ107XG4gKiAgICAgICAgICRzY29wZS5jb2xvckNsYXNzID0gZnVuY3Rpb24obnVtYmVyKSB7XG4gKiAgICAgICAgICAgcmV0dXJuIGNvbG9yc1tudW1iZXIgJSBjb2xvcnMubGVuZ3RoXTtcbiAqICAgICAgICAgfTtcbiAqICAgICAgIH1dKTtcbiAqICAgPC9maWxlPlxuICogIDxmaWxlIG5hbWU9XCJhbmltYXRpb25zLmNzc1wiPlxuICogIC5jb250YWluZXIge1xuICogICAgaGVpZ2h0OjI1MHB4O1xuICogICAgd2lkdGg6MjUwcHg7XG4gKiAgICBwb3NpdGlvbjpyZWxhdGl2ZTtcbiAqICAgIG92ZXJmbG93OmhpZGRlbjtcbiAqICAgIGJvcmRlcjoycHggc29saWQgYmxhY2s7XG4gKiAgfVxuICogIC5jb250YWluZXIgLmNlbGwge1xuICogICAgZm9udC1zaXplOjE1MHB4O1xuICogICAgdGV4dC1hbGlnbjpjZW50ZXI7XG4gKiAgICBsaW5lLWhlaWdodDoyNTBweDtcbiAqICAgIHBvc2l0aW9uOmFic29sdXRlO1xuICogICAgdG9wOjA7XG4gKiAgICBsZWZ0OjA7XG4gKiAgICByaWdodDowO1xuICogICAgYm9yZGVyLWJvdHRvbToycHggc29saWQgYmxhY2s7XG4gKiAgfVxuICogIC5zd2FwLWFuaW1hdGlvbi5uZy1lbnRlciwgLnN3YXAtYW5pbWF0aW9uLm5nLWxlYXZlIHtcbiAqICAgIHRyYW5zaXRpb246MC41cyBsaW5lYXIgYWxsO1xuICogIH1cbiAqICAuc3dhcC1hbmltYXRpb24ubmctZW50ZXIge1xuICogICAgdG9wOi0yNTBweDtcbiAqICB9XG4gKiAgLnN3YXAtYW5pbWF0aW9uLm5nLWVudGVyLWFjdGl2ZSB7XG4gKiAgICB0b3A6MHB4O1xuICogIH1cbiAqICAuc3dhcC1hbmltYXRpb24ubmctbGVhdmUge1xuICogICAgdG9wOjBweDtcbiAqICB9XG4gKiAgLnN3YXAtYW5pbWF0aW9uLm5nLWxlYXZlLWFjdGl2ZSB7XG4gKiAgICB0b3A6MjUwcHg7XG4gKiAgfVxuICogIC5yZWQgeyBiYWNrZ3JvdW5kOnJlZDsgfVxuICogIC5ncmVlbiB7IGJhY2tncm91bmQ6Z3JlZW47IH1cbiAqICAuYmx1ZSB7IGJhY2tncm91bmQ6Ymx1ZTsgfVxuICogIC55ZWxsb3cgeyBiYWNrZ3JvdW5kOnllbGxvdzsgfVxuICogIC5vcmFuZ2UgeyBiYWNrZ3JvdW5kOm9yYW5nZTsgfVxuICogIDwvZmlsZT5cbiAqIDwvZXhhbXBsZT5cbiAqL1xudmFyIG5nQW5pbWF0ZVN3YXBEaXJlY3RpdmUgPSBbJyRhbmltYXRlJywgJyRyb290U2NvcGUnLCBmdW5jdGlvbigkYW5pbWF0ZSwgJHJvb3RTY29wZSkge1xuICByZXR1cm4ge1xuICAgIHJlc3RyaWN0OiAnQScsXG4gICAgdHJhbnNjbHVkZTogJ2VsZW1lbnQnLFxuICAgIHRlcm1pbmFsOiB0cnVlLFxuICAgIHByaW9yaXR5OiA2MDAsIC8vIHdlIHVzZSA2MDAgaGVyZSB0byBlbnN1cmUgdGhhdCB0aGUgZGlyZWN0aXZlIGlzIGNhdWdodCBiZWZvcmUgb3RoZXJzXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsICRlbGVtZW50LCBhdHRycywgY3RybCwgJHRyYW5zY2x1ZGUpIHtcbiAgICAgIHZhciBwcmV2aW91c0VsZW1lbnQsIHByZXZpb3VzU2NvcGU7XG4gICAgICBzY29wZS4kd2F0Y2hDb2xsZWN0aW9uKGF0dHJzLm5nQW5pbWF0ZVN3YXAgfHwgYXR0cnNbJ2ZvciddLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAocHJldmlvdXNFbGVtZW50KSB7XG4gICAgICAgICAgJGFuaW1hdGUubGVhdmUocHJldmlvdXNFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJldmlvdXNTY29wZSkge1xuICAgICAgICAgIHByZXZpb3VzU2NvcGUuJGRlc3Ryb3koKTtcbiAgICAgICAgICBwcmV2aW91c1Njb3BlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgfHwgdmFsdWUgPT09IDApIHtcbiAgICAgICAgICBwcmV2aW91c1Njb3BlID0gc2NvcGUuJG5ldygpO1xuICAgICAgICAgICR0cmFuc2NsdWRlKHByZXZpb3VzU2NvcGUsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHByZXZpb3VzRWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgICAgICAkYW5pbWF0ZS5lbnRlcihlbGVtZW50LCBudWxsLCAkZWxlbWVudCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn1dO1xuXG4vKipcbiAqIEBuZ2RvYyBtb2R1bGVcbiAqIEBuYW1lIG5nQW5pbWF0ZVxuICogQGRlc2NyaXB0aW9uXG4gKlxuICogVGhlIGBuZ0FuaW1hdGVgIG1vZHVsZSBwcm92aWRlcyBzdXBwb3J0IGZvciBDU1MtYmFzZWQgYW5pbWF0aW9ucyAoa2V5ZnJhbWVzIGFuZCB0cmFuc2l0aW9ucykgYXMgd2VsbCBhcyBKYXZhU2NyaXB0LWJhc2VkIGFuaW1hdGlvbnMgdmlhXG4gKiBjYWxsYmFjayBob29rcy4gQW5pbWF0aW9ucyBhcmUgbm90IGVuYWJsZWQgYnkgZGVmYXVsdCwgaG93ZXZlciwgYnkgaW5jbHVkaW5nIGBuZ0FuaW1hdGVgIHRoZSBhbmltYXRpb24gaG9va3MgYXJlIGVuYWJsZWQgZm9yIGFuIEFuZ3VsYXIgYXBwLlxuICpcbiAqICMjIFVzYWdlXG4gKiBTaW1wbHkgcHV0LCB0aGVyZSBhcmUgdHdvIHdheXMgdG8gbWFrZSB1c2Ugb2YgYW5pbWF0aW9ucyB3aGVuIG5nQW5pbWF0ZSBpcyB1c2VkOiBieSB1c2luZyAqKkNTUyoqIGFuZCAqKkphdmFTY3JpcHQqKi4gVGhlIGZvcm1lciB3b3JrcyBwdXJlbHkgYmFzZWRcbiAqIHVzaW5nIENTUyAoYnkgdXNpbmcgbWF0Y2hpbmcgQ1NTIHNlbGVjdG9ycy9zdHlsZXMpIGFuZCB0aGUgbGF0dGVyIHRyaWdnZXJzIGFuaW1hdGlvbnMgdGhhdCBhcmUgcmVnaXN0ZXJlZCB2aWEgYG1vZHVsZS5hbmltYXRpb24oKWAuIEZvclxuICogYm90aCBDU1MgYW5kIEpTIGFuaW1hdGlvbnMgdGhlIHNvbGUgcmVxdWlyZW1lbnQgaXMgdG8gaGF2ZSBhIG1hdGNoaW5nIGBDU1MgY2xhc3NgIHRoYXQgZXhpc3RzIGJvdGggaW4gdGhlIHJlZ2lzdGVyZWQgYW5pbWF0aW9uIGFuZCB3aXRoaW5cbiAqIHRoZSBIVE1MIGVsZW1lbnQgdGhhdCB0aGUgYW5pbWF0aW9uIHdpbGwgYmUgdHJpZ2dlcmVkIG9uLlxuICpcbiAqICMjIERpcmVjdGl2ZSBTdXBwb3J0XG4gKiBUaGUgZm9sbG93aW5nIGRpcmVjdGl2ZXMgYXJlIFwiYW5pbWF0aW9uIGF3YXJlXCI6XG4gKlxuICogfCBEaXJlY3RpdmUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IFN1cHBvcnRlZCBBbmltYXRpb25zICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXwtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXxcbiAqIHwge0BsaW5rIG5nLmRpcmVjdGl2ZTpuZ1JlcGVhdCNhbmltYXRpb25zIG5nUmVwZWF0fSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBlbnRlciwgbGVhdmUgYW5kIG1vdmUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCB7QGxpbmsgbmdSb3V0ZS5kaXJlY3RpdmU6bmdWaWV3I2FuaW1hdGlvbnMgbmdWaWV3fSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGVudGVyIGFuZCBsZWF2ZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8IHtAbGluayBuZy5kaXJlY3RpdmU6bmdJbmNsdWRlI2FuaW1hdGlvbnMgbmdJbmNsdWRlfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgZW50ZXIgYW5kIGxlYXZlICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwge0BsaW5rIG5nLmRpcmVjdGl2ZTpuZ1N3aXRjaCNhbmltYXRpb25zIG5nU3dpdGNofSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBlbnRlciBhbmQgbGVhdmUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCB7QGxpbmsgbmcuZGlyZWN0aXZlOm5nSWYjYW5pbWF0aW9ucyBuZ0lmfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGVudGVyIGFuZCBsZWF2ZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKiB8IHtAbGluayBuZy5kaXJlY3RpdmU6bmdDbGFzcyNhbmltYXRpb25zIG5nQ2xhc3N9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgYWRkIGFuZCByZW1vdmUgKHRoZSBDU1MgY2xhc3MoZXMpIHByZXNlbnQpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAqIHwge0BsaW5rIG5nLmRpcmVjdGl2ZTpuZ1Nob3cjYW5pbWF0aW9ucyBuZ1Nob3d9ICYge0BsaW5rIG5nLmRpcmVjdGl2ZTpuZ0hpZGUjYW5pbWF0aW9ucyBuZ0hpZGV9ICAgICAgICAgICAgfCBhZGQgYW5kIHJlbW92ZSAodGhlIG5nLWhpZGUgY2xhc3MgdmFsdWUpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCB7QGxpbmsgbmcuZGlyZWN0aXZlOmZvcm0jYW5pbWF0aW9ucyBmb3JtfSAmIHtAbGluayBuZy5kaXJlY3RpdmU6bmdNb2RlbCNhbmltYXRpb25zIG5nTW9kZWx9ICAgIHwgYWRkIGFuZCByZW1vdmUgKGRpcnR5LCBwcmlzdGluZSwgdmFsaWQsIGludmFsaWQgJiBhbGwgb3RoZXIgdmFsaWRhdGlvbnMpIHxcbiAqIHwge0BsaW5rIG1vZHVsZTpuZ01lc3NhZ2VzI2FuaW1hdGlvbnMgbmdNZXNzYWdlc30gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBhZGQgYW5kIHJlbW92ZSAobmctYWN0aXZlICYgbmctaW5hY3RpdmUpICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICogfCB7QGxpbmsgbW9kdWxlOm5nTWVzc2FnZXMjYW5pbWF0aW9ucyBuZ01lc3NhZ2V9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGVudGVyIGFuZCBsZWF2ZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gKlxuICogKE1vcmUgaW5mb3JtYXRpb24gY2FuIGJlIGZvdW5kIGJ5IHZpc2l0aW5nIGVhY2ggdGhlIGRvY3VtZW50YXRpb24gYXNzb2NpYXRlZCB3aXRoIGVhY2ggZGlyZWN0aXZlLilcbiAqXG4gKiAjIyBDU1MtYmFzZWQgQW5pbWF0aW9uc1xuICpcbiAqIENTUy1iYXNlZCBhbmltYXRpb25zIHdpdGggbmdBbmltYXRlIGFyZSB1bmlxdWUgc2luY2UgdGhleSByZXF1aXJlIG5vIEphdmFTY3JpcHQgY29kZSBhdCBhbGwuIEJ5IHVzaW5nIGEgQ1NTIGNsYXNzIHRoYXQgd2UgcmVmZXJlbmNlIGJldHdlZW4gb3VyIEhUTUxcbiAqIGFuZCBDU1MgY29kZSB3ZSBjYW4gY3JlYXRlIGFuIGFuaW1hdGlvbiB0aGF0IHdpbGwgYmUgcGlja2VkIHVwIGJ5IEFuZ3VsYXIgd2hlbiBhbiB1bmRlcmx5aW5nIGRpcmVjdGl2ZSBwZXJmb3JtcyBhbiBvcGVyYXRpb24uXG4gKlxuICogVGhlIGV4YW1wbGUgYmVsb3cgc2hvd3MgaG93IGFuIGBlbnRlcmAgYW5pbWF0aW9uIGNhbiBiZSBtYWRlIHBvc3NpYmxlIG9uIGFuIGVsZW1lbnQgdXNpbmcgYG5nLWlmYDpcbiAqXG4gKiBgYGBodG1sXG4gKiA8ZGl2IG5nLWlmPVwiYm9vbFwiIGNsYXNzPVwiZmFkZVwiPlxuICogICAgRmFkZSBtZSBpbiBvdXRcbiAqIDwvZGl2PlxuICogPGJ1dHRvbiBuZy1jbGljaz1cImJvb2w9dHJ1ZVwiPkZhZGUgSW4hPC9idXR0b24+XG4gKiA8YnV0dG9uIG5nLWNsaWNrPVwiYm9vbD1mYWxzZVwiPkZhZGUgT3V0ITwvYnV0dG9uPlxuICogYGBgXG4gKlxuICogTm90aWNlIHRoZSBDU1MgY2xhc3MgKipmYWRlKio/IFdlIGNhbiBub3cgY3JlYXRlIHRoZSBDU1MgdHJhbnNpdGlvbiBjb2RlIHRoYXQgcmVmZXJlbmNlcyB0aGlzIGNsYXNzOlxuICpcbiAqIGBgYGNzc1xuICogLyYjNDI7IFRoZSBzdGFydGluZyBDU1Mgc3R5bGVzIGZvciB0aGUgZW50ZXIgYW5pbWF0aW9uICYjNDI7L1xuICogLmZhZGUubmctZW50ZXIge1xuICogICB0cmFuc2l0aW9uOjAuNXMgbGluZWFyIGFsbDtcbiAqICAgb3BhY2l0eTowO1xuICogfVxuICpcbiAqIC8mIzQyOyBUaGUgZmluaXNoaW5nIENTUyBzdHlsZXMgZm9yIHRoZSBlbnRlciBhbmltYXRpb24gJiM0MjsvXG4gKiAuZmFkZS5uZy1lbnRlci5uZy1lbnRlci1hY3RpdmUge1xuICogICBvcGFjaXR5OjE7XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBUaGUga2V5IHRoaW5nIHRvIHJlbWVtYmVyIGhlcmUgaXMgdGhhdCwgZGVwZW5kaW5nIG9uIHRoZSBhbmltYXRpb24gZXZlbnQgKHdoaWNoIGVhY2ggb2YgdGhlIGRpcmVjdGl2ZXMgYWJvdmUgdHJpZ2dlciBkZXBlbmRpbmcgb24gd2hhdCdzIGdvaW5nIG9uKSB0d29cbiAqIGdlbmVyYXRlZCBDU1MgY2xhc3NlcyB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIGVsZW1lbnQ7IGluIHRoZSBleGFtcGxlIGFib3ZlIHdlIGhhdmUgYC5uZy1lbnRlcmAgYW5kIGAubmctZW50ZXItYWN0aXZlYC4gRm9yIENTUyB0cmFuc2l0aW9ucywgdGhlIHRyYW5zaXRpb25cbiAqIGNvZGUgKiptdXN0KiogYmUgZGVmaW5lZCB3aXRoaW4gdGhlIHN0YXJ0aW5nIENTUyBjbGFzcyAoaW4gdGhpcyBjYXNlIGAubmctZW50ZXJgKS4gVGhlIGRlc3RpbmF0aW9uIGNsYXNzIGlzIHdoYXQgdGhlIHRyYW5zaXRpb24gd2lsbCBhbmltYXRlIHRvd2FyZHMuXG4gKlxuICogSWYgZm9yIGV4YW1wbGUgd2Ugd2FudGVkIHRvIGNyZWF0ZSBhbmltYXRpb25zIGZvciBgbGVhdmVgIGFuZCBgbW92ZWAgKG5nUmVwZWF0IHRyaWdnZXJzIG1vdmUpIHRoZW4gd2UgY2FuIGRvIHNvIHVzaW5nIHRoZSBzYW1lIENTUyBuYW1pbmcgY29udmVudGlvbnM6XG4gKlxuICogYGBgY3NzXG4gKiAvJiM0Mjsgbm93IHRoZSBlbGVtZW50IHdpbGwgZmFkZSBvdXQgYmVmb3JlIGl0IGlzIHJlbW92ZWQgZnJvbSB0aGUgRE9NICYjNDI7L1xuICogLmZhZGUubmctbGVhdmUge1xuICogICB0cmFuc2l0aW9uOjAuNXMgbGluZWFyIGFsbDtcbiAqICAgb3BhY2l0eToxO1xuICogfVxuICogLmZhZGUubmctbGVhdmUubmctbGVhdmUtYWN0aXZlIHtcbiAqICAgb3BhY2l0eTowO1xuICogfVxuICogYGBgXG4gKlxuICogV2UgY2FuIGFsc28gbWFrZSB1c2Ugb2YgKipDU1MgS2V5ZnJhbWVzKiogYnkgcmVmZXJlbmNpbmcgdGhlIGtleWZyYW1lIGFuaW1hdGlvbiB3aXRoaW4gdGhlIHN0YXJ0aW5nIENTUyBjbGFzczpcbiAqXG4gKiBgYGBjc3NcbiAqIC8mIzQyOyB0aGVyZSBpcyBubyBuZWVkIHRvIGRlZmluZSBhbnl0aGluZyBpbnNpZGUgb2YgdGhlIGRlc3RpbmF0aW9uXG4gKiBDU1MgY2xhc3Mgc2luY2UgdGhlIGtleWZyYW1lIHdpbGwgdGFrZSBjaGFyZ2Ugb2YgdGhlIGFuaW1hdGlvbiAmIzQyOy9cbiAqIC5mYWRlLm5nLWxlYXZlIHtcbiAqICAgYW5pbWF0aW9uOiBteV9mYWRlX2FuaW1hdGlvbiAwLjVzIGxpbmVhcjtcbiAqICAgLXdlYmtpdC1hbmltYXRpb246IG15X2ZhZGVfYW5pbWF0aW9uIDAuNXMgbGluZWFyO1xuICogfVxuICpcbiAqIEBrZXlmcmFtZXMgbXlfZmFkZV9hbmltYXRpb24ge1xuICogICBmcm9tIHsgb3BhY2l0eToxOyB9XG4gKiAgIHRvIHsgb3BhY2l0eTowOyB9XG4gKiB9XG4gKlxuICogQC13ZWJraXQta2V5ZnJhbWVzIG15X2ZhZGVfYW5pbWF0aW9uIHtcbiAqICAgZnJvbSB7IG9wYWNpdHk6MTsgfVxuICogICB0byB7IG9wYWNpdHk6MDsgfVxuICogfVxuICogYGBgXG4gKlxuICogRmVlbCBmcmVlIGFsc28gbWl4IHRyYW5zaXRpb25zIGFuZCBrZXlmcmFtZXMgdG9nZXRoZXIgYXMgd2VsbCBhcyBhbnkgb3RoZXIgQ1NTIGNsYXNzZXMgb24gdGhlIHNhbWUgZWxlbWVudC5cbiAqXG4gKiAjIyMgQ1NTIENsYXNzLWJhc2VkIEFuaW1hdGlvbnNcbiAqXG4gKiBDbGFzcy1iYXNlZCBhbmltYXRpb25zIChhbmltYXRpb25zIHRoYXQgYXJlIHRyaWdnZXJlZCB2aWEgYG5nQ2xhc3NgLCBgbmdTaG93YCwgYG5nSGlkZWAgYW5kIHNvbWUgb3RoZXIgZGlyZWN0aXZlcykgaGF2ZSBhIHNsaWdodGx5IGRpZmZlcmVudFxuICogbmFtaW5nIGNvbnZlbnRpb24uIENsYXNzLWJhc2VkIGFuaW1hdGlvbnMgYXJlIGJhc2ljIGVub3VnaCB0aGF0IGEgc3RhbmRhcmQgdHJhbnNpdGlvbiBvciBrZXlmcmFtZSBjYW4gYmUgcmVmZXJlbmNlZCBvbiB0aGUgY2xhc3MgYmVpbmcgYWRkZWRcbiAqIGFuZCByZW1vdmVkLlxuICpcbiAqIEZvciBleGFtcGxlIGlmIHdlIHdhbnRlZCB0byBkbyBhIENTUyBhbmltYXRpb24gZm9yIGBuZ0hpZGVgIHRoZW4gd2UgcGxhY2UgYW4gYW5pbWF0aW9uIG9uIHRoZSBgLm5nLWhpZGVgIENTUyBjbGFzczpcbiAqXG4gKiBgYGBodG1sXG4gKiA8ZGl2IG5nLXNob3c9XCJib29sXCIgY2xhc3M9XCJmYWRlXCI+XG4gKiAgIFNob3cgYW5kIGhpZGUgbWVcbiAqIDwvZGl2PlxuICogPGJ1dHRvbiBuZy1jbGljaz1cImJvb2w9IWJvb2xcIj5Ub2dnbGU8L2J1dHRvbj5cbiAqXG4gKiA8c3R5bGU+XG4gKiAuZmFkZS5uZy1oaWRlIHtcbiAqICAgdHJhbnNpdGlvbjowLjVzIGxpbmVhciBhbGw7XG4gKiAgIG9wYWNpdHk6MDtcbiAqIH1cbiAqIDwvc3R5bGU+XG4gKiBgYGBcbiAqXG4gKiBBbGwgdGhhdCBpcyBnb2luZyBvbiBoZXJlIHdpdGggbmdTaG93L25nSGlkZSBiZWhpbmQgdGhlIHNjZW5lcyBpcyB0aGUgYC5uZy1oaWRlYCBjbGFzcyBpcyBhZGRlZC9yZW1vdmVkICh3aGVuIHRoZSBoaWRkZW4gc3RhdGUgaXMgdmFsaWQpLiBTaW5jZVxuICogbmdTaG93IGFuZCBuZ0hpZGUgYXJlIGFuaW1hdGlvbiBhd2FyZSB0aGVuIHdlIGNhbiBtYXRjaCB1cCBhIHRyYW5zaXRpb24gYW5kIG5nQW5pbWF0ZSBoYW5kbGVzIHRoZSByZXN0LlxuICpcbiAqIEluIGFkZGl0aW9uIHRoZSBhZGRpdGlvbiBhbmQgcmVtb3ZhbCBvZiB0aGUgQ1NTIGNsYXNzLCBuZ0FuaW1hdGUgYWxzbyBwcm92aWRlcyB0d28gaGVscGVyIG1ldGhvZHMgdGhhdCB3ZSBjYW4gdXNlIHRvIGZ1cnRoZXIgZGVjb3JhdGUgdGhlIGFuaW1hdGlvblxuICogd2l0aCBDU1Mgc3R5bGVzLlxuICpcbiAqIGBgYGh0bWxcbiAqIDxkaXYgbmctY2xhc3M9XCJ7b246b25PZmZ9XCIgY2xhc3M9XCJoaWdobGlnaHRcIj5cbiAqICAgSGlnaGxpZ2h0IHRoaXMgYm94XG4gKiA8L2Rpdj5cbiAqIDxidXR0b24gbmctY2xpY2s9XCJvbk9mZj0hb25PZmZcIj5Ub2dnbGU8L2J1dHRvbj5cbiAqXG4gKiA8c3R5bGU+XG4gKiAuaGlnaGxpZ2h0IHtcbiAqICAgdHJhbnNpdGlvbjowLjVzIGxpbmVhciBhbGw7XG4gKiB9XG4gKiAuaGlnaGxpZ2h0Lm9uLWFkZCB7XG4gKiAgIGJhY2tncm91bmQ6d2hpdGU7XG4gKiB9XG4gKiAuaGlnaGxpZ2h0Lm9uIHtcbiAqICAgYmFja2dyb3VuZDp5ZWxsb3c7XG4gKiB9XG4gKiAuaGlnaGxpZ2h0Lm9uLXJlbW92ZSB7XG4gKiAgIGJhY2tncm91bmQ6YmxhY2s7XG4gKiB9XG4gKiA8L3N0eWxlPlxuICogYGBgXG4gKlxuICogV2UgY2FuIGFsc28gbWFrZSB1c2Ugb2YgQ1NTIGtleWZyYW1lcyBieSBwbGFjaW5nIHRoZW0gd2l0aGluIHRoZSBDU1MgY2xhc3Nlcy5cbiAqXG4gKlxuICogIyMjIENTUyBTdGFnZ2VyaW5nIEFuaW1hdGlvbnNcbiAqIEEgU3RhZ2dlcmluZyBhbmltYXRpb24gaXMgYSBjb2xsZWN0aW9uIG9mIGFuaW1hdGlvbnMgdGhhdCBhcmUgaXNzdWVkIHdpdGggYSBzbGlnaHQgZGVsYXkgaW4gYmV0d2VlbiBlYWNoIHN1Y2Nlc3NpdmUgb3BlcmF0aW9uIHJlc3VsdGluZyBpbiBhXG4gKiBjdXJ0YWluLWxpa2UgZWZmZWN0LiBUaGUgbmdBbmltYXRlIG1vZHVsZSAodmVyc2lvbnMgPj0xLjIpIHN1cHBvcnRzIHN0YWdnZXJpbmcgYW5pbWF0aW9ucyBhbmQgdGhlIHN0YWdnZXIgZWZmZWN0IGNhbiBiZVxuICogcGVyZm9ybWVkIGJ5IGNyZWF0aW5nIGEgKipuZy1FVkVOVC1zdGFnZ2VyKiogQ1NTIGNsYXNzIGFuZCBhdHRhY2hpbmcgdGhhdCBjbGFzcyB0byB0aGUgYmFzZSBDU1MgY2xhc3MgdXNlZCBmb3JcbiAqIHRoZSBhbmltYXRpb24uIFRoZSBzdHlsZSBwcm9wZXJ0eSBleHBlY3RlZCB3aXRoaW4gdGhlIHN0YWdnZXIgY2xhc3MgY2FuIGVpdGhlciBiZSBhICoqdHJhbnNpdGlvbi1kZWxheSoqIG9yIGFuXG4gKiAqKmFuaW1hdGlvbi1kZWxheSoqIHByb3BlcnR5IChvciBib3RoIGlmIHlvdXIgYW5pbWF0aW9uIGNvbnRhaW5zIGJvdGggdHJhbnNpdGlvbnMgYW5kIGtleWZyYW1lIGFuaW1hdGlvbnMpLlxuICpcbiAqIGBgYGNzc1xuICogLm15LWFuaW1hdGlvbi5uZy1lbnRlciB7XG4gKiAgIC8mIzQyOyBzdGFuZGFyZCB0cmFuc2l0aW9uIGNvZGUgJiM0MjsvXG4gKiAgIHRyYW5zaXRpb246IDFzIGxpbmVhciBhbGw7XG4gKiAgIG9wYWNpdHk6MDtcbiAqIH1cbiAqIC5teS1hbmltYXRpb24ubmctZW50ZXItc3RhZ2dlciB7XG4gKiAgIC8mIzQyOyB0aGlzIHdpbGwgaGF2ZSBhIDEwMG1zIGRlbGF5IGJldHdlZW4gZWFjaCBzdWNjZXNzaXZlIGxlYXZlIGFuaW1hdGlvbiAmIzQyOy9cbiAqICAgdHJhbnNpdGlvbi1kZWxheTogMC4xcztcbiAqXG4gKiAgIC8mIzQyOyBBcyBvZiAxLjQuNCwgdGhpcyBtdXN0IGFsd2F5cyBiZSBzZXQ6IGl0IHNpZ25hbHMgbmdBbmltYXRlXG4gKiAgICAgdG8gbm90IGFjY2lkZW50YWxseSBpbmhlcml0IGEgZGVsYXkgcHJvcGVydHkgZnJvbSBhbm90aGVyIENTUyBjbGFzcyAmIzQyOy9cbiAqICAgdHJhbnNpdGlvbi1kdXJhdGlvbjogMHM7XG4gKlxuICogICAvJiM0MjsgaWYgeW91IGFyZSB1c2luZyBhbmltYXRpb25zIGluc3RlYWQgb2YgdHJhbnNpdGlvbnMgeW91IHNob3VsZCBjb25maWd1cmUgYXMgZm9sbG93czpcbiAqICAgICBhbmltYXRpb24tZGVsYXk6IDAuMXM7XG4gKiAgICAgYW5pbWF0aW9uLWR1cmF0aW9uOiAwczsgJiM0MjsvXG4gKiB9XG4gKiAubXktYW5pbWF0aW9uLm5nLWVudGVyLm5nLWVudGVyLWFjdGl2ZSB7XG4gKiAgIC8mIzQyOyBzdGFuZGFyZCB0cmFuc2l0aW9uIHN0eWxlcyAmIzQyOy9cbiAqICAgb3BhY2l0eToxO1xuICogfVxuICogYGBgXG4gKlxuICogU3RhZ2dlcmluZyBhbmltYXRpb25zIHdvcmsgYnkgZGVmYXVsdCBpbiBuZ1JlcGVhdCAoc28gbG9uZyBhcyB0aGUgQ1NTIGNsYXNzIGlzIGRlZmluZWQpLiBPdXRzaWRlIG9mIG5nUmVwZWF0LCB0byB1c2Ugc3RhZ2dlcmluZyBhbmltYXRpb25zXG4gKiBvbiB5b3VyIG93biwgdGhleSBjYW4gYmUgdHJpZ2dlcmVkIGJ5IGZpcmluZyBtdWx0aXBsZSBjYWxscyB0byB0aGUgc2FtZSBldmVudCBvbiAkYW5pbWF0ZS4gSG93ZXZlciwgdGhlIHJlc3RyaWN0aW9ucyBzdXJyb3VuZGluZyB0aGlzXG4gKiBhcmUgdGhhdCBlYWNoIG9mIHRoZSBlbGVtZW50cyBtdXN0IGhhdmUgdGhlIHNhbWUgQ1NTIGNsYXNzTmFtZSB2YWx1ZSBhcyB3ZWxsIGFzIHRoZSBzYW1lIHBhcmVudCBlbGVtZW50LiBBIHN0YWdnZXIgb3BlcmF0aW9uXG4gKiB3aWxsIGFsc28gYmUgcmVzZXQgaWYgb25lIG9yIG1vcmUgYW5pbWF0aW9uIGZyYW1lcyBoYXZlIHBhc3NlZCBzaW5jZSB0aGUgbXVsdGlwbGUgY2FsbHMgdG8gYCRhbmltYXRlYCB3ZXJlIGZpcmVkLlxuICpcbiAqIFRoZSBmb2xsb3dpbmcgY29kZSB3aWxsIGlzc3VlIHRoZSAqKm5nLWxlYXZlLXN0YWdnZXIqKiBldmVudCBvbiB0aGUgZWxlbWVudCBwcm92aWRlZDpcbiAqXG4gKiBgYGBqc1xuICogdmFyIGtpZHMgPSBwYXJlbnQuY2hpbGRyZW4oKTtcbiAqXG4gKiAkYW5pbWF0ZS5sZWF2ZShraWRzWzBdKTsgLy9zdGFnZ2VyIGluZGV4PTBcbiAqICRhbmltYXRlLmxlYXZlKGtpZHNbMV0pOyAvL3N0YWdnZXIgaW5kZXg9MVxuICogJGFuaW1hdGUubGVhdmUoa2lkc1syXSk7IC8vc3RhZ2dlciBpbmRleD0yXG4gKiAkYW5pbWF0ZS5sZWF2ZShraWRzWzNdKTsgLy9zdGFnZ2VyIGluZGV4PTNcbiAqICRhbmltYXRlLmxlYXZlKGtpZHNbNF0pOyAvL3N0YWdnZXIgaW5kZXg9NFxuICpcbiAqIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKSB7XG4gKiAgIC8vc3RhZ2dlciBoYXMgcmVzZXQgaXRzZWxmXG4gKiAgICRhbmltYXRlLmxlYXZlKGtpZHNbNV0pOyAvL3N0YWdnZXIgaW5kZXg9MFxuICogICAkYW5pbWF0ZS5sZWF2ZShraWRzWzZdKTsgLy9zdGFnZ2VyIGluZGV4PTFcbiAqXG4gKiAgICRzY29wZS4kZGlnZXN0KCk7XG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIFN0YWdnZXIgYW5pbWF0aW9ucyBhcmUgY3VycmVudGx5IG9ubHkgc3VwcG9ydGVkIHdpdGhpbiBDU1MtZGVmaW5lZCBhbmltYXRpb25zLlxuICpcbiAqICMjIyBUaGUgYG5nLWFuaW1hdGVgIENTUyBjbGFzc1xuICpcbiAqIFdoZW4gbmdBbmltYXRlIGlzIGFuaW1hdGluZyBhbiBlbGVtZW50IGl0IHdpbGwgYXBwbHkgdGhlIGBuZy1hbmltYXRlYCBDU1MgY2xhc3MgdG8gdGhlIGVsZW1lbnQgZm9yIHRoZSBkdXJhdGlvbiBvZiB0aGUgYW5pbWF0aW9uLlxuICogVGhpcyBpcyBhIHRlbXBvcmFyeSBDU1MgY2xhc3MgYW5kIGl0IHdpbGwgYmUgcmVtb3ZlZCBvbmNlIHRoZSBhbmltYXRpb24gaXMgb3ZlciAoZm9yIGJvdGggSmF2YVNjcmlwdCBhbmQgQ1NTLWJhc2VkIGFuaW1hdGlvbnMpLlxuICpcbiAqIFRoZXJlZm9yZSwgYW5pbWF0aW9ucyBjYW4gYmUgYXBwbGllZCB0byBhbiBlbGVtZW50IHVzaW5nIHRoaXMgdGVtcG9yYXJ5IGNsYXNzIGRpcmVjdGx5IHZpYSBDU1MuXG4gKlxuICogYGBgY3NzXG4gKiAuemlwcGVyLm5nLWFuaW1hdGUge1xuICogICB0cmFuc2l0aW9uOjAuNXMgbGluZWFyIGFsbDtcbiAqIH1cbiAqIC56aXBwZXIubmctZW50ZXIge1xuICogICBvcGFjaXR5OjA7XG4gKiB9XG4gKiAuemlwcGVyLm5nLWVudGVyLm5nLWVudGVyLWFjdGl2ZSB7XG4gKiAgIG9wYWNpdHk6MTtcbiAqIH1cbiAqIC56aXBwZXIubmctbGVhdmUge1xuICogICBvcGFjaXR5OjE7XG4gKiB9XG4gKiAuemlwcGVyLm5nLWxlYXZlLm5nLWxlYXZlLWFjdGl2ZSB7XG4gKiAgIG9wYWNpdHk6MDtcbiAqIH1cbiAqIGBgYFxuICpcbiAqIChOb3RlIHRoYXQgdGhlIGBuZy1hbmltYXRlYCBDU1MgY2xhc3MgaXMgcmVzZXJ2ZWQgYW5kIGl0IGNhbm5vdCBiZSBhcHBsaWVkIG9uIGFuIGVsZW1lbnQgZGlyZWN0bHkgc2luY2UgbmdBbmltYXRlIHdpbGwgYWx3YXlzIHJlbW92ZVxuICogdGhlIENTUyBjbGFzcyBvbmNlIGFuIGFuaW1hdGlvbiBoYXMgY29tcGxldGVkLilcbiAqXG4gKlxuICogIyMjIFRoZSBgbmctW2V2ZW50XS1wcmVwYXJlYCBjbGFzc1xuICpcbiAqIFRoaXMgaXMgYSBzcGVjaWFsIGNsYXNzIHRoYXQgY2FuIGJlIHVzZWQgdG8gcHJldmVudCB1bndhbnRlZCBmbGlja2VyaW5nIC8gZmxhc2ggb2YgY29udGVudCBiZWZvcmVcbiAqIHRoZSBhY3R1YWwgYW5pbWF0aW9uIHN0YXJ0cy4gVGhlIGNsYXNzIGlzIGFkZGVkIGFzIHNvb24gYXMgYW4gYW5pbWF0aW9uIGlzIGluaXRpYWxpemVkLCBidXQgcmVtb3ZlZFxuICogYmVmb3JlIHRoZSBhY3R1YWwgYW5pbWF0aW9uIHN0YXJ0cyAoYWZ0ZXIgd2FpdGluZyBmb3IgYSAkZGlnZXN0KS5cbiAqIEl0IGlzIGFsc28gb25seSBhZGRlZCBmb3IgKnN0cnVjdHVyYWwqIGFuaW1hdGlvbnMgKGBlbnRlcmAsIGBtb3ZlYCwgYW5kIGBsZWF2ZWApLlxuICpcbiAqIEluIHByYWN0aWNlLCBmbGlja2VyaW5nIGNhbiBhcHBlYXIgd2hlbiBuZXN0aW5nIGVsZW1lbnRzIHdpdGggc3RydWN0dXJhbCBhbmltYXRpb25zIHN1Y2ggYXMgYG5nSWZgXG4gKiBpbnRvIGVsZW1lbnRzIHRoYXQgaGF2ZSBjbGFzcy1iYXNlZCBhbmltYXRpb25zIHN1Y2ggYXMgYG5nQ2xhc3NgLlxuICpcbiAqIGBgYGh0bWxcbiAqIDxkaXYgbmctY2xhc3M9XCJ7cmVkOiBteVByb3B9XCI+XG4gKiAgIDxkaXYgbmctY2xhc3M9XCJ7Ymx1ZTogbXlQcm9wfVwiPlxuICogICAgIDxkaXYgY2xhc3M9XCJtZXNzYWdlXCIgbmctaWY9XCJteVByb3BcIj48L2Rpdj5cbiAqICAgPC9kaXY+XG4gKiA8L2Rpdj5cbiAqIGBgYFxuICpcbiAqIEl0IGlzIHBvc3NpYmxlIHRoYXQgZHVyaW5nIHRoZSBgZW50ZXJgIGFuaW1hdGlvbiwgdGhlIGAubWVzc2FnZWAgZGl2IHdpbGwgYmUgYnJpZWZseSB2aXNpYmxlIGJlZm9yZSBpdCBzdGFydHMgYW5pbWF0aW5nLlxuICogSW4gdGhhdCBjYXNlLCB5b3UgY2FuIGFkZCBzdHlsZXMgdG8gdGhlIENTUyB0aGF0IG1ha2Ugc3VyZSB0aGUgZWxlbWVudCBzdGF5cyBoaWRkZW4gYmVmb3JlIHRoZSBhbmltYXRpb24gc3RhcnRzOlxuICpcbiAqIGBgYGNzc1xuICogLm1lc3NhZ2UubmctZW50ZXItcHJlcGFyZSB7XG4gKiAgIG9wYWNpdHk6IDA7XG4gKiB9XG4gKlxuICogYGBgXG4gKlxuICogIyMgSmF2YVNjcmlwdC1iYXNlZCBBbmltYXRpb25zXG4gKlxuICogbmdBbmltYXRlIGFsc28gYWxsb3dzIGZvciBhbmltYXRpb25zIHRvIGJlIGNvbnN1bWVkIGJ5IEphdmFTY3JpcHQgY29kZS4gVGhlIGFwcHJvYWNoIGlzIHNpbWlsYXIgdG8gQ1NTLWJhc2VkIGFuaW1hdGlvbnMgKHdoZXJlIHRoZXJlIGlzIGEgc2hhcmVkXG4gKiBDU1MgY2xhc3MgdGhhdCBpcyByZWZlcmVuY2VkIGluIG91ciBIVE1MIGNvZGUpIGJ1dCBpbiBhZGRpdGlvbiB3ZSBuZWVkIHRvIHJlZ2lzdGVyIHRoZSBKYXZhU2NyaXB0IGFuaW1hdGlvbiBvbiB0aGUgbW9kdWxlLiBCeSBtYWtpbmcgdXNlIG9mIHRoZVxuICogYG1vZHVsZS5hbmltYXRpb24oKWAgbW9kdWxlIGZ1bmN0aW9uIHdlIGNhbiByZWdpc3RlciB0aGUgYW5pbWF0aW9uLlxuICpcbiAqIExldCdzIHNlZSBhbiBleGFtcGxlIG9mIGEgZW50ZXIvbGVhdmUgYW5pbWF0aW9uIHVzaW5nIGBuZ1JlcGVhdGA6XG4gKlxuICogYGBgaHRtbFxuICogPGRpdiBuZy1yZXBlYXQ9XCJpdGVtIGluIGl0ZW1zXCIgY2xhc3M9XCJzbGlkZVwiPlxuICogICB7eyBpdGVtIH19XG4gKiA8L2Rpdj5cbiAqIGBgYFxuICpcbiAqIFNlZSB0aGUgKipzbGlkZSoqIENTUyBjbGFzcz8gTGV0J3MgdXNlIHRoYXQgY2xhc3MgdG8gZGVmaW5lIGFuIGFuaW1hdGlvbiB0aGF0IHdlJ2xsIHN0cnVjdHVyZSBpbiBvdXIgbW9kdWxlIGNvZGUgYnkgdXNpbmcgYG1vZHVsZS5hbmltYXRpb25gOlxuICpcbiAqIGBgYGpzXG4gKiBteU1vZHVsZS5hbmltYXRpb24oJy5zbGlkZScsIFtmdW5jdGlvbigpIHtcbiAqICAgcmV0dXJuIHtcbiAqICAgICAvLyBtYWtlIG5vdGUgdGhhdCBvdGhlciBldmVudHMgKGxpa2UgYWRkQ2xhc3MvcmVtb3ZlQ2xhc3MpXG4gKiAgICAgLy8gaGF2ZSBkaWZmZXJlbnQgZnVuY3Rpb24gaW5wdXQgcGFyYW1ldGVyc1xuICogICAgIGVudGVyOiBmdW5jdGlvbihlbGVtZW50LCBkb25lRm4pIHtcbiAqICAgICAgIGpRdWVyeShlbGVtZW50KS5mYWRlSW4oMTAwMCwgZG9uZUZuKTtcbiAqXG4gKiAgICAgICAvLyByZW1lbWJlciB0byBjYWxsIGRvbmVGbiBzbyB0aGF0IGFuZ3VsYXJcbiAqICAgICAgIC8vIGtub3dzIHRoYXQgdGhlIGFuaW1hdGlvbiBoYXMgY29uY2x1ZGVkXG4gKiAgICAgfSxcbiAqXG4gKiAgICAgbW92ZTogZnVuY3Rpb24oZWxlbWVudCwgZG9uZUZuKSB7XG4gKiAgICAgICBqUXVlcnkoZWxlbWVudCkuZmFkZUluKDEwMDAsIGRvbmVGbik7XG4gKiAgICAgfSxcbiAqXG4gKiAgICAgbGVhdmU6IGZ1bmN0aW9uKGVsZW1lbnQsIGRvbmVGbikge1xuICogICAgICAgalF1ZXJ5KGVsZW1lbnQpLmZhZGVPdXQoMTAwMCwgZG9uZUZuKTtcbiAqICAgICB9XG4gKiAgIH1cbiAqIH1dKTtcbiAqIGBgYFxuICpcbiAqIFRoZSBuaWNlIHRoaW5nIGFib3V0IEpTLWJhc2VkIGFuaW1hdGlvbnMgaXMgdGhhdCB3ZSBjYW4gaW5qZWN0IG90aGVyIHNlcnZpY2VzIGFuZCBtYWtlIHVzZSBvZiBhZHZhbmNlZCBhbmltYXRpb24gbGlicmFyaWVzIHN1Y2ggYXNcbiAqIGdyZWVuc29jay5qcyBhbmQgdmVsb2NpdHkuanMuXG4gKlxuICogSWYgb3VyIGFuaW1hdGlvbiBjb2RlIGNsYXNzLWJhc2VkIChtZWFuaW5nIHRoYXQgc29tZXRoaW5nIGxpa2UgYG5nQ2xhc3NgLCBgbmdIaWRlYCBhbmQgYG5nU2hvd2AgdHJpZ2dlcnMgaXQpIHRoZW4gd2UgY2FuIHN0aWxsIGRlZmluZVxuICogb3VyIGFuaW1hdGlvbnMgaW5zaWRlIG9mIHRoZSBzYW1lIHJlZ2lzdGVyZWQgYW5pbWF0aW9uLCBob3dldmVyLCB0aGUgZnVuY3Rpb24gaW5wdXQgYXJndW1lbnRzIGFyZSBhIGJpdCBkaWZmZXJlbnQ6XG4gKlxuICogYGBgaHRtbFxuICogPGRpdiBuZy1jbGFzcz1cImNvbG9yXCIgY2xhc3M9XCJjb2xvcmZ1bFwiPlxuICogICB0aGlzIGJveCBpcyBtb29keVxuICogPC9kaXY+XG4gKiA8YnV0dG9uIG5nLWNsaWNrPVwiY29sb3I9J3JlZCdcIj5DaGFuZ2UgdG8gcmVkPC9idXR0b24+XG4gKiA8YnV0dG9uIG5nLWNsaWNrPVwiY29sb3I9J2JsdWUnXCI+Q2hhbmdlIHRvIGJsdWU8L2J1dHRvbj5cbiAqIDxidXR0b24gbmctY2xpY2s9XCJjb2xvcj0nZ3JlZW4nXCI+Q2hhbmdlIHRvIGdyZWVuPC9idXR0b24+XG4gKiBgYGBcbiAqXG4gKiBgYGBqc1xuICogbXlNb2R1bGUuYW5pbWF0aW9uKCcuY29sb3JmdWwnLCBbZnVuY3Rpb24oKSB7XG4gKiAgIHJldHVybiB7XG4gKiAgICAgYWRkQ2xhc3M6IGZ1bmN0aW9uKGVsZW1lbnQsIGNsYXNzTmFtZSwgZG9uZUZuKSB7XG4gKiAgICAgICAvLyBkbyBzb21lIGNvb2wgYW5pbWF0aW9uIGFuZCBjYWxsIHRoZSBkb25lRm5cbiAqICAgICB9LFxuICogICAgIHJlbW92ZUNsYXNzOiBmdW5jdGlvbihlbGVtZW50LCBjbGFzc05hbWUsIGRvbmVGbikge1xuICogICAgICAgLy8gZG8gc29tZSBjb29sIGFuaW1hdGlvbiBhbmQgY2FsbCB0aGUgZG9uZUZuXG4gKiAgICAgfSxcbiAqICAgICBzZXRDbGFzczogZnVuY3Rpb24oZWxlbWVudCwgYWRkZWRDbGFzcywgcmVtb3ZlZENsYXNzLCBkb25lRm4pIHtcbiAqICAgICAgIC8vIGRvIHNvbWUgY29vbCBhbmltYXRpb24gYW5kIGNhbGwgdGhlIGRvbmVGblxuICogICAgIH1cbiAqICAgfVxuICogfV0pO1xuICogYGBgXG4gKlxuICogIyMgQ1NTICsgSlMgQW5pbWF0aW9ucyBUb2dldGhlclxuICpcbiAqIEFuZ3VsYXJKUyAxLjQgYW5kIGhpZ2hlciBoYXMgdGFrZW4gc3RlcHMgdG8gbWFrZSB0aGUgYW1hbGdhbWF0aW9uIG9mIENTUyBhbmQgSlMgYW5pbWF0aW9ucyBtb3JlIGZsZXhpYmxlLiBIb3dldmVyLCB1bmxpa2UgZWFybGllciB2ZXJzaW9ucyBvZiBBbmd1bGFyLFxuICogZGVmaW5pbmcgQ1NTIGFuZCBKUyBhbmltYXRpb25zIHRvIHdvcmsgb2ZmIG9mIHRoZSBzYW1lIENTUyBjbGFzcyB3aWxsIG5vdCB3b3JrIGFueW1vcmUuIFRoZXJlZm9yZSB0aGUgZXhhbXBsZSBiZWxvdyB3aWxsIG9ubHkgcmVzdWx0IGluICoqSlMgYW5pbWF0aW9ucyB0YWtpbmdcbiAqIGNoYXJnZSBvZiB0aGUgYW5pbWF0aW9uKio6XG4gKlxuICogYGBgaHRtbFxuICogPGRpdiBuZy1pZj1cImJvb2xcIiBjbGFzcz1cInNsaWRlXCI+XG4gKiAgIFNsaWRlIGluIGFuZCBvdXRcbiAqIDwvZGl2PlxuICogYGBgXG4gKlxuICogYGBganNcbiAqIG15TW9kdWxlLmFuaW1hdGlvbignLnNsaWRlJywgW2Z1bmN0aW9uKCkge1xuICogICByZXR1cm4ge1xuICogICAgIGVudGVyOiBmdW5jdGlvbihlbGVtZW50LCBkb25lRm4pIHtcbiAqICAgICAgIGpRdWVyeShlbGVtZW50KS5zbGlkZUluKDEwMDAsIGRvbmVGbik7XG4gKiAgICAgfVxuICogICB9XG4gKiB9XSk7XG4gKiBgYGBcbiAqXG4gKiBgYGBjc3NcbiAqIC5zbGlkZS5uZy1lbnRlciB7XG4gKiAgIHRyYW5zaXRpb246MC41cyBsaW5lYXIgYWxsO1xuICogICB0cmFuc2Zvcm06dHJhbnNsYXRlWSgtMTAwcHgpO1xuICogfVxuICogLnNsaWRlLm5nLWVudGVyLm5nLWVudGVyLWFjdGl2ZSB7XG4gKiAgIHRyYW5zZm9ybTp0cmFuc2xhdGVZKDApO1xuICogfVxuICogYGBgXG4gKlxuICogRG9lcyB0aGlzIG1lYW4gdGhhdCBDU1MgYW5kIEpTIGFuaW1hdGlvbnMgY2Fubm90IGJlIHVzZWQgdG9nZXRoZXI/IERvIEpTLWJhc2VkIGFuaW1hdGlvbnMgYWx3YXlzIGhhdmUgaGlnaGVyIHByaW9yaXR5PyBXZSBjYW4gbWFrZSB1cCBmb3IgdGhlXG4gKiBsYWNrIG9mIENTUyBhbmltYXRpb25zIGJ5IHVzaW5nIHRoZSBgJGFuaW1hdGVDc3NgIHNlcnZpY2UgdG8gdHJpZ2dlciBvdXIgb3duIHR3ZWFrZWQtb3V0LCBDU1MtYmFzZWQgYW5pbWF0aW9ucyBkaXJlY3RseSBmcm9tXG4gKiBvdXIgb3duIEpTLWJhc2VkIGFuaW1hdGlvbiBjb2RlOlxuICpcbiAqIGBgYGpzXG4gKiBteU1vZHVsZS5hbmltYXRpb24oJy5zbGlkZScsIFsnJGFuaW1hdGVDc3MnLCBmdW5jdGlvbigkYW5pbWF0ZUNzcykge1xuICogICByZXR1cm4ge1xuICogICAgIGVudGVyOiBmdW5jdGlvbihlbGVtZW50KSB7XG4qICAgICAgICAvLyB0aGlzIHdpbGwgdHJpZ2dlciBgLnNsaWRlLm5nLWVudGVyYCBhbmQgYC5zbGlkZS5uZy1lbnRlci1hY3RpdmVgLlxuICogICAgICAgcmV0dXJuICRhbmltYXRlQ3NzKGVsZW1lbnQsIHtcbiAqICAgICAgICAgZXZlbnQ6ICdlbnRlcicsXG4gKiAgICAgICAgIHN0cnVjdHVyYWw6IHRydWVcbiAqICAgICAgIH0pO1xuICogICAgIH1cbiAqICAgfVxuICogfV0pO1xuICogYGBgXG4gKlxuICogVGhlIG5pY2UgdGhpbmcgaGVyZSBpcyB0aGF0IHdlIGNhbiBzYXZlIGJhbmR3aWR0aCBieSBzdGlja2luZyB0byBvdXIgQ1NTLWJhc2VkIGFuaW1hdGlvbiBjb2RlIGFuZCB3ZSBkb24ndCBuZWVkIHRvIHJlbHkgb24gYSAzcmQtcGFydHkgYW5pbWF0aW9uIGZyYW1ld29yay5cbiAqXG4gKiBUaGUgYCRhbmltYXRlQ3NzYCBzZXJ2aWNlIGlzIHZlcnkgcG93ZXJmdWwgc2luY2Ugd2UgY2FuIGZlZWQgaW4gYWxsIGtpbmRzIG9mIGV4dHJhIHByb3BlcnRpZXMgdGhhdCB3aWxsIGJlIGV2YWx1YXRlZCBhbmQgZmVkIGludG8gYSBDU1MgdHJhbnNpdGlvbiBvclxuICoga2V5ZnJhbWUgYW5pbWF0aW9uLiBGb3IgZXhhbXBsZSBpZiB3ZSB3YW50ZWQgdG8gYW5pbWF0ZSB0aGUgaGVpZ2h0IG9mIGFuIGVsZW1lbnQgd2hpbGUgYWRkaW5nIGFuZCByZW1vdmluZyBjbGFzc2VzIHRoZW4gd2UgY2FuIGRvIHNvIGJ5IHByb3ZpZGluZyB0aGF0XG4gKiBkYXRhIGludG8gYCRhbmltYXRlQ3NzYCBkaXJlY3RseTpcbiAqXG4gKiBgYGBqc1xuICogbXlNb2R1bGUuYW5pbWF0aW9uKCcuc2xpZGUnLCBbJyRhbmltYXRlQ3NzJywgZnVuY3Rpb24oJGFuaW1hdGVDc3MpIHtcbiAqICAgcmV0dXJuIHtcbiAqICAgICBlbnRlcjogZnVuY3Rpb24oZWxlbWVudCkge1xuICogICAgICAgcmV0dXJuICRhbmltYXRlQ3NzKGVsZW1lbnQsIHtcbiAqICAgICAgICAgZXZlbnQ6ICdlbnRlcicsXG4gKiAgICAgICAgIHN0cnVjdHVyYWw6IHRydWUsXG4gKiAgICAgICAgIGFkZENsYXNzOiAnbWFyb29uLXNldHRpbmcnLFxuICogICAgICAgICBmcm9tOiB7IGhlaWdodDowIH0sXG4gKiAgICAgICAgIHRvOiB7IGhlaWdodDogMjAwIH1cbiAqICAgICAgIH0pO1xuICogICAgIH1cbiAqICAgfVxuICogfV0pO1xuICogYGBgXG4gKlxuICogTm93IHdlIGNhbiBmaWxsIGluIHRoZSByZXN0IHZpYSBvdXIgdHJhbnNpdGlvbiBDU1MgY29kZTpcbiAqXG4gKiBgYGBjc3NcbiAqIC8mIzQyOyB0aGUgdHJhbnNpdGlvbiB0ZWxscyBuZ0FuaW1hdGUgdG8gbWFrZSB0aGUgYW5pbWF0aW9uIGhhcHBlbiAmIzQyOy9cbiAqIC5zbGlkZS5uZy1lbnRlciB7IHRyYW5zaXRpb246MC41cyBsaW5lYXIgYWxsOyB9XG4gKlxuICogLyYjNDI7IHRoaXMgZXh0cmEgQ1NTIGNsYXNzIHdpbGwgYmUgYWJzb3JiZWQgaW50byB0aGUgdHJhbnNpdGlvblxuICogc2luY2UgdGhlICRhbmltYXRlQ3NzIGNvZGUgaXMgYWRkaW5nIHRoZSBjbGFzcyAmIzQyOy9cbiAqIC5tYXJvb24tc2V0dGluZyB7IGJhY2tncm91bmQ6cmVkOyB9XG4gKiBgYGBcbiAqXG4gKiBBbmQgYCRhbmltYXRlQ3NzYCB3aWxsIGZpZ3VyZSBvdXQgdGhlIHJlc3QuIEp1c3QgbWFrZSBzdXJlIHRvIGhhdmUgdGhlIGBkb25lKClgIGNhbGxiYWNrIGZpcmUgdGhlIGBkb25lRm5gIGZ1bmN0aW9uIHRvIHNpZ25hbCB3aGVuIHRoZSBhbmltYXRpb24gaXMgb3Zlci5cbiAqXG4gKiBUbyBsZWFybiBtb3JlIGFib3V0IHdoYXQncyBwb3NzaWJsZSBiZSBzdXJlIHRvIHZpc2l0IHRoZSB7QGxpbmsgbmdBbmltYXRlLiRhbmltYXRlQ3NzICRhbmltYXRlQ3NzIHNlcnZpY2V9LlxuICpcbiAqICMjIEFuaW1hdGlvbiBBbmNob3JpbmcgKHZpYSBgbmctYW5pbWF0ZS1yZWZgKVxuICpcbiAqIG5nQW5pbWF0ZSBpbiBBbmd1bGFySlMgMS40IGNvbWVzIHBhY2tlZCB3aXRoIHRoZSBhYmlsaXR5IHRvIGNyb3NzLWFuaW1hdGUgZWxlbWVudHMgYmV0d2VlblxuICogc3RydWN0dXJhbCBhcmVhcyBvZiBhbiBhcHBsaWNhdGlvbiAobGlrZSB2aWV3cykgYnkgcGFpcmluZyB1cCBlbGVtZW50cyB1c2luZyBhbiBhdHRyaWJ1dGVcbiAqIGNhbGxlZCBgbmctYW5pbWF0ZS1yZWZgLlxuICpcbiAqIExldCdzIHNheSBmb3IgZXhhbXBsZSB3ZSBoYXZlIHR3byB2aWV3cyB0aGF0IGFyZSBtYW5hZ2VkIGJ5IGBuZy12aWV3YCBhbmQgd2Ugd2FudCB0byBzaG93XG4gKiB0aGF0IHRoZXJlIGlzIGEgcmVsYXRpb25zaGlwIGJldHdlZW4gdHdvIGNvbXBvbmVudHMgc2l0dWF0ZWQgaW4gd2l0aGluIHRoZXNlIHZpZXdzLiBCeSB1c2luZyB0aGVcbiAqIGBuZy1hbmltYXRlLXJlZmAgYXR0cmlidXRlIHdlIGNhbiBpZGVudGlmeSB0aGF0IHRoZSB0d28gY29tcG9uZW50cyBhcmUgcGFpcmVkIHRvZ2V0aGVyIGFuZCB3ZVxuICogY2FuIHRoZW4gYXR0YWNoIGFuIGFuaW1hdGlvbiwgd2hpY2ggaXMgdHJpZ2dlcmVkIHdoZW4gdGhlIHZpZXcgY2hhbmdlcy5cbiAqXG4gKiBTYXkgZm9yIGV4YW1wbGUgd2UgaGF2ZSB0aGUgZm9sbG93aW5nIHRlbXBsYXRlIGNvZGU6XG4gKlxuICogYGBgaHRtbFxuICogPCEtLSBpbmRleC5odG1sIC0tPlxuICogPGRpdiBuZy12aWV3IGNsYXNzPVwidmlldy1hbmltYXRpb25cIj5cbiAqIDwvZGl2PlxuICpcbiAqIDwhLS0gaG9tZS5odG1sIC0tPlxuICogPGEgaHJlZj1cIiMvYmFubmVyLXBhZ2VcIj5cbiAqICAgPGltZyBzcmM9XCIuL2Jhbm5lci5qcGdcIiBjbGFzcz1cImJhbm5lclwiIG5nLWFuaW1hdGUtcmVmPVwiYmFubmVyXCI+XG4gKiA8L2E+XG4gKlxuICogPCEtLSBiYW5uZXItcGFnZS5odG1sIC0tPlxuICogPGltZyBzcmM9XCIuL2Jhbm5lci5qcGdcIiBjbGFzcz1cImJhbm5lclwiIG5nLWFuaW1hdGUtcmVmPVwiYmFubmVyXCI+XG4gKiBgYGBcbiAqXG4gKiBOb3csIHdoZW4gdGhlIHZpZXcgY2hhbmdlcyAob25jZSB0aGUgbGluayBpcyBjbGlja2VkKSwgbmdBbmltYXRlIHdpbGwgZXhhbWluZSB0aGVcbiAqIEhUTUwgY29udGVudHMgdG8gc2VlIGlmIHRoZXJlIGlzIGEgbWF0Y2ggcmVmZXJlbmNlIGJldHdlZW4gYW55IGNvbXBvbmVudHMgaW4gdGhlIHZpZXdcbiAqIHRoYXQgaXMgbGVhdmluZyBhbmQgdGhlIHZpZXcgdGhhdCBpcyBlbnRlcmluZy4gSXQgd2lsbCBzY2FuIGJvdGggdGhlIHZpZXcgd2hpY2ggaXMgYmVpbmdcbiAqIHJlbW92ZWQgKGxlYXZlKSBhbmQgaW5zZXJ0ZWQgKGVudGVyKSB0byBzZWUgaWYgdGhlcmUgYXJlIGFueSBwYWlyZWQgRE9NIGVsZW1lbnRzIHRoYXRcbiAqIGNvbnRhaW4gYSBtYXRjaGluZyByZWYgdmFsdWUuXG4gKlxuICogVGhlIHR3byBpbWFnZXMgbWF0Y2ggc2luY2UgdGhleSBzaGFyZSB0aGUgc2FtZSByZWYgdmFsdWUuIG5nQW5pbWF0ZSB3aWxsIG5vdyBjcmVhdGUgYVxuICogdHJhbnNwb3J0IGVsZW1lbnQgKHdoaWNoIGlzIGEgY2xvbmUgb2YgdGhlIGZpcnN0IGltYWdlIGVsZW1lbnQpIGFuZCBpdCB3aWxsIHRoZW4gYXR0ZW1wdFxuICogdG8gYW5pbWF0ZSB0byB0aGUgcG9zaXRpb24gb2YgdGhlIHNlY29uZCBpbWFnZSBlbGVtZW50IGluIHRoZSBuZXh0IHZpZXcuIEZvciB0aGUgYW5pbWF0aW9uIHRvXG4gKiB3b3JrIGEgc3BlY2lhbCBDU1MgY2xhc3MgY2FsbGVkIGBuZy1hbmNob3JgIHdpbGwgYmUgYWRkZWQgdG8gdGhlIHRyYW5zcG9ydGVkIGVsZW1lbnQuXG4gKlxuICogV2UgY2FuIG5vdyBhdHRhY2ggYSB0cmFuc2l0aW9uIG9udG8gdGhlIGAuYmFubmVyLm5nLWFuY2hvcmAgQ1NTIGNsYXNzIGFuZCB0aGVuXG4gKiBuZ0FuaW1hdGUgd2lsbCBoYW5kbGUgdGhlIGVudGlyZSB0cmFuc2l0aW9uIGZvciB1cyBhcyB3ZWxsIGFzIHRoZSBhZGRpdGlvbiBhbmQgcmVtb3ZhbCBvZlxuICogYW55IGNoYW5nZXMgb2YgQ1NTIGNsYXNzZXMgYmV0d2VlbiB0aGUgZWxlbWVudHM6XG4gKlxuICogYGBgY3NzXG4gKiAuYmFubmVyLm5nLWFuY2hvciB7XG4gKiAgIC8mIzQyOyB0aGlzIGFuaW1hdGlvbiB3aWxsIGxhc3QgZm9yIDEgc2Vjb25kIHNpbmNlIHRoZXJlIGFyZVxuICogICAgICAgICAgdHdvIHBoYXNlcyB0byB0aGUgYW5pbWF0aW9uIChhbiBgaW5gIGFuZCBhbiBgb3V0YCBwaGFzZSkgJiM0MjsvXG4gKiAgIHRyYW5zaXRpb246MC41cyBsaW5lYXIgYWxsO1xuICogfVxuICogYGBgXG4gKlxuICogV2UgYWxzbyAqKm11c3QqKiBpbmNsdWRlIGFuaW1hdGlvbnMgZm9yIHRoZSB2aWV3cyB0aGF0IGFyZSBiZWluZyBlbnRlcmVkIGFuZCByZW1vdmVkXG4gKiAob3RoZXJ3aXNlIGFuY2hvcmluZyB3b3VsZG4ndCBiZSBwb3NzaWJsZSBzaW5jZSB0aGUgbmV3IHZpZXcgd291bGQgYmUgaW5zZXJ0ZWQgcmlnaHQgYXdheSkuXG4gKlxuICogYGBgY3NzXG4gKiAudmlldy1hbmltYXRpb24ubmctZW50ZXIsIC52aWV3LWFuaW1hdGlvbi5uZy1sZWF2ZSB7XG4gKiAgIHRyYW5zaXRpb246MC41cyBsaW5lYXIgYWxsO1xuICogICBwb3NpdGlvbjpmaXhlZDtcbiAqICAgbGVmdDowO1xuICogICB0b3A6MDtcbiAqICAgd2lkdGg6MTAwJTtcbiAqIH1cbiAqIC52aWV3LWFuaW1hdGlvbi5uZy1lbnRlciB7XG4gKiAgIHRyYW5zZm9ybTp0cmFuc2xhdGVYKDEwMCUpO1xuICogfVxuICogLnZpZXctYW5pbWF0aW9uLm5nLWxlYXZlLFxuICogLnZpZXctYW5pbWF0aW9uLm5nLWVudGVyLm5nLWVudGVyLWFjdGl2ZSB7XG4gKiAgIHRyYW5zZm9ybTp0cmFuc2xhdGVYKDAlKTtcbiAqIH1cbiAqIC52aWV3LWFuaW1hdGlvbi5uZy1sZWF2ZS5uZy1sZWF2ZS1hY3RpdmUge1xuICogICB0cmFuc2Zvcm06dHJhbnNsYXRlWCgtMTAwJSk7XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBOb3cgd2UgY2FuIGp1bXAgYmFjayB0byB0aGUgYW5jaG9yIGFuaW1hdGlvbi4gV2hlbiB0aGUgYW5pbWF0aW9uIGhhcHBlbnMsIHRoZXJlIGFyZSB0d28gc3RhZ2VzIHRoYXQgb2NjdXI6XG4gKiBhbiBgb3V0YCBhbmQgYW4gYGluYCBzdGFnZS4gVGhlIGBvdXRgIHN0YWdlIGhhcHBlbnMgZmlyc3QgYW5kIHRoYXQgaXMgd2hlbiB0aGUgZWxlbWVudCBpcyBhbmltYXRlZCBhd2F5XG4gKiBmcm9tIGl0cyBvcmlnaW4uIE9uY2UgdGhhdCBhbmltYXRpb24gaXMgb3ZlciB0aGVuIHRoZSBgaW5gIHN0YWdlIG9jY3VycyB3aGljaCBhbmltYXRlcyB0aGVcbiAqIGVsZW1lbnQgdG8gaXRzIGRlc3RpbmF0aW9uLiBUaGUgcmVhc29uIHdoeSB0aGVyZSBhcmUgdHdvIGFuaW1hdGlvbnMgaXMgdG8gZ2l2ZSBlbm91Z2ggdGltZVxuICogZm9yIHRoZSBlbnRlciBhbmltYXRpb24gb24gdGhlIG5ldyBlbGVtZW50IHRvIGJlIHJlYWR5LlxuICpcbiAqIFRoZSBleGFtcGxlIGFib3ZlIHNldHMgdXAgYSB0cmFuc2l0aW9uIGZvciBib3RoIHRoZSBpbiBhbmQgb3V0IHBoYXNlcywgYnV0IHdlIGNhbiBhbHNvIHRhcmdldCB0aGUgb3V0IG9yXG4gKiBpbiBwaGFzZXMgZGlyZWN0bHkgdmlhIGBuZy1hbmNob3Itb3V0YCBhbmQgYG5nLWFuY2hvci1pbmAuXG4gKlxuICogYGBgY3NzXG4gKiAuYmFubmVyLm5nLWFuY2hvci1vdXQge1xuICogICB0cmFuc2l0aW9uOiAwLjVzIGxpbmVhciBhbGw7XG4gKlxuICogICAvJiM0MjsgdGhlIHNjYWxlIHdpbGwgYmUgYXBwbGllZCBkdXJpbmcgdGhlIG91dCBhbmltYXRpb24sXG4gKiAgICAgICAgICBidXQgd2lsbCBiZSBhbmltYXRlZCBhd2F5IHdoZW4gdGhlIGluIGFuaW1hdGlvbiBydW5zICYjNDI7L1xuICogICB0cmFuc2Zvcm06IHNjYWxlKDEuMik7XG4gKiB9XG4gKlxuICogLmJhbm5lci5uZy1hbmNob3ItaW4ge1xuICogICB0cmFuc2l0aW9uOiAxcyBsaW5lYXIgYWxsO1xuICogfVxuICogYGBgXG4gKlxuICpcbiAqXG4gKlxuICogIyMjIEFuY2hvcmluZyBEZW1vXG4gKlxuICA8ZXhhbXBsZSBtb2R1bGU9XCJhbmNob3JpbmdFeGFtcGxlXCJcbiAgICAgICAgICAgbmFtZT1cImFuY2hvcmluZ0V4YW1wbGVcIlxuICAgICAgICAgICBpZD1cImFuY2hvcmluZ0V4YW1wbGVcIlxuICAgICAgICAgICBkZXBzPVwiYW5ndWxhci1hbmltYXRlLmpzO2FuZ3VsYXItcm91dGUuanNcIlxuICAgICAgICAgICBhbmltYXRpb25zPVwidHJ1ZVwiPlxuICAgIDxmaWxlIG5hbWU9XCJpbmRleC5odG1sXCI+XG4gICAgICA8YSBocmVmPVwiIyEvXCI+SG9tZTwvYT5cbiAgICAgIDxociAvPlxuICAgICAgPGRpdiBjbGFzcz1cInZpZXctY29udGFpbmVyXCI+XG4gICAgICAgIDxkaXYgbmctdmlldyBjbGFzcz1cInZpZXdcIj48L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZmlsZT5cbiAgICA8ZmlsZSBuYW1lPVwic2NyaXB0LmpzXCI+XG4gICAgICBhbmd1bGFyLm1vZHVsZSgnYW5jaG9yaW5nRXhhbXBsZScsIFsnbmdBbmltYXRlJywgJ25nUm91dGUnXSlcbiAgICAgICAgLmNvbmZpZyhbJyRyb3V0ZVByb3ZpZGVyJywgZnVuY3Rpb24oJHJvdXRlUHJvdmlkZXIpIHtcbiAgICAgICAgICAkcm91dGVQcm92aWRlci53aGVuKCcvJywge1xuICAgICAgICAgICAgdGVtcGxhdGVVcmw6ICdob21lLmh0bWwnLFxuICAgICAgICAgICAgY29udHJvbGxlcjogJ0hvbWVDb250cm9sbGVyIGFzIGhvbWUnXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgJHJvdXRlUHJvdmlkZXIud2hlbignL3Byb2ZpbGUvOmlkJywge1xuICAgICAgICAgICAgdGVtcGxhdGVVcmw6ICdwcm9maWxlLmh0bWwnLFxuICAgICAgICAgICAgY29udHJvbGxlcjogJ1Byb2ZpbGVDb250cm9sbGVyIGFzIHByb2ZpbGUnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1dKVxuICAgICAgICAucnVuKFsnJHJvb3RTY29wZScsIGZ1bmN0aW9uKCRyb290U2NvcGUpIHtcbiAgICAgICAgICAkcm9vdFNjb3BlLnJlY29yZHMgPSBbXG4gICAgICAgICAgICB7IGlkOiAxLCB0aXRsZTogJ01pc3MgQmV1bGFoIFJvb2InIH0sXG4gICAgICAgICAgICB7IGlkOiAyLCB0aXRsZTogJ1RyZW50IE1vcmlzc2V0dGUnIH0sXG4gICAgICAgICAgICB7IGlkOiAzLCB0aXRsZTogJ01pc3MgQXZhIFBvdXJvcycgfSxcbiAgICAgICAgICAgIHsgaWQ6IDQsIHRpdGxlOiAnUm9kIFBvdXJvcycgfSxcbiAgICAgICAgICAgIHsgaWQ6IDUsIHRpdGxlOiAnQWJkdWwgUmljZScgfSxcbiAgICAgICAgICAgIHsgaWQ6IDYsIHRpdGxlOiAnTGF1cmllIFJ1dGhlcmZvcmQgU3IuJyB9LFxuICAgICAgICAgICAgeyBpZDogNywgdGl0bGU6ICdOYWtpYSBNY0xhdWdobGluJyB9LFxuICAgICAgICAgICAgeyBpZDogOCwgdGl0bGU6ICdKb3Jkb24gQmxhbmRhIERWTScgfSxcbiAgICAgICAgICAgIHsgaWQ6IDksIHRpdGxlOiAnUmhvZGEgSGFuZCcgfSxcbiAgICAgICAgICAgIHsgaWQ6IDEwLCB0aXRsZTogJ0FsZXhhbmRyZWEgU2F1ZXInIH1cbiAgICAgICAgICBdO1xuICAgICAgICB9XSlcbiAgICAgICAgLmNvbnRyb2xsZXIoJ0hvbWVDb250cm9sbGVyJywgW2Z1bmN0aW9uKCkge1xuICAgICAgICAgIC8vZW1wdHlcbiAgICAgICAgfV0pXG4gICAgICAgIC5jb250cm9sbGVyKCdQcm9maWxlQ29udHJvbGxlcicsIFsnJHJvb3RTY29wZScsICckcm91dGVQYXJhbXMnLFxuICAgICAgICAgICAgZnVuY3Rpb24gUHJvZmlsZUNvbnRyb2xsZXIoJHJvb3RTY29wZSwgJHJvdXRlUGFyYW1zKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gcGFyc2VJbnQoJHJvdXRlUGFyYW1zLmlkLCAxMCk7XG4gICAgICAgICAgdmFyIHJlY29yZCA9ICRyb290U2NvcGUucmVjb3Jkc1tpbmRleCAtIDFdO1xuXG4gICAgICAgICAgdGhpcy50aXRsZSA9IHJlY29yZC50aXRsZTtcbiAgICAgICAgICB0aGlzLmlkID0gcmVjb3JkLmlkO1xuICAgICAgICB9XSk7XG4gICAgPC9maWxlPlxuICAgIDxmaWxlIG5hbWU9XCJob21lLmh0bWxcIj5cbiAgICAgIDxoMj5XZWxjb21lIHRvIHRoZSBob21lIHBhZ2U8L2gxPlxuICAgICAgPHA+UGxlYXNlIGNsaWNrIG9uIGFuIGVsZW1lbnQ8L3A+XG4gICAgICA8YSBjbGFzcz1cInJlY29yZFwiXG4gICAgICAgICBuZy1ocmVmPVwiIyEvcHJvZmlsZS97eyByZWNvcmQuaWQgfX1cIlxuICAgICAgICAgbmctYW5pbWF0ZS1yZWY9XCJ7eyByZWNvcmQuaWQgfX1cIlxuICAgICAgICAgbmctcmVwZWF0PVwicmVjb3JkIGluIHJlY29yZHNcIj5cbiAgICAgICAge3sgcmVjb3JkLnRpdGxlIH19XG4gICAgICA8L2E+XG4gICAgPC9maWxlPlxuICAgIDxmaWxlIG5hbWU9XCJwcm9maWxlLmh0bWxcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJwcm9maWxlIHJlY29yZFwiIG5nLWFuaW1hdGUtcmVmPVwie3sgcHJvZmlsZS5pZCB9fVwiPlxuICAgICAgICB7eyBwcm9maWxlLnRpdGxlIH19XG4gICAgICA8L2Rpdj5cbiAgICA8L2ZpbGU+XG4gICAgPGZpbGUgbmFtZT1cImFuaW1hdGlvbnMuY3NzXCI+XG4gICAgICAucmVjb3JkIHtcbiAgICAgICAgZGlzcGxheTpibG9jaztcbiAgICAgICAgZm9udC1zaXplOjIwcHg7XG4gICAgICB9XG4gICAgICAucHJvZmlsZSB7XG4gICAgICAgIGJhY2tncm91bmQ6YmxhY2s7XG4gICAgICAgIGNvbG9yOndoaXRlO1xuICAgICAgICBmb250LXNpemU6MTAwcHg7XG4gICAgICB9XG4gICAgICAudmlldy1jb250YWluZXIge1xuICAgICAgICBwb3NpdGlvbjpyZWxhdGl2ZTtcbiAgICAgIH1cbiAgICAgIC52aWV3LWNvbnRhaW5lciA+IC52aWV3Lm5nLWFuaW1hdGUge1xuICAgICAgICBwb3NpdGlvbjphYnNvbHV0ZTtcbiAgICAgICAgdG9wOjA7XG4gICAgICAgIGxlZnQ6MDtcbiAgICAgICAgd2lkdGg6MTAwJTtcbiAgICAgICAgbWluLWhlaWdodDo1MDBweDtcbiAgICAgIH1cbiAgICAgIC52aWV3Lm5nLWVudGVyLCAudmlldy5uZy1sZWF2ZSxcbiAgICAgIC5yZWNvcmQubmctYW5jaG9yIHtcbiAgICAgICAgdHJhbnNpdGlvbjowLjVzIGxpbmVhciBhbGw7XG4gICAgICB9XG4gICAgICAudmlldy5uZy1lbnRlciB7XG4gICAgICAgIHRyYW5zZm9ybTp0cmFuc2xhdGVYKDEwMCUpO1xuICAgICAgfVxuICAgICAgLnZpZXcubmctZW50ZXIubmctZW50ZXItYWN0aXZlLCAudmlldy5uZy1sZWF2ZSB7XG4gICAgICAgIHRyYW5zZm9ybTp0cmFuc2xhdGVYKDAlKTtcbiAgICAgIH1cbiAgICAgIC52aWV3Lm5nLWxlYXZlLm5nLWxlYXZlLWFjdGl2ZSB7XG4gICAgICAgIHRyYW5zZm9ybTp0cmFuc2xhdGVYKC0xMDAlKTtcbiAgICAgIH1cbiAgICAgIC5yZWNvcmQubmctYW5jaG9yLW91dCB7XG4gICAgICAgIGJhY2tncm91bmQ6cmVkO1xuICAgICAgfVxuICAgIDwvZmlsZT5cbiAgPC9leGFtcGxlPlxuICpcbiAqICMjIyBIb3cgaXMgdGhlIGVsZW1lbnQgdHJhbnNwb3J0ZWQ/XG4gKlxuICogV2hlbiBhbiBhbmNob3IgYW5pbWF0aW9uIG9jY3VycywgbmdBbmltYXRlIHdpbGwgY2xvbmUgdGhlIHN0YXJ0aW5nIGVsZW1lbnQgYW5kIHBvc2l0aW9uIGl0IGV4YWN0bHkgd2hlcmUgdGhlIHN0YXJ0aW5nXG4gKiBlbGVtZW50IGlzIGxvY2F0ZWQgb24gc2NyZWVuIHZpYSBhYnNvbHV0ZSBwb3NpdGlvbmluZy4gVGhlIGNsb25lZCBlbGVtZW50IHdpbGwgYmUgcGxhY2VkIGluc2lkZSBvZiB0aGUgcm9vdCBlbGVtZW50XG4gKiBvZiB0aGUgYXBwbGljYXRpb24gKHdoZXJlIG5nLWFwcCB3YXMgZGVmaW5lZCkgYW5kIGFsbCBvZiB0aGUgQ1NTIGNsYXNzZXMgb2YgdGhlIHN0YXJ0aW5nIGVsZW1lbnQgd2lsbCBiZSBhcHBsaWVkLiBUaGVcbiAqIGVsZW1lbnQgd2lsbCB0aGVuIGFuaW1hdGUgaW50byB0aGUgYG91dGAgYW5kIGBpbmAgYW5pbWF0aW9ucyBhbmQgd2lsbCBldmVudHVhbGx5IHJlYWNoIHRoZSBjb29yZGluYXRlcyBhbmQgbWF0Y2hcbiAqIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBkZXN0aW5hdGlvbiBlbGVtZW50LiBEdXJpbmcgdGhlIGVudGlyZSBhbmltYXRpb24gYSBDU1MgY2xhc3Mgb2YgYC5uZy1hbmltYXRlLXNoaW1gIHdpbGwgYmUgYXBwbGllZFxuICogdG8gYm90aCB0aGUgc3RhcnRpbmcgYW5kIGRlc3RpbmF0aW9uIGVsZW1lbnRzIGluIG9yZGVyIHRvIGhpZGUgdGhlbSBmcm9tIGJlaW5nIHZpc2libGUgKHRoZSBDU1Mgc3R5bGluZyBmb3IgdGhlIGNsYXNzXG4gKiBpczogYHZpc2liaWxpdHk6aGlkZGVuYCkuIE9uY2UgdGhlIGFuY2hvciByZWFjaGVzIGl0cyBkZXN0aW5hdGlvbiB0aGVuIGl0IHdpbGwgYmUgcmVtb3ZlZCBhbmQgdGhlIGRlc3RpbmF0aW9uIGVsZW1lbnRcbiAqIHdpbGwgYmVjb21lIHZpc2libGUgc2luY2UgdGhlIHNoaW0gY2xhc3Mgd2lsbCBiZSByZW1vdmVkLlxuICpcbiAqICMjIyBIb3cgaXMgdGhlIG1vcnBoaW5nIGhhbmRsZWQ/XG4gKlxuICogQ1NTIEFuY2hvcmluZyByZWxpZXMgb24gdHJhbnNpdGlvbnMgYW5kIGtleWZyYW1lcyBhbmQgdGhlIGludGVybmFsIGNvZGUgaXMgaW50ZWxsaWdlbnQgZW5vdWdoIHRvIGZpZ3VyZSBvdXRcbiAqIHdoYXQgQ1NTIGNsYXNzZXMgZGlmZmVyIGJldHdlZW4gdGhlIHN0YXJ0aW5nIGVsZW1lbnQgYW5kIHRoZSBkZXN0aW5hdGlvbiBlbGVtZW50LiBUaGVzZSBkaWZmZXJlbnQgQ1NTIGNsYXNzZXNcbiAqIHdpbGwgYmUgYWRkZWQvcmVtb3ZlZCBvbiB0aGUgYW5jaG9yIGVsZW1lbnQgYW5kIGEgdHJhbnNpdGlvbiB3aWxsIGJlIGFwcGxpZWQgKHRoZSB0cmFuc2l0aW9uIHRoYXQgaXMgcHJvdmlkZWRcbiAqIGluIHRoZSBhbmNob3IgY2xhc3MpLiBMb25nIHN0b3J5IHNob3J0LCBuZ0FuaW1hdGUgd2lsbCBmaWd1cmUgb3V0IHdoYXQgY2xhc3NlcyB0byBhZGQgYW5kIHJlbW92ZSB3aGljaCB3aWxsXG4gKiBtYWtlIHRoZSB0cmFuc2l0aW9uIG9mIHRoZSBlbGVtZW50IGFzIHNtb290aCBhbmQgYXV0b21hdGljIGFzIHBvc3NpYmxlLiBCZSBzdXJlIHRvIHVzZSBzaW1wbGUgQ1NTIGNsYXNzZXMgdGhhdFxuICogZG8gbm90IHJlbHkgb24gRE9NIG5lc3Rpbmcgc3RydWN0dXJlIHNvIHRoYXQgdGhlIGFuY2hvciBlbGVtZW50IGFwcGVhcnMgdGhlIHNhbWUgYXMgdGhlIHN0YXJ0aW5nIGVsZW1lbnQgKHNpbmNlXG4gKiB0aGUgY2xvbmVkIGVsZW1lbnQgaXMgcGxhY2VkIGluc2lkZSBvZiByb290IGVsZW1lbnQgd2hpY2ggaXMgbGlrZWx5IGNsb3NlIHRvIHRoZSBib2R5IGVsZW1lbnQpLlxuICpcbiAqIE5vdGUgdGhhdCBpZiB0aGUgcm9vdCBlbGVtZW50IGlzIG9uIHRoZSBgPGh0bWw+YCBlbGVtZW50IHRoZW4gdGhlIGNsb25lZCBub2RlIHdpbGwgYmUgcGxhY2VkIGluc2lkZSBvZiBib2R5LlxuICpcbiAqXG4gKiAjIyBVc2luZyAkYW5pbWF0ZSBpbiB5b3VyIGRpcmVjdGl2ZSBjb2RlXG4gKlxuICogU28gZmFyIHdlJ3ZlIGV4cGxvcmVkIGhvdyB0byBmZWVkIGluIGFuaW1hdGlvbnMgaW50byBhbiBBbmd1bGFyIGFwcGxpY2F0aW9uLCBidXQgaG93IGRvIHdlIHRyaWdnZXIgYW5pbWF0aW9ucyB3aXRoaW4gb3VyIG93biBkaXJlY3RpdmVzIGluIG91ciBhcHBsaWNhdGlvbj9cbiAqIEJ5IGluamVjdGluZyB0aGUgYCRhbmltYXRlYCBzZXJ2aWNlIGludG8gb3VyIGRpcmVjdGl2ZSBjb2RlLCB3ZSBjYW4gdHJpZ2dlciBzdHJ1Y3R1cmFsIGFuZCBjbGFzcy1iYXNlZCBob29rcyB3aGljaCBjYW4gdGhlbiBiZSBjb25zdW1lZCBieSBhbmltYXRpb25zLiBMZXQnc1xuICogaW1hZ2luZSB3ZSBoYXZlIGEgZ3JlZXRpbmcgYm94IHRoYXQgc2hvd3MgYW5kIGhpZGVzIGl0c2VsZiB3aGVuIHRoZSBkYXRhIGNoYW5nZXNcbiAqXG4gKiBgYGBodG1sXG4gKiA8Z3JlZXRpbmctYm94IGFjdGl2ZT1cIm9uT3JPZmZcIj5IaSB0aGVyZTwvZ3JlZXRpbmctYm94PlxuICogYGBgXG4gKlxuICogYGBganNcbiAqIG5nTW9kdWxlLmRpcmVjdGl2ZSgnZ3JlZXRpbmdCb3gnLCBbJyRhbmltYXRlJywgZnVuY3Rpb24oJGFuaW1hdGUpIHtcbiAqICAgcmV0dXJuIGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycykge1xuICogICAgIGF0dHJzLiRvYnNlcnZlKCdhY3RpdmUnLCBmdW5jdGlvbih2YWx1ZSkge1xuICogICAgICAgdmFsdWUgPyAkYW5pbWF0ZS5hZGRDbGFzcyhlbGVtZW50LCAnb24nKSA6ICRhbmltYXRlLnJlbW92ZUNsYXNzKGVsZW1lbnQsICdvbicpO1xuICogICAgIH0pO1xuICogICB9KTtcbiAqIH1dKTtcbiAqIGBgYFxuICpcbiAqIE5vdyB0aGUgYG9uYCBDU1MgY2xhc3MgaXMgYWRkZWQgYW5kIHJlbW92ZWQgb24gdGhlIGdyZWV0aW5nIGJveCBjb21wb25lbnQuIE5vdyBpZiB3ZSBhZGQgYSBDU1MgY2xhc3Mgb24gdG9wIG9mIHRoZSBncmVldGluZyBib3ggZWxlbWVudFxuICogaW4gb3VyIEhUTUwgY29kZSB0aGVuIHdlIGNhbiB0cmlnZ2VyIGEgQ1NTIG9yIEpTIGFuaW1hdGlvbiB0byBoYXBwZW4uXG4gKlxuICogYGBgY3NzXG4gKiAvJiM0Mjsgbm9ybWFsbHkgd2Ugd291bGQgY3JlYXRlIGEgQ1NTIGNsYXNzIHRvIHJlZmVyZW5jZSBvbiB0aGUgZWxlbWVudCAmIzQyOy9cbiAqIGdyZWV0aW5nLWJveC5vbiB7IHRyYW5zaXRpb246MC41cyBsaW5lYXIgYWxsOyBiYWNrZ3JvdW5kOmdyZWVuOyBjb2xvcjp3aGl0ZTsgfVxuICogYGBgXG4gKlxuICogVGhlIGAkYW5pbWF0ZWAgc2VydmljZSBjb250YWlucyBhIHZhcmlldHkgb2Ygb3RoZXIgbWV0aG9kcyBsaWtlIGBlbnRlcmAsIGBsZWF2ZWAsIGBhbmltYXRlYCBhbmQgYHNldENsYXNzYC4gVG8gbGVhcm4gbW9yZSBhYm91dCB3aGF0J3NcbiAqIHBvc3NpYmxlIGJlIHN1cmUgdG8gdmlzaXQgdGhlIHtAbGluayBuZy4kYW5pbWF0ZSAkYW5pbWF0ZSBzZXJ2aWNlIEFQSSBwYWdlfS5cbiAqXG4gKlxuICogIyMgQ2FsbGJhY2tzIGFuZCBQcm9taXNlc1xuICpcbiAqIFdoZW4gYCRhbmltYXRlYCBpcyBjYWxsZWQgaXQgcmV0dXJucyBhIHByb21pc2UgdGhhdCBjYW4gYmUgdXNlZCB0byBjYXB0dXJlIHdoZW4gdGhlIGFuaW1hdGlvbiBoYXMgZW5kZWQuIFRoZXJlZm9yZSBpZiB3ZSB3ZXJlIHRvIHRyaWdnZXJcbiAqIGFuIGFuaW1hdGlvbiAod2l0aGluIG91ciBkaXJlY3RpdmUgY29kZSkgdGhlbiB3ZSBjYW4gY29udGludWUgcGVyZm9ybWluZyBkaXJlY3RpdmUgYW5kIHNjb3BlIHJlbGF0ZWQgYWN0aXZpdGllcyBhZnRlciB0aGUgYW5pbWF0aW9uIGhhc1xuICogZW5kZWQgYnkgY2hhaW5pbmcgb250byB0aGUgcmV0dXJuZWQgcHJvbWlzZSB0aGF0IGFuaW1hdGlvbiBtZXRob2QgcmV0dXJucy5cbiAqXG4gKiBgYGBqc1xuICogLy8gc29tZXdoZXJlIHdpdGhpbiB0aGUgZGVwdGhzIG9mIHRoZSBkaXJlY3RpdmVcbiAqICRhbmltYXRlLmVudGVyKGVsZW1lbnQsIHBhcmVudCkudGhlbihmdW5jdGlvbigpIHtcbiAqICAgLy90aGUgYW5pbWF0aW9uIGhhcyBjb21wbGV0ZWRcbiAqIH0pO1xuICogYGBgXG4gKlxuICogKE5vdGUgdGhhdCBlYXJsaWVyIHZlcnNpb25zIG9mIEFuZ3VsYXIgcHJpb3IgdG8gdjEuNCByZXF1aXJlZCB0aGUgcHJvbWlzZSBjb2RlIHRvIGJlIHdyYXBwZWQgdXNpbmcgYCRzY29wZS4kYXBwbHkoLi4uKWAuIFRoaXMgaXMgbm90IHRoZSBjYXNlXG4gKiBhbnltb3JlLilcbiAqXG4gKiBJbiBhZGRpdGlvbiB0byB0aGUgYW5pbWF0aW9uIHByb21pc2UsIHdlIGNhbiBhbHNvIG1ha2UgdXNlIG9mIGFuaW1hdGlvbi1yZWxhdGVkIGNhbGxiYWNrcyB3aXRoaW4gb3VyIGRpcmVjdGl2ZXMgYW5kIGNvbnRyb2xsZXIgY29kZSBieSByZWdpc3RlcmluZ1xuICogYW4gZXZlbnQgbGlzdGVuZXIgdXNpbmcgdGhlIGAkYW5pbWF0ZWAgc2VydmljZS4gTGV0J3Mgc2F5IGZvciBleGFtcGxlIHRoYXQgYW4gYW5pbWF0aW9uIHdhcyB0cmlnZ2VyZWQgb24gb3VyIHZpZXdcbiAqIHJvdXRpbmcgY29udHJvbGxlciB0byBob29rIGludG8gdGhhdDpcbiAqXG4gKiBgYGBqc1xuICogbmdNb2R1bGUuY29udHJvbGxlcignSG9tZVBhZ2VDb250cm9sbGVyJywgWyckYW5pbWF0ZScsIGZ1bmN0aW9uKCRhbmltYXRlKSB7XG4gKiAgICRhbmltYXRlLm9uKCdlbnRlcicsIG5nVmlld0VsZW1lbnQsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAqICAgICAvLyB0aGUgYW5pbWF0aW9uIGZvciB0aGlzIHJvdXRlIGhhcyBjb21wbGV0ZWRcbiAqICAgfV0pO1xuICogfV0pXG4gKiBgYGBcbiAqXG4gKiAoTm90ZSB0aGF0IHlvdSB3aWxsIG5lZWQgdG8gdHJpZ2dlciBhIGRpZ2VzdCB3aXRoaW4gdGhlIGNhbGxiYWNrIHRvIGdldCBhbmd1bGFyIHRvIG5vdGljZSBhbnkgc2NvcGUtcmVsYXRlZCBjaGFuZ2VzLilcbiAqL1xuXG52YXIgY29weTtcbnZhciBleHRlbmQ7XG52YXIgZm9yRWFjaDtcbnZhciBpc0FycmF5O1xudmFyIGlzRGVmaW5lZDtcbnZhciBpc0VsZW1lbnQ7XG52YXIgaXNGdW5jdGlvbjtcbnZhciBpc09iamVjdDtcbnZhciBpc1N0cmluZztcbnZhciBpc1VuZGVmaW5lZDtcbnZhciBqcUxpdGU7XG52YXIgbm9vcDtcblxuLyoqXG4gKiBAbmdkb2Mgc2VydmljZVxuICogQG5hbWUgJGFuaW1hdGVcbiAqIEBraW5kIG9iamVjdFxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogVGhlIG5nQW5pbWF0ZSBgJGFuaW1hdGVgIHNlcnZpY2UgZG9jdW1lbnRhdGlvbiBpcyB0aGUgc2FtZSBmb3IgdGhlIGNvcmUgYCRhbmltYXRlYCBzZXJ2aWNlLlxuICpcbiAqIENsaWNrIGhlcmUge0BsaW5rIG5nLiRhbmltYXRlIHRvIGxlYXJuIG1vcmUgYWJvdXQgYW5pbWF0aW9ucyB3aXRoIGAkYW5pbWF0ZWB9LlxuICovXG5hbmd1bGFyLm1vZHVsZSgnbmdBbmltYXRlJywgW10sIGZ1bmN0aW9uIGluaXRBbmd1bGFySGVscGVycygpIHtcbiAgLy8gQWNjZXNzIGhlbHBlcnMgZnJvbSBhbmd1bGFyIGNvcmUuXG4gIC8vIERvIGl0IGluc2lkZSBhIGBjb25maWdgIGJsb2NrIHRvIGVuc3VyZSBgd2luZG93LmFuZ3VsYXJgIGlzIGF2YWlsYWJsZS5cbiAgbm9vcCAgICAgICAgPSBhbmd1bGFyLm5vb3A7XG4gIGNvcHkgICAgICAgID0gYW5ndWxhci5jb3B5O1xuICBleHRlbmQgICAgICA9IGFuZ3VsYXIuZXh0ZW5kO1xuICBqcUxpdGUgICAgICA9IGFuZ3VsYXIuZWxlbWVudDtcbiAgZm9yRWFjaCAgICAgPSBhbmd1bGFyLmZvckVhY2g7XG4gIGlzQXJyYXkgICAgID0gYW5ndWxhci5pc0FycmF5O1xuICBpc1N0cmluZyAgICA9IGFuZ3VsYXIuaXNTdHJpbmc7XG4gIGlzT2JqZWN0ICAgID0gYW5ndWxhci5pc09iamVjdDtcbiAgaXNVbmRlZmluZWQgPSBhbmd1bGFyLmlzVW5kZWZpbmVkO1xuICBpc0RlZmluZWQgICA9IGFuZ3VsYXIuaXNEZWZpbmVkO1xuICBpc0Z1bmN0aW9uICA9IGFuZ3VsYXIuaXNGdW5jdGlvbjtcbiAgaXNFbGVtZW50ICAgPSBhbmd1bGFyLmlzRWxlbWVudDtcbn0pXG4gIC5pbmZvKHsgYW5ndWxhclZlcnNpb246ICcxLjYuOCcgfSlcbiAgLmRpcmVjdGl2ZSgnbmdBbmltYXRlU3dhcCcsIG5nQW5pbWF0ZVN3YXBEaXJlY3RpdmUpXG5cbiAgLmRpcmVjdGl2ZSgnbmdBbmltYXRlQ2hpbGRyZW4nLCAkJEFuaW1hdGVDaGlsZHJlbkRpcmVjdGl2ZSlcbiAgLmZhY3RvcnkoJyQkckFGU2NoZWR1bGVyJywgJCRyQUZTY2hlZHVsZXJGYWN0b3J5KVxuXG4gIC5wcm92aWRlcignJCRhbmltYXRlUXVldWUnLCAkJEFuaW1hdGVRdWV1ZVByb3ZpZGVyKVxuICAucHJvdmlkZXIoJyQkYW5pbWF0aW9uJywgJCRBbmltYXRpb25Qcm92aWRlcilcblxuICAucHJvdmlkZXIoJyRhbmltYXRlQ3NzJywgJEFuaW1hdGVDc3NQcm92aWRlcilcbiAgLnByb3ZpZGVyKCckJGFuaW1hdGVDc3NEcml2ZXInLCAkJEFuaW1hdGVDc3NEcml2ZXJQcm92aWRlcilcblxuICAucHJvdmlkZXIoJyQkYW5pbWF0ZUpzJywgJCRBbmltYXRlSnNQcm92aWRlcilcbiAgLnByb3ZpZGVyKCckJGFuaW1hdGVKc0RyaXZlcicsICQkQW5pbWF0ZUpzRHJpdmVyUHJvdmlkZXIpO1xuXG5cbn0pKHdpbmRvdywgd2luZG93LmFuZ3VsYXIpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYW5ndWxhci1hbmltYXRlL2FuZ3VsYXItYW5pbWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///133\n")},function(module,exports,__webpack_require__){eval("__webpack_require__(135);\n\nmodule.exports = 'ui.bootstrap';\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTM0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FuZ3VsYXItdWktYm9vdHN0cmFwL2luZGV4LmpzPzg0MGYiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSgnLi9kaXN0L3VpLWJvb3RzdHJhcC10cGxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gJ3VpLmJvb3RzdHJhcCc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9hbmd1bGFyLXVpLWJvb3RzdHJhcC9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMTM0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///134\n")},function(module,exports){eval("/*\n * angular-ui-bootstrap\n * http://angular-ui.github.io/bootstrap/\n\n * Version: 2.5.6 - 2017-10-14\n * License: MIT\n */angular.module(\"ui.bootstrap\", [\"ui.bootstrap.tpls\", \"ui.bootstrap.collapse\",\"ui.bootstrap.tabindex\",\"ui.bootstrap.accordion\",\"ui.bootstrap.alert\",\"ui.bootstrap.buttons\",\"ui.bootstrap.carousel\",\"ui.bootstrap.dateparser\",\"ui.bootstrap.isClass\",\"ui.bootstrap.datepicker\",\"ui.bootstrap.position\",\"ui.bootstrap.datepickerPopup\",\"ui.bootstrap.debounce\",\"ui.bootstrap.multiMap\",\"ui.bootstrap.dropdown\",\"ui.bootstrap.stackedMap\",\"ui.bootstrap.modal\",\"ui.bootstrap.paging\",\"ui.bootstrap.pager\",\"ui.bootstrap.pagination\",\"ui.bootstrap.tooltip\",\"ui.bootstrap.popover\",\"ui.bootstrap.progressbar\",\"ui.bootstrap.rating\",\"ui.bootstrap.tabs\",\"ui.bootstrap.timepicker\",\"ui.bootstrap.typeahead\"]);\nangular.module(\"ui.bootstrap.tpls\", [\"uib/template/accordion/accordion-group.html\",\"uib/template/accordion/accordion.html\",\"uib/template/alert/alert.html\",\"uib/template/carousel/carousel.html\",\"uib/template/carousel/slide.html\",\"uib/template/datepicker/datepicker.html\",\"uib/template/datepicker/day.html\",\"uib/template/datepicker/month.html\",\"uib/template/datepicker/year.html\",\"uib/template/datepickerPopup/popup.html\",\"uib/template/modal/window.html\",\"uib/template/pager/pager.html\",\"uib/template/pagination/pagination.html\",\"uib/template/tooltip/tooltip-html-popup.html\",\"uib/template/tooltip/tooltip-popup.html\",\"uib/template/tooltip/tooltip-template-popup.html\",\"uib/template/popover/popover-html.html\",\"uib/template/popover/popover-template.html\",\"uib/template/popover/popover.html\",\"uib/template/progressbar/bar.html\",\"uib/template/progressbar/progress.html\",\"uib/template/progressbar/progressbar.html\",\"uib/template/rating/rating.html\",\"uib/template/tabs/tab.html\",\"uib/template/tabs/tabset.html\",\"uib/template/timepicker/timepicker.html\",\"uib/template/typeahead/typeahead-match.html\",\"uib/template/typeahead/typeahead-popup.html\"]);\nangular.module('ui.bootstrap.collapse', [])\n\n  .directive('uibCollapse', ['$animate', '$q', '$parse', '$injector', function($animate, $q, $parse, $injector) {\n    var $animateCss = $injector.has('$animateCss') ? $injector.get('$animateCss') : null;\n    return {\n      link: function(scope, element, attrs) {\n        var expandingExpr = $parse(attrs.expanding),\n          expandedExpr = $parse(attrs.expanded),\n          collapsingExpr = $parse(attrs.collapsing),\n          collapsedExpr = $parse(attrs.collapsed),\n          horizontal = false,\n          css = {},\n          cssTo = {};\n\n        init();\n\n        function init() {\n          horizontal = !!('horizontal' in attrs);\n          if (horizontal) {\n            css = {\n              width: ''\n            };\n            cssTo = {width: '0'};\n          } else {\n            css = {\n              height: ''\n            };\n            cssTo = {height: '0'};\n          }\n          if (!scope.$eval(attrs.uibCollapse)) {\n            element.addClass('in')\n              .addClass('collapse')\n              .attr('aria-expanded', true)\n              .attr('aria-hidden', false)\n              .css(css);\n          }\n        }\n\n        function getScrollFromElement(element) {\n          if (horizontal) {\n            return {width: element.scrollWidth + 'px'};\n          }\n          return {height: element.scrollHeight + 'px'};\n        }\n\n        function expand() {\n          if (element.hasClass('collapse') && element.hasClass('in')) {\n            return;\n          }\n\n          $q.resolve(expandingExpr(scope))\n            .then(function() {\n              element.removeClass('collapse')\n                .addClass('collapsing')\n                .attr('aria-expanded', true)\n                .attr('aria-hidden', false);\n\n              if ($animateCss) {\n                $animateCss(element, {\n                  addClass: 'in',\n                  easing: 'ease',\n                  css: {\n                    overflow: 'hidden'\n                  },\n                  to: getScrollFromElement(element[0])\n                }).start()['finally'](expandDone);\n              } else {\n                $animate.addClass(element, 'in', {\n                  css: {\n                    overflow: 'hidden'\n                  },\n                  to: getScrollFromElement(element[0])\n                }).then(expandDone);\n              }\n            }, angular.noop);\n        }\n\n        function expandDone() {\n          element.removeClass('collapsing')\n            .addClass('collapse')\n            .css(css);\n          expandedExpr(scope);\n        }\n\n        function collapse() {\n          if (!element.hasClass('collapse') && !element.hasClass('in')) {\n            return collapseDone();\n          }\n\n          $q.resolve(collapsingExpr(scope))\n            .then(function() {\n              element\n              // IMPORTANT: The width must be set before adding \"collapsing\" class.\n              // Otherwise, the browser attempts to animate from width 0 (in\n              // collapsing class) to the given width here.\n                .css(getScrollFromElement(element[0]))\n                // initially all panel collapse have the collapse class, this removal\n                // prevents the animation from jumping to collapsed state\n                .removeClass('collapse')\n                .addClass('collapsing')\n                .attr('aria-expanded', false)\n                .attr('aria-hidden', true);\n\n              if ($animateCss) {\n                $animateCss(element, {\n                  removeClass: 'in',\n                  to: cssTo\n                }).start()['finally'](collapseDone);\n              } else {\n                $animate.removeClass(element, 'in', {\n                  to: cssTo\n                }).then(collapseDone);\n              }\n            }, angular.noop);\n        }\n\n        function collapseDone() {\n          element.css(cssTo); // Required so that collapse works when animation is disabled\n          element.removeClass('collapsing')\n            .addClass('collapse');\n          collapsedExpr(scope);\n        }\n\n        scope.$watch(attrs.uibCollapse, function(shouldCollapse) {\n          if (shouldCollapse) {\n            collapse();\n          } else {\n            expand();\n          }\n        });\n      }\n    };\n  }]);\n\nangular.module('ui.bootstrap.tabindex', [])\n\n.directive('uibTabindexToggle', function() {\n  return {\n    restrict: 'A',\n    link: function(scope, elem, attrs) {\n      attrs.$observe('disabled', function(disabled) {\n        attrs.$set('tabindex', disabled ? -1 : null);\n      });\n    }\n  };\n});\n\nangular.module('ui.bootstrap.accordion', ['ui.bootstrap.collapse', 'ui.bootstrap.tabindex'])\n\n.constant('uibAccordionConfig', {\n  closeOthers: true\n})\n\n.controller('UibAccordionController', ['$scope', '$attrs', 'uibAccordionConfig', function($scope, $attrs, accordionConfig) {\n  // This array keeps track of the accordion groups\n  this.groups = [];\n\n  // Ensure that all the groups in this accordion are closed, unless close-others explicitly says not to\n  this.closeOthers = function(openGroup) {\n    var closeOthers = angular.isDefined($attrs.closeOthers) ?\n      $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers;\n    if (closeOthers) {\n      angular.forEach(this.groups, function(group) {\n        if (group !== openGroup) {\n          group.isOpen = false;\n        }\n      });\n    }\n  };\n\n  // This is called from the accordion-group directive to add itself to the accordion\n  this.addGroup = function(groupScope) {\n    var that = this;\n    this.groups.push(groupScope);\n\n    groupScope.$on('$destroy', function(event) {\n      that.removeGroup(groupScope);\n    });\n  };\n\n  // This is called from the accordion-group directive when to remove itself\n  this.removeGroup = function(group) {\n    var index = this.groups.indexOf(group);\n    if (index !== -1) {\n      this.groups.splice(index, 1);\n    }\n  };\n}])\n\n// The accordion directive simply sets up the directive controller\n// and adds an accordion CSS class to itself element.\n.directive('uibAccordion', function() {\n  return {\n    controller: 'UibAccordionController',\n    controllerAs: 'accordion',\n    transclude: true,\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'uib/template/accordion/accordion.html';\n    }\n  };\n})\n\n// The accordion-group directive indicates a block of html that will expand and collapse in an accordion\n.directive('uibAccordionGroup', function() {\n  return {\n    require: '^uibAccordion',         // We need this directive to be inside an accordion\n    transclude: true,              // It transcludes the contents of the directive into the template\n    restrict: 'A',\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'uib/template/accordion/accordion-group.html';\n    },\n    scope: {\n      heading: '@',               // Interpolate the heading attribute onto this scope\n      panelClass: '@?',           // Ditto with panelClass\n      isOpen: '=?',\n      isDisabled: '=?'\n    },\n    controller: function() {\n      this.setHeading = function(element) {\n        this.heading = element;\n      };\n    },\n    link: function(scope, element, attrs, accordionCtrl) {\n      element.addClass('panel');\n      accordionCtrl.addGroup(scope);\n\n      scope.openClass = attrs.openClass || 'panel-open';\n      scope.panelClass = attrs.panelClass || 'panel-default';\n      scope.$watch('isOpen', function(value) {\n        element.toggleClass(scope.openClass, !!value);\n        if (value) {\n          accordionCtrl.closeOthers(scope);\n        }\n      });\n\n      scope.toggleOpen = function($event) {\n        if (!scope.isDisabled) {\n          if (!$event || $event.which === 32) {\n            scope.isOpen = !scope.isOpen;\n          }\n        }\n      };\n\n      var id = 'accordiongroup-' + scope.$id + '-' + Math.floor(Math.random() * 10000);\n      scope.headingId = id + '-tab';\n      scope.panelId = id + '-panel';\n    }\n  };\n})\n\n// Use accordion-heading below an accordion-group to provide a heading containing HTML\n.directive('uibAccordionHeading', function() {\n  return {\n    transclude: true,   // Grab the contents to be used as the heading\n    template: '',       // In effect remove this element!\n    replace: true,\n    require: '^uibAccordionGroup',\n    link: function(scope, element, attrs, accordionGroupCtrl, transclude) {\n      // Pass the heading to the accordion-group controller\n      // so that it can be transcluded into the right place in the template\n      // [The second parameter to transclude causes the elements to be cloned so that they work in ng-repeat]\n      accordionGroupCtrl.setHeading(transclude(scope, angular.noop));\n    }\n  };\n})\n\n// Use in the accordion-group template to indicate where you want the heading to be transcluded\n// You must provide the property on the accordion-group controller that will hold the transcluded element\n.directive('uibAccordionTransclude', function() {\n  return {\n    require: '^uibAccordionGroup',\n    link: function(scope, element, attrs, controller) {\n      scope.$watch(function() { return controller[attrs.uibAccordionTransclude]; }, function(heading) {\n        if (heading) {\n          var elem = angular.element(element[0].querySelector(getHeaderSelectors()));\n          elem.html('');\n          elem.append(heading);\n        }\n      });\n    }\n  };\n\n  function getHeaderSelectors() {\n      return 'uib-accordion-header,' +\n          'data-uib-accordion-header,' +\n          'x-uib-accordion-header,' +\n          'uib\\\\:accordion-header,' +\n          '[uib-accordion-header],' +\n          '[data-uib-accordion-header],' +\n          '[x-uib-accordion-header]';\n  }\n});\n\nangular.module('ui.bootstrap.alert', [])\n\n.controller('UibAlertController', ['$scope', '$element', '$attrs', '$interpolate', '$timeout', function($scope, $element, $attrs, $interpolate, $timeout) {\n  $scope.closeable = !!$attrs.close;\n  $element.addClass('alert');\n  $attrs.$set('role', 'alert');\n  if ($scope.closeable) {\n    $element.addClass('alert-dismissible');\n  }\n\n  var dismissOnTimeout = angular.isDefined($attrs.dismissOnTimeout) ?\n    $interpolate($attrs.dismissOnTimeout)($scope.$parent) : null;\n\n  if (dismissOnTimeout) {\n    $timeout(function() {\n      $scope.close();\n    }, parseInt(dismissOnTimeout, 10));\n  }\n}])\n\n.directive('uibAlert', function() {\n  return {\n    controller: 'UibAlertController',\n    controllerAs: 'alert',\n    restrict: 'A',\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'uib/template/alert/alert.html';\n    },\n    transclude: true,\n    scope: {\n      close: '&'\n    }\n  };\n});\n\nangular.module('ui.bootstrap.buttons', [])\n\n.constant('uibButtonConfig', {\n  activeClass: 'active',\n  toggleEvent: 'click'\n})\n\n.controller('UibButtonsController', ['uibButtonConfig', function(buttonConfig) {\n  this.activeClass = buttonConfig.activeClass || 'active';\n  this.toggleEvent = buttonConfig.toggleEvent || 'click';\n}])\n\n.directive('uibBtnRadio', ['$parse', function($parse) {\n  return {\n    require: ['uibBtnRadio', 'ngModel'],\n    controller: 'UibButtonsController',\n    controllerAs: 'buttons',\n    link: function(scope, element, attrs, ctrls) {\n      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n      var uncheckableExpr = $parse(attrs.uibUncheckable);\n\n      element.find('input').css({display: 'none'});\n\n      //model -> UI\n      ngModelCtrl.$render = function() {\n        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.uibBtnRadio)));\n      };\n\n      //ui->model\n      element.on(buttonsCtrl.toggleEvent, function() {\n        if (attrs.disabled) {\n          return;\n        }\n\n        var isActive = element.hasClass(buttonsCtrl.activeClass);\n\n        if (!isActive || angular.isDefined(attrs.uncheckable)) {\n          scope.$apply(function() {\n            ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.uibBtnRadio));\n            ngModelCtrl.$render();\n          });\n        }\n      });\n\n      if (attrs.uibUncheckable) {\n        scope.$watch(uncheckableExpr, function(uncheckable) {\n          attrs.$set('uncheckable', uncheckable ? '' : undefined);\n        });\n      }\n    }\n  };\n}])\n\n.directive('uibBtnCheckbox', function() {\n  return {\n    require: ['uibBtnCheckbox', 'ngModel'],\n    controller: 'UibButtonsController',\n    controllerAs: 'button',\n    link: function(scope, element, attrs, ctrls) {\n      var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      element.find('input').css({display: 'none'});\n\n      function getTrueValue() {\n        return getCheckboxValue(attrs.btnCheckboxTrue, true);\n      }\n\n      function getFalseValue() {\n        return getCheckboxValue(attrs.btnCheckboxFalse, false);\n      }\n\n      function getCheckboxValue(attribute, defaultValue) {\n        return angular.isDefined(attribute) ? scope.$eval(attribute) : defaultValue;\n      }\n\n      //model -> UI\n      ngModelCtrl.$render = function() {\n        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));\n      };\n\n      //ui->model\n      element.on(buttonsCtrl.toggleEvent, function() {\n        if (attrs.disabled) {\n          return;\n        }\n\n        scope.$apply(function() {\n          ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());\n          ngModelCtrl.$render();\n        });\n      });\n    }\n  };\n});\n\nangular.module('ui.bootstrap.carousel', [])\n\n.controller('UibCarouselController', ['$scope', '$element', '$interval', '$timeout', '$animate', function($scope, $element, $interval, $timeout, $animate) {\n  var self = this,\n    slides = self.slides = $scope.slides = [],\n    SLIDE_DIRECTION = 'uib-slideDirection',\n    currentIndex = $scope.active,\n    currentInterval, isPlaying;\n\n  var destroyed = false;\n  $element.addClass('carousel');\n\n  self.addSlide = function(slide, element) {\n    slides.push({\n      slide: slide,\n      element: element\n    });\n    slides.sort(function(a, b) {\n      return +a.slide.index - +b.slide.index;\n    });\n    //if this is the first slide or the slide is set to active, select it\n    if (slide.index === $scope.active || slides.length === 1 && !angular.isNumber($scope.active)) {\n      if ($scope.$currentTransition) {\n        $scope.$currentTransition = null;\n      }\n\n      currentIndex = slide.index;\n      $scope.active = slide.index;\n      setActive(currentIndex);\n      self.select(slides[findSlideIndex(slide)]);\n      if (slides.length === 1) {\n        $scope.play();\n      }\n    }\n  };\n\n  self.getCurrentIndex = function() {\n    for (var i = 0; i < slides.length; i++) {\n      if (slides[i].slide.index === currentIndex) {\n        return i;\n      }\n    }\n  };\n\n  self.next = $scope.next = function() {\n    var newIndex = (self.getCurrentIndex() + 1) % slides.length;\n\n    if (newIndex === 0 && $scope.noWrap()) {\n      $scope.pause();\n      return;\n    }\n\n    return self.select(slides[newIndex], 'next');\n  };\n\n  self.prev = $scope.prev = function() {\n    var newIndex = self.getCurrentIndex() - 1 < 0 ? slides.length - 1 : self.getCurrentIndex() - 1;\n\n    if ($scope.noWrap() && newIndex === slides.length - 1) {\n      $scope.pause();\n      return;\n    }\n\n    return self.select(slides[newIndex], 'prev');\n  };\n\n  self.removeSlide = function(slide) {\n    var index = findSlideIndex(slide);\n\n    //get the index of the slide inside the carousel\n    slides.splice(index, 1);\n    if (slides.length > 0 && currentIndex === index) {\n      if (index >= slides.length) {\n        currentIndex = slides.length - 1;\n        $scope.active = currentIndex;\n        setActive(currentIndex);\n        self.select(slides[slides.length - 1]);\n      } else {\n        currentIndex = index;\n        $scope.active = currentIndex;\n        setActive(currentIndex);\n        self.select(slides[index]);\n      }\n    } else if (currentIndex > index) {\n      currentIndex--;\n      $scope.active = currentIndex;\n    }\n\n    //clean the active value when no more slide\n    if (slides.length === 0) {\n      currentIndex = null;\n      $scope.active = null;\n    }\n  };\n\n  /* direction: \"prev\" or \"next\" */\n  self.select = $scope.select = function(nextSlide, direction) {\n    var nextIndex = findSlideIndex(nextSlide.slide);\n    //Decide direction if it's not given\n    if (direction === undefined) {\n      direction = nextIndex > self.getCurrentIndex() ? 'next' : 'prev';\n    }\n    //Prevent this user-triggered transition from occurring if there is already one in progress\n    if (nextSlide.slide.index !== currentIndex &&\n      !$scope.$currentTransition) {\n      goNext(nextSlide.slide, nextIndex, direction);\n    }\n  };\n\n  /* Allow outside people to call indexOf on slides array */\n  $scope.indexOfSlide = function(slide) {\n    return +slide.slide.index;\n  };\n\n  $scope.isActive = function(slide) {\n    return $scope.active === slide.slide.index;\n  };\n\n  $scope.isPrevDisabled = function() {\n    return $scope.active === 0 && $scope.noWrap();\n  };\n\n  $scope.isNextDisabled = function() {\n    return $scope.active === slides.length - 1 && $scope.noWrap();\n  };\n\n  $scope.pause = function() {\n    if (!$scope.noPause) {\n      isPlaying = false;\n      resetTimer();\n    }\n  };\n\n  $scope.play = function() {\n    if (!isPlaying) {\n      isPlaying = true;\n      restartTimer();\n    }\n  };\n\n  $element.on('mouseenter', $scope.pause);\n  $element.on('mouseleave', $scope.play);\n\n  $scope.$on('$destroy', function() {\n    destroyed = true;\n    resetTimer();\n  });\n\n  $scope.$watch('noTransition', function(noTransition) {\n    $animate.enabled($element, !noTransition);\n  });\n\n  $scope.$watch('interval', restartTimer);\n\n  $scope.$watchCollection('slides', resetTransition);\n\n  $scope.$watch('active', function(index) {\n    if (angular.isNumber(index) && currentIndex !== index) {\n      for (var i = 0; i < slides.length; i++) {\n        if (slides[i].slide.index === index) {\n          index = i;\n          break;\n        }\n      }\n\n      var slide = slides[index];\n      if (slide) {\n        setActive(index);\n        self.select(slides[index]);\n        currentIndex = index;\n      }\n    }\n  });\n\n  function getSlideByIndex(index) {\n    for (var i = 0, l = slides.length; i < l; ++i) {\n      if (slides[i].index === index) {\n        return slides[i];\n      }\n    }\n  }\n\n  function setActive(index) {\n    for (var i = 0; i < slides.length; i++) {\n      slides[i].slide.active = i === index;\n    }\n  }\n\n  function goNext(slide, index, direction) {\n    if (destroyed) {\n      return;\n    }\n\n    angular.extend(slide, {direction: direction});\n    angular.extend(slides[currentIndex].slide || {}, {direction: direction});\n    if ($animate.enabled($element) && !$scope.$currentTransition &&\n      slides[index].element && self.slides.length > 1) {\n      slides[index].element.data(SLIDE_DIRECTION, slide.direction);\n      var currentIdx = self.getCurrentIndex();\n\n      if (angular.isNumber(currentIdx) && slides[currentIdx].element) {\n        slides[currentIdx].element.data(SLIDE_DIRECTION, slide.direction);\n      }\n\n      $scope.$currentTransition = true;\n      $animate.on('addClass', slides[index].element, function(element, phase) {\n        if (phase === 'close') {\n          $scope.$currentTransition = null;\n          $animate.off('addClass', element);\n        }\n      });\n    }\n\n    $scope.active = slide.index;\n    currentIndex = slide.index;\n    setActive(index);\n\n    //every time you change slides, reset the timer\n    restartTimer();\n  }\n\n  function findSlideIndex(slide) {\n    for (var i = 0; i < slides.length; i++) {\n      if (slides[i].slide === slide) {\n        return i;\n      }\n    }\n  }\n\n  function resetTimer() {\n    if (currentInterval) {\n      $interval.cancel(currentInterval);\n      currentInterval = null;\n    }\n  }\n\n  function resetTransition(slides) {\n    if (!slides.length) {\n      $scope.$currentTransition = null;\n    }\n  }\n\n  function restartTimer() {\n    resetTimer();\n    var interval = +$scope.interval;\n    if (!isNaN(interval) && interval > 0) {\n      currentInterval = $interval(timerFn, interval);\n    }\n  }\n\n  function timerFn() {\n    var interval = +$scope.interval;\n    if (isPlaying && !isNaN(interval) && interval > 0 && slides.length) {\n      $scope.next();\n    } else {\n      $scope.pause();\n    }\n  }\n}])\n\n.directive('uibCarousel', function() {\n  return {\n    transclude: true,\n    controller: 'UibCarouselController',\n    controllerAs: 'carousel',\n    restrict: 'A',\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'uib/template/carousel/carousel.html';\n    },\n    scope: {\n      active: '=',\n      interval: '=',\n      noTransition: '=',\n      noPause: '=',\n      noWrap: '&'\n    }\n  };\n})\n\n.directive('uibSlide', ['$animate', function($animate) {\n  return {\n    require: '^uibCarousel',\n    restrict: 'A',\n    transclude: true,\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'uib/template/carousel/slide.html';\n    },\n    scope: {\n      actual: '=?',\n      index: '=?'\n    },\n    link: function (scope, element, attrs, carouselCtrl) {\n      element.addClass('item');\n      carouselCtrl.addSlide(scope, element);\n      //when the scope is destroyed then remove the slide from the current slides array\n      scope.$on('$destroy', function() {\n        carouselCtrl.removeSlide(scope);\n      });\n\n      scope.$watch('active', function(active) {\n        $animate[active ? 'addClass' : 'removeClass'](element, 'active');\n      });\n    }\n  };\n}])\n\n.animation('.item', ['$animateCss',\nfunction($animateCss) {\n  var SLIDE_DIRECTION = 'uib-slideDirection';\n\n  function removeClass(element, className, callback) {\n    element.removeClass(className);\n    if (callback) {\n      callback();\n    }\n  }\n\n  return {\n    beforeAddClass: function(element, className, done) {\n      if (className === 'active') {\n        var stopped = false;\n        var direction = element.data(SLIDE_DIRECTION);\n        var directionClass = direction === 'next' ? 'left' : 'right';\n        var removeClassFn = removeClass.bind(this, element,\n          directionClass + ' ' + direction, done);\n        element.addClass(direction);\n\n        $animateCss(element, {addClass: directionClass})\n          .start()\n          .done(removeClassFn);\n\n        return function() {\n          stopped = true;\n        };\n      }\n      done();\n    },\n    beforeRemoveClass: function (element, className, done) {\n      if (className === 'active') {\n        var stopped = false;\n        var direction = element.data(SLIDE_DIRECTION);\n        var directionClass = direction === 'next' ? 'left' : 'right';\n        var removeClassFn = removeClass.bind(this, element, directionClass, done);\n\n        $animateCss(element, {addClass: directionClass})\n          .start()\n          .done(removeClassFn);\n\n        return function() {\n          stopped = true;\n        };\n      }\n      done();\n    }\n  };\n}]);\n\nangular.module('ui.bootstrap.dateparser', [])\n\n.service('uibDateParser', ['$log', '$locale', 'dateFilter', 'orderByFilter', 'filterFilter', function($log, $locale, dateFilter, orderByFilter, filterFilter) {\n  // Pulled from https://github.com/mbostock/d3/blob/master/src/format/requote.js\n  var SPECIAL_CHARACTERS_REGEXP = /[\\\\\\^\\$\\*\\+\\?\\|\\[\\]\\(\\)\\.\\{\\}]/g;\n\n  var localeId;\n  var formatCodeToRegex;\n\n  this.init = function() {\n    localeId = $locale.id;\n\n    this.parsers = {};\n    this.formatters = {};\n\n    formatCodeToRegex = [\n      {\n        key: 'yyyy',\n        regex: '\\\\d{4}',\n        apply: function(value) { this.year = +value; },\n        formatter: function(date) {\n          var _date = new Date();\n          _date.setFullYear(Math.abs(date.getFullYear()));\n          return dateFilter(_date, 'yyyy');\n        }\n      },\n      {\n        key: 'yy',\n        regex: '\\\\d{2}',\n        apply: function(value) { value = +value; this.year = value < 69 ? value + 2000 : value + 1900; },\n        formatter: function(date) {\n          var _date = new Date();\n          _date.setFullYear(Math.abs(date.getFullYear()));\n          return dateFilter(_date, 'yy');\n        }\n      },\n      {\n        key: 'y',\n        regex: '\\\\d{1,4}',\n        apply: function(value) { this.year = +value; },\n        formatter: function(date) {\n          var _date = new Date();\n          _date.setFullYear(Math.abs(date.getFullYear()));\n          return dateFilter(_date, 'y');\n        }\n      },\n      {\n        key: 'M!',\n        regex: '0?[1-9]|1[0-2]',\n        apply: function(value) { this.month = value - 1; },\n        formatter: function(date) {\n          var value = date.getMonth();\n          if (/^[0-9]$/.test(value)) {\n            return dateFilter(date, 'MM');\n          }\n\n          return dateFilter(date, 'M');\n        }\n      },\n      {\n        key: 'MMMM',\n        regex: $locale.DATETIME_FORMATS.MONTH.join('|'),\n        apply: function(value) { this.month = $locale.DATETIME_FORMATS.MONTH.indexOf(value); },\n        formatter: function(date) { return dateFilter(date, 'MMMM'); }\n      },\n      {\n        key: 'MMM',\n        regex: $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),\n        apply: function(value) { this.month = $locale.DATETIME_FORMATS.SHORTMONTH.indexOf(value); },\n        formatter: function(date) { return dateFilter(date, 'MMM'); }\n      },\n      {\n        key: 'MM',\n        regex: '0[1-9]|1[0-2]',\n        apply: function(value) { this.month = value - 1; },\n        formatter: function(date) { return dateFilter(date, 'MM'); }\n      },\n      {\n        key: 'M',\n        regex: '[1-9]|1[0-2]',\n        apply: function(value) { this.month = value - 1; },\n        formatter: function(date) { return dateFilter(date, 'M'); }\n      },\n      {\n        key: 'd!',\n        regex: '[0-2]?[0-9]{1}|3[0-1]{1}',\n        apply: function(value) { this.date = +value; },\n        formatter: function(date) {\n          var value = date.getDate();\n          if (/^[1-9]$/.test(value)) {\n            return dateFilter(date, 'dd');\n          }\n\n          return dateFilter(date, 'd');\n        }\n      },\n      {\n        key: 'dd',\n        regex: '[0-2][0-9]{1}|3[0-1]{1}',\n        apply: function(value) { this.date = +value; },\n        formatter: function(date) { return dateFilter(date, 'dd'); }\n      },\n      {\n        key: 'd',\n        regex: '[1-2]?[0-9]{1}|3[0-1]{1}',\n        apply: function(value) { this.date = +value; },\n        formatter: function(date) { return dateFilter(date, 'd'); }\n      },\n      {\n        key: 'EEEE',\n        regex: $locale.DATETIME_FORMATS.DAY.join('|'),\n        formatter: function(date) { return dateFilter(date, 'EEEE'); }\n      },\n      {\n        key: 'EEE',\n        regex: $locale.DATETIME_FORMATS.SHORTDAY.join('|'),\n        formatter: function(date) { return dateFilter(date, 'EEE'); }\n      },\n      {\n        key: 'HH',\n        regex: '(?:0|1)[0-9]|2[0-3]',\n        apply: function(value) { this.hours = +value; },\n        formatter: function(date) { return dateFilter(date, 'HH'); }\n      },\n      {\n        key: 'hh',\n        regex: '0[0-9]|1[0-2]',\n        apply: function(value) { this.hours = +value; },\n        formatter: function(date) { return dateFilter(date, 'hh'); }\n      },\n      {\n        key: 'H',\n        regex: '1?[0-9]|2[0-3]',\n        apply: function(value) { this.hours = +value; },\n        formatter: function(date) { return dateFilter(date, 'H'); }\n      },\n      {\n        key: 'h',\n        regex: '[0-9]|1[0-2]',\n        apply: function(value) { this.hours = +value; },\n        formatter: function(date) { return dateFilter(date, 'h'); }\n      },\n      {\n        key: 'mm',\n        regex: '[0-5][0-9]',\n        apply: function(value) { this.minutes = +value; },\n        formatter: function(date) { return dateFilter(date, 'mm'); }\n      },\n      {\n        key: 'm',\n        regex: '[0-9]|[1-5][0-9]',\n        apply: function(value) { this.minutes = +value; },\n        formatter: function(date) { return dateFilter(date, 'm'); }\n      },\n      {\n        key: 'sss',\n        regex: '[0-9][0-9][0-9]',\n        apply: function(value) { this.milliseconds = +value; },\n        formatter: function(date) { return dateFilter(date, 'sss'); }\n      },\n      {\n        key: 'ss',\n        regex: '[0-5][0-9]',\n        apply: function(value) { this.seconds = +value; },\n        formatter: function(date) { return dateFilter(date, 'ss'); }\n      },\n      {\n        key: 's',\n        regex: '[0-9]|[1-5][0-9]',\n        apply: function(value) { this.seconds = +value; },\n        formatter: function(date) { return dateFilter(date, 's'); }\n      },\n      {\n        key: 'a',\n        regex: $locale.DATETIME_FORMATS.AMPMS.join('|'),\n        apply: function(value) {\n          if (this.hours === 12) {\n            this.hours = 0;\n          }\n\n          if (value === 'PM') {\n            this.hours += 12;\n          }\n        },\n        formatter: function(date) { return dateFilter(date, 'a'); }\n      },\n      {\n        key: 'Z',\n        regex: '[+-]\\\\d{4}',\n        apply: function(value) {\n          var matches = value.match(/([+-])(\\d{2})(\\d{2})/),\n            sign = matches[1],\n            hours = matches[2],\n            minutes = matches[3];\n          this.hours += toInt(sign + hours);\n          this.minutes += toInt(sign + minutes);\n        },\n        formatter: function(date) {\n          return dateFilter(date, 'Z');\n        }\n      },\n      {\n        key: 'ww',\n        regex: '[0-4][0-9]|5[0-3]',\n        formatter: function(date) { return dateFilter(date, 'ww'); }\n      },\n      {\n        key: 'w',\n        regex: '[0-9]|[1-4][0-9]|5[0-3]',\n        formatter: function(date) { return dateFilter(date, 'w'); }\n      },\n      {\n        key: 'GGGG',\n        regex: $locale.DATETIME_FORMATS.ERANAMES.join('|').replace(/\\s/g, '\\\\s'),\n        formatter: function(date) { return dateFilter(date, 'GGGG'); }\n      },\n      {\n        key: 'GGG',\n        regex: $locale.DATETIME_FORMATS.ERAS.join('|'),\n        formatter: function(date) { return dateFilter(date, 'GGG'); }\n      },\n      {\n        key: 'GG',\n        regex: $locale.DATETIME_FORMATS.ERAS.join('|'),\n        formatter: function(date) { return dateFilter(date, 'GG'); }\n      },\n      {\n        key: 'G',\n        regex: $locale.DATETIME_FORMATS.ERAS.join('|'),\n        formatter: function(date) { return dateFilter(date, 'G'); }\n      }\n    ];\n\n    if (angular.version.major >= 1 && angular.version.minor > 4) {\n      formatCodeToRegex.push({\n        key: 'LLLL',\n        regex: $locale.DATETIME_FORMATS.STANDALONEMONTH.join('|'),\n        apply: function(value) { this.month = $locale.DATETIME_FORMATS.STANDALONEMONTH.indexOf(value); },\n        formatter: function(date) { return dateFilter(date, 'LLLL'); }\n      });\n    }\n  };\n\n  this.init();\n\n  function getFormatCodeToRegex(key) {\n    return filterFilter(formatCodeToRegex, {key: key}, true)[0];\n  }\n\n  this.getParser = function (key) {\n    var f = getFormatCodeToRegex(key);\n    return f && f.apply || null;\n  };\n\n  this.overrideParser = function (key, parser) {\n    var f = getFormatCodeToRegex(key);\n    if (f && angular.isFunction(parser)) {\n      this.parsers = {};\n      f.apply = parser;\n    }\n  }.bind(this);\n\n  function createParser(format) {\n    var map = [], regex = format.split('');\n\n    // check for literal values\n    var quoteIndex = format.indexOf('\\'');\n    if (quoteIndex > -1) {\n      var inLiteral = false;\n      format = format.split('');\n      for (var i = quoteIndex; i < format.length; i++) {\n        if (inLiteral) {\n          if (format[i] === '\\'') {\n            if (i + 1 < format.length && format[i+1] === '\\'') { // escaped single quote\n              format[i+1] = '$';\n              regex[i+1] = '';\n            } else { // end of literal\n              regex[i] = '';\n              inLiteral = false;\n            }\n          }\n          format[i] = '$';\n        } else {\n          if (format[i] === '\\'') { // start of literal\n            format[i] = '$';\n            regex[i] = '';\n            inLiteral = true;\n          }\n        }\n      }\n\n      format = format.join('');\n    }\n\n    angular.forEach(formatCodeToRegex, function(data) {\n      var index = format.indexOf(data.key);\n\n      if (index > -1) {\n        format = format.split('');\n\n        regex[index] = '(' + data.regex + ')';\n        format[index] = '$'; // Custom symbol to define consumed part of format\n        for (var i = index + 1, n = index + data.key.length; i < n; i++) {\n          regex[i] = '';\n          format[i] = '$';\n        }\n        format = format.join('');\n\n        map.push({\n          index: index,\n          key: data.key,\n          apply: data.apply,\n          matcher: data.regex\n        });\n      }\n    });\n\n    return {\n      regex: new RegExp('^' + regex.join('') + '$'),\n      map: orderByFilter(map, 'index')\n    };\n  }\n\n  function createFormatter(format) {\n    var formatters = [];\n    var i = 0;\n    var formatter, literalIdx;\n    while (i < format.length) {\n      if (angular.isNumber(literalIdx)) {\n        if (format.charAt(i) === '\\'') {\n          if (i + 1 >= format.length || format.charAt(i + 1) !== '\\'') {\n            formatters.push(constructLiteralFormatter(format, literalIdx, i));\n            literalIdx = null;\n          }\n        } else if (i === format.length) {\n          while (literalIdx < format.length) {\n            formatter = constructFormatterFromIdx(format, literalIdx);\n            formatters.push(formatter);\n            literalIdx = formatter.endIdx;\n          }\n        }\n\n        i++;\n        continue;\n      }\n\n      if (format.charAt(i) === '\\'') {\n        literalIdx = i;\n        i++;\n        continue;\n      }\n\n      formatter = constructFormatterFromIdx(format, i);\n\n      formatters.push(formatter.parser);\n      i = formatter.endIdx;\n    }\n\n    return formatters;\n  }\n\n  function constructLiteralFormatter(format, literalIdx, endIdx) {\n    return function() {\n      return format.substr(literalIdx + 1, endIdx - literalIdx - 1);\n    };\n  }\n\n  function constructFormatterFromIdx(format, i) {\n    var currentPosStr = format.substr(i);\n    for (var j = 0; j < formatCodeToRegex.length; j++) {\n      if (new RegExp('^' + formatCodeToRegex[j].key).test(currentPosStr)) {\n        var data = formatCodeToRegex[j];\n        return {\n          endIdx: i + data.key.length,\n          parser: data.formatter\n        };\n      }\n    }\n\n    return {\n      endIdx: i + 1,\n      parser: function() {\n        return currentPosStr.charAt(0);\n      }\n    };\n  }\n\n  this.filter = function(date, format) {\n    if (!angular.isDate(date) || isNaN(date) || !format) {\n      return '';\n    }\n\n    format = $locale.DATETIME_FORMATS[format] || format;\n\n    if ($locale.id !== localeId) {\n      this.init();\n    }\n\n    if (!this.formatters[format]) {\n      this.formatters[format] = createFormatter(format);\n    }\n\n    var formatters = this.formatters[format];\n\n    return formatters.reduce(function(str, formatter) {\n      return str + formatter(date);\n    }, '');\n  };\n\n  this.parse = function(input, format, baseDate) {\n    if (!angular.isString(input) || !format) {\n      return input;\n    }\n\n    format = $locale.DATETIME_FORMATS[format] || format;\n    format = format.replace(SPECIAL_CHARACTERS_REGEXP, '\\\\$&');\n\n    if ($locale.id !== localeId) {\n      this.init();\n    }\n\n    if (!this.parsers[format]) {\n      this.parsers[format] = createParser(format, 'apply');\n    }\n\n    var parser = this.parsers[format],\n        regex = parser.regex,\n        map = parser.map,\n        results = input.match(regex),\n        tzOffset = false;\n    if (results && results.length) {\n      var fields, dt;\n      if (angular.isDate(baseDate) && !isNaN(baseDate.getTime())) {\n        fields = {\n          year: baseDate.getFullYear(),\n          month: baseDate.getMonth(),\n          date: baseDate.getDate(),\n          hours: baseDate.getHours(),\n          minutes: baseDate.getMinutes(),\n          seconds: baseDate.getSeconds(),\n          milliseconds: baseDate.getMilliseconds()\n        };\n      } else {\n        if (baseDate) {\n          $log.warn('dateparser:', 'baseDate is not a valid date');\n        }\n        fields = { year: 1900, month: 0, date: 1, hours: 0, minutes: 0, seconds: 0, milliseconds: 0 };\n      }\n\n      for (var i = 1, n = results.length; i < n; i++) {\n        var mapper = map[i - 1];\n        if (mapper.matcher === 'Z') {\n          tzOffset = true;\n        }\n\n        if (mapper.apply) {\n          mapper.apply.call(fields, results[i]);\n        }\n      }\n\n      var datesetter = tzOffset ? Date.prototype.setUTCFullYear :\n        Date.prototype.setFullYear;\n      var timesetter = tzOffset ? Date.prototype.setUTCHours :\n        Date.prototype.setHours;\n\n      if (isValid(fields.year, fields.month, fields.date)) {\n        if (angular.isDate(baseDate) && !isNaN(baseDate.getTime()) && !tzOffset) {\n          dt = new Date(baseDate);\n          datesetter.call(dt, fields.year, fields.month, fields.date);\n          timesetter.call(dt, fields.hours, fields.minutes,\n            fields.seconds, fields.milliseconds);\n        } else {\n          dt = new Date(0);\n          datesetter.call(dt, fields.year, fields.month, fields.date);\n          timesetter.call(dt, fields.hours || 0, fields.minutes || 0,\n            fields.seconds || 0, fields.milliseconds || 0);\n        }\n      }\n\n      return dt;\n    }\n  };\n\n  // Check if date is valid for specific month (and year for February).\n  // Month: 0 = Jan, 1 = Feb, etc\n  function isValid(year, month, date) {\n    if (date < 1) {\n      return false;\n    }\n\n    if (month === 1 && date > 28) {\n      return date === 29 && (year % 4 === 0 && year % 100 !== 0 || year % 400 === 0);\n    }\n\n    if (month === 3 || month === 5 || month === 8 || month === 10) {\n      return date < 31;\n    }\n\n    return true;\n  }\n\n  function toInt(str) {\n    return parseInt(str, 10);\n  }\n\n  this.toTimezone = toTimezone;\n  this.fromTimezone = fromTimezone;\n  this.timezoneToOffset = timezoneToOffset;\n  this.addDateMinutes = addDateMinutes;\n  this.convertTimezoneToLocal = convertTimezoneToLocal;\n\n  function toTimezone(date, timezone) {\n    return date && timezone ? convertTimezoneToLocal(date, timezone) : date;\n  }\n\n  function fromTimezone(date, timezone) {\n    return date && timezone ? convertTimezoneToLocal(date, timezone, true) : date;\n  }\n\n  //https://github.com/angular/angular.js/blob/622c42169699ec07fc6daaa19fe6d224e5d2f70e/src/Angular.js#L1207\n  function timezoneToOffset(timezone, fallback) {\n    timezone = timezone.replace(/:/g, '');\n    var requestedTimezoneOffset = Date.parse('Jan 01, 1970 00:00:00 ' + timezone) / 60000;\n    return isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;\n  }\n\n  function addDateMinutes(date, minutes) {\n    date = new Date(date.getTime());\n    date.setMinutes(date.getMinutes() + minutes);\n    return date;\n  }\n\n  function convertTimezoneToLocal(date, timezone, reverse) {\n    reverse = reverse ? -1 : 1;\n    var dateTimezoneOffset = date.getTimezoneOffset();\n    var timezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);\n    return addDateMinutes(date, reverse * (timezoneOffset - dateTimezoneOffset));\n  }\n}]);\n\n// Avoiding use of ng-class as it creates a lot of watchers when a class is to be applied to\n// at most one element.\nangular.module('ui.bootstrap.isClass', [])\n.directive('uibIsClass', [\n         '$animate',\nfunction ($animate) {\n  //                    11111111          22222222\n  var ON_REGEXP = /^\\s*([\\s\\S]+?)\\s+on\\s+([\\s\\S]+?)\\s*$/;\n  //                    11111111           22222222\n  var IS_REGEXP = /^\\s*([\\s\\S]+?)\\s+for\\s+([\\s\\S]+?)\\s*$/;\n\n  var dataPerTracked = {};\n\n  return {\n    restrict: 'A',\n    compile: function(tElement, tAttrs) {\n      var linkedScopes = [];\n      var instances = [];\n      var expToData = {};\n      var lastActivated = null;\n      var onExpMatches = tAttrs.uibIsClass.match(ON_REGEXP);\n      var onExp = onExpMatches[2];\n      var expsStr = onExpMatches[1];\n      var exps = expsStr.split(',');\n\n      return linkFn;\n\n      function linkFn(scope, element, attrs) {\n        linkedScopes.push(scope);\n        instances.push({\n          scope: scope,\n          element: element\n        });\n\n        exps.forEach(function(exp, k) {\n          addForExp(exp, scope);\n        });\n\n        scope.$on('$destroy', removeScope);\n      }\n\n      function addForExp(exp, scope) {\n        var matches = exp.match(IS_REGEXP);\n        var clazz = scope.$eval(matches[1]);\n        var compareWithExp = matches[2];\n        var data = expToData[exp];\n        if (!data) {\n          var watchFn = function(compareWithVal) {\n            var newActivated = null;\n            instances.some(function(instance) {\n              var thisVal = instance.scope.$eval(onExp);\n              if (thisVal === compareWithVal) {\n                newActivated = instance;\n                return true;\n              }\n            });\n            if (data.lastActivated !== newActivated) {\n              if (data.lastActivated) {\n                $animate.removeClass(data.lastActivated.element, clazz);\n              }\n              if (newActivated) {\n                $animate.addClass(newActivated.element, clazz);\n              }\n              data.lastActivated = newActivated;\n            }\n          };\n          expToData[exp] = data = {\n            lastActivated: null,\n            scope: scope,\n            watchFn: watchFn,\n            compareWithExp: compareWithExp,\n            watcher: scope.$watch(compareWithExp, watchFn)\n          };\n        }\n        data.watchFn(scope.$eval(compareWithExp));\n      }\n\n      function removeScope(e) {\n        var removedScope = e.targetScope;\n        var index = linkedScopes.indexOf(removedScope);\n        linkedScopes.splice(index, 1);\n        instances.splice(index, 1);\n        if (linkedScopes.length) {\n          var newWatchScope = linkedScopes[0];\n          angular.forEach(expToData, function(data) {\n            if (data.scope === removedScope) {\n              data.watcher = newWatchScope.$watch(data.compareWithExp, data.watchFn);\n              data.scope = newWatchScope;\n            }\n          });\n        } else {\n          expToData = {};\n        }\n      }\n    }\n  };\n}]);\nangular.module('ui.bootstrap.datepicker', ['ui.bootstrap.dateparser', 'ui.bootstrap.isClass'])\n\n.value('$datepickerSuppressError', false)\n\n.value('$datepickerLiteralWarning', true)\n\n.constant('uibDatepickerConfig', {\n  datepickerMode: 'day',\n  formatDay: 'dd',\n  formatMonth: 'MMMM',\n  formatYear: 'yyyy',\n  formatDayHeader: 'EEE',\n  formatDayTitle: 'MMMM yyyy',\n  formatMonthTitle: 'yyyy',\n  maxDate: null,\n  maxMode: 'year',\n  minDate: null,\n  minMode: 'day',\n  monthColumns: 3,\n  ngModelOptions: {},\n  shortcutPropagation: false,\n  showWeeks: true,\n  yearColumns: 5,\n  yearRows: 4\n})\n\n.controller('UibDatepickerController', ['$scope', '$element', '$attrs', '$parse', '$interpolate', '$locale', '$log', 'dateFilter', 'uibDatepickerConfig', '$datepickerLiteralWarning', '$datepickerSuppressError', 'uibDateParser',\n  function($scope, $element, $attrs, $parse, $interpolate, $locale, $log, dateFilter, datepickerConfig, $datepickerLiteralWarning, $datepickerSuppressError, dateParser) {\n  var self = this,\n      ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl;\n      ngModelOptions = {},\n      watchListeners = [];\n\n  $element.addClass('uib-datepicker');\n  $attrs.$set('role', 'application');\n\n  if (!$scope.datepickerOptions) {\n    $scope.datepickerOptions = {};\n  }\n\n  // Modes chain\n  this.modes = ['day', 'month', 'year'];\n\n  [\n    'customClass',\n    'dateDisabled',\n    'datepickerMode',\n    'formatDay',\n    'formatDayHeader',\n    'formatDayTitle',\n    'formatMonth',\n    'formatMonthTitle',\n    'formatYear',\n    'maxDate',\n    'maxMode',\n    'minDate',\n    'minMode',\n    'monthColumns',\n    'showWeeks',\n    'shortcutPropagation',\n    'startingDay',\n    'yearColumns',\n    'yearRows'\n  ].forEach(function(key) {\n    switch (key) {\n      case 'customClass':\n      case 'dateDisabled':\n        $scope[key] = $scope.datepickerOptions[key] || angular.noop;\n        break;\n      case 'datepickerMode':\n        $scope.datepickerMode = angular.isDefined($scope.datepickerOptions.datepickerMode) ?\n          $scope.datepickerOptions.datepickerMode : datepickerConfig.datepickerMode;\n        break;\n      case 'formatDay':\n      case 'formatDayHeader':\n      case 'formatDayTitle':\n      case 'formatMonth':\n      case 'formatMonthTitle':\n      case 'formatYear':\n        self[key] = angular.isDefined($scope.datepickerOptions[key]) ?\n          $interpolate($scope.datepickerOptions[key])($scope.$parent) :\n          datepickerConfig[key];\n        break;\n      case 'monthColumns':\n      case 'showWeeks':\n      case 'shortcutPropagation':\n      case 'yearColumns':\n      case 'yearRows':\n        self[key] = angular.isDefined($scope.datepickerOptions[key]) ?\n          $scope.datepickerOptions[key] : datepickerConfig[key];\n        break;\n      case 'startingDay':\n        if (angular.isDefined($scope.datepickerOptions.startingDay)) {\n          self.startingDay = $scope.datepickerOptions.startingDay;\n        } else if (angular.isNumber(datepickerConfig.startingDay)) {\n          self.startingDay = datepickerConfig.startingDay;\n        } else {\n          self.startingDay = ($locale.DATETIME_FORMATS.FIRSTDAYOFWEEK + 8) % 7;\n        }\n\n        break;\n      case 'maxDate':\n      case 'minDate':\n        $scope.$watch('datepickerOptions.' + key, function(value) {\n          if (value) {\n            if (angular.isDate(value)) {\n              self[key] = dateParser.fromTimezone(new Date(value), ngModelOptions.getOption('timezone'));\n            } else {\n              if ($datepickerLiteralWarning) {\n                $log.warn('Literal date support has been deprecated, please switch to date object usage');\n              }\n\n              self[key] = new Date(dateFilter(value, 'medium'));\n            }\n          } else {\n            self[key] = datepickerConfig[key] ?\n              dateParser.fromTimezone(new Date(datepickerConfig[key]), ngModelOptions.getOption('timezone')) :\n              null;\n          }\n\n          self.refreshView();\n        });\n\n        break;\n      case 'maxMode':\n      case 'minMode':\n        if ($scope.datepickerOptions[key]) {\n          $scope.$watch(function() { return $scope.datepickerOptions[key]; }, function(value) {\n            self[key] = $scope[key] = angular.isDefined(value) ? value : $scope.datepickerOptions[key];\n            if (key === 'minMode' && self.modes.indexOf($scope.datepickerOptions.datepickerMode) < self.modes.indexOf(self[key]) ||\n              key === 'maxMode' && self.modes.indexOf($scope.datepickerOptions.datepickerMode) > self.modes.indexOf(self[key])) {\n              $scope.datepickerMode = self[key];\n              $scope.datepickerOptions.datepickerMode = self[key];\n            }\n          });\n        } else {\n          self[key] = $scope[key] = datepickerConfig[key] || null;\n        }\n\n        break;\n    }\n  });\n\n  $scope.uniqueId = 'datepicker-' + $scope.$id + '-' + Math.floor(Math.random() * 10000);\n\n  $scope.disabled = angular.isDefined($attrs.disabled) || false;\n  if (angular.isDefined($attrs.ngDisabled)) {\n    watchListeners.push($scope.$parent.$watch($attrs.ngDisabled, function(disabled) {\n      $scope.disabled = disabled;\n      self.refreshView();\n    }));\n  }\n\n  $scope.isActive = function(dateObject) {\n    if (self.compare(dateObject.date, self.activeDate) === 0) {\n      $scope.activeDateId = dateObject.uid;\n      return true;\n    }\n    return false;\n  };\n\n  this.init = function(ngModelCtrl_) {\n    ngModelCtrl = ngModelCtrl_;\n    ngModelOptions = extractOptions(ngModelCtrl);\n\n    if ($scope.datepickerOptions.initDate) {\n      self.activeDate = dateParser.fromTimezone($scope.datepickerOptions.initDate, ngModelOptions.getOption('timezone')) || new Date();\n      $scope.$watch('datepickerOptions.initDate', function(initDate) {\n        if (initDate && (ngModelCtrl.$isEmpty(ngModelCtrl.$modelValue) || ngModelCtrl.$invalid)) {\n          self.activeDate = dateParser.fromTimezone(initDate, ngModelOptions.getOption('timezone'));\n          self.refreshView();\n        }\n      });\n    } else {\n      self.activeDate = new Date();\n    }\n\n    var date = ngModelCtrl.$modelValue ? new Date(ngModelCtrl.$modelValue) : new Date();\n    this.activeDate = !isNaN(date) ?\n      dateParser.fromTimezone(date, ngModelOptions.getOption('timezone')) :\n      dateParser.fromTimezone(new Date(), ngModelOptions.getOption('timezone'));\n\n    ngModelCtrl.$render = function() {\n      self.render();\n    };\n  };\n\n  this.render = function() {\n    if (ngModelCtrl.$viewValue) {\n      var date = new Date(ngModelCtrl.$viewValue),\n          isValid = !isNaN(date);\n\n      if (isValid) {\n        this.activeDate = dateParser.fromTimezone(date, ngModelOptions.getOption('timezone'));\n      } else if (!$datepickerSuppressError) {\n        $log.error('Datepicker directive: \"ng-model\" value must be a Date object');\n      }\n    }\n    this.refreshView();\n  };\n\n  this.refreshView = function() {\n    if (this.element) {\n      $scope.selectedDt = null;\n      this._refreshView();\n      if ($scope.activeDt) {\n        $scope.activeDateId = $scope.activeDt.uid;\n      }\n\n      var date = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;\n      date = dateParser.fromTimezone(date, ngModelOptions.getOption('timezone'));\n      ngModelCtrl.$setValidity('dateDisabled', !date ||\n        this.element && !this.isDisabled(date));\n    }\n  };\n\n  this.createDateObject = function(date, format) {\n    var model = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;\n    model = dateParser.fromTimezone(model, ngModelOptions.getOption('timezone'));\n    var today = new Date();\n    today = dateParser.fromTimezone(today, ngModelOptions.getOption('timezone'));\n    var time = this.compare(date, today);\n    var dt = {\n      date: date,\n      label: dateParser.filter(date, format),\n      selected: model && this.compare(date, model) === 0,\n      disabled: this.isDisabled(date),\n      past: time < 0,\n      current: time === 0,\n      future: time > 0,\n      customClass: this.customClass(date) || null\n    };\n\n    if (model && this.compare(date, model) === 0) {\n      $scope.selectedDt = dt;\n    }\n\n    if (self.activeDate && this.compare(dt.date, self.activeDate) === 0) {\n      $scope.activeDt = dt;\n    }\n\n    return dt;\n  };\n\n  this.isDisabled = function(date) {\n    return $scope.disabled ||\n      this.minDate && this.compare(date, this.minDate) < 0 ||\n      this.maxDate && this.compare(date, this.maxDate) > 0 ||\n      $scope.dateDisabled && $scope.dateDisabled({date: date, mode: $scope.datepickerMode});\n  };\n\n  this.customClass = function(date) {\n    return $scope.customClass({date: date, mode: $scope.datepickerMode});\n  };\n\n  // Split array into smaller arrays\n  this.split = function(arr, size) {\n    var arrays = [];\n    while (arr.length > 0) {\n      arrays.push(arr.splice(0, size));\n    }\n    return arrays;\n  };\n\n  $scope.select = function(date) {\n    if ($scope.datepickerMode === self.minMode) {\n      var dt = ngModelCtrl.$viewValue ? dateParser.fromTimezone(new Date(ngModelCtrl.$viewValue), ngModelOptions.getOption('timezone')) : new Date(0, 0, 0, 0, 0, 0, 0);\n      dt.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());\n      dt = dateParser.toTimezone(dt, ngModelOptions.getOption('timezone'));\n      ngModelCtrl.$setViewValue(dt);\n      ngModelCtrl.$render();\n    } else {\n      self.activeDate = date;\n      setMode(self.modes[self.modes.indexOf($scope.datepickerMode) - 1]);\n\n      $scope.$emit('uib:datepicker.mode');\n    }\n\n    $scope.$broadcast('uib:datepicker.focus');\n  };\n\n  $scope.move = function(direction) {\n    var year = self.activeDate.getFullYear() + direction * (self.step.years || 0),\n        month = self.activeDate.getMonth() + direction * (self.step.months || 0);\n    self.activeDate.setFullYear(year, month, 1);\n    self.refreshView();\n  };\n\n  $scope.toggleMode = function(direction) {\n    direction = direction || 1;\n\n    if ($scope.datepickerMode === self.maxMode && direction === 1 ||\n      $scope.datepickerMode === self.minMode && direction === -1) {\n      return;\n    }\n\n    setMode(self.modes[self.modes.indexOf($scope.datepickerMode) + direction]);\n\n    $scope.$emit('uib:datepicker.mode');\n  };\n\n  // Key event mapper\n  $scope.keys = { 13: 'enter', 32: 'space', 33: 'pageup', 34: 'pagedown', 35: 'end', 36: 'home', 37: 'left', 38: 'up', 39: 'right', 40: 'down' };\n\n  var focusElement = function() {\n    self.element[0].focus();\n  };\n\n  // Listen for focus requests from popup directive\n  $scope.$on('uib:datepicker.focus', focusElement);\n\n  $scope.keydown = function(evt) {\n    var key = $scope.keys[evt.which];\n\n    if (!key || evt.shiftKey || evt.altKey || $scope.disabled) {\n      return;\n    }\n\n    evt.preventDefault();\n    if (!self.shortcutPropagation) {\n      evt.stopPropagation();\n    }\n\n    if (key === 'enter' || key === 'space') {\n      if (self.isDisabled(self.activeDate)) {\n        return; // do nothing\n      }\n      $scope.select(self.activeDate);\n    } else if (evt.ctrlKey && (key === 'up' || key === 'down')) {\n      $scope.toggleMode(key === 'up' ? 1 : -1);\n    } else {\n      self.handleKeyDown(key, evt);\n      self.refreshView();\n    }\n  };\n\n  $element.on('keydown', function(evt) {\n    $scope.$apply(function() {\n      $scope.keydown(evt);\n    });\n  });\n\n  $scope.$on('$destroy', function() {\n    //Clear all watch listeners on destroy\n    while (watchListeners.length) {\n      watchListeners.shift()();\n    }\n  });\n\n  function setMode(mode) {\n    $scope.datepickerMode = mode;\n    $scope.datepickerOptions.datepickerMode = mode;\n  }\n\n  function extractOptions(ngModelCtrl) {\n    var ngModelOptions;\n\n    if (angular.version.minor < 6) { // in angular < 1.6 $options could be missing\n      // guarantee a value\n      ngModelOptions = ngModelCtrl.$options ||\n        $scope.datepickerOptions.ngModelOptions ||\n        datepickerConfig.ngModelOptions ||\n        {};\n\n      // mimic 1.6+ api\n      ngModelOptions.getOption = function (key) {\n        return ngModelOptions[key];\n      };\n    } else { // in angular >=1.6 $options is always present\n      // ng-model-options defaults timezone to null; don't let its precedence squash a non-null value\n      var timezone = ngModelCtrl.$options.getOption('timezone') ||\n        ($scope.datepickerOptions.ngModelOptions ? $scope.datepickerOptions.ngModelOptions.timezone : null) ||\n        (datepickerConfig.ngModelOptions ? datepickerConfig.ngModelOptions.timezone : null);\n\n      // values passed to createChild override existing values\n      ngModelOptions = ngModelCtrl.$options // start with a ModelOptions instance\n        .createChild(datepickerConfig.ngModelOptions) // lowest precedence\n        .createChild($scope.datepickerOptions.ngModelOptions)\n        .createChild(ngModelCtrl.$options) // highest precedence\n        .createChild({timezone: timezone}); // to keep from squashing a non-null value\n    }\n\n    return ngModelOptions;\n  }\n}])\n\n.controller('UibDaypickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {\n  var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\n  this.step = { months: 1 };\n  this.element = $element;\n  function getDaysInMonth(year, month) {\n    return month === 1 && year % 4 === 0 &&\n      (year % 100 !== 0 || year % 400 === 0) ? 29 : DAYS_IN_MONTH[month];\n  }\n\n  this.init = function(ctrl) {\n    angular.extend(ctrl, this);\n    scope.showWeeks = ctrl.showWeeks;\n    ctrl.refreshView();\n  };\n\n  this.getDates = function(startDate, n) {\n    var dates = new Array(n), current = new Date(startDate), i = 0, date;\n    while (i < n) {\n      date = new Date(current);\n      dates[i++] = date;\n      current.setDate(current.getDate() + 1);\n    }\n    return dates;\n  };\n\n  this._refreshView = function() {\n    var year = this.activeDate.getFullYear(),\n      month = this.activeDate.getMonth(),\n      firstDayOfMonth = new Date(this.activeDate);\n\n    firstDayOfMonth.setFullYear(year, month, 1);\n\n    var difference = this.startingDay - firstDayOfMonth.getDay(),\n      numDisplayedFromPreviousMonth = difference > 0 ?\n        7 - difference : - difference,\n      firstDate = new Date(firstDayOfMonth);\n\n    if (numDisplayedFromPreviousMonth > 0) {\n      firstDate.setDate(-numDisplayedFromPreviousMonth + 1);\n    }\n\n    // 42 is the number of days on a six-week calendar\n    var days = this.getDates(firstDate, 42);\n    for (var i = 0; i < 42; i ++) {\n      days[i] = angular.extend(this.createDateObject(days[i], this.formatDay), {\n        secondary: days[i].getMonth() !== month,\n        uid: scope.uniqueId + '-' + i\n      });\n    }\n\n    scope.labels = new Array(7);\n    for (var j = 0; j < 7; j++) {\n      scope.labels[j] = {\n        abbr: dateFilter(days[j].date, this.formatDayHeader),\n        full: dateFilter(days[j].date, 'EEEE')\n      };\n    }\n\n    scope.title = dateFilter(this.activeDate, this.formatDayTitle);\n    scope.rows = this.split(days, 7);\n\n    if (scope.showWeeks) {\n      scope.weekNumbers = [];\n      var thursdayIndex = (4 + 7 - this.startingDay) % 7,\n          numWeeks = scope.rows.length;\n      for (var curWeek = 0; curWeek < numWeeks; curWeek++) {\n        scope.weekNumbers.push(\n          getISO8601WeekNumber(scope.rows[curWeek][thursdayIndex].date));\n      }\n    }\n  };\n\n  this.compare = function(date1, date2) {\n    var _date1 = new Date(date1.getFullYear(), date1.getMonth(), date1.getDate());\n    var _date2 = new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());\n    _date1.setFullYear(date1.getFullYear());\n    _date2.setFullYear(date2.getFullYear());\n    return _date1 - _date2;\n  };\n\n  function getISO8601WeekNumber(date) {\n    var checkDate = new Date(date);\n    checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7)); // Thursday\n    var time = checkDate.getTime();\n    checkDate.setMonth(0); // Compare with Jan 1\n    checkDate.setDate(1);\n    return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;\n  }\n\n  this.handleKeyDown = function(key, evt) {\n    var date = this.activeDate.getDate();\n\n    if (key === 'left') {\n      date = date - 1;\n    } else if (key === 'up') {\n      date = date - 7;\n    } else if (key === 'right') {\n      date = date + 1;\n    } else if (key === 'down') {\n      date = date + 7;\n    } else if (key === 'pageup' || key === 'pagedown') {\n      var month = this.activeDate.getMonth() + (key === 'pageup' ? - 1 : 1);\n      this.activeDate.setMonth(month, 1);\n      date = Math.min(getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth()), date);\n    } else if (key === 'home') {\n      date = 1;\n    } else if (key === 'end') {\n      date = getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth());\n    }\n    this.activeDate.setDate(date);\n  };\n}])\n\n.controller('UibMonthpickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {\n  this.step = { years: 1 };\n  this.element = $element;\n\n  this.init = function(ctrl) {\n    angular.extend(ctrl, this);\n    ctrl.refreshView();\n  };\n\n  this._refreshView = function() {\n    var months = new Array(12),\n        year = this.activeDate.getFullYear(),\n        date;\n\n    for (var i = 0; i < 12; i++) {\n      date = new Date(this.activeDate);\n      date.setFullYear(year, i, 1);\n      months[i] = angular.extend(this.createDateObject(date, this.formatMonth), {\n        uid: scope.uniqueId + '-' + i\n      });\n    }\n\n    scope.title = dateFilter(this.activeDate, this.formatMonthTitle);\n    scope.rows = this.split(months, this.monthColumns);\n    scope.yearHeaderColspan = this.monthColumns > 3 ? this.monthColumns - 2 : 1;\n  };\n\n  this.compare = function(date1, date2) {\n    var _date1 = new Date(date1.getFullYear(), date1.getMonth());\n    var _date2 = new Date(date2.getFullYear(), date2.getMonth());\n    _date1.setFullYear(date1.getFullYear());\n    _date2.setFullYear(date2.getFullYear());\n    return _date1 - _date2;\n  };\n\n  this.handleKeyDown = function(key, evt) {\n    var date = this.activeDate.getMonth();\n\n    if (key === 'left') {\n      date = date - 1;\n    } else if (key === 'up') {\n      date = date - this.monthColumns;\n    } else if (key === 'right') {\n      date = date + 1;\n    } else if (key === 'down') {\n      date = date + this.monthColumns;\n    } else if (key === 'pageup' || key === 'pagedown') {\n      var year = this.activeDate.getFullYear() + (key === 'pageup' ? - 1 : 1);\n      this.activeDate.setFullYear(year);\n    } else if (key === 'home') {\n      date = 0;\n    } else if (key === 'end') {\n      date = 11;\n    }\n    this.activeDate.setMonth(date);\n  };\n}])\n\n.controller('UibYearpickerController', ['$scope', '$element', 'dateFilter', function(scope, $element, dateFilter) {\n  var columns, range;\n  this.element = $element;\n\n  function getStartingYear(year) {\n    return parseInt((year - 1) / range, 10) * range + 1;\n  }\n\n  this.yearpickerInit = function() {\n    columns = this.yearColumns;\n    range = this.yearRows * columns;\n    this.step = { years: range };\n  };\n\n  this._refreshView = function() {\n    var years = new Array(range), date;\n\n    for (var i = 0, start = getStartingYear(this.activeDate.getFullYear()); i < range; i++) {\n      date = new Date(this.activeDate);\n      date.setFullYear(start + i, 0, 1);\n      years[i] = angular.extend(this.createDateObject(date, this.formatYear), {\n        uid: scope.uniqueId + '-' + i\n      });\n    }\n\n    scope.title = [years[0].label, years[range - 1].label].join(' - ');\n    scope.rows = this.split(years, columns);\n    scope.columns = columns;\n  };\n\n  this.compare = function(date1, date2) {\n    return date1.getFullYear() - date2.getFullYear();\n  };\n\n  this.handleKeyDown = function(key, evt) {\n    var date = this.activeDate.getFullYear();\n\n    if (key === 'left') {\n      date = date - 1;\n    } else if (key === 'up') {\n      date = date - columns;\n    } else if (key === 'right') {\n      date = date + 1;\n    } else if (key === 'down') {\n      date = date + columns;\n    } else if (key === 'pageup' || key === 'pagedown') {\n      date += (key === 'pageup' ? - 1 : 1) * range;\n    } else if (key === 'home') {\n      date = getStartingYear(this.activeDate.getFullYear());\n    } else if (key === 'end') {\n      date = getStartingYear(this.activeDate.getFullYear()) + range - 1;\n    }\n    this.activeDate.setFullYear(date);\n  };\n}])\n\n.directive('uibDatepicker', function() {\n  return {\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'uib/template/datepicker/datepicker.html';\n    },\n    scope: {\n      datepickerOptions: '=?'\n    },\n    require: ['uibDatepicker', '^ngModel'],\n    restrict: 'A',\n    controller: 'UibDatepickerController',\n    controllerAs: 'datepicker',\n    link: function(scope, element, attrs, ctrls) {\n      var datepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      datepickerCtrl.init(ngModelCtrl);\n    }\n  };\n})\n\n.directive('uibDaypicker', function() {\n  return {\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'uib/template/datepicker/day.html';\n    },\n    require: ['^uibDatepicker', 'uibDaypicker'],\n    restrict: 'A',\n    controller: 'UibDaypickerController',\n    link: function(scope, element, attrs, ctrls) {\n      var datepickerCtrl = ctrls[0],\n        daypickerCtrl = ctrls[1];\n\n      daypickerCtrl.init(datepickerCtrl);\n    }\n  };\n})\n\n.directive('uibMonthpicker', function() {\n  return {\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'uib/template/datepicker/month.html';\n    },\n    require: ['^uibDatepicker', 'uibMonthpicker'],\n    restrict: 'A',\n    controller: 'UibMonthpickerController',\n    link: function(scope, element, attrs, ctrls) {\n      var datepickerCtrl = ctrls[0],\n        monthpickerCtrl = ctrls[1];\n\n      monthpickerCtrl.init(datepickerCtrl);\n    }\n  };\n})\n\n.directive('uibYearpicker', function() {\n  return {\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'uib/template/datepicker/year.html';\n    },\n    require: ['^uibDatepicker', 'uibYearpicker'],\n    restrict: 'A',\n    controller: 'UibYearpickerController',\n    link: function(scope, element, attrs, ctrls) {\n      var ctrl = ctrls[0];\n      angular.extend(ctrl, ctrls[1]);\n      ctrl.yearpickerInit();\n\n      ctrl.refreshView();\n    }\n  };\n});\n\nangular.module('ui.bootstrap.position', [])\n\n/**\n * A set of utility methods for working with the DOM.\n * It is meant to be used where we need to absolute-position elements in\n * relation to another element (this is the case for tooltips, popovers,\n * typeahead suggestions etc.).\n */\n  .factory('$uibPosition', ['$document', '$window', function($document, $window) {\n    /**\n     * Used by scrollbarWidth() function to cache scrollbar's width.\n     * Do not access this variable directly, use scrollbarWidth() instead.\n     */\n    var SCROLLBAR_WIDTH;\n    /**\n     * scrollbar on body and html element in IE and Edge overlay\n     * content and should be considered 0 width.\n     */\n    var BODY_SCROLLBAR_WIDTH;\n    var OVERFLOW_REGEX = {\n      normal: /(auto|scroll)/,\n      hidden: /(auto|scroll|hidden)/\n    };\n    var PLACEMENT_REGEX = {\n      auto: /\\s?auto?\\s?/i,\n      primary: /^(top|bottom|left|right)$/,\n      secondary: /^(top|bottom|left|right|center)$/,\n      vertical: /^(top|bottom)$/\n    };\n    var BODY_REGEX = /(HTML|BODY)/;\n\n    return {\n\n      /**\n       * Provides a raw DOM element from a jQuery/jQLite element.\n       *\n       * @param {element} elem - The element to convert.\n       *\n       * @returns {element} A HTML element.\n       */\n      getRawNode: function(elem) {\n        return elem.nodeName ? elem : elem[0] || elem;\n      },\n\n      /**\n       * Provides a parsed number for a style property.  Strips\n       * units and casts invalid numbers to 0.\n       *\n       * @param {string} value - The style value to parse.\n       *\n       * @returns {number} A valid number.\n       */\n      parseStyle: function(value) {\n        value = parseFloat(value);\n        return isFinite(value) ? value : 0;\n      },\n\n      /**\n       * Provides the closest positioned ancestor.\n       *\n       * @param {element} element - The element to get the offest parent for.\n       *\n       * @returns {element} The closest positioned ancestor.\n       */\n      offsetParent: function(elem) {\n        elem = this.getRawNode(elem);\n\n        var offsetParent = elem.offsetParent || $document[0].documentElement;\n\n        function isStaticPositioned(el) {\n          return ($window.getComputedStyle(el).position || 'static') === 'static';\n        }\n\n        while (offsetParent && offsetParent !== $document[0].documentElement && isStaticPositioned(offsetParent)) {\n          offsetParent = offsetParent.offsetParent;\n        }\n\n        return offsetParent || $document[0].documentElement;\n      },\n\n      /**\n       * Provides the scrollbar width, concept from TWBS measureScrollbar()\n       * function in https://github.com/twbs/bootstrap/blob/master/js/modal.js\n       * In IE and Edge, scollbar on body and html element overlay and should\n       * return a width of 0.\n       *\n       * @returns {number} The width of the browser scollbar.\n       */\n      scrollbarWidth: function(isBody) {\n        if (isBody) {\n          if (angular.isUndefined(BODY_SCROLLBAR_WIDTH)) {\n            var bodyElem = $document.find('body');\n            bodyElem.addClass('uib-position-body-scrollbar-measure');\n            BODY_SCROLLBAR_WIDTH = $window.innerWidth - bodyElem[0].clientWidth;\n            BODY_SCROLLBAR_WIDTH = isFinite(BODY_SCROLLBAR_WIDTH) ? BODY_SCROLLBAR_WIDTH : 0;\n            bodyElem.removeClass('uib-position-body-scrollbar-measure');\n          }\n          return BODY_SCROLLBAR_WIDTH;\n        }\n\n        if (angular.isUndefined(SCROLLBAR_WIDTH)) {\n          var scrollElem = angular.element('<div class=\"uib-position-scrollbar-measure\"></div>');\n          $document.find('body').append(scrollElem);\n          SCROLLBAR_WIDTH = scrollElem[0].offsetWidth - scrollElem[0].clientWidth;\n          SCROLLBAR_WIDTH = isFinite(SCROLLBAR_WIDTH) ? SCROLLBAR_WIDTH : 0;\n          scrollElem.remove();\n        }\n\n        return SCROLLBAR_WIDTH;\n      },\n\n      /**\n       * Provides the padding required on an element to replace the scrollbar.\n       *\n       * @returns {object} An object with the following properties:\n       *   <ul>\n       *     <li>**scrollbarWidth**: the width of the scrollbar</li>\n       *     <li>**widthOverflow**: whether the the width is overflowing</li>\n       *     <li>**right**: the amount of right padding on the element needed to replace the scrollbar</li>\n       *     <li>**rightOriginal**: the amount of right padding currently on the element</li>\n       *     <li>**heightOverflow**: whether the the height is overflowing</li>\n       *     <li>**bottom**: the amount of bottom padding on the element needed to replace the scrollbar</li>\n       *     <li>**bottomOriginal**: the amount of bottom padding currently on the element</li>\n       *   </ul>\n       */\n      scrollbarPadding: function(elem) {\n        elem = this.getRawNode(elem);\n\n        var elemStyle = $window.getComputedStyle(elem);\n        var paddingRight = this.parseStyle(elemStyle.paddingRight);\n        var paddingBottom = this.parseStyle(elemStyle.paddingBottom);\n        var scrollParent = this.scrollParent(elem, false, true);\n        var scrollbarWidth = this.scrollbarWidth(BODY_REGEX.test(scrollParent.tagName));\n\n        return {\n          scrollbarWidth: scrollbarWidth,\n          widthOverflow: scrollParent.scrollWidth > scrollParent.clientWidth,\n          right: paddingRight + scrollbarWidth,\n          originalRight: paddingRight,\n          heightOverflow: scrollParent.scrollHeight > scrollParent.clientHeight,\n          bottom: paddingBottom + scrollbarWidth,\n          originalBottom: paddingBottom\n         };\n      },\n\n      /**\n       * Checks to see if the element is scrollable.\n       *\n       * @param {element} elem - The element to check.\n       * @param {boolean=} [includeHidden=false] - Should scroll style of 'hidden' be considered,\n       *   default is false.\n       *\n       * @returns {boolean} Whether the element is scrollable.\n       */\n      isScrollable: function(elem, includeHidden) {\n        elem = this.getRawNode(elem);\n\n        var overflowRegex = includeHidden ? OVERFLOW_REGEX.hidden : OVERFLOW_REGEX.normal;\n        var elemStyle = $window.getComputedStyle(elem);\n        return overflowRegex.test(elemStyle.overflow + elemStyle.overflowY + elemStyle.overflowX);\n      },\n\n      /**\n       * Provides the closest scrollable ancestor.\n       * A port of the jQuery UI scrollParent method:\n       * https://github.com/jquery/jquery-ui/blob/master/ui/scroll-parent.js\n       *\n       * @param {element} elem - The element to find the scroll parent of.\n       * @param {boolean=} [includeHidden=false] - Should scroll style of 'hidden' be considered,\n       *   default is false.\n       * @param {boolean=} [includeSelf=false] - Should the element being passed be\n       * included in the scrollable llokup.\n       *\n       * @returns {element} A HTML element.\n       */\n      scrollParent: function(elem, includeHidden, includeSelf) {\n        elem = this.getRawNode(elem);\n\n        var overflowRegex = includeHidden ? OVERFLOW_REGEX.hidden : OVERFLOW_REGEX.normal;\n        var documentEl = $document[0].documentElement;\n        var elemStyle = $window.getComputedStyle(elem);\n        if (includeSelf && overflowRegex.test(elemStyle.overflow + elemStyle.overflowY + elemStyle.overflowX)) {\n          return elem;\n        }\n        var excludeStatic = elemStyle.position === 'absolute';\n        var scrollParent = elem.parentElement || documentEl;\n\n        if (scrollParent === documentEl || elemStyle.position === 'fixed') {\n          return documentEl;\n        }\n\n        while (scrollParent.parentElement && scrollParent !== documentEl) {\n          var spStyle = $window.getComputedStyle(scrollParent);\n          if (excludeStatic && spStyle.position !== 'static') {\n            excludeStatic = false;\n          }\n\n          if (!excludeStatic && overflowRegex.test(spStyle.overflow + spStyle.overflowY + spStyle.overflowX)) {\n            break;\n          }\n          scrollParent = scrollParent.parentElement;\n        }\n\n        return scrollParent;\n      },\n\n      /**\n       * Provides read-only equivalent of jQuery's position function:\n       * http://api.jquery.com/position/ - distance to closest positioned\n       * ancestor.  Does not account for margins by default like jQuery position.\n       *\n       * @param {element} elem - The element to caclulate the position on.\n       * @param {boolean=} [includeMargins=false] - Should margins be accounted\n       * for, default is false.\n       *\n       * @returns {object} An object with the following properties:\n       *   <ul>\n       *     <li>**width**: the width of the element</li>\n       *     <li>**height**: the height of the element</li>\n       *     <li>**top**: distance to top edge of offset parent</li>\n       *     <li>**left**: distance to left edge of offset parent</li>\n       *   </ul>\n       */\n      position: function(elem, includeMagins) {\n        elem = this.getRawNode(elem);\n\n        var elemOffset = this.offset(elem);\n        if (includeMagins) {\n          var elemStyle = $window.getComputedStyle(elem);\n          elemOffset.top -= this.parseStyle(elemStyle.marginTop);\n          elemOffset.left -= this.parseStyle(elemStyle.marginLeft);\n        }\n        var parent = this.offsetParent(elem);\n        var parentOffset = {top: 0, left: 0};\n\n        if (parent !== $document[0].documentElement) {\n          parentOffset = this.offset(parent);\n          parentOffset.top += parent.clientTop - parent.scrollTop;\n          parentOffset.left += parent.clientLeft - parent.scrollLeft;\n        }\n\n        return {\n          width: Math.round(angular.isNumber(elemOffset.width) ? elemOffset.width : elem.offsetWidth),\n          height: Math.round(angular.isNumber(elemOffset.height) ? elemOffset.height : elem.offsetHeight),\n          top: Math.round(elemOffset.top - parentOffset.top),\n          left: Math.round(elemOffset.left - parentOffset.left)\n        };\n      },\n\n      /**\n       * Provides read-only equivalent of jQuery's offset function:\n       * http://api.jquery.com/offset/ - distance to viewport.  Does\n       * not account for borders, margins, or padding on the body\n       * element.\n       *\n       * @param {element} elem - The element to calculate the offset on.\n       *\n       * @returns {object} An object with the following properties:\n       *   <ul>\n       *     <li>**width**: the width of the element</li>\n       *     <li>**height**: the height of the element</li>\n       *     <li>**top**: distance to top edge of viewport</li>\n       *     <li>**right**: distance to bottom edge of viewport</li>\n       *   </ul>\n       */\n      offset: function(elem) {\n        elem = this.getRawNode(elem);\n\n        var elemBCR = elem.getBoundingClientRect();\n        return {\n          width: Math.round(angular.isNumber(elemBCR.width) ? elemBCR.width : elem.offsetWidth),\n          height: Math.round(angular.isNumber(elemBCR.height) ? elemBCR.height : elem.offsetHeight),\n          top: Math.round(elemBCR.top + ($window.pageYOffset || $document[0].documentElement.scrollTop)),\n          left: Math.round(elemBCR.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft))\n        };\n      },\n\n      /**\n       * Provides offset distance to the closest scrollable ancestor\n       * or viewport.  Accounts for border and scrollbar width.\n       *\n       * Right and bottom dimensions represent the distance to the\n       * respective edge of the viewport element.  If the element\n       * edge extends beyond the viewport, a negative value will be\n       * reported.\n       *\n       * @param {element} elem - The element to get the viewport offset for.\n       * @param {boolean=} [useDocument=false] - Should the viewport be the document element instead\n       * of the first scrollable element, default is false.\n       * @param {boolean=} [includePadding=true] - Should the padding on the offset parent element\n       * be accounted for, default is true.\n       *\n       * @returns {object} An object with the following properties:\n       *   <ul>\n       *     <li>**top**: distance to the top content edge of viewport element</li>\n       *     <li>**bottom**: distance to the bottom content edge of viewport element</li>\n       *     <li>**left**: distance to the left content edge of viewport element</li>\n       *     <li>**right**: distance to the right content edge of viewport element</li>\n       *   </ul>\n       */\n      viewportOffset: function(elem, useDocument, includePadding) {\n        elem = this.getRawNode(elem);\n        includePadding = includePadding !== false ? true : false;\n\n        var elemBCR = elem.getBoundingClientRect();\n        var offsetBCR = {top: 0, left: 0, bottom: 0, right: 0};\n\n        var offsetParent = useDocument ? $document[0].documentElement : this.scrollParent(elem);\n        var offsetParentBCR = offsetParent.getBoundingClientRect();\n\n        offsetBCR.top = offsetParentBCR.top + offsetParent.clientTop;\n        offsetBCR.left = offsetParentBCR.left + offsetParent.clientLeft;\n        if (offsetParent === $document[0].documentElement) {\n          offsetBCR.top += $window.pageYOffset;\n          offsetBCR.left += $window.pageXOffset;\n        }\n        offsetBCR.bottom = offsetBCR.top + offsetParent.clientHeight;\n        offsetBCR.right = offsetBCR.left + offsetParent.clientWidth;\n\n        if (includePadding) {\n          var offsetParentStyle = $window.getComputedStyle(offsetParent);\n          offsetBCR.top += this.parseStyle(offsetParentStyle.paddingTop);\n          offsetBCR.bottom -= this.parseStyle(offsetParentStyle.paddingBottom);\n          offsetBCR.left += this.parseStyle(offsetParentStyle.paddingLeft);\n          offsetBCR.right -= this.parseStyle(offsetParentStyle.paddingRight);\n        }\n\n        return {\n          top: Math.round(elemBCR.top - offsetBCR.top),\n          bottom: Math.round(offsetBCR.bottom - elemBCR.bottom),\n          left: Math.round(elemBCR.left - offsetBCR.left),\n          right: Math.round(offsetBCR.right - elemBCR.right)\n        };\n      },\n\n      /**\n       * Provides an array of placement values parsed from a placement string.\n       * Along with the 'auto' indicator, supported placement strings are:\n       *   <ul>\n       *     <li>top: element on top, horizontally centered on host element.</li>\n       *     <li>top-left: element on top, left edge aligned with host element left edge.</li>\n       *     <li>top-right: element on top, lerightft edge aligned with host element right edge.</li>\n       *     <li>bottom: element on bottom, horizontally centered on host element.</li>\n       *     <li>bottom-left: element on bottom, left edge aligned with host element left edge.</li>\n       *     <li>bottom-right: element on bottom, right edge aligned with host element right edge.</li>\n       *     <li>left: element on left, vertically centered on host element.</li>\n       *     <li>left-top: element on left, top edge aligned with host element top edge.</li>\n       *     <li>left-bottom: element on left, bottom edge aligned with host element bottom edge.</li>\n       *     <li>right: element on right, vertically centered on host element.</li>\n       *     <li>right-top: element on right, top edge aligned with host element top edge.</li>\n       *     <li>right-bottom: element on right, bottom edge aligned with host element bottom edge.</li>\n       *   </ul>\n       * A placement string with an 'auto' indicator is expected to be\n       * space separated from the placement, i.e: 'auto bottom-left'  If\n       * the primary and secondary placement values do not match 'top,\n       * bottom, left, right' then 'top' will be the primary placement and\n       * 'center' will be the secondary placement.  If 'auto' is passed, true\n       * will be returned as the 3rd value of the array.\n       *\n       * @param {string} placement - The placement string to parse.\n       *\n       * @returns {array} An array with the following values\n       * <ul>\n       *   <li>**[0]**: The primary placement.</li>\n       *   <li>**[1]**: The secondary placement.</li>\n       *   <li>**[2]**: If auto is passed: true, else undefined.</li>\n       * </ul>\n       */\n      parsePlacement: function(placement) {\n        var autoPlace = PLACEMENT_REGEX.auto.test(placement);\n        if (autoPlace) {\n          placement = placement.replace(PLACEMENT_REGEX.auto, '');\n        }\n\n        placement = placement.split('-');\n\n        placement[0] = placement[0] || 'top';\n        if (!PLACEMENT_REGEX.primary.test(placement[0])) {\n          placement[0] = 'top';\n        }\n\n        placement[1] = placement[1] || 'center';\n        if (!PLACEMENT_REGEX.secondary.test(placement[1])) {\n          placement[1] = 'center';\n        }\n\n        if (autoPlace) {\n          placement[2] = true;\n        } else {\n          placement[2] = false;\n        }\n\n        return placement;\n      },\n\n      /**\n       * Provides coordinates for an element to be positioned relative to\n       * another element.  Passing 'auto' as part of the placement parameter\n       * will enable smart placement - where the element fits. i.e:\n       * 'auto left-top' will check to see if there is enough space to the left\n       * of the hostElem to fit the targetElem, if not place right (same for secondary\n       * top placement).  Available space is calculated using the viewportOffset\n       * function.\n       *\n       * @param {element} hostElem - The element to position against.\n       * @param {element} targetElem - The element to position.\n       * @param {string=} [placement=top] - The placement for the targetElem,\n       *   default is 'top'. 'center' is assumed as secondary placement for\n       *   'top', 'left', 'right', and 'bottom' placements.  Available placements are:\n       *   <ul>\n       *     <li>top</li>\n       *     <li>top-right</li>\n       *     <li>top-left</li>\n       *     <li>bottom</li>\n       *     <li>bottom-left</li>\n       *     <li>bottom-right</li>\n       *     <li>left</li>\n       *     <li>left-top</li>\n       *     <li>left-bottom</li>\n       *     <li>right</li>\n       *     <li>right-top</li>\n       *     <li>right-bottom</li>\n       *   </ul>\n       * @param {boolean=} [appendToBody=false] - Should the top and left values returned\n       *   be calculated from the body element, default is false.\n       *\n       * @returns {object} An object with the following properties:\n       *   <ul>\n       *     <li>**top**: Value for targetElem top.</li>\n       *     <li>**left**: Value for targetElem left.</li>\n       *     <li>**placement**: The resolved placement.</li>\n       *   </ul>\n       */\n      positionElements: function(hostElem, targetElem, placement, appendToBody) {\n        hostElem = this.getRawNode(hostElem);\n        targetElem = this.getRawNode(targetElem);\n\n        // need to read from prop to support tests.\n        var targetWidth = angular.isDefined(targetElem.offsetWidth) ? targetElem.offsetWidth : targetElem.prop('offsetWidth');\n        var targetHeight = angular.isDefined(targetElem.offsetHeight) ? targetElem.offsetHeight : targetElem.prop('offsetHeight');\n\n        placement = this.parsePlacement(placement);\n\n        var hostElemPos = appendToBody ? this.offset(hostElem) : this.position(hostElem);\n        var targetElemPos = {top: 0, left: 0, placement: ''};\n\n        if (placement[2]) {\n          var viewportOffset = this.viewportOffset(hostElem, appendToBody);\n\n          var targetElemStyle = $window.getComputedStyle(targetElem);\n          var adjustedSize = {\n            width: targetWidth + Math.round(Math.abs(this.parseStyle(targetElemStyle.marginLeft) + this.parseStyle(targetElemStyle.marginRight))),\n            height: targetHeight + Math.round(Math.abs(this.parseStyle(targetElemStyle.marginTop) + this.parseStyle(targetElemStyle.marginBottom)))\n          };\n\n          placement[0] = placement[0] === 'top' && adjustedSize.height > viewportOffset.top && adjustedSize.height <= viewportOffset.bottom ? 'bottom' :\n                         placement[0] === 'bottom' && adjustedSize.height > viewportOffset.bottom && adjustedSize.height <= viewportOffset.top ? 'top' :\n                         placement[0] === 'left' && adjustedSize.width > viewportOffset.left && adjustedSize.width <= viewportOffset.right ? 'right' :\n                         placement[0] === 'right' && adjustedSize.width > viewportOffset.right && adjustedSize.width <= viewportOffset.left ? 'left' :\n                         placement[0];\n\n          placement[1] = placement[1] === 'top' && adjustedSize.height - hostElemPos.height > viewportOffset.bottom && adjustedSize.height - hostElemPos.height <= viewportOffset.top ? 'bottom' :\n                         placement[1] === 'bottom' && adjustedSize.height - hostElemPos.height > viewportOffset.top && adjustedSize.height - hostElemPos.height <= viewportOffset.bottom ? 'top' :\n                         placement[1] === 'left' && adjustedSize.width - hostElemPos.width > viewportOffset.right && adjustedSize.width - hostElemPos.width <= viewportOffset.left ? 'right' :\n                         placement[1] === 'right' && adjustedSize.width - hostElemPos.width > viewportOffset.left && adjustedSize.width - hostElemPos.width <= viewportOffset.right ? 'left' :\n                         placement[1];\n\n          if (placement[1] === 'center') {\n            if (PLACEMENT_REGEX.vertical.test(placement[0])) {\n              var xOverflow = hostElemPos.width / 2 - targetWidth / 2;\n              if (viewportOffset.left + xOverflow < 0 && adjustedSize.width - hostElemPos.width <= viewportOffset.right) {\n                placement[1] = 'left';\n              } else if (viewportOffset.right + xOverflow < 0 && adjustedSize.width - hostElemPos.width <= viewportOffset.left) {\n                placement[1] = 'right';\n              }\n            } else {\n              var yOverflow = hostElemPos.height / 2 - adjustedSize.height / 2;\n              if (viewportOffset.top + yOverflow < 0 && adjustedSize.height - hostElemPos.height <= viewportOffset.bottom) {\n                placement[1] = 'top';\n              } else if (viewportOffset.bottom + yOverflow < 0 && adjustedSize.height - hostElemPos.height <= viewportOffset.top) {\n                placement[1] = 'bottom';\n              }\n            }\n          }\n        }\n\n        switch (placement[0]) {\n          case 'top':\n            targetElemPos.top = hostElemPos.top - targetHeight;\n            break;\n          case 'bottom':\n            targetElemPos.top = hostElemPos.top + hostElemPos.height;\n            break;\n          case 'left':\n            targetElemPos.left = hostElemPos.left - targetWidth;\n            break;\n          case 'right':\n            targetElemPos.left = hostElemPos.left + hostElemPos.width;\n            break;\n        }\n\n        switch (placement[1]) {\n          case 'top':\n            targetElemPos.top = hostElemPos.top;\n            break;\n          case 'bottom':\n            targetElemPos.top = hostElemPos.top + hostElemPos.height - targetHeight;\n            break;\n          case 'left':\n            targetElemPos.left = hostElemPos.left;\n            break;\n          case 'right':\n            targetElemPos.left = hostElemPos.left + hostElemPos.width - targetWidth;\n            break;\n          case 'center':\n            if (PLACEMENT_REGEX.vertical.test(placement[0])) {\n              targetElemPos.left = hostElemPos.left + hostElemPos.width / 2 - targetWidth / 2;\n            } else {\n              targetElemPos.top = hostElemPos.top + hostElemPos.height / 2 - targetHeight / 2;\n            }\n            break;\n        }\n\n        targetElemPos.top = Math.round(targetElemPos.top);\n        targetElemPos.left = Math.round(targetElemPos.left);\n        targetElemPos.placement = placement[1] === 'center' ? placement[0] : placement[0] + '-' + placement[1];\n\n        return targetElemPos;\n      },\n\n      /**\n       * Provides a way to adjust the top positioning after first\n       * render to correctly align element to top after content\n       * rendering causes resized element height\n       *\n       * @param {array} placementClasses - The array of strings of classes\n       * element should have.\n       * @param {object} containerPosition - The object with container\n       * position information\n       * @param {number} initialHeight - The initial height for the elem.\n       * @param {number} currentHeight - The current height for the elem.\n       */\n      adjustTop: function(placementClasses, containerPosition, initialHeight, currentHeight) {\n        if (placementClasses.indexOf('top') !== -1 && initialHeight !== currentHeight) {\n          return {\n            top: containerPosition.top - currentHeight + 'px'\n          };\n        }\n      },\n\n      /**\n       * Provides a way for positioning tooltip & dropdown\n       * arrows when using placement options beyond the standard\n       * left, right, top, or bottom.\n       *\n       * @param {element} elem - The tooltip/dropdown element.\n       * @param {string} placement - The placement for the elem.\n       */\n      positionArrow: function(elem, placement) {\n        elem = this.getRawNode(elem);\n\n        var innerElem = elem.querySelector('.tooltip-inner, .popover-inner');\n        if (!innerElem) {\n          return;\n        }\n\n        var isTooltip = angular.element(innerElem).hasClass('tooltip-inner');\n\n        var arrowElem = isTooltip ? elem.querySelector('.tooltip-arrow') : elem.querySelector('.arrow');\n        if (!arrowElem) {\n          return;\n        }\n\n        var arrowCss = {\n          top: '',\n          bottom: '',\n          left: '',\n          right: ''\n        };\n\n        placement = this.parsePlacement(placement);\n        if (placement[1] === 'center') {\n          // no adjustment necessary - just reset styles\n          angular.element(arrowElem).css(arrowCss);\n          return;\n        }\n\n        var borderProp = 'border-' + placement[0] + '-width';\n        var borderWidth = $window.getComputedStyle(arrowElem)[borderProp];\n\n        var borderRadiusProp = 'border-';\n        if (PLACEMENT_REGEX.vertical.test(placement[0])) {\n          borderRadiusProp += placement[0] + '-' + placement[1];\n        } else {\n          borderRadiusProp += placement[1] + '-' + placement[0];\n        }\n        borderRadiusProp += '-radius';\n        var borderRadius = $window.getComputedStyle(isTooltip ? innerElem : elem)[borderRadiusProp];\n\n        switch (placement[0]) {\n          case 'top':\n            arrowCss.bottom = isTooltip ? '0' : '-' + borderWidth;\n            break;\n          case 'bottom':\n            arrowCss.top = isTooltip ? '0' : '-' + borderWidth;\n            break;\n          case 'left':\n            arrowCss.right = isTooltip ? '0' : '-' + borderWidth;\n            break;\n          case 'right':\n            arrowCss.left = isTooltip ? '0' : '-' + borderWidth;\n            break;\n        }\n\n        arrowCss[placement[1]] = borderRadius;\n\n        angular.element(arrowElem).css(arrowCss);\n      }\n    };\n  }]);\n\nangular.module('ui.bootstrap.datepickerPopup', ['ui.bootstrap.datepicker', 'ui.bootstrap.position'])\n\n.value('$datepickerPopupLiteralWarning', true)\n\n.constant('uibDatepickerPopupConfig', {\n  altInputFormats: [],\n  appendToBody: false,\n  clearText: 'Clear',\n  closeOnDateSelection: true,\n  closeText: 'Done',\n  currentText: 'Today',\n  datepickerPopup: 'yyyy-MM-dd',\n  datepickerPopupTemplateUrl: 'uib/template/datepickerPopup/popup.html',\n  datepickerTemplateUrl: 'uib/template/datepicker/datepicker.html',\n  html5Types: {\n    date: 'yyyy-MM-dd',\n    'datetime-local': 'yyyy-MM-ddTHH:mm:ss.sss',\n    'month': 'yyyy-MM'\n  },\n  onOpenFocus: true,\n  showButtonBar: true,\n  placement: 'auto bottom-left'\n})\n\n.controller('UibDatepickerPopupController', ['$scope', '$element', '$attrs', '$compile', '$log', '$parse', '$window', '$document', '$rootScope', '$uibPosition', 'dateFilter', 'uibDateParser', 'uibDatepickerPopupConfig', '$timeout', 'uibDatepickerConfig', '$datepickerPopupLiteralWarning',\nfunction($scope, $element, $attrs, $compile, $log, $parse, $window, $document, $rootScope, $position, dateFilter, dateParser, datepickerPopupConfig, $timeout, datepickerConfig, $datepickerPopupLiteralWarning) {\n  var cache = {},\n    isHtml5DateInput = false;\n  var dateFormat, closeOnDateSelection, appendToBody, onOpenFocus,\n    datepickerPopupTemplateUrl, datepickerTemplateUrl, popupEl, datepickerEl, scrollParentEl,\n    ngModel, ngModelOptions, $popup, altInputFormats, watchListeners = [];\n\n  this.init = function(_ngModel_) {\n    ngModel = _ngModel_;\n    ngModelOptions = extractOptions(ngModel);\n    closeOnDateSelection = angular.isDefined($attrs.closeOnDateSelection) ?\n      $scope.$parent.$eval($attrs.closeOnDateSelection) :\n      datepickerPopupConfig.closeOnDateSelection;\n    appendToBody = angular.isDefined($attrs.datepickerAppendToBody) ?\n      $scope.$parent.$eval($attrs.datepickerAppendToBody) :\n      datepickerPopupConfig.appendToBody;\n    onOpenFocus = angular.isDefined($attrs.onOpenFocus) ?\n      $scope.$parent.$eval($attrs.onOpenFocus) : datepickerPopupConfig.onOpenFocus;\n    datepickerPopupTemplateUrl = angular.isDefined($attrs.datepickerPopupTemplateUrl) ?\n      $attrs.datepickerPopupTemplateUrl :\n      datepickerPopupConfig.datepickerPopupTemplateUrl;\n    datepickerTemplateUrl = angular.isDefined($attrs.datepickerTemplateUrl) ?\n      $attrs.datepickerTemplateUrl : datepickerPopupConfig.datepickerTemplateUrl;\n    altInputFormats = angular.isDefined($attrs.altInputFormats) ?\n      $scope.$parent.$eval($attrs.altInputFormats) :\n      datepickerPopupConfig.altInputFormats;\n\n    $scope.showButtonBar = angular.isDefined($attrs.showButtonBar) ?\n      $scope.$parent.$eval($attrs.showButtonBar) :\n      datepickerPopupConfig.showButtonBar;\n\n    if (datepickerPopupConfig.html5Types[$attrs.type]) {\n      dateFormat = datepickerPopupConfig.html5Types[$attrs.type];\n      isHtml5DateInput = true;\n    } else {\n      dateFormat = $attrs.uibDatepickerPopup || datepickerPopupConfig.datepickerPopup;\n      $attrs.$observe('uibDatepickerPopup', function(value, oldValue) {\n        var newDateFormat = value || datepickerPopupConfig.datepickerPopup;\n        // Invalidate the $modelValue to ensure that formatters re-run\n        // FIXME: Refactor when PR is merged: https://github.com/angular/angular.js/pull/10764\n        if (newDateFormat !== dateFormat) {\n          dateFormat = newDateFormat;\n          ngModel.$modelValue = null;\n\n          if (!dateFormat) {\n            throw new Error('uibDatepickerPopup must have a date format specified.');\n          }\n        }\n      });\n    }\n\n    if (!dateFormat) {\n      throw new Error('uibDatepickerPopup must have a date format specified.');\n    }\n\n    if (isHtml5DateInput && $attrs.uibDatepickerPopup) {\n      throw new Error('HTML5 date input types do not support custom formats.');\n    }\n\n    // popup element used to display calendar\n    popupEl = angular.element('<div uib-datepicker-popup-wrap><div uib-datepicker></div></div>');\n\n    popupEl.attr({\n      'ng-model': 'date',\n      'ng-change': 'dateSelection(date)',\n      'template-url': datepickerPopupTemplateUrl\n    });\n\n    // datepicker element\n    datepickerEl = angular.element(popupEl.children()[0]);\n    datepickerEl.attr('template-url', datepickerTemplateUrl);\n\n    if (!$scope.datepickerOptions) {\n      $scope.datepickerOptions = {};\n    }\n\n    if (isHtml5DateInput) {\n      if ($attrs.type === 'month') {\n        $scope.datepickerOptions.datepickerMode = 'month';\n        $scope.datepickerOptions.minMode = 'month';\n      }\n    }\n\n    datepickerEl.attr('datepicker-options', 'datepickerOptions');\n\n    if (!isHtml5DateInput) {\n      // Internal API to maintain the correct ng-invalid-[key] class\n      ngModel.$$parserName = 'date';\n      ngModel.$validators.date = validator;\n      ngModel.$parsers.unshift(parseDate);\n      ngModel.$formatters.push(function(value) {\n        if (ngModel.$isEmpty(value)) {\n          $scope.date = value;\n          return value;\n        }\n\n        if (angular.isNumber(value)) {\n          value = new Date(value);\n        }\n\n        $scope.date = dateParser.fromTimezone(value, ngModelOptions.getOption('timezone'));\n\n        return dateParser.filter($scope.date, dateFormat);\n      });\n    } else {\n      ngModel.$formatters.push(function(value) {\n        $scope.date = dateParser.fromTimezone(value, ngModelOptions.getOption('timezone'));\n        return value;\n      });\n    }\n\n    // Detect changes in the view from the text box\n    ngModel.$viewChangeListeners.push(function() {\n      $scope.date = parseDateString(ngModel.$viewValue);\n    });\n\n    $element.on('keydown', inputKeydownBind);\n\n    $popup = $compile(popupEl)($scope);\n    // Prevent jQuery cache memory leak (template is now redundant after linking)\n    popupEl.remove();\n\n    if (appendToBody) {\n      $document.find('body').append($popup);\n    } else {\n      $element.after($popup);\n    }\n\n    $scope.$on('$destroy', function() {\n      if ($scope.isOpen === true) {\n        if (!$rootScope.$$phase) {\n          $scope.$apply(function() {\n            $scope.isOpen = false;\n          });\n        }\n      }\n\n      $popup.remove();\n      $element.off('keydown', inputKeydownBind);\n      $document.off('click', documentClickBind);\n      if (scrollParentEl) {\n        scrollParentEl.off('scroll', positionPopup);\n      }\n      angular.element($window).off('resize', positionPopup);\n\n      //Clear all watch listeners on destroy\n      while (watchListeners.length) {\n        watchListeners.shift()();\n      }\n    });\n  };\n\n  $scope.getText = function(key) {\n    return $scope[key + 'Text'] || datepickerPopupConfig[key + 'Text'];\n  };\n\n  $scope.isDisabled = function(date) {\n    if (date === 'today') {\n      date = dateParser.fromTimezone(new Date(), ngModelOptions.getOption('timezone'));\n    }\n\n    var dates = {};\n    angular.forEach(['minDate', 'maxDate'], function(key) {\n      if (!$scope.datepickerOptions[key]) {\n        dates[key] = null;\n      } else if (angular.isDate($scope.datepickerOptions[key])) {\n        dates[key] = new Date($scope.datepickerOptions[key]);\n      } else {\n        if ($datepickerPopupLiteralWarning) {\n          $log.warn('Literal date support has been deprecated, please switch to date object usage');\n        }\n\n        dates[key] = new Date(dateFilter($scope.datepickerOptions[key], 'medium'));\n      }\n    });\n\n    return $scope.datepickerOptions &&\n      dates.minDate && $scope.compare(date, dates.minDate) < 0 ||\n      dates.maxDate && $scope.compare(date, dates.maxDate) > 0;\n  };\n\n  $scope.compare = function(date1, date2) {\n    return new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());\n  };\n\n  // Inner change\n  $scope.dateSelection = function(dt) {\n    $scope.date = dt;\n    var date = $scope.date ? dateParser.filter($scope.date, dateFormat) : null; // Setting to NULL is necessary for form validators to function\n    $element.val(date);\n    ngModel.$setViewValue(date);\n\n    if (closeOnDateSelection) {\n      $scope.isOpen = false;\n      $element[0].focus();\n    }\n  };\n\n  $scope.keydown = function(evt) {\n    if (evt.which === 27) {\n      evt.stopPropagation();\n      $scope.isOpen = false;\n      $element[0].focus();\n    }\n  };\n\n  $scope.select = function(date, evt) {\n    evt.stopPropagation();\n\n    if (date === 'today') {\n      var today = new Date();\n      if (angular.isDate($scope.date)) {\n        date = new Date($scope.date);\n        date.setFullYear(today.getFullYear(), today.getMonth(), today.getDate());\n      } else {\n        date = dateParser.fromTimezone(today, ngModelOptions.getOption('timezone'));\n        date.setHours(0, 0, 0, 0);\n      }\n    }\n    $scope.dateSelection(date);\n  };\n\n  $scope.close = function(evt) {\n    evt.stopPropagation();\n\n    $scope.isOpen = false;\n    $element[0].focus();\n  };\n\n  $scope.disabled = angular.isDefined($attrs.disabled) || false;\n  if ($attrs.ngDisabled) {\n    watchListeners.push($scope.$parent.$watch($parse($attrs.ngDisabled), function(disabled) {\n      $scope.disabled = disabled;\n    }));\n  }\n\n  $scope.$watch('isOpen', function(value) {\n    if (value) {\n      if (!$scope.disabled) {\n        $timeout(function() {\n          positionPopup();\n\n          if (onOpenFocus) {\n            $scope.$broadcast('uib:datepicker.focus');\n          }\n\n          $document.on('click', documentClickBind);\n\n          var placement = $attrs.popupPlacement ? $attrs.popupPlacement : datepickerPopupConfig.placement;\n          if (appendToBody || $position.parsePlacement(placement)[2]) {\n            scrollParentEl = scrollParentEl || angular.element($position.scrollParent($element));\n            if (scrollParentEl) {\n              scrollParentEl.on('scroll', positionPopup);\n            }\n          } else {\n            scrollParentEl = null;\n          }\n\n          angular.element($window).on('resize', positionPopup);\n        }, 0, false);\n      } else {\n        $scope.isOpen = false;\n      }\n    } else {\n      $document.off('click', documentClickBind);\n      if (scrollParentEl) {\n        scrollParentEl.off('scroll', positionPopup);\n      }\n      angular.element($window).off('resize', positionPopup);\n    }\n  });\n\n  function cameltoDash(string) {\n    return string.replace(/([A-Z])/g, function($1) { return '-' + $1.toLowerCase(); });\n  }\n\n  function parseDateString(viewValue) {\n    var date = dateParser.parse(viewValue, dateFormat, $scope.date);\n    if (isNaN(date)) {\n      for (var i = 0; i < altInputFormats.length; i++) {\n        date = dateParser.parse(viewValue, altInputFormats[i], $scope.date);\n        if (!isNaN(date)) {\n          return date;\n        }\n      }\n    }\n    return date;\n  }\n\n  function parseDate(viewValue) {\n    if (angular.isNumber(viewValue)) {\n      // presumably timestamp to date object\n      viewValue = new Date(viewValue);\n    }\n\n    if (!viewValue) {\n      return null;\n    }\n\n    if (angular.isDate(viewValue) && !isNaN(viewValue)) {\n      return viewValue;\n    }\n\n    if (angular.isString(viewValue)) {\n      var date = parseDateString(viewValue);\n      if (!isNaN(date)) {\n        return dateParser.toTimezone(date, ngModelOptions.getOption('timezone'));\n      }\n    }\n\n    return ngModelOptions.getOption('allowInvalid') ? viewValue : undefined;\n  }\n\n  function validator(modelValue, viewValue) {\n    var value = modelValue || viewValue;\n\n    if (!$attrs.ngRequired && !value) {\n      return true;\n    }\n\n    if (angular.isNumber(value)) {\n      value = new Date(value);\n    }\n\n    if (!value) {\n      return true;\n    }\n\n    if (angular.isDate(value) && !isNaN(value)) {\n      return true;\n    }\n\n    if (angular.isString(value)) {\n      return !isNaN(parseDateString(value));\n    }\n\n    return false;\n  }\n\n  function documentClickBind(event) {\n    if (!$scope.isOpen && $scope.disabled) {\n      return;\n    }\n\n    var popup = $popup[0];\n    var dpContainsTarget = $element[0].contains(event.target);\n    // The popup node may not be an element node\n    // In some browsers (IE) only element nodes have the 'contains' function\n    var popupContainsTarget = popup.contains !== undefined && popup.contains(event.target);\n    if ($scope.isOpen && !(dpContainsTarget || popupContainsTarget)) {\n      $scope.$apply(function() {\n        $scope.isOpen = false;\n      });\n    }\n  }\n\n  function inputKeydownBind(evt) {\n    if (evt.which === 27 && $scope.isOpen) {\n      evt.preventDefault();\n      evt.stopPropagation();\n      $scope.$apply(function() {\n        $scope.isOpen = false;\n      });\n      $element[0].focus();\n    } else if (evt.which === 40 && !$scope.isOpen) {\n      evt.preventDefault();\n      evt.stopPropagation();\n      $scope.$apply(function() {\n        $scope.isOpen = true;\n      });\n    }\n  }\n\n  function positionPopup() {\n    if ($scope.isOpen) {\n      var dpElement = angular.element($popup[0].querySelector('.uib-datepicker-popup'));\n      var placement = $attrs.popupPlacement ? $attrs.popupPlacement : datepickerPopupConfig.placement;\n      var position = $position.positionElements($element, dpElement, placement, appendToBody);\n      dpElement.css({top: position.top + 'px', left: position.left + 'px'});\n      if (dpElement.hasClass('uib-position-measure')) {\n        dpElement.removeClass('uib-position-measure');\n      }\n    }\n  }\n\n  function extractOptions(ngModelCtrl) {\n    var ngModelOptions;\n\n    if (angular.version.minor < 6) { // in angular < 1.6 $options could be missing\n      // guarantee a value\n      ngModelOptions = angular.isObject(ngModelCtrl.$options) ?\n        ngModelCtrl.$options :\n        {\n          timezone: null\n        };\n\n      // mimic 1.6+ api\n      ngModelOptions.getOption = function (key) {\n        return ngModelOptions[key];\n      };\n    } else { // in angular >=1.6 $options is always present\n      ngModelOptions = ngModelCtrl.$options;\n    }\n\n    return ngModelOptions;\n  }\n\n  $scope.$on('uib:datepicker.mode', function() {\n    $timeout(positionPopup, 0, false);\n  });\n}])\n\n.directive('uibDatepickerPopup', function() {\n  return {\n    require: ['ngModel', 'uibDatepickerPopup'],\n    controller: 'UibDatepickerPopupController',\n    scope: {\n      datepickerOptions: '=?',\n      isOpen: '=?',\n      currentText: '@',\n      clearText: '@',\n      closeText: '@'\n    },\n    link: function(scope, element, attrs, ctrls) {\n      var ngModel = ctrls[0],\n        ctrl = ctrls[1];\n\n      ctrl.init(ngModel);\n    }\n  };\n})\n\n.directive('uibDatepickerPopupWrap', function() {\n  return {\n    restrict: 'A',\n    transclude: true,\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'uib/template/datepickerPopup/popup.html';\n    }\n  };\n});\n\nangular.module('ui.bootstrap.debounce', [])\n/**\n * A helper, internal service that debounces a function\n */\n  .factory('$$debounce', ['$timeout', function($timeout) {\n    return function(callback, debounceTime) {\n      var timeoutPromise;\n\n      return function() {\n        var self = this;\n        var args = Array.prototype.slice.call(arguments);\n        if (timeoutPromise) {\n          $timeout.cancel(timeoutPromise);\n        }\n\n        timeoutPromise = $timeout(function() {\n          callback.apply(self, args);\n        }, debounceTime);\n      };\n    };\n  }]);\n\nangular.module('ui.bootstrap.multiMap', [])\n/**\n * A helper, internal data structure that stores all references attached to key\n */\n  .factory('$$multiMap', function() {\n    return {\n      createNew: function() {\n        var map = {};\n\n        return {\n          entries: function() {\n            return Object.keys(map).map(function(key) {\n              return {\n                key: key,\n                value: map[key]\n              };\n            });\n          },\n          get: function(key) {\n            return map[key];\n          },\n          hasKey: function(key) {\n            return !!map[key];\n          },\n          keys: function() {\n            return Object.keys(map);\n          },\n          put: function(key, value) {\n            if (!map[key]) {\n              map[key] = [];\n            }\n\n            map[key].push(value);\n          },\n          remove: function(key, value) {\n            var values = map[key];\n\n            if (!values) {\n              return;\n            }\n\n            var idx = values.indexOf(value);\n\n            if (idx !== -1) {\n              values.splice(idx, 1);\n            }\n\n            if (!values.length) {\n              delete map[key];\n            }\n          }\n        };\n      }\n    };\n  });\n\nangular.module('ui.bootstrap.dropdown', ['ui.bootstrap.multiMap', 'ui.bootstrap.position'])\n\n.constant('uibDropdownConfig', {\n  appendToOpenClass: 'uib-dropdown-open',\n  openClass: 'open'\n})\n\n.service('uibDropdownService', ['$document', '$rootScope', '$$multiMap', function($document, $rootScope, $$multiMap) {\n  var openScope = null;\n  var openedContainers = $$multiMap.createNew();\n\n  this.isOnlyOpen = function(dropdownScope, appendTo) {\n    var openedDropdowns = openedContainers.get(appendTo);\n    if (openedDropdowns) {\n      var openDropdown = openedDropdowns.reduce(function(toClose, dropdown) {\n        if (dropdown.scope === dropdownScope) {\n          return dropdown;\n        }\n\n        return toClose;\n      }, {});\n      if (openDropdown) {\n        return openedDropdowns.length === 1;\n      }\n    }\n\n    return false;\n  };\n\n  this.open = function(dropdownScope, element, appendTo) {\n    if (!openScope) {\n      $document.on('click', closeDropdown);\n    }\n\n    if (openScope && openScope !== dropdownScope) {\n      openScope.isOpen = false;\n    }\n\n    openScope = dropdownScope;\n\n    if (!appendTo) {\n      return;\n    }\n\n    var openedDropdowns = openedContainers.get(appendTo);\n    if (openedDropdowns) {\n      var openedScopes = openedDropdowns.map(function(dropdown) {\n        return dropdown.scope;\n      });\n      if (openedScopes.indexOf(dropdownScope) === -1) {\n        openedContainers.put(appendTo, {\n          scope: dropdownScope\n        });\n      }\n    } else {\n      openedContainers.put(appendTo, {\n        scope: dropdownScope\n      });\n    }\n  };\n\n  this.close = function(dropdownScope, element, appendTo) {\n    if (openScope === dropdownScope) {\n      $document.off('click', closeDropdown);\n      $document.off('keydown', this.keybindFilter);\n      openScope = null;\n    }\n\n    if (!appendTo) {\n      return;\n    }\n\n    var openedDropdowns = openedContainers.get(appendTo);\n    if (openedDropdowns) {\n      var dropdownToClose = openedDropdowns.reduce(function(toClose, dropdown) {\n        if (dropdown.scope === dropdownScope) {\n          return dropdown;\n        }\n\n        return toClose;\n      }, {});\n      if (dropdownToClose) {\n        openedContainers.remove(appendTo, dropdownToClose);\n      }\n    }\n  };\n\n  var closeDropdown = function(evt) {\n    // This method may still be called during the same mouse event that\n    // unbound this event handler. So check openScope before proceeding.\n    if (!openScope || !openScope.isOpen) { return; }\n\n    if (evt && openScope.getAutoClose() === 'disabled') { return; }\n\n    if (evt && evt.which === 3) { return; }\n\n    var toggleElement = openScope.getToggleElement();\n    if (evt && toggleElement && toggleElement[0].contains(evt.target)) {\n      return;\n    }\n\n    var dropdownElement = openScope.getDropdownElement();\n    if (evt && openScope.getAutoClose() === 'outsideClick' &&\n      dropdownElement && dropdownElement[0].contains(evt.target)) {\n      return;\n    }\n\n    openScope.focusToggleElement();\n    openScope.isOpen = false;\n\n    if (!$rootScope.$$phase) {\n      openScope.$apply();\n    }\n  };\n\n  this.keybindFilter = function(evt) {\n    if (!openScope) {\n      // see this.close as ESC could have been pressed which kills the scope so we can not proceed\n      return;\n    }\n\n    var dropdownElement = openScope.getDropdownElement();\n    var toggleElement = openScope.getToggleElement();\n    var dropdownElementTargeted = dropdownElement && dropdownElement[0].contains(evt.target);\n    var toggleElementTargeted = toggleElement && toggleElement[0].contains(evt.target);\n    if (evt.which === 27) {\n      evt.stopPropagation();\n      openScope.focusToggleElement();\n      closeDropdown();\n    } else if (openScope.isKeynavEnabled() && [38, 40].indexOf(evt.which) !== -1 && openScope.isOpen && (dropdownElementTargeted || toggleElementTargeted)) {\n      evt.preventDefault();\n      evt.stopPropagation();\n      openScope.focusDropdownEntry(evt.which);\n    }\n  };\n}])\n\n.controller('UibDropdownController', ['$scope', '$element', '$attrs', '$parse', 'uibDropdownConfig', 'uibDropdownService', '$animate', '$uibPosition', '$document', '$compile', '$templateRequest', function($scope, $element, $attrs, $parse, dropdownConfig, uibDropdownService, $animate, $position, $document, $compile, $templateRequest) {\n  var self = this,\n    scope = $scope.$new(), // create a child scope so we are not polluting original one\n    templateScope,\n    appendToOpenClass = dropdownConfig.appendToOpenClass,\n    openClass = dropdownConfig.openClass,\n    getIsOpen,\n    setIsOpen = angular.noop,\n    toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop,\n    keynavEnabled = false,\n    selectedOption = null,\n    body = $document.find('body');\n\n  $element.addClass('dropdown');\n\n  this.init = function() {\n    if ($attrs.isOpen) {\n      getIsOpen = $parse($attrs.isOpen);\n      setIsOpen = getIsOpen.assign;\n\n      $scope.$watch(getIsOpen, function(value) {\n        scope.isOpen = !!value;\n      });\n    }\n\n    keynavEnabled = angular.isDefined($attrs.keyboardNav);\n  };\n\n  this.toggle = function(open) {\n    scope.isOpen = arguments.length ? !!open : !scope.isOpen;\n    if (angular.isFunction(setIsOpen)) {\n      setIsOpen(scope, scope.isOpen);\n    }\n\n    return scope.isOpen;\n  };\n\n  // Allow other directives to watch status\n  this.isOpen = function() {\n    return scope.isOpen;\n  };\n\n  scope.getToggleElement = function() {\n    return self.toggleElement;\n  };\n\n  scope.getAutoClose = function() {\n    return $attrs.autoClose || 'always'; //or 'outsideClick' or 'disabled'\n  };\n\n  scope.getElement = function() {\n    return $element;\n  };\n\n  scope.isKeynavEnabled = function() {\n    return keynavEnabled;\n  };\n\n  scope.focusDropdownEntry = function(keyCode) {\n    var elems = self.dropdownMenu ? //If append to body is used.\n      angular.element(self.dropdownMenu).find('a') :\n      $element.find('ul').eq(0).find('a');\n\n    switch (keyCode) {\n      case 40: {\n        if (!angular.isNumber(self.selectedOption)) {\n          self.selectedOption = 0;\n        } else {\n          self.selectedOption = self.selectedOption === elems.length - 1 ?\n            self.selectedOption :\n            self.selectedOption + 1;\n        }\n        break;\n      }\n      case 38: {\n        if (!angular.isNumber(self.selectedOption)) {\n          self.selectedOption = elems.length - 1;\n        } else {\n          self.selectedOption = self.selectedOption === 0 ?\n            0 : self.selectedOption - 1;\n        }\n        break;\n      }\n    }\n    elems[self.selectedOption].focus();\n  };\n\n  scope.getDropdownElement = function() {\n    return self.dropdownMenu;\n  };\n\n  scope.focusToggleElement = function() {\n    if (self.toggleElement) {\n      self.toggleElement[0].focus();\n    }\n  };\n\n  function removeDropdownMenu() {\n    $element.append(self.dropdownMenu);\n  }\n\n  scope.$watch('isOpen', function(isOpen, wasOpen) {\n    var appendTo = null,\n      appendToBody = false;\n\n    if (angular.isDefined($attrs.dropdownAppendTo)) {\n      var appendToEl = $parse($attrs.dropdownAppendTo)(scope);\n      if (appendToEl) {\n        appendTo = angular.element(appendToEl);\n      }\n    }\n\n    if (angular.isDefined($attrs.dropdownAppendToBody)) {\n      var appendToBodyValue = $parse($attrs.dropdownAppendToBody)(scope);\n      if (appendToBodyValue !== false) {\n        appendToBody = true;\n      }\n    }\n\n    if (appendToBody && !appendTo) {\n      appendTo = body;\n    }\n\n    if (appendTo && self.dropdownMenu) {\n      if (isOpen) {\n        appendTo.append(self.dropdownMenu);\n        $element.on('$destroy', removeDropdownMenu);\n      } else {\n        $element.off('$destroy', removeDropdownMenu);\n        removeDropdownMenu();\n      }\n    }\n\n    if (appendTo && self.dropdownMenu) {\n      var pos = $position.positionElements($element, self.dropdownMenu, 'bottom-left', true),\n        css,\n        rightalign,\n        scrollbarPadding,\n        scrollbarWidth = 0;\n\n      css = {\n        top: pos.top + 'px',\n        display: isOpen ? 'block' : 'none'\n      };\n\n      rightalign = self.dropdownMenu.hasClass('dropdown-menu-right');\n      if (!rightalign) {\n        css.left = pos.left + 'px';\n        css.right = 'auto';\n      } else {\n        css.left = 'auto';\n        scrollbarPadding = $position.scrollbarPadding(appendTo);\n\n        if (scrollbarPadding.heightOverflow && scrollbarPadding.scrollbarWidth) {\n          scrollbarWidth = scrollbarPadding.scrollbarWidth;\n        }\n\n        css.right = window.innerWidth - scrollbarWidth -\n          (pos.left + $element.prop('offsetWidth')) + 'px';\n      }\n\n      // Need to adjust our positioning to be relative to the appendTo container\n      // if it's not the body element\n      if (!appendToBody) {\n        var appendOffset = $position.offset(appendTo);\n\n        css.top = pos.top - appendOffset.top + 'px';\n\n        if (!rightalign) {\n          css.left = pos.left - appendOffset.left + 'px';\n        } else {\n          css.right = window.innerWidth -\n            (pos.left - appendOffset.left + $element.prop('offsetWidth')) + 'px';\n        }\n      }\n\n      self.dropdownMenu.css(css);\n    }\n\n    var openContainer = appendTo ? appendTo : $element;\n    var dropdownOpenClass = appendTo ? appendToOpenClass : openClass;\n    var hasOpenClass = openContainer.hasClass(dropdownOpenClass);\n    var isOnlyOpen = uibDropdownService.isOnlyOpen($scope, appendTo);\n\n    if (hasOpenClass === !isOpen) {\n      var toggleClass;\n      if (appendTo) {\n        toggleClass = !isOnlyOpen ? 'addClass' : 'removeClass';\n      } else {\n        toggleClass = isOpen ? 'addClass' : 'removeClass';\n      }\n      $animate[toggleClass](openContainer, dropdownOpenClass).then(function() {\n        if (angular.isDefined(isOpen) && isOpen !== wasOpen) {\n          toggleInvoker($scope, { open: !!isOpen });\n        }\n      });\n    }\n\n    if (isOpen) {\n      if (self.dropdownMenuTemplateUrl) {\n        $templateRequest(self.dropdownMenuTemplateUrl).then(function(tplContent) {\n          templateScope = scope.$new();\n          $compile(tplContent.trim())(templateScope, function(dropdownElement) {\n            var newEl = dropdownElement;\n            self.dropdownMenu.replaceWith(newEl);\n            self.dropdownMenu = newEl;\n            $document.on('keydown', uibDropdownService.keybindFilter);\n          });\n        });\n      } else {\n        $document.on('keydown', uibDropdownService.keybindFilter);\n      }\n\n      scope.focusToggleElement();\n      uibDropdownService.open(scope, $element, appendTo);\n    } else {\n      uibDropdownService.close(scope, $element, appendTo);\n      if (self.dropdownMenuTemplateUrl) {\n        if (templateScope) {\n          templateScope.$destroy();\n        }\n        var newEl = angular.element('<ul class=\"dropdown-menu\"></ul>');\n        self.dropdownMenu.replaceWith(newEl);\n        self.dropdownMenu = newEl;\n      }\n\n      self.selectedOption = null;\n    }\n\n    if (angular.isFunction(setIsOpen)) {\n      setIsOpen($scope, isOpen);\n    }\n  });\n}])\n\n.directive('uibDropdown', function() {\n  return {\n    controller: 'UibDropdownController',\n    link: function(scope, element, attrs, dropdownCtrl) {\n      dropdownCtrl.init();\n    }\n  };\n})\n\n.directive('uibDropdownMenu', function() {\n  return {\n    restrict: 'A',\n    require: '?^uibDropdown',\n    link: function(scope, element, attrs, dropdownCtrl) {\n      if (!dropdownCtrl || angular.isDefined(attrs.dropdownNested)) {\n        return;\n      }\n\n      element.addClass('dropdown-menu');\n\n      var tplUrl = attrs.templateUrl;\n      if (tplUrl) {\n        dropdownCtrl.dropdownMenuTemplateUrl = tplUrl;\n      }\n\n      if (!dropdownCtrl.dropdownMenu) {\n        dropdownCtrl.dropdownMenu = element;\n      }\n    }\n  };\n})\n\n.directive('uibDropdownToggle', function() {\n  return {\n    require: '?^uibDropdown',\n    link: function(scope, element, attrs, dropdownCtrl) {\n      if (!dropdownCtrl) {\n        return;\n      }\n\n      element.addClass('dropdown-toggle');\n\n      dropdownCtrl.toggleElement = element;\n\n      var toggleDropdown = function(event) {\n        event.preventDefault();\n\n        if (!element.hasClass('disabled') && !attrs.disabled) {\n          scope.$apply(function() {\n            dropdownCtrl.toggle();\n          });\n        }\n      };\n\n      element.on('click', toggleDropdown);\n\n      // WAI-ARIA\n      element.attr({ 'aria-haspopup': true, 'aria-expanded': false });\n      scope.$watch(dropdownCtrl.isOpen, function(isOpen) {\n        element.attr('aria-expanded', !!isOpen);\n      });\n\n      scope.$on('$destroy', function() {\n        element.off('click', toggleDropdown);\n      });\n    }\n  };\n});\n\nangular.module('ui.bootstrap.stackedMap', [])\n/**\n * A helper, internal data structure that acts as a map but also allows getting / removing\n * elements in the LIFO order\n */\n  .factory('$$stackedMap', function() {\n    return {\n      createNew: function() {\n        var stack = [];\n\n        return {\n          add: function(key, value) {\n            stack.push({\n              key: key,\n              value: value\n            });\n          },\n          get: function(key) {\n            for (var i = 0; i < stack.length; i++) {\n              if (key === stack[i].key) {\n                return stack[i];\n              }\n            }\n          },\n          keys: function() {\n            var keys = [];\n            for (var i = 0; i < stack.length; i++) {\n              keys.push(stack[i].key);\n            }\n            return keys;\n          },\n          top: function() {\n            return stack[stack.length - 1];\n          },\n          remove: function(key) {\n            var idx = -1;\n            for (var i = 0; i < stack.length; i++) {\n              if (key === stack[i].key) {\n                idx = i;\n                break;\n              }\n            }\n            return stack.splice(idx, 1)[0];\n          },\n          removeTop: function() {\n            return stack.pop();\n          },\n          length: function() {\n            return stack.length;\n          }\n        };\n      }\n    };\n  });\nangular.module('ui.bootstrap.modal', ['ui.bootstrap.multiMap', 'ui.bootstrap.stackedMap', 'ui.bootstrap.position'])\n/**\n * Pluggable resolve mechanism for the modal resolve resolution\n * Supports UI Router's $resolve service\n */\n  .provider('$uibResolve', function() {\n    var resolve = this;\n    this.resolver = null;\n\n    this.setResolver = function(resolver) {\n      this.resolver = resolver;\n    };\n\n    this.$get = ['$injector', '$q', function($injector, $q) {\n      var resolver = resolve.resolver ? $injector.get(resolve.resolver) : null;\n      return {\n        resolve: function(invocables, locals, parent, self) {\n          if (resolver) {\n            return resolver.resolve(invocables, locals, parent, self);\n          }\n\n          var promises = [];\n\n          angular.forEach(invocables, function(value) {\n            if (angular.isFunction(value) || angular.isArray(value)) {\n              promises.push($q.resolve($injector.invoke(value)));\n            } else if (angular.isString(value)) {\n              promises.push($q.resolve($injector.get(value)));\n            } else {\n              promises.push($q.resolve(value));\n            }\n          });\n\n          return $q.all(promises).then(function(resolves) {\n            var resolveObj = {};\n            var resolveIter = 0;\n            angular.forEach(invocables, function(value, key) {\n              resolveObj[key] = resolves[resolveIter++];\n            });\n\n            return resolveObj;\n          });\n        }\n      };\n    }];\n  })\n\n/**\n * A helper directive for the $modal service. It creates a backdrop element.\n */\n  .directive('uibModalBackdrop', ['$animate', '$injector', '$uibModalStack',\n  function($animate, $injector, $modalStack) {\n    return {\n      restrict: 'A',\n      compile: function(tElement, tAttrs) {\n        tElement.addClass(tAttrs.backdropClass);\n        return linkFn;\n      }\n    };\n\n    function linkFn(scope, element, attrs) {\n      if (attrs.modalInClass) {\n        $animate.addClass(element, attrs.modalInClass);\n\n        scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {\n          var done = setIsAsync();\n          if (scope.modalOptions.animation) {\n            $animate.removeClass(element, attrs.modalInClass).then(done);\n          } else {\n            done();\n          }\n        });\n      }\n    }\n  }])\n\n  .directive('uibModalWindow', ['$uibModalStack', '$q', '$animateCss', '$document',\n  function($modalStack, $q, $animateCss, $document) {\n    return {\n      scope: {\n        index: '@'\n      },\n      restrict: 'A',\n      transclude: true,\n      templateUrl: function(tElement, tAttrs) {\n        return tAttrs.templateUrl || 'uib/template/modal/window.html';\n      },\n      link: function(scope, element, attrs) {\n        element.addClass(attrs.windowTopClass || '');\n        scope.size = attrs.size;\n\n        scope.close = function(evt) {\n          var modal = $modalStack.getTop();\n          if (modal && modal.value.backdrop &&\n            modal.value.backdrop !== 'static' &&\n            evt.target === evt.currentTarget) {\n            evt.preventDefault();\n            evt.stopPropagation();\n            $modalStack.dismiss(modal.key, 'backdrop click');\n          }\n        };\n\n        // moved from template to fix issue #2280\n        element.on('click', scope.close);\n\n        // This property is only added to the scope for the purpose of detecting when this directive is rendered.\n        // We can detect that by using this property in the template associated with this directive and then use\n        // {@link Attribute#$observe} on it. For more details please see {@link TableColumnResize}.\n        scope.$isRendered = true;\n\n        // Deferred object that will be resolved when this modal is rendered.\n        var modalRenderDeferObj = $q.defer();\n        // Resolve render promise post-digest\n        scope.$$postDigest(function() {\n          modalRenderDeferObj.resolve();\n        });\n\n        modalRenderDeferObj.promise.then(function() {\n          var animationPromise = null;\n\n          if (attrs.modalInClass) {\n            animationPromise = $animateCss(element, {\n              addClass: attrs.modalInClass\n            }).start();\n\n            scope.$on($modalStack.NOW_CLOSING_EVENT, function(e, setIsAsync) {\n              var done = setIsAsync();\n              $animateCss(element, {\n                removeClass: attrs.modalInClass\n              }).start().then(done);\n            });\n          }\n\n\n          $q.when(animationPromise).then(function() {\n            // Notify {@link $modalStack} that modal is rendered.\n            var modal = $modalStack.getTop();\n            if (modal) {\n              $modalStack.modalRendered(modal.key);\n            }\n\n            /**\n             * If something within the freshly-opened modal already has focus (perhaps via a\n             * directive that causes focus) then there's no need to try to focus anything.\n             */\n            if (!($document[0].activeElement && element[0].contains($document[0].activeElement))) {\n              var inputWithAutofocus = element[0].querySelector('[autofocus]');\n              /**\n               * Auto-focusing of a freshly-opened modal element causes any child elements\n               * with the autofocus attribute to lose focus. This is an issue on touch\n               * based devices which will show and then hide the onscreen keyboard.\n               * Attempts to refocus the autofocus element via JavaScript will not reopen\n               * the onscreen keyboard. Fixed by updated the focusing logic to only autofocus\n               * the modal element if the modal does not contain an autofocus element.\n               */\n              if (inputWithAutofocus) {\n                inputWithAutofocus.focus();\n              } else {\n                element[0].focus();\n              }\n            }\n          });\n        });\n      }\n    };\n  }])\n\n  .directive('uibModalAnimationClass', function() {\n    return {\n      compile: function(tElement, tAttrs) {\n        if (tAttrs.modalAnimation) {\n          tElement.addClass(tAttrs.uibModalAnimationClass);\n        }\n      }\n    };\n  })\n\n  .directive('uibModalTransclude', ['$animate', function($animate) {\n    return {\n      link: function(scope, element, attrs, controller, transclude) {\n        transclude(scope.$parent, function(clone) {\n          element.empty();\n          $animate.enter(clone, element);\n        });\n      }\n    };\n  }])\n\n  .factory('$uibModalStack', ['$animate', '$animateCss', '$document',\n    '$compile', '$rootScope', '$q', '$$multiMap', '$$stackedMap', '$uibPosition',\n    function($animate, $animateCss, $document, $compile, $rootScope, $q, $$multiMap, $$stackedMap, $uibPosition) {\n      var OPENED_MODAL_CLASS = 'modal-open';\n\n      var backdropDomEl, backdropScope;\n      var openedWindows = $$stackedMap.createNew();\n      var openedClasses = $$multiMap.createNew();\n      var $modalStack = {\n        NOW_CLOSING_EVENT: 'modal.stack.now-closing'\n      };\n      var topModalIndex = 0;\n      var previousTopOpenedModal = null;\n      var ARIA_HIDDEN_ATTRIBUTE_NAME = 'data-bootstrap-modal-aria-hidden-count';\n\n      //Modal focus behavior\n      var tabbableSelector = 'a[href], area[href], input:not([disabled]):not([tabindex=\\'-1\\']), ' +\n        'button:not([disabled]):not([tabindex=\\'-1\\']),select:not([disabled]):not([tabindex=\\'-1\\']), textarea:not([disabled]):not([tabindex=\\'-1\\']), ' +\n        'iframe, object, embed, *[tabindex]:not([tabindex=\\'-1\\']), *[contenteditable=true]';\n      var scrollbarPadding;\n      var SNAKE_CASE_REGEXP = /[A-Z]/g;\n\n      // TODO: extract into common dependency with tooltip\n      function snake_case(name) {\n        var separator = '-';\n        return name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {\n          return (pos ? separator : '') + letter.toLowerCase();\n        });\n      }\n\n      function isVisible(element) {\n        return !!(element.offsetWidth ||\n          element.offsetHeight ||\n          element.getClientRects().length);\n      }\n\n      function backdropIndex() {\n        var topBackdropIndex = -1;\n        var opened = openedWindows.keys();\n        for (var i = 0; i < opened.length; i++) {\n          if (openedWindows.get(opened[i]).value.backdrop) {\n            topBackdropIndex = i;\n          }\n        }\n\n        // If any backdrop exist, ensure that it's index is always\n        // right below the top modal\n        if (topBackdropIndex > -1 && topBackdropIndex < topModalIndex) {\n          topBackdropIndex = topModalIndex;\n        }\n        return topBackdropIndex;\n      }\n\n      $rootScope.$watch(backdropIndex, function(newBackdropIndex) {\n        if (backdropScope) {\n          backdropScope.index = newBackdropIndex;\n        }\n      });\n\n      function removeModalWindow(modalInstance, elementToReceiveFocus) {\n        var modalWindow = openedWindows.get(modalInstance).value;\n        var appendToElement = modalWindow.appendTo;\n\n        //clean up the stack\n        openedWindows.remove(modalInstance);\n        previousTopOpenedModal = openedWindows.top();\n        if (previousTopOpenedModal) {\n          topModalIndex = parseInt(previousTopOpenedModal.value.modalDomEl.attr('index'), 10);\n        }\n\n        removeAfterAnimate(modalWindow.modalDomEl, modalWindow.modalScope, function() {\n          var modalBodyClass = modalWindow.openedClass || OPENED_MODAL_CLASS;\n          openedClasses.remove(modalBodyClass, modalInstance);\n          var areAnyOpen = openedClasses.hasKey(modalBodyClass);\n          appendToElement.toggleClass(modalBodyClass, areAnyOpen);\n          if (!areAnyOpen && scrollbarPadding && scrollbarPadding.heightOverflow && scrollbarPadding.scrollbarWidth) {\n            if (scrollbarPadding.originalRight) {\n              appendToElement.css({paddingRight: scrollbarPadding.originalRight + 'px'});\n            } else {\n              appendToElement.css({paddingRight: ''});\n            }\n            scrollbarPadding = null;\n          }\n          toggleTopWindowClass(true);\n        }, modalWindow.closedDeferred);\n        checkRemoveBackdrop();\n\n        //move focus to specified element if available, or else to body\n        if (elementToReceiveFocus && elementToReceiveFocus.focus) {\n          elementToReceiveFocus.focus();\n        } else if (appendToElement.focus) {\n          appendToElement.focus();\n        }\n      }\n\n      // Add or remove \"windowTopClass\" from the top window in the stack\n      function toggleTopWindowClass(toggleSwitch) {\n        var modalWindow;\n\n        if (openedWindows.length() > 0) {\n          modalWindow = openedWindows.top().value;\n          modalWindow.modalDomEl.toggleClass(modalWindow.windowTopClass || '', toggleSwitch);\n        }\n      }\n\n      function checkRemoveBackdrop() {\n        //remove backdrop if no longer needed\n        if (backdropDomEl && backdropIndex() === -1) {\n          var backdropScopeRef = backdropScope;\n          removeAfterAnimate(backdropDomEl, backdropScope, function() {\n            backdropScopeRef = null;\n          });\n          backdropDomEl = undefined;\n          backdropScope = undefined;\n        }\n      }\n\n      function removeAfterAnimate(domEl, scope, done, closedDeferred) {\n        var asyncDeferred;\n        var asyncPromise = null;\n        var setIsAsync = function() {\n          if (!asyncDeferred) {\n            asyncDeferred = $q.defer();\n            asyncPromise = asyncDeferred.promise;\n          }\n\n          return function asyncDone() {\n            asyncDeferred.resolve();\n          };\n        };\n        scope.$broadcast($modalStack.NOW_CLOSING_EVENT, setIsAsync);\n\n        // Note that it's intentional that asyncPromise might be null.\n        // That's when setIsAsync has not been called during the\n        // NOW_CLOSING_EVENT broadcast.\n        return $q.when(asyncPromise).then(afterAnimating);\n\n        function afterAnimating() {\n          if (afterAnimating.done) {\n            return;\n          }\n          afterAnimating.done = true;\n\n          $animate.leave(domEl).then(function() {\n            if (done) {\n              done();\n            }\n\n            domEl.remove();\n            if (closedDeferred) {\n              closedDeferred.resolve();\n            }\n          });\n\n          scope.$destroy();\n        }\n      }\n\n      $document.on('keydown', keydownListener);\n\n      $rootScope.$on('$destroy', function() {\n        $document.off('keydown', keydownListener);\n      });\n\n      function keydownListener(evt) {\n        if (evt.isDefaultPrevented()) {\n          return evt;\n        }\n\n        var modal = openedWindows.top();\n        if (modal) {\n          switch (evt.which) {\n            case 27: {\n              if (modal.value.keyboard) {\n                evt.preventDefault();\n                $rootScope.$apply(function() {\n                  $modalStack.dismiss(modal.key, 'escape key press');\n                });\n              }\n              break;\n            }\n            case 9: {\n              var list = $modalStack.loadFocusElementList(modal);\n              var focusChanged = false;\n              if (evt.shiftKey) {\n                if ($modalStack.isFocusInFirstItem(evt, list) || $modalStack.isModalFocused(evt, modal)) {\n                  focusChanged = $modalStack.focusLastFocusableElement(list);\n                }\n              } else {\n                if ($modalStack.isFocusInLastItem(evt, list)) {\n                  focusChanged = $modalStack.focusFirstFocusableElement(list);\n                }\n              }\n\n              if (focusChanged) {\n                evt.preventDefault();\n                evt.stopPropagation();\n              }\n\n              break;\n            }\n          }\n        }\n      }\n\n      $modalStack.open = function(modalInstance, modal) {\n        var modalOpener = $document[0].activeElement,\n          modalBodyClass = modal.openedClass || OPENED_MODAL_CLASS;\n\n        toggleTopWindowClass(false);\n\n        // Store the current top first, to determine what index we ought to use\n        // for the current top modal\n        previousTopOpenedModal = openedWindows.top();\n\n        openedWindows.add(modalInstance, {\n          deferred: modal.deferred,\n          renderDeferred: modal.renderDeferred,\n          closedDeferred: modal.closedDeferred,\n          modalScope: modal.scope,\n          backdrop: modal.backdrop,\n          keyboard: modal.keyboard,\n          openedClass: modal.openedClass,\n          windowTopClass: modal.windowTopClass,\n          animation: modal.animation,\n          appendTo: modal.appendTo\n        });\n\n        openedClasses.put(modalBodyClass, modalInstance);\n\n        var appendToElement = modal.appendTo,\n            currBackdropIndex = backdropIndex();\n\n        if (currBackdropIndex >= 0 && !backdropDomEl) {\n          backdropScope = $rootScope.$new(true);\n          backdropScope.modalOptions = modal;\n          backdropScope.index = currBackdropIndex;\n          backdropDomEl = angular.element('<div uib-modal-backdrop=\"modal-backdrop\"></div>');\n          backdropDomEl.attr({\n            'class': 'modal-backdrop',\n            'ng-style': '{\\'z-index\\': 1040 + (index && 1 || 0) + index*10}',\n            'uib-modal-animation-class': 'fade',\n            'modal-in-class': 'in'\n          });\n          if (modal.backdropClass) {\n            backdropDomEl.addClass(modal.backdropClass);\n          }\n\n          if (modal.animation) {\n            backdropDomEl.attr('modal-animation', 'true');\n          }\n          $compile(backdropDomEl)(backdropScope);\n          $animate.enter(backdropDomEl, appendToElement);\n          if ($uibPosition.isScrollable(appendToElement)) {\n            scrollbarPadding = $uibPosition.scrollbarPadding(appendToElement);\n            if (scrollbarPadding.heightOverflow && scrollbarPadding.scrollbarWidth) {\n              appendToElement.css({paddingRight: scrollbarPadding.right + 'px'});\n            }\n          }\n        }\n\n        var content;\n        if (modal.component) {\n          content = document.createElement(snake_case(modal.component.name));\n          content = angular.element(content);\n          content.attr({\n            resolve: '$resolve',\n            'modal-instance': '$uibModalInstance',\n            close: '$close($value)',\n            dismiss: '$dismiss($value)'\n          });\n        } else {\n          content = modal.content;\n        }\n\n        // Set the top modal index based on the index of the previous top modal\n        topModalIndex = previousTopOpenedModal ? parseInt(previousTopOpenedModal.value.modalDomEl.attr('index'), 10) + 1 : 0;\n        var angularDomEl = angular.element('<div uib-modal-window=\"modal-window\"></div>');\n        angularDomEl.attr({\n          'class': 'modal',\n          'template-url': modal.windowTemplateUrl,\n          'window-top-class': modal.windowTopClass,\n          'role': 'dialog',\n          'aria-labelledby': modal.ariaLabelledBy,\n          'aria-describedby': modal.ariaDescribedBy,\n          'size': modal.size,\n          'index': topModalIndex,\n          'animate': 'animate',\n          'ng-style': '{\\'z-index\\': 1050 + $$topModalIndex*10, display: \\'block\\'}',\n          'tabindex': -1,\n          'uib-modal-animation-class': 'fade',\n          'modal-in-class': 'in'\n        }).append(content);\n        if (modal.windowClass) {\n          angularDomEl.addClass(modal.windowClass);\n        }\n\n        if (modal.animation) {\n          angularDomEl.attr('modal-animation', 'true');\n        }\n\n        appendToElement.addClass(modalBodyClass);\n        if (modal.scope) {\n          // we need to explicitly add the modal index to the modal scope\n          // because it is needed by ngStyle to compute the zIndex property.\n          modal.scope.$$topModalIndex = topModalIndex;\n        }\n        $animate.enter($compile(angularDomEl)(modal.scope), appendToElement);\n\n        openedWindows.top().value.modalDomEl = angularDomEl;\n        openedWindows.top().value.modalOpener = modalOpener;\n\n        applyAriaHidden(angularDomEl);\n\n        function applyAriaHidden(el) {\n          if (!el || el[0].tagName === 'BODY') {\n            return;\n          }\n\n          getSiblings(el).forEach(function(sibling) {\n            var elemIsAlreadyHidden = sibling.getAttribute('aria-hidden') === 'true',\n              ariaHiddenCount = parseInt(sibling.getAttribute(ARIA_HIDDEN_ATTRIBUTE_NAME), 10);\n\n            if (!ariaHiddenCount) {\n              ariaHiddenCount = elemIsAlreadyHidden ? 1 : 0;\n            }\n\n            sibling.setAttribute(ARIA_HIDDEN_ATTRIBUTE_NAME, ariaHiddenCount + 1);\n            sibling.setAttribute('aria-hidden', 'true');\n          });\n\n          return applyAriaHidden(el.parent());\n\n          function getSiblings(el) {\n            var children = el.parent() ? el.parent().children() : [];\n\n            return Array.prototype.filter.call(children, function(child) {\n              return child !== el[0];\n            });\n          }\n        }\n      };\n\n      function broadcastClosing(modalWindow, resultOrReason, closing) {\n        return !modalWindow.value.modalScope.$broadcast('modal.closing', resultOrReason, closing).defaultPrevented;\n      }\n\n      function unhideBackgroundElements() {\n        Array.prototype.forEach.call(\n          document.querySelectorAll('[' + ARIA_HIDDEN_ATTRIBUTE_NAME + ']'),\n          function(hiddenEl) {\n            var ariaHiddenCount = parseInt(hiddenEl.getAttribute(ARIA_HIDDEN_ATTRIBUTE_NAME), 10),\n              newHiddenCount = ariaHiddenCount - 1;\n            hiddenEl.setAttribute(ARIA_HIDDEN_ATTRIBUTE_NAME, newHiddenCount);\n\n            if (!newHiddenCount) {\n              hiddenEl.removeAttribute(ARIA_HIDDEN_ATTRIBUTE_NAME);\n              hiddenEl.removeAttribute('aria-hidden');\n            }\n          }\n        );\n      }\n\n      $modalStack.close = function(modalInstance, result) {\n        var modalWindow = openedWindows.get(modalInstance);\n        unhideBackgroundElements();\n        if (modalWindow && broadcastClosing(modalWindow, result, true)) {\n          modalWindow.value.modalScope.$$uibDestructionScheduled = true;\n          modalWindow.value.deferred.resolve(result);\n          removeModalWindow(modalInstance, modalWindow.value.modalOpener);\n          return true;\n        }\n\n        return !modalWindow;\n      };\n\n      $modalStack.dismiss = function(modalInstance, reason) {\n        var modalWindow = openedWindows.get(modalInstance);\n        unhideBackgroundElements();\n        if (modalWindow && broadcastClosing(modalWindow, reason, false)) {\n          modalWindow.value.modalScope.$$uibDestructionScheduled = true;\n          modalWindow.value.deferred.reject(reason);\n          removeModalWindow(modalInstance, modalWindow.value.modalOpener);\n          return true;\n        }\n        return !modalWindow;\n      };\n\n      $modalStack.dismissAll = function(reason) {\n        var topModal = this.getTop();\n        while (topModal && this.dismiss(topModal.key, reason)) {\n          topModal = this.getTop();\n        }\n      };\n\n      $modalStack.getTop = function() {\n        return openedWindows.top();\n      };\n\n      $modalStack.modalRendered = function(modalInstance) {\n        var modalWindow = openedWindows.get(modalInstance);\n        if (modalWindow) {\n          modalWindow.value.renderDeferred.resolve();\n        }\n      };\n\n      $modalStack.focusFirstFocusableElement = function(list) {\n        if (list.length > 0) {\n          list[0].focus();\n          return true;\n        }\n        return false;\n      };\n\n      $modalStack.focusLastFocusableElement = function(list) {\n        if (list.length > 0) {\n          list[list.length - 1].focus();\n          return true;\n        }\n        return false;\n      };\n\n      $modalStack.isModalFocused = function(evt, modalWindow) {\n        if (evt && modalWindow) {\n          var modalDomEl = modalWindow.value.modalDomEl;\n          if (modalDomEl && modalDomEl.length) {\n            return (evt.target || evt.srcElement) === modalDomEl[0];\n          }\n        }\n        return false;\n      };\n\n      $modalStack.isFocusInFirstItem = function(evt, list) {\n        if (list.length > 0) {\n          return (evt.target || evt.srcElement) === list[0];\n        }\n        return false;\n      };\n\n      $modalStack.isFocusInLastItem = function(evt, list) {\n        if (list.length > 0) {\n          return (evt.target || evt.srcElement) === list[list.length - 1];\n        }\n        return false;\n      };\n\n      $modalStack.loadFocusElementList = function(modalWindow) {\n        if (modalWindow) {\n          var modalDomE1 = modalWindow.value.modalDomEl;\n          if (modalDomE1 && modalDomE1.length) {\n            var elements = modalDomE1[0].querySelectorAll(tabbableSelector);\n            return elements ?\n              Array.prototype.filter.call(elements, function(element) {\n                return isVisible(element);\n              }) : elements;\n          }\n        }\n      };\n\n      return $modalStack;\n    }])\n\n  .provider('$uibModal', function() {\n    var $modalProvider = {\n      options: {\n        animation: true,\n        backdrop: true, //can also be false or 'static'\n        keyboard: true\n      },\n      $get: ['$rootScope', '$q', '$document', '$templateRequest', '$controller', '$uibResolve', '$uibModalStack',\n        function ($rootScope, $q, $document, $templateRequest, $controller, $uibResolve, $modalStack) {\n          var $modal = {};\n\n          function getTemplatePromise(options) {\n            return options.template ? $q.when(options.template) :\n              $templateRequest(angular.isFunction(options.templateUrl) ?\n                options.templateUrl() : options.templateUrl);\n          }\n\n          var promiseChain = null;\n          $modal.getPromiseChain = function() {\n            return promiseChain;\n          };\n\n          $modal.open = function(modalOptions) {\n            var modalResultDeferred = $q.defer();\n            var modalOpenedDeferred = $q.defer();\n            var modalClosedDeferred = $q.defer();\n            var modalRenderDeferred = $q.defer();\n\n            //prepare an instance of a modal to be injected into controllers and returned to a caller\n            var modalInstance = {\n              result: modalResultDeferred.promise,\n              opened: modalOpenedDeferred.promise,\n              closed: modalClosedDeferred.promise,\n              rendered: modalRenderDeferred.promise,\n              close: function (result) {\n                return $modalStack.close(modalInstance, result);\n              },\n              dismiss: function (reason) {\n                return $modalStack.dismiss(modalInstance, reason);\n              }\n            };\n\n            //merge and clean up options\n            modalOptions = angular.extend({}, $modalProvider.options, modalOptions);\n            modalOptions.resolve = modalOptions.resolve || {};\n            modalOptions.appendTo = modalOptions.appendTo || $document.find('body').eq(0);\n\n            if (!modalOptions.appendTo.length) {\n              throw new Error('appendTo element not found. Make sure that the element passed is in DOM.');\n            }\n\n            //verify options\n            if (!modalOptions.component && !modalOptions.template && !modalOptions.templateUrl) {\n              throw new Error('One of component or template or templateUrl options is required.');\n            }\n\n            var templateAndResolvePromise;\n            if (modalOptions.component) {\n              templateAndResolvePromise = $q.when($uibResolve.resolve(modalOptions.resolve, {}, null, null));\n            } else {\n              templateAndResolvePromise =\n                $q.all([getTemplatePromise(modalOptions), $uibResolve.resolve(modalOptions.resolve, {}, null, null)]);\n            }\n\n            function resolveWithTemplate() {\n              return templateAndResolvePromise;\n            }\n\n            // Wait for the resolution of the existing promise chain.\n            // Then switch to our own combined promise dependency (regardless of how the previous modal fared).\n            // Then add to $modalStack and resolve opened.\n            // Finally clean up the chain variable if no subsequent modal has overwritten it.\n            var samePromise;\n            samePromise = promiseChain = $q.all([promiseChain])\n              .then(resolveWithTemplate, resolveWithTemplate)\n              .then(function resolveSuccess(tplAndVars) {\n                var providedScope = modalOptions.scope || $rootScope;\n\n                var modalScope = providedScope.$new();\n                modalScope.$close = modalInstance.close;\n                modalScope.$dismiss = modalInstance.dismiss;\n\n                modalScope.$on('$destroy', function() {\n                  if (!modalScope.$$uibDestructionScheduled) {\n                    modalScope.$dismiss('$uibUnscheduledDestruction');\n                  }\n                });\n\n                var modal = {\n                  scope: modalScope,\n                  deferred: modalResultDeferred,\n                  renderDeferred: modalRenderDeferred,\n                  closedDeferred: modalClosedDeferred,\n                  animation: modalOptions.animation,\n                  backdrop: modalOptions.backdrop,\n                  keyboard: modalOptions.keyboard,\n                  backdropClass: modalOptions.backdropClass,\n                  windowTopClass: modalOptions.windowTopClass,\n                  windowClass: modalOptions.windowClass,\n                  windowTemplateUrl: modalOptions.windowTemplateUrl,\n                  ariaLabelledBy: modalOptions.ariaLabelledBy,\n                  ariaDescribedBy: modalOptions.ariaDescribedBy,\n                  size: modalOptions.size,\n                  openedClass: modalOptions.openedClass,\n                  appendTo: modalOptions.appendTo\n                };\n\n                var component = {};\n                var ctrlInstance, ctrlInstantiate, ctrlLocals = {};\n\n                if (modalOptions.component) {\n                  constructLocals(component, false, true, false);\n                  component.name = modalOptions.component;\n                  modal.component = component;\n                } else if (modalOptions.controller) {\n                  constructLocals(ctrlLocals, true, false, true);\n\n                  // the third param will make the controller instantiate later,private api\n                  // @see https://github.com/angular/angular.js/blob/master/src/ng/controller.js#L126\n                  ctrlInstantiate = $controller(modalOptions.controller, ctrlLocals, true, modalOptions.controllerAs);\n                  if (modalOptions.controllerAs && modalOptions.bindToController) {\n                    ctrlInstance = ctrlInstantiate.instance;\n                    ctrlInstance.$close = modalScope.$close;\n                    ctrlInstance.$dismiss = modalScope.$dismiss;\n                    angular.extend(ctrlInstance, {\n                      $resolve: ctrlLocals.$scope.$resolve\n                    }, providedScope);\n                  }\n\n                  ctrlInstance = ctrlInstantiate();\n\n                  if (angular.isFunction(ctrlInstance.$onInit)) {\n                    ctrlInstance.$onInit();\n                  }\n                }\n\n                if (!modalOptions.component) {\n                  modal.content = tplAndVars[0];\n                }\n\n                $modalStack.open(modalInstance, modal);\n                modalOpenedDeferred.resolve(true);\n\n                function constructLocals(obj, template, instanceOnScope, injectable) {\n                  obj.$scope = modalScope;\n                  obj.$scope.$resolve = {};\n                  if (instanceOnScope) {\n                    obj.$scope.$uibModalInstance = modalInstance;\n                  } else {\n                    obj.$uibModalInstance = modalInstance;\n                  }\n\n                  var resolves = template ? tplAndVars[1] : tplAndVars;\n                  angular.forEach(resolves, function(value, key) {\n                    if (injectable) {\n                      obj[key] = value;\n                    }\n\n                    obj.$scope.$resolve[key] = value;\n                  });\n                }\n            }, function resolveError(reason) {\n              modalOpenedDeferred.reject(reason);\n              modalResultDeferred.reject(reason);\n            })['finally'](function() {\n              if (promiseChain === samePromise) {\n                promiseChain = null;\n              }\n            });\n\n            return modalInstance;\n          };\n\n          return $modal;\n        }\n      ]\n    };\n\n    return $modalProvider;\n  });\n\nangular.module('ui.bootstrap.paging', [])\n/**\n * Helper internal service for generating common controller code between the\n * pager and pagination components\n */\n.factory('uibPaging', ['$parse', function($parse) {\n  return {\n    create: function(ctrl, $scope, $attrs) {\n      ctrl.setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;\n      ctrl.ngModelCtrl = { $setViewValue: angular.noop }; // nullModelCtrl\n      ctrl._watchers = [];\n\n      ctrl.init = function(ngModelCtrl, config) {\n        ctrl.ngModelCtrl = ngModelCtrl;\n        ctrl.config = config;\n\n        ngModelCtrl.$render = function() {\n          ctrl.render();\n        };\n\n        if ($attrs.itemsPerPage) {\n          ctrl._watchers.push($scope.$parent.$watch($attrs.itemsPerPage, function(value) {\n            ctrl.itemsPerPage = parseInt(value, 10);\n            $scope.totalPages = ctrl.calculateTotalPages();\n            ctrl.updatePage();\n          }));\n        } else {\n          ctrl.itemsPerPage = config.itemsPerPage;\n        }\n\n        $scope.$watch('totalItems', function(newTotal, oldTotal) {\n          if (angular.isDefined(newTotal) || newTotal !== oldTotal) {\n            $scope.totalPages = ctrl.calculateTotalPages();\n            ctrl.updatePage();\n          }\n        });\n      };\n\n      ctrl.calculateTotalPages = function() {\n        var totalPages = ctrl.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / ctrl.itemsPerPage);\n        return Math.max(totalPages || 0, 1);\n      };\n\n      ctrl.render = function() {\n        $scope.page = parseInt(ctrl.ngModelCtrl.$viewValue, 10) || 1;\n      };\n\n      $scope.selectPage = function(page, evt) {\n        if (evt) {\n          evt.preventDefault();\n        }\n\n        var clickAllowed = !$scope.ngDisabled || !evt;\n        if (clickAllowed && $scope.page !== page && page > 0 && page <= $scope.totalPages) {\n          if (evt && evt.target) {\n            evt.target.blur();\n          }\n          ctrl.ngModelCtrl.$setViewValue(page);\n          ctrl.ngModelCtrl.$render();\n        }\n      };\n\n      $scope.getText = function(key) {\n        return $scope[key + 'Text'] || ctrl.config[key + 'Text'];\n      };\n\n      $scope.noPrevious = function() {\n        return $scope.page === 1;\n      };\n\n      $scope.noNext = function() {\n        return $scope.page === $scope.totalPages;\n      };\n\n      ctrl.updatePage = function() {\n        ctrl.setNumPages($scope.$parent, $scope.totalPages); // Readonly variable\n\n        if ($scope.page > $scope.totalPages) {\n          $scope.selectPage($scope.totalPages);\n        } else {\n          ctrl.ngModelCtrl.$render();\n        }\n      };\n\n      $scope.$on('$destroy', function() {\n        while (ctrl._watchers.length) {\n          ctrl._watchers.shift()();\n        }\n      });\n    }\n  };\n}]);\n\nangular.module('ui.bootstrap.pager', ['ui.bootstrap.paging', 'ui.bootstrap.tabindex'])\n\n.controller('UibPagerController', ['$scope', '$attrs', 'uibPaging', 'uibPagerConfig', function($scope, $attrs, uibPaging, uibPagerConfig) {\n  $scope.align = angular.isDefined($attrs.align) ? $scope.$parent.$eval($attrs.align) : uibPagerConfig.align;\n\n  uibPaging.create(this, $scope, $attrs);\n}])\n\n.constant('uibPagerConfig', {\n  itemsPerPage: 10,\n  previousText: '« Previous',\n  nextText: 'Next »',\n  align: true\n})\n\n.directive('uibPager', ['uibPagerConfig', function(uibPagerConfig) {\n  return {\n    scope: {\n      totalItems: '=',\n      previousText: '@',\n      nextText: '@',\n      ngDisabled: '='\n    },\n    require: ['uibPager', '?ngModel'],\n    restrict: 'A',\n    controller: 'UibPagerController',\n    controllerAs: 'pager',\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'uib/template/pager/pager.html';\n    },\n    link: function(scope, element, attrs, ctrls) {\n      element.addClass('pager');\n      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      if (!ngModelCtrl) {\n        return; // do nothing if no ng-model\n      }\n\n      paginationCtrl.init(ngModelCtrl, uibPagerConfig);\n    }\n  };\n}]);\n\nangular.module('ui.bootstrap.pagination', ['ui.bootstrap.paging', 'ui.bootstrap.tabindex'])\n.controller('UibPaginationController', ['$scope', '$attrs', '$parse', 'uibPaging', 'uibPaginationConfig', function($scope, $attrs, $parse, uibPaging, uibPaginationConfig) {\n  var ctrl = this;\n  // Setup configuration parameters\n  var maxSize = angular.isDefined($attrs.maxSize) ? $scope.$parent.$eval($attrs.maxSize) : uibPaginationConfig.maxSize,\n    rotate = angular.isDefined($attrs.rotate) ? $scope.$parent.$eval($attrs.rotate) : uibPaginationConfig.rotate,\n    forceEllipses = angular.isDefined($attrs.forceEllipses) ? $scope.$parent.$eval($attrs.forceEllipses) : uibPaginationConfig.forceEllipses,\n    boundaryLinkNumbers = angular.isDefined($attrs.boundaryLinkNumbers) ? $scope.$parent.$eval($attrs.boundaryLinkNumbers) : uibPaginationConfig.boundaryLinkNumbers,\n    pageLabel = angular.isDefined($attrs.pageLabel) ? function(idx) { return $scope.$parent.$eval($attrs.pageLabel, {$page: idx}); } : angular.identity;\n  $scope.boundaryLinks = angular.isDefined($attrs.boundaryLinks) ? $scope.$parent.$eval($attrs.boundaryLinks) : uibPaginationConfig.boundaryLinks;\n  $scope.directionLinks = angular.isDefined($attrs.directionLinks) ? $scope.$parent.$eval($attrs.directionLinks) : uibPaginationConfig.directionLinks;\n  $attrs.$set('role', 'menu');\n\n  uibPaging.create(this, $scope, $attrs);\n\n  if ($attrs.maxSize) {\n    ctrl._watchers.push($scope.$parent.$watch($parse($attrs.maxSize), function(value) {\n      maxSize = parseInt(value, 10);\n      ctrl.render();\n    }));\n  }\n\n  // Create page object used in template\n  function makePage(number, text, isActive) {\n    return {\n      number: number,\n      text: text,\n      active: isActive\n    };\n  }\n\n  function getPages(currentPage, totalPages) {\n    var pages = [];\n\n    // Default page limits\n    var startPage = 1, endPage = totalPages;\n    var isMaxSized = angular.isDefined(maxSize) && maxSize < totalPages;\n\n    // recompute if maxSize\n    if (isMaxSized) {\n      if (rotate) {\n        // Current page is displayed in the middle of the visible ones\n        startPage = Math.max(currentPage - Math.floor(maxSize / 2), 1);\n        endPage = startPage + maxSize - 1;\n\n        // Adjust if limit is exceeded\n        if (endPage > totalPages) {\n          endPage = totalPages;\n          startPage = endPage - maxSize + 1;\n        }\n      } else {\n        // Visible pages are paginated with maxSize\n        startPage = (Math.ceil(currentPage / maxSize) - 1) * maxSize + 1;\n\n        // Adjust last page if limit is exceeded\n        endPage = Math.min(startPage + maxSize - 1, totalPages);\n      }\n    }\n\n    // Add page number links\n    for (var number = startPage; number <= endPage; number++) {\n      var page = makePage(number, pageLabel(number), number === currentPage);\n      pages.push(page);\n    }\n\n    // Add links to move between page sets\n    if (isMaxSized && maxSize > 0 && (!rotate || forceEllipses || boundaryLinkNumbers)) {\n      if (startPage > 1) {\n        if (!boundaryLinkNumbers || startPage > 3) { //need ellipsis for all options unless range is too close to beginning\n        var previousPageSet = makePage(startPage - 1, '...', false);\n        pages.unshift(previousPageSet);\n      }\n        if (boundaryLinkNumbers) {\n          if (startPage === 3) { //need to replace ellipsis when the buttons would be sequential\n            var secondPageLink = makePage(2, '2', false);\n            pages.unshift(secondPageLink);\n          }\n          //add the first page\n          var firstPageLink = makePage(1, '1', false);\n          pages.unshift(firstPageLink);\n        }\n      }\n\n      if (endPage < totalPages) {\n        if (!boundaryLinkNumbers || endPage < totalPages - 2) { //need ellipsis for all options unless range is too close to end\n        var nextPageSet = makePage(endPage + 1, '...', false);\n        pages.push(nextPageSet);\n      }\n        if (boundaryLinkNumbers) {\n          if (endPage === totalPages - 2) { //need to replace ellipsis when the buttons would be sequential\n            var secondToLastPageLink = makePage(totalPages - 1, totalPages - 1, false);\n            pages.push(secondToLastPageLink);\n          }\n          //add the last page\n          var lastPageLink = makePage(totalPages, totalPages, false);\n          pages.push(lastPageLink);\n        }\n      }\n    }\n    return pages;\n  }\n\n  var originalRender = this.render;\n  this.render = function() {\n    originalRender();\n    if ($scope.page > 0 && $scope.page <= $scope.totalPages) {\n      $scope.pages = getPages($scope.page, $scope.totalPages);\n    }\n  };\n}])\n\n.constant('uibPaginationConfig', {\n  itemsPerPage: 10,\n  boundaryLinks: false,\n  boundaryLinkNumbers: false,\n  directionLinks: true,\n  firstText: 'First',\n  previousText: 'Previous',\n  nextText: 'Next',\n  lastText: 'Last',\n  rotate: true,\n  forceEllipses: false\n})\n\n.directive('uibPagination', ['$parse', 'uibPaginationConfig', function($parse, uibPaginationConfig) {\n  return {\n    scope: {\n      totalItems: '=',\n      firstText: '@',\n      previousText: '@',\n      nextText: '@',\n      lastText: '@',\n      ngDisabled:'='\n    },\n    require: ['uibPagination', '?ngModel'],\n    restrict: 'A',\n    controller: 'UibPaginationController',\n    controllerAs: 'pagination',\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'uib/template/pagination/pagination.html';\n    },\n    link: function(scope, element, attrs, ctrls) {\n      element.addClass('pagination');\n      var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      if (!ngModelCtrl) {\n         return; // do nothing if no ng-model\n      }\n\n      paginationCtrl.init(ngModelCtrl, uibPaginationConfig);\n    }\n  };\n}]);\n\n/**\n * The following features are still outstanding: animation as a\n * function, placement as a function, inside, support for more triggers than\n * just mouse enter/leave, html tooltips, and selector delegation.\n */\nangular.module('ui.bootstrap.tooltip', ['ui.bootstrap.position', 'ui.bootstrap.stackedMap'])\n\n/**\n * The $tooltip service creates tooltip- and popover-like directives as well as\n * houses global options for them.\n */\n.provider('$uibTooltip', function() {\n  // The default options tooltip and popover.\n  var defaultOptions = {\n    placement: 'top',\n    placementClassPrefix: '',\n    animation: true,\n    popupDelay: 0,\n    popupCloseDelay: 0,\n    useContentExp: false\n  };\n\n  // Default hide triggers for each show trigger\n  var triggerMap = {\n    'mouseenter': 'mouseleave',\n    'click': 'click',\n    'outsideClick': 'outsideClick',\n    'focus': 'blur',\n    'none': ''\n  };\n\n  // The options specified to the provider globally.\n  var globalOptions = {};\n\n  /**\n   * `options({})` allows global configuration of all tooltips in the\n   * application.\n   *\n   *   var app = angular.module( 'App', ['ui.bootstrap.tooltip'], function( $tooltipProvider ) {\n   *     // place tooltips left instead of top by default\n   *     $tooltipProvider.options( { placement: 'left' } );\n   *   });\n   */\n\tthis.options = function(value) {\n\t\tangular.extend(globalOptions, value);\n\t};\n\n  /**\n   * This allows you to extend the set of trigger mappings available. E.g.:\n   *\n   *   $tooltipProvider.setTriggers( { 'openTrigger': 'closeTrigger' } );\n   */\n  this.setTriggers = function setTriggers(triggers) {\n    angular.extend(triggerMap, triggers);\n  };\n\n  /**\n   * This is a helper function for translating camel-case to snake_case.\n   */\n  function snake_case(name) {\n    var regexp = /[A-Z]/g;\n    var separator = '-';\n    return name.replace(regexp, function(letter, pos) {\n      return (pos ? separator : '') + letter.toLowerCase();\n    });\n  }\n\n  /**\n   * Returns the actual instance of the $tooltip service.\n   * TODO support multiple triggers\n   */\n  this.$get = ['$window', '$compile', '$timeout', '$document', '$uibPosition', '$interpolate', '$rootScope', '$parse', '$$stackedMap', function($window, $compile, $timeout, $document, $position, $interpolate, $rootScope, $parse, $$stackedMap) {\n    var openedTooltips = $$stackedMap.createNew();\n    $document.on('keyup', keypressListener);\n\n    $rootScope.$on('$destroy', function() {\n      $document.off('keyup', keypressListener);\n    });\n\n    function keypressListener(e) {\n      if (e.which === 27) {\n        var last = openedTooltips.top();\n        if (last) {\n          last.value.close();\n          last = null;\n        }\n      }\n    }\n\n    return function $tooltip(ttType, prefix, defaultTriggerShow, options) {\n      options = angular.extend({}, defaultOptions, globalOptions, options);\n\n      /**\n       * Returns an object of show and hide triggers.\n       *\n       * If a trigger is supplied,\n       * it is used to show the tooltip; otherwise, it will use the `trigger`\n       * option passed to the `$tooltipProvider.options` method; else it will\n       * default to the trigger supplied to this directive factory.\n       *\n       * The hide trigger is based on the show trigger. If the `trigger` option\n       * was passed to the `$tooltipProvider.options` method, it will use the\n       * mapped trigger from `triggerMap` or the passed trigger if the map is\n       * undefined; otherwise, it uses the `triggerMap` value of the show\n       * trigger; else it will just use the show trigger.\n       */\n      function getTriggers(trigger) {\n        var show = (trigger || options.trigger || defaultTriggerShow).split(' ');\n        var hide = show.map(function(trigger) {\n          return triggerMap[trigger] || trigger;\n        });\n        return {\n          show: show,\n          hide: hide\n        };\n      }\n\n      var directiveName = snake_case(ttType);\n\n      var startSym = $interpolate.startSymbol();\n      var endSym = $interpolate.endSymbol();\n      var template =\n        '<div '+ directiveName + '-popup ' +\n          'uib-title=\"' + startSym + 'title' + endSym + '\" ' +\n          (options.useContentExp ?\n            'content-exp=\"contentExp()\" ' :\n            'content=\"' + startSym + 'content' + endSym + '\" ') +\n          'origin-scope=\"origScope\" ' +\n          'class=\"uib-position-measure ' + prefix + '\" ' +\n          'tooltip-animation-class=\"fade\"' +\n          'uib-tooltip-classes ' +\n          'ng-class=\"{ in: isOpen }\" ' +\n          '>' +\n        '</div>';\n\n      return {\n        compile: function(tElem, tAttrs) {\n          var tooltipLinker = $compile(template);\n\n          return function link(scope, element, attrs, tooltipCtrl) {\n            var tooltip;\n            var tooltipLinkedScope;\n            var transitionTimeout;\n            var showTimeout;\n            var hideTimeout;\n            var positionTimeout;\n            var adjustmentTimeout;\n            var appendToBody = angular.isDefined(options.appendToBody) ? options.appendToBody : false;\n            var triggers = getTriggers(undefined);\n            var hasEnableExp = angular.isDefined(attrs[prefix + 'Enable']);\n            var ttScope = scope.$new(true);\n            var repositionScheduled = false;\n            var isOpenParse = angular.isDefined(attrs[prefix + 'IsOpen']) ? $parse(attrs[prefix + 'IsOpen']) : false;\n            var contentParse = options.useContentExp ? $parse(attrs[ttType]) : false;\n            var observers = [];\n            var lastPlacement;\n\n            var positionTooltip = function() {\n              // check if tooltip exists and is not empty\n              if (!tooltip || !tooltip.html()) { return; }\n\n              if (!positionTimeout) {\n                positionTimeout = $timeout(function() {\n                  var ttPosition = $position.positionElements(element, tooltip, ttScope.placement, appendToBody);\n                  var initialHeight = angular.isDefined(tooltip.offsetHeight) ? tooltip.offsetHeight : tooltip.prop('offsetHeight');\n                  var elementPos = appendToBody ? $position.offset(element) : $position.position(element);\n                  tooltip.css({ top: ttPosition.top + 'px', left: ttPosition.left + 'px' });\n                  var placementClasses = ttPosition.placement.split('-');\n\n                  if (!tooltip.hasClass(placementClasses[0])) {\n                    tooltip.removeClass(lastPlacement.split('-')[0]);\n                    tooltip.addClass(placementClasses[0]);\n                  }\n\n                  if (!tooltip.hasClass(options.placementClassPrefix + ttPosition.placement)) {\n                    tooltip.removeClass(options.placementClassPrefix + lastPlacement);\n                    tooltip.addClass(options.placementClassPrefix + ttPosition.placement);\n                  }\n\n                  adjustmentTimeout = $timeout(function() {\n                    var currentHeight = angular.isDefined(tooltip.offsetHeight) ? tooltip.offsetHeight : tooltip.prop('offsetHeight');\n                    var adjustment = $position.adjustTop(placementClasses, elementPos, initialHeight, currentHeight);\n                    if (adjustment) {\n                      tooltip.css(adjustment);\n                    }\n                    adjustmentTimeout = null;\n                  }, 0, false);\n\n                  // first time through tt element will have the\n                  // uib-position-measure class or if the placement\n                  // has changed we need to position the arrow.\n                  if (tooltip.hasClass('uib-position-measure')) {\n                    $position.positionArrow(tooltip, ttPosition.placement);\n                    tooltip.removeClass('uib-position-measure');\n                  } else if (lastPlacement !== ttPosition.placement) {\n                    $position.positionArrow(tooltip, ttPosition.placement);\n                  }\n                  lastPlacement = ttPosition.placement;\n\n                  positionTimeout = null;\n                }, 0, false);\n              }\n            };\n\n            // Set up the correct scope to allow transclusion later\n            ttScope.origScope = scope;\n\n            // By default, the tooltip is not open.\n            // TODO add ability to start tooltip opened\n            ttScope.isOpen = false;\n\n            function toggleTooltipBind() {\n              if (!ttScope.isOpen) {\n                showTooltipBind();\n              } else {\n                hideTooltipBind();\n              }\n            }\n\n            // Show the tooltip with delay if specified, otherwise show it immediately\n            function showTooltipBind() {\n              if (hasEnableExp && !scope.$eval(attrs[prefix + 'Enable'])) {\n                return;\n              }\n\n              cancelHide();\n              prepareTooltip();\n\n              if (ttScope.popupDelay) {\n                // Do nothing if the tooltip was already scheduled to pop-up.\n                // This happens if show is triggered multiple times before any hide is triggered.\n                if (!showTimeout) {\n                  showTimeout = $timeout(show, ttScope.popupDelay, false);\n                }\n              } else {\n                show();\n              }\n            }\n\n            function hideTooltipBind() {\n              cancelShow();\n\n              if (ttScope.popupCloseDelay) {\n                if (!hideTimeout) {\n                  hideTimeout = $timeout(hide, ttScope.popupCloseDelay, false);\n                }\n              } else {\n                hide();\n              }\n            }\n\n            // Show the tooltip popup element.\n            function show() {\n              cancelShow();\n              cancelHide();\n\n              // Don't show empty tooltips.\n              if (!ttScope.content) {\n                return angular.noop;\n              }\n\n              createTooltip();\n\n              // And show the tooltip.\n              ttScope.$evalAsync(function() {\n                ttScope.isOpen = true;\n                assignIsOpen(true);\n                positionTooltip();\n              });\n            }\n\n            function cancelShow() {\n              if (showTimeout) {\n                $timeout.cancel(showTimeout);\n                showTimeout = null;\n              }\n\n              if (positionTimeout) {\n                $timeout.cancel(positionTimeout);\n                positionTimeout = null;\n              }\n            }\n\n            // Hide the tooltip popup element.\n            function hide() {\n              if (!ttScope) {\n                return;\n              }\n\n              // First things first: we don't show it anymore.\n              ttScope.$evalAsync(function() {\n                if (ttScope) {\n                  ttScope.isOpen = false;\n                  assignIsOpen(false);\n                  // And now we remove it from the DOM. However, if we have animation, we\n                  // need to wait for it to expire beforehand.\n                  // FIXME: this is a placeholder for a port of the transitions library.\n                  // The fade transition in TWBS is 150ms.\n                  if (ttScope.animation) {\n                    if (!transitionTimeout) {\n                      transitionTimeout = $timeout(removeTooltip, 150, false);\n                    }\n                  } else {\n                    removeTooltip();\n                  }\n                }\n              });\n            }\n\n            function cancelHide() {\n              if (hideTimeout) {\n                $timeout.cancel(hideTimeout);\n                hideTimeout = null;\n              }\n\n              if (transitionTimeout) {\n                $timeout.cancel(transitionTimeout);\n                transitionTimeout = null;\n              }\n            }\n\n            function createTooltip() {\n              // There can only be one tooltip element per directive shown at once.\n              if (tooltip) {\n                return;\n              }\n\n              tooltipLinkedScope = ttScope.$new();\n              tooltip = tooltipLinker(tooltipLinkedScope, function(tooltip) {\n                if (appendToBody) {\n                  $document.find('body').append(tooltip);\n                } else {\n                  element.after(tooltip);\n                }\n              });\n\n              openedTooltips.add(ttScope, {\n                close: hide\n              });\n\n              prepObservers();\n            }\n\n            function removeTooltip() {\n              cancelShow();\n              cancelHide();\n              unregisterObservers();\n\n              if (tooltip) {\n                tooltip.remove();\n                \n                tooltip = null;\n                if (adjustmentTimeout) {\n                  $timeout.cancel(adjustmentTimeout);\n                }\n              }\n\n              openedTooltips.remove(ttScope);\n              \n              if (tooltipLinkedScope) {\n                tooltipLinkedScope.$destroy();\n                tooltipLinkedScope = null;\n              }\n            }\n\n            /**\n             * Set the initial scope values. Once\n             * the tooltip is created, the observers\n             * will be added to keep things in sync.\n             */\n            function prepareTooltip() {\n              ttScope.title = attrs[prefix + 'Title'];\n              if (contentParse) {\n                ttScope.content = contentParse(scope);\n              } else {\n                ttScope.content = attrs[ttType];\n              }\n\n              ttScope.popupClass = attrs[prefix + 'Class'];\n              ttScope.placement = angular.isDefined(attrs[prefix + 'Placement']) ? attrs[prefix + 'Placement'] : options.placement;\n              var placement = $position.parsePlacement(ttScope.placement);\n              lastPlacement = placement[1] ? placement[0] + '-' + placement[1] : placement[0];\n\n              var delay = parseInt(attrs[prefix + 'PopupDelay'], 10);\n              var closeDelay = parseInt(attrs[prefix + 'PopupCloseDelay'], 10);\n              ttScope.popupDelay = !isNaN(delay) ? delay : options.popupDelay;\n              ttScope.popupCloseDelay = !isNaN(closeDelay) ? closeDelay : options.popupCloseDelay;\n            }\n\n            function assignIsOpen(isOpen) {\n              if (isOpenParse && angular.isFunction(isOpenParse.assign)) {\n                isOpenParse.assign(scope, isOpen);\n              }\n            }\n\n            ttScope.contentExp = function() {\n              return ttScope.content;\n            };\n\n            /**\n             * Observe the relevant attributes.\n             */\n            attrs.$observe('disabled', function(val) {\n              if (val) {\n                cancelShow();\n              }\n\n              if (val && ttScope.isOpen) {\n                hide();\n              }\n            });\n\n            if (isOpenParse) {\n              scope.$watch(isOpenParse, function(val) {\n                if (ttScope && !val === ttScope.isOpen) {\n                  toggleTooltipBind();\n                }\n              });\n            }\n\n            function prepObservers() {\n              observers.length = 0;\n\n              if (contentParse) {\n                observers.push(\n                  scope.$watch(contentParse, function(val) {\n                    ttScope.content = val;\n                    if (!val && ttScope.isOpen) {\n                      hide();\n                    }\n                  })\n                );\n\n                observers.push(\n                  tooltipLinkedScope.$watch(function() {\n                    if (!repositionScheduled) {\n                      repositionScheduled = true;\n                      tooltipLinkedScope.$$postDigest(function() {\n                        repositionScheduled = false;\n                        if (ttScope && ttScope.isOpen) {\n                          positionTooltip();\n                        }\n                      });\n                    }\n                  })\n                );\n              } else {\n                observers.push(\n                  attrs.$observe(ttType, function(val) {\n                    ttScope.content = val;\n                    if (!val && ttScope.isOpen) {\n                      hide();\n                    } else {\n                      positionTooltip();\n                    }\n                  })\n                );\n              }\n\n              observers.push(\n                attrs.$observe(prefix + 'Title', function(val) {\n                  ttScope.title = val;\n                  if (ttScope.isOpen) {\n                    positionTooltip();\n                  }\n                })\n              );\n\n              observers.push(\n                attrs.$observe(prefix + 'Placement', function(val) {\n                  ttScope.placement = val ? val : options.placement;\n                  if (ttScope.isOpen) {\n                    positionTooltip();\n                  }\n                })\n              );\n            }\n\n            function unregisterObservers() {\n              if (observers.length) {\n                angular.forEach(observers, function(observer) {\n                  observer();\n                });\n                observers.length = 0;\n              }\n            }\n\n            // hide tooltips/popovers for outsideClick trigger\n            function bodyHideTooltipBind(e) {\n              if (!ttScope || !ttScope.isOpen || !tooltip) {\n                return;\n              }\n              // make sure the tooltip/popover link or tool tooltip/popover itself were not clicked\n              if (!element[0].contains(e.target) && !tooltip[0].contains(e.target)) {\n                hideTooltipBind();\n              }\n            }\n\n            // KeyboardEvent handler to hide the tooltip on Escape key press\n            function hideOnEscapeKey(e) {\n              if (e.which === 27) {\n                hideTooltipBind();\n              }\n            }\n\n            var unregisterTriggers = function() {\n              triggers.show.forEach(function(trigger) {\n                if (trigger === 'outsideClick') {\n                  element.off('click', toggleTooltipBind);\n                } else {\n                  element.off(trigger, showTooltipBind);\n                  element.off(trigger, toggleTooltipBind);\n                }\n                element.off('keypress', hideOnEscapeKey);\n              });\n              triggers.hide.forEach(function(trigger) {\n                if (trigger === 'outsideClick') {\n                  $document.off('click', bodyHideTooltipBind);\n                } else {\n                  element.off(trigger, hideTooltipBind);\n                }\n              });\n            };\n\n            function prepTriggers() {\n              var showTriggers = [], hideTriggers = [];\n              var val = scope.$eval(attrs[prefix + 'Trigger']);\n              unregisterTriggers();\n\n              if (angular.isObject(val)) {\n                Object.keys(val).forEach(function(key) {\n                  showTriggers.push(key);\n                  hideTriggers.push(val[key]);\n                });\n                triggers = {\n                  show: showTriggers,\n                  hide: hideTriggers\n                };\n              } else {\n                triggers = getTriggers(val);\n              }\n\n              if (triggers.show !== 'none') {\n                triggers.show.forEach(function(trigger, idx) {\n                  if (trigger === 'outsideClick') {\n                    element.on('click', toggleTooltipBind);\n                    $document.on('click', bodyHideTooltipBind);\n                  } else if (trigger === triggers.hide[idx]) {\n                    element.on(trigger, toggleTooltipBind);\n                  } else if (trigger) {\n                    element.on(trigger, showTooltipBind);\n                    element.on(triggers.hide[idx], hideTooltipBind);\n                  }\n                  element.on('keypress', hideOnEscapeKey);\n                });\n              }\n            }\n\n            prepTriggers();\n\n            var animation = scope.$eval(attrs[prefix + 'Animation']);\n            ttScope.animation = angular.isDefined(animation) ? !!animation : options.animation;\n\n            var appendToBodyVal;\n            var appendKey = prefix + 'AppendToBody';\n            if (appendKey in attrs && attrs[appendKey] === undefined) {\n              appendToBodyVal = true;\n            } else {\n              appendToBodyVal = scope.$eval(attrs[appendKey]);\n            }\n\n            appendToBody = angular.isDefined(appendToBodyVal) ? appendToBodyVal : appendToBody;\n\n            // Make sure tooltip is destroyed and removed.\n            scope.$on('$destroy', function onDestroyTooltip() {\n              unregisterTriggers();\n              removeTooltip();\n              ttScope = null;\n            });\n          };\n        }\n      };\n    };\n  }];\n})\n\n// This is mostly ngInclude code but with a custom scope\n.directive('uibTooltipTemplateTransclude', [\n         '$animate', '$sce', '$compile', '$templateRequest',\nfunction ($animate, $sce, $compile, $templateRequest) {\n  return {\n    link: function(scope, elem, attrs) {\n      var origScope = scope.$eval(attrs.tooltipTemplateTranscludeScope);\n\n      var changeCounter = 0,\n        currentScope,\n        previousElement,\n        currentElement;\n\n      var cleanupLastIncludeContent = function() {\n        if (previousElement) {\n          previousElement.remove();\n          previousElement = null;\n        }\n\n        if (currentScope) {\n          currentScope.$destroy();\n          currentScope = null;\n        }\n\n        if (currentElement) {\n          $animate.leave(currentElement).then(function() {\n            previousElement = null;\n          });\n          previousElement = currentElement;\n          currentElement = null;\n        }\n      };\n\n      scope.$watch($sce.parseAsResourceUrl(attrs.uibTooltipTemplateTransclude), function(src) {\n        var thisChangeId = ++changeCounter;\n\n        if (src) {\n          //set the 2nd param to true to ignore the template request error so that the inner\n          //contents and scope can be cleaned up.\n          $templateRequest(src, true).then(function(response) {\n            if (thisChangeId !== changeCounter) { return; }\n            var newScope = origScope.$new();\n            var template = response;\n\n            var clone = $compile(template)(newScope, function(clone) {\n              cleanupLastIncludeContent();\n              $animate.enter(clone, elem);\n            });\n\n            currentScope = newScope;\n            currentElement = clone;\n\n            currentScope.$emit('$includeContentLoaded', src);\n          }, function() {\n            if (thisChangeId === changeCounter) {\n              cleanupLastIncludeContent();\n              scope.$emit('$includeContentError', src);\n            }\n          });\n          scope.$emit('$includeContentRequested', src);\n        } else {\n          cleanupLastIncludeContent();\n        }\n      });\n\n      scope.$on('$destroy', cleanupLastIncludeContent);\n    }\n  };\n}])\n\n/**\n * Note that it's intentional that these classes are *not* applied through $animate.\n * They must not be animated as they're expected to be present on the tooltip on\n * initialization.\n */\n.directive('uibTooltipClasses', ['$uibPosition', function($uibPosition) {\n  return {\n    restrict: 'A',\n    link: function(scope, element, attrs) {\n      // need to set the primary position so the\n      // arrow has space during position measure.\n      // tooltip.positionTooltip()\n      if (scope.placement) {\n        // // There are no top-left etc... classes\n        // // in TWBS, so we need the primary position.\n        var position = $uibPosition.parsePlacement(scope.placement);\n        element.addClass(position[0]);\n      }\n\n      if (scope.popupClass) {\n        element.addClass(scope.popupClass);\n      }\n\n      if (scope.animation) {\n        element.addClass(attrs.tooltipAnimationClass);\n      }\n    }\n  };\n}])\n\n.directive('uibTooltipPopup', function() {\n  return {\n    restrict: 'A',\n    scope: { content: '@' },\n    templateUrl: 'uib/template/tooltip/tooltip-popup.html'\n  };\n})\n\n.directive('uibTooltip', [ '$uibTooltip', function($uibTooltip) {\n  return $uibTooltip('uibTooltip', 'tooltip', 'mouseenter');\n}])\n\n.directive('uibTooltipTemplatePopup', function() {\n  return {\n    restrict: 'A',\n    scope: { contentExp: '&', originScope: '&' },\n    templateUrl: 'uib/template/tooltip/tooltip-template-popup.html'\n  };\n})\n\n.directive('uibTooltipTemplate', ['$uibTooltip', function($uibTooltip) {\n  return $uibTooltip('uibTooltipTemplate', 'tooltip', 'mouseenter', {\n    useContentExp: true\n  });\n}])\n\n.directive('uibTooltipHtmlPopup', function() {\n  return {\n    restrict: 'A',\n    scope: { contentExp: '&' },\n    templateUrl: 'uib/template/tooltip/tooltip-html-popup.html'\n  };\n})\n\n.directive('uibTooltipHtml', ['$uibTooltip', function($uibTooltip) {\n  return $uibTooltip('uibTooltipHtml', 'tooltip', 'mouseenter', {\n    useContentExp: true\n  });\n}]);\n\n/**\n * The following features are still outstanding: popup delay, animation as a\n * function, placement as a function, inside, support for more triggers than\n * just mouse enter/leave, and selector delegatation.\n */\nangular.module('ui.bootstrap.popover', ['ui.bootstrap.tooltip'])\n\n.directive('uibPopoverTemplatePopup', function() {\n  return {\n    restrict: 'A',\n    scope: { uibTitle: '@', contentExp: '&', originScope: '&' },\n    templateUrl: 'uib/template/popover/popover-template.html'\n  };\n})\n\n.directive('uibPopoverTemplate', ['$uibTooltip', function($uibTooltip) {\n  return $uibTooltip('uibPopoverTemplate', 'popover', 'click', {\n    useContentExp: true\n  });\n}])\n\n.directive('uibPopoverHtmlPopup', function() {\n  return {\n    restrict: 'A',\n    scope: { contentExp: '&', uibTitle: '@' },\n    templateUrl: 'uib/template/popover/popover-html.html'\n  };\n})\n\n.directive('uibPopoverHtml', ['$uibTooltip', function($uibTooltip) {\n  return $uibTooltip('uibPopoverHtml', 'popover', 'click', {\n    useContentExp: true\n  });\n}])\n\n.directive('uibPopoverPopup', function() {\n  return {\n    restrict: 'A',\n    scope: { uibTitle: '@', content: '@' },\n    templateUrl: 'uib/template/popover/popover.html'\n  };\n})\n\n.directive('uibPopover', ['$uibTooltip', function($uibTooltip) {\n  return $uibTooltip('uibPopover', 'popover', 'click');\n}]);\n\nangular.module('ui.bootstrap.progressbar', [])\n\n.constant('uibProgressConfig', {\n  animate: true,\n  max: 100\n})\n\n.controller('UibProgressController', ['$scope', '$attrs', 'uibProgressConfig', function($scope, $attrs, progressConfig) {\n  var self = this,\n      animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;\n\n  this.bars = [];\n  $scope.max = getMaxOrDefault();\n\n  this.addBar = function(bar, element, attrs) {\n    if (!animate) {\n      element.css({'transition': 'none'});\n    }\n\n    this.bars.push(bar);\n\n    bar.max = getMaxOrDefault();\n    bar.title = attrs && angular.isDefined(attrs.title) ? attrs.title : 'progressbar';\n\n    bar.$watch('value', function(value) {\n      bar.recalculatePercentage();\n    });\n\n    bar.recalculatePercentage = function() {\n      var totalPercentage = self.bars.reduce(function(total, bar) {\n        bar.percent = +(100 * bar.value / bar.max).toFixed(2);\n        return total + bar.percent;\n      }, 0);\n\n      if (totalPercentage > 100) {\n        bar.percent -= totalPercentage - 100;\n      }\n    };\n\n    bar.$on('$destroy', function() {\n      element = null;\n      self.removeBar(bar);\n    });\n  };\n\n  this.removeBar = function(bar) {\n    this.bars.splice(this.bars.indexOf(bar), 1);\n    this.bars.forEach(function (bar) {\n      bar.recalculatePercentage();\n    });\n  };\n\n  //$attrs.$observe('maxParam', function(maxParam) {\n  $scope.$watch('maxParam', function(maxParam) {\n    self.bars.forEach(function(bar) {\n      bar.max = getMaxOrDefault();\n      bar.recalculatePercentage();\n    });\n  });\n\n  function getMaxOrDefault () {\n    return angular.isDefined($scope.maxParam) ? $scope.maxParam : progressConfig.max;\n  }\n}])\n\n.directive('uibProgress', function() {\n  return {\n    replace: true,\n    transclude: true,\n    controller: 'UibProgressController',\n    require: 'uibProgress',\n    scope: {\n      maxParam: '=?max'\n    },\n    templateUrl: 'uib/template/progressbar/progress.html'\n  };\n})\n\n.directive('uibBar', function() {\n  return {\n    replace: true,\n    transclude: true,\n    require: '^uibProgress',\n    scope: {\n      value: '=',\n      type: '@'\n    },\n    templateUrl: 'uib/template/progressbar/bar.html',\n    link: function(scope, element, attrs, progressCtrl) {\n      progressCtrl.addBar(scope, element, attrs);\n    }\n  };\n})\n\n.directive('uibProgressbar', function() {\n  return {\n    replace: true,\n    transclude: true,\n    controller: 'UibProgressController',\n    scope: {\n      value: '=',\n      maxParam: '=?max',\n      type: '@'\n    },\n    templateUrl: 'uib/template/progressbar/progressbar.html',\n    link: function(scope, element, attrs, progressCtrl) {\n      progressCtrl.addBar(scope, angular.element(element.children()[0]), {title: attrs.title});\n    }\n  };\n});\n\nangular.module('ui.bootstrap.rating', [])\n\n.constant('uibRatingConfig', {\n  max: 5,\n  stateOn: null,\n  stateOff: null,\n  enableReset: true,\n  titles: ['one', 'two', 'three', 'four', 'five']\n})\n\n.controller('UibRatingController', ['$scope', '$attrs', 'uibRatingConfig', function($scope, $attrs, ratingConfig) {\n  var ngModelCtrl = { $setViewValue: angular.noop },\n    self = this;\n\n  this.init = function(ngModelCtrl_) {\n    ngModelCtrl = ngModelCtrl_;\n    ngModelCtrl.$render = this.render;\n\n    ngModelCtrl.$formatters.push(function(value) {\n      if (angular.isNumber(value) && value << 0 !== value) {\n        value = Math.round(value);\n      }\n\n      return value;\n    });\n\n    this.stateOn = angular.isDefined($attrs.stateOn) ? $scope.$parent.$eval($attrs.stateOn) : ratingConfig.stateOn;\n    this.stateOff = angular.isDefined($attrs.stateOff) ? $scope.$parent.$eval($attrs.stateOff) : ratingConfig.stateOff;\n    this.enableReset = angular.isDefined($attrs.enableReset) ?\n      $scope.$parent.$eval($attrs.enableReset) : ratingConfig.enableReset;\n    var tmpTitles = angular.isDefined($attrs.titles) ? $scope.$parent.$eval($attrs.titles) : ratingConfig.titles;\n    this.titles = angular.isArray(tmpTitles) && tmpTitles.length > 0 ?\n      tmpTitles : ratingConfig.titles;\n\n    var ratingStates = angular.isDefined($attrs.ratingStates) ?\n      $scope.$parent.$eval($attrs.ratingStates) :\n      new Array(angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : ratingConfig.max);\n    $scope.range = this.buildTemplateObjects(ratingStates);\n  };\n\n  this.buildTemplateObjects = function(states) {\n    for (var i = 0, n = states.length; i < n; i++) {\n      states[i] = angular.extend({ index: i }, { stateOn: this.stateOn, stateOff: this.stateOff, title: this.getTitle(i) }, states[i]);\n    }\n    return states;\n  };\n\n  this.getTitle = function(index) {\n    if (index >= this.titles.length) {\n      return index + 1;\n    }\n\n    return this.titles[index];\n  };\n\n  $scope.rate = function(value) {\n    if (!$scope.readonly && value >= 0 && value <= $scope.range.length) {\n      var newViewValue = self.enableReset && ngModelCtrl.$viewValue === value ? 0 : value;\n      ngModelCtrl.$setViewValue(newViewValue);\n      ngModelCtrl.$render();\n    }\n  };\n\n  $scope.enter = function(value) {\n    if (!$scope.readonly) {\n      $scope.value = value;\n    }\n    $scope.onHover({value: value});\n  };\n\n  $scope.reset = function() {\n    $scope.value = ngModelCtrl.$viewValue;\n    $scope.onLeave();\n  };\n\n  $scope.onKeydown = function(evt) {\n    if (/(37|38|39|40)/.test(evt.which)) {\n      evt.preventDefault();\n      evt.stopPropagation();\n      $scope.rate($scope.value + (evt.which === 38 || evt.which === 39 ? 1 : -1));\n    }\n  };\n\n  this.render = function() {\n    $scope.value = ngModelCtrl.$viewValue;\n    $scope.title = self.getTitle($scope.value - 1);\n  };\n}])\n\n.directive('uibRating', function() {\n  return {\n    require: ['uibRating', 'ngModel'],\n    restrict: 'A',\n    scope: {\n      readonly: '=?readOnly',\n      onHover: '&',\n      onLeave: '&'\n    },\n    controller: 'UibRatingController',\n    templateUrl: 'uib/template/rating/rating.html',\n    link: function(scope, element, attrs, ctrls) {\n      var ratingCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n      ratingCtrl.init(ngModelCtrl);\n    }\n  };\n});\n\nangular.module('ui.bootstrap.tabs', [])\n\n.controller('UibTabsetController', ['$scope', function ($scope) {\n  var ctrl = this,\n    oldIndex;\n  ctrl.tabs = [];\n\n  ctrl.select = function(index, evt) {\n    if (!destroyed) {\n      var previousIndex = findTabIndex(oldIndex);\n      var previousSelected = ctrl.tabs[previousIndex];\n      if (previousSelected) {\n        previousSelected.tab.onDeselect({\n          $event: evt,\n          $selectedIndex: index\n        });\n        if (evt && evt.isDefaultPrevented()) {\n          return;\n        }\n        previousSelected.tab.active = false;\n      }\n\n      var selected = ctrl.tabs[index];\n      if (selected) {\n        selected.tab.onSelect({\n          $event: evt\n        });\n        selected.tab.active = true;\n        ctrl.active = selected.index;\n        oldIndex = selected.index;\n      } else if (!selected && angular.isDefined(oldIndex)) {\n        ctrl.active = null;\n        oldIndex = null;\n      }\n    }\n  };\n\n  ctrl.addTab = function addTab(tab) {\n    ctrl.tabs.push({\n      tab: tab,\n      index: tab.index\n    });\n    ctrl.tabs.sort(function(t1, t2) {\n      if (t1.index > t2.index) {\n        return 1;\n      }\n\n      if (t1.index < t2.index) {\n        return -1;\n      }\n\n      return 0;\n    });\n\n    if (tab.index === ctrl.active || !angular.isDefined(ctrl.active) && ctrl.tabs.length === 1) {\n      var newActiveIndex = findTabIndex(tab.index);\n      ctrl.select(newActiveIndex);\n    }\n  };\n\n  ctrl.removeTab = function removeTab(tab) {\n    var index;\n    for (var i = 0; i < ctrl.tabs.length; i++) {\n      if (ctrl.tabs[i].tab === tab) {\n        index = i;\n        break;\n      }\n    }\n\n    if (ctrl.tabs[index].index === ctrl.active) {\n      var newActiveTabIndex = index === ctrl.tabs.length - 1 ?\n        index - 1 : index + 1 % ctrl.tabs.length;\n      ctrl.select(newActiveTabIndex);\n    }\n\n    ctrl.tabs.splice(index, 1);\n  };\n\n  $scope.$watch('tabset.active', function(val) {\n    if (angular.isDefined(val) && val !== oldIndex) {\n      ctrl.select(findTabIndex(val));\n    }\n  });\n\n  var destroyed;\n  $scope.$on('$destroy', function() {\n    destroyed = true;\n  });\n\n  function findTabIndex(index) {\n    for (var i = 0; i < ctrl.tabs.length; i++) {\n      if (ctrl.tabs[i].index === index) {\n        return i;\n      }\n    }\n  }\n}])\n\n.directive('uibTabset', function() {\n  return {\n    transclude: true,\n    replace: true,\n    scope: {},\n    bindToController: {\n      active: '=?',\n      type: '@'\n    },\n    controller: 'UibTabsetController',\n    controllerAs: 'tabset',\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'uib/template/tabs/tabset.html';\n    },\n    link: function(scope, element, attrs) {\n      scope.vertical = angular.isDefined(attrs.vertical) ?\n        scope.$parent.$eval(attrs.vertical) : false;\n      scope.justified = angular.isDefined(attrs.justified) ?\n        scope.$parent.$eval(attrs.justified) : false;\n    }\n  };\n})\n\n.directive('uibTab', ['$parse', function($parse) {\n  return {\n    require: '^uibTabset',\n    replace: true,\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || 'uib/template/tabs/tab.html';\n    },\n    transclude: true,\n    scope: {\n      heading: '@',\n      index: '=?',\n      classes: '@?',\n      onSelect: '&select', //This callback is called in contentHeadingTransclude\n                          //once it inserts the tab's content into the dom\n      onDeselect: '&deselect'\n    },\n    controller: function() {\n      //Empty controller so other directives can require being 'under' a tab\n    },\n    controllerAs: 'tab',\n    link: function(scope, elm, attrs, tabsetCtrl, transclude) {\n      scope.disabled = false;\n      if (attrs.disable) {\n        scope.$parent.$watch($parse(attrs.disable), function(value) {\n          scope.disabled = !! value;\n        });\n      }\n\n      if (angular.isUndefined(attrs.index)) {\n        if (tabsetCtrl.tabs && tabsetCtrl.tabs.length) {\n          scope.index = Math.max.apply(null, tabsetCtrl.tabs.map(function(t) { return t.index; })) + 1;\n        } else {\n          scope.index = 0;\n        }\n      }\n\n      if (angular.isUndefined(attrs.classes)) {\n        scope.classes = '';\n      }\n\n      scope.select = function(evt) {\n        if (!scope.disabled) {\n          var index;\n          for (var i = 0; i < tabsetCtrl.tabs.length; i++) {\n            if (tabsetCtrl.tabs[i].tab === scope) {\n              index = i;\n              break;\n            }\n          }\n\n          tabsetCtrl.select(index, evt);\n        }\n      };\n\n      tabsetCtrl.addTab(scope);\n      scope.$on('$destroy', function() {\n        tabsetCtrl.removeTab(scope);\n      });\n\n      //We need to transclude later, once the content container is ready.\n      //when this link happens, we're inside a tab heading.\n      scope.$transcludeFn = transclude;\n    }\n  };\n}])\n\n.directive('uibTabHeadingTransclude', function() {\n  return {\n    restrict: 'A',\n    require: '^uibTab',\n    link: function(scope, elm) {\n      scope.$watch('headingElement', function updateHeadingElement(heading) {\n        if (heading) {\n          elm.html('');\n          elm.append(heading);\n        }\n      });\n    }\n  };\n})\n\n.directive('uibTabContentTransclude', function() {\n  return {\n    restrict: 'A',\n    require: '^uibTabset',\n    link: function(scope, elm, attrs) {\n      var tab = scope.$eval(attrs.uibTabContentTransclude).tab;\n\n      //Now our tab is ready to be transcluded: both the tab heading area\n      //and the tab content area are loaded.  Transclude 'em both.\n      tab.$transcludeFn(tab.$parent, function(contents) {\n        angular.forEach(contents, function(node) {\n          if (isTabHeading(node)) {\n            //Let tabHeadingTransclude know.\n            tab.headingElement = node;\n          } else {\n            elm.append(node);\n          }\n        });\n      });\n    }\n  };\n\n  function isTabHeading(node) {\n    return node.tagName && (\n      node.hasAttribute('uib-tab-heading') ||\n      node.hasAttribute('data-uib-tab-heading') ||\n      node.hasAttribute('x-uib-tab-heading') ||\n      node.tagName.toLowerCase() === 'uib-tab-heading' ||\n      node.tagName.toLowerCase() === 'data-uib-tab-heading' ||\n      node.tagName.toLowerCase() === 'x-uib-tab-heading' ||\n      node.tagName.toLowerCase() === 'uib:tab-heading'\n    );\n  }\n});\n\nangular.module('ui.bootstrap.timepicker', [])\n\n.constant('uibTimepickerConfig', {\n  hourStep: 1,\n  minuteStep: 1,\n  secondStep: 1,\n  showMeridian: true,\n  showSeconds: false,\n  meridians: null,\n  readonlyInput: false,\n  mousewheel: true,\n  arrowkeys: true,\n  showSpinners: true,\n  templateUrl: 'uib/template/timepicker/timepicker.html'\n})\n\n.controller('UibTimepickerController', ['$scope', '$element', '$attrs', '$parse', '$log', '$locale', 'uibTimepickerConfig', function($scope, $element, $attrs, $parse, $log, $locale, timepickerConfig) {\n  var hoursModelCtrl, minutesModelCtrl, secondsModelCtrl;\n  var selected = new Date(),\n    watchers = [],\n    ngModelCtrl = { $setViewValue: angular.noop }, // nullModelCtrl\n    meridians = angular.isDefined($attrs.meridians) ? $scope.$parent.$eval($attrs.meridians) : timepickerConfig.meridians || $locale.DATETIME_FORMATS.AMPMS,\n    padHours = angular.isDefined($attrs.padHours) ? $scope.$parent.$eval($attrs.padHours) : true;\n\n  $scope.tabindex = angular.isDefined($attrs.tabindex) ? $attrs.tabindex : 0;\n  $element.removeAttr('tabindex');\n\n  this.init = function(ngModelCtrl_, inputs) {\n    ngModelCtrl = ngModelCtrl_;\n    ngModelCtrl.$render = this.render;\n\n    ngModelCtrl.$formatters.unshift(function(modelValue) {\n      return modelValue ? new Date(modelValue) : null;\n    });\n\n    var hoursInputEl = inputs.eq(0),\n        minutesInputEl = inputs.eq(1),\n        secondsInputEl = inputs.eq(2);\n\n    hoursModelCtrl = hoursInputEl.controller('ngModel');\n    minutesModelCtrl = minutesInputEl.controller('ngModel');\n    secondsModelCtrl = secondsInputEl.controller('ngModel');\n\n    var mousewheel = angular.isDefined($attrs.mousewheel) ? $scope.$parent.$eval($attrs.mousewheel) : timepickerConfig.mousewheel;\n\n    if (mousewheel) {\n      this.setupMousewheelEvents(hoursInputEl, minutesInputEl, secondsInputEl);\n    }\n\n    var arrowkeys = angular.isDefined($attrs.arrowkeys) ? $scope.$parent.$eval($attrs.arrowkeys) : timepickerConfig.arrowkeys;\n    if (arrowkeys) {\n      this.setupArrowkeyEvents(hoursInputEl, minutesInputEl, secondsInputEl);\n    }\n\n    $scope.readonlyInput = angular.isDefined($attrs.readonlyInput) ? $scope.$parent.$eval($attrs.readonlyInput) : timepickerConfig.readonlyInput;\n    this.setupInputEvents(hoursInputEl, minutesInputEl, secondsInputEl);\n  };\n\n  var hourStep = timepickerConfig.hourStep;\n  if ($attrs.hourStep) {\n    watchers.push($scope.$parent.$watch($parse($attrs.hourStep), function(value) {\n      hourStep = +value;\n    }));\n  }\n\n  var minuteStep = timepickerConfig.minuteStep;\n  if ($attrs.minuteStep) {\n    watchers.push($scope.$parent.$watch($parse($attrs.minuteStep), function(value) {\n      minuteStep = +value;\n    }));\n  }\n\n  var min;\n  watchers.push($scope.$parent.$watch($parse($attrs.min), function(value) {\n    var dt = new Date(value);\n    min = isNaN(dt) ? undefined : dt;\n  }));\n\n  var max;\n  watchers.push($scope.$parent.$watch($parse($attrs.max), function(value) {\n    var dt = new Date(value);\n    max = isNaN(dt) ? undefined : dt;\n  }));\n\n  var disabled = false;\n  if ($attrs.ngDisabled) {\n    watchers.push($scope.$parent.$watch($parse($attrs.ngDisabled), function(value) {\n      disabled = value;\n    }));\n  }\n\n  $scope.noIncrementHours = function() {\n    var incrementedSelected = addMinutes(selected, hourStep * 60);\n    return disabled || incrementedSelected > max ||\n      incrementedSelected < selected && incrementedSelected < min;\n  };\n\n  $scope.noDecrementHours = function() {\n    var decrementedSelected = addMinutes(selected, -hourStep * 60);\n    return disabled || decrementedSelected < min ||\n      decrementedSelected > selected && decrementedSelected > max;\n  };\n\n  $scope.noIncrementMinutes = function() {\n    var incrementedSelected = addMinutes(selected, minuteStep);\n    return disabled || incrementedSelected > max ||\n      incrementedSelected < selected && incrementedSelected < min;\n  };\n\n  $scope.noDecrementMinutes = function() {\n    var decrementedSelected = addMinutes(selected, -minuteStep);\n    return disabled || decrementedSelected < min ||\n      decrementedSelected > selected && decrementedSelected > max;\n  };\n\n  $scope.noIncrementSeconds = function() {\n    var incrementedSelected = addSeconds(selected, secondStep);\n    return disabled || incrementedSelected > max ||\n      incrementedSelected < selected && incrementedSelected < min;\n  };\n\n  $scope.noDecrementSeconds = function() {\n    var decrementedSelected = addSeconds(selected, -secondStep);\n    return disabled || decrementedSelected < min ||\n      decrementedSelected > selected && decrementedSelected > max;\n  };\n\n  $scope.noToggleMeridian = function() {\n    if (selected.getHours() < 12) {\n      return disabled || addMinutes(selected, 12 * 60) > max;\n    }\n\n    return disabled || addMinutes(selected, -12 * 60) < min;\n  };\n\n  var secondStep = timepickerConfig.secondStep;\n  if ($attrs.secondStep) {\n    watchers.push($scope.$parent.$watch($parse($attrs.secondStep), function(value) {\n      secondStep = +value;\n    }));\n  }\n\n  $scope.showSeconds = timepickerConfig.showSeconds;\n  if ($attrs.showSeconds) {\n    watchers.push($scope.$parent.$watch($parse($attrs.showSeconds), function(value) {\n      $scope.showSeconds = !!value;\n    }));\n  }\n\n  // 12H / 24H mode\n  $scope.showMeridian = timepickerConfig.showMeridian;\n  if ($attrs.showMeridian) {\n    watchers.push($scope.$parent.$watch($parse($attrs.showMeridian), function(value) {\n      $scope.showMeridian = !!value;\n\n      if (ngModelCtrl.$error.time) {\n        // Evaluate from template\n        var hours = getHoursFromTemplate(), minutes = getMinutesFromTemplate();\n        if (angular.isDefined(hours) && angular.isDefined(minutes)) {\n          selected.setHours(hours);\n          refresh();\n        }\n      } else {\n        updateTemplate();\n      }\n    }));\n  }\n\n  // Get $scope.hours in 24H mode if valid\n  function getHoursFromTemplate() {\n    var hours = +$scope.hours;\n    var valid = $scope.showMeridian ? hours > 0 && hours < 13 :\n      hours >= 0 && hours < 24;\n    if (!valid || $scope.hours === '') {\n      return undefined;\n    }\n\n    if ($scope.showMeridian) {\n      if (hours === 12) {\n        hours = 0;\n      }\n      if ($scope.meridian === meridians[1]) {\n        hours = hours + 12;\n      }\n    }\n    return hours;\n  }\n\n  function getMinutesFromTemplate() {\n    var minutes = +$scope.minutes;\n    var valid = minutes >= 0 && minutes < 60;\n    if (!valid || $scope.minutes === '') {\n      return undefined;\n    }\n    return minutes;\n  }\n\n  function getSecondsFromTemplate() {\n    var seconds = +$scope.seconds;\n    return seconds >= 0 && seconds < 60 ? seconds : undefined;\n  }\n\n  function pad(value, noPad) {\n    if (value === null) {\n      return '';\n    }\n\n    return angular.isDefined(value) && value.toString().length < 2 && !noPad ?\n      '0' + value : value.toString();\n  }\n\n  // Respond on mousewheel spin\n  this.setupMousewheelEvents = function(hoursInputEl, minutesInputEl, secondsInputEl) {\n    var isScrollingUp = function(e) {\n      if (e.originalEvent) {\n        e = e.originalEvent;\n      }\n      //pick correct delta variable depending on event\n      var delta = e.wheelDelta ? e.wheelDelta : -e.deltaY;\n      return e.detail || delta > 0;\n    };\n\n    hoursInputEl.on('mousewheel wheel', function(e) {\n      if (!disabled) {\n        $scope.$apply(isScrollingUp(e) ? $scope.incrementHours() : $scope.decrementHours());\n      }\n      e.preventDefault();\n    });\n\n    minutesInputEl.on('mousewheel wheel', function(e) {\n      if (!disabled) {\n        $scope.$apply(isScrollingUp(e) ? $scope.incrementMinutes() : $scope.decrementMinutes());\n      }\n      e.preventDefault();\n    });\n\n     secondsInputEl.on('mousewheel wheel', function(e) {\n      if (!disabled) {\n        $scope.$apply(isScrollingUp(e) ? $scope.incrementSeconds() : $scope.decrementSeconds());\n      }\n      e.preventDefault();\n    });\n  };\n\n  // Respond on up/down arrowkeys\n  this.setupArrowkeyEvents = function(hoursInputEl, minutesInputEl, secondsInputEl) {\n    hoursInputEl.on('keydown', function(e) {\n      if (!disabled) {\n        if (e.which === 38) { // up\n          e.preventDefault();\n          $scope.incrementHours();\n          $scope.$apply();\n        } else if (e.which === 40) { // down\n          e.preventDefault();\n          $scope.decrementHours();\n          $scope.$apply();\n        }\n      }\n    });\n\n    minutesInputEl.on('keydown', function(e) {\n      if (!disabled) {\n        if (e.which === 38) { // up\n          e.preventDefault();\n          $scope.incrementMinutes();\n          $scope.$apply();\n        } else if (e.which === 40) { // down\n          e.preventDefault();\n          $scope.decrementMinutes();\n          $scope.$apply();\n        }\n      }\n    });\n\n    secondsInputEl.on('keydown', function(e) {\n      if (!disabled) {\n        if (e.which === 38) { // up\n          e.preventDefault();\n          $scope.incrementSeconds();\n          $scope.$apply();\n        } else if (e.which === 40) { // down\n          e.preventDefault();\n          $scope.decrementSeconds();\n          $scope.$apply();\n        }\n      }\n    });\n  };\n\n  this.setupInputEvents = function(hoursInputEl, minutesInputEl, secondsInputEl) {\n    if ($scope.readonlyInput) {\n      $scope.updateHours = angular.noop;\n      $scope.updateMinutes = angular.noop;\n      $scope.updateSeconds = angular.noop;\n      return;\n    }\n\n    var invalidate = function(invalidHours, invalidMinutes, invalidSeconds) {\n      ngModelCtrl.$setViewValue(null);\n      ngModelCtrl.$setValidity('time', false);\n      if (angular.isDefined(invalidHours)) {\n        $scope.invalidHours = invalidHours;\n        if (hoursModelCtrl) {\n          hoursModelCtrl.$setValidity('hours', false);\n        }\n      }\n\n      if (angular.isDefined(invalidMinutes)) {\n        $scope.invalidMinutes = invalidMinutes;\n        if (minutesModelCtrl) {\n          minutesModelCtrl.$setValidity('minutes', false);\n        }\n      }\n\n      if (angular.isDefined(invalidSeconds)) {\n        $scope.invalidSeconds = invalidSeconds;\n        if (secondsModelCtrl) {\n          secondsModelCtrl.$setValidity('seconds', false);\n        }\n      }\n    };\n\n    $scope.updateHours = function() {\n      var hours = getHoursFromTemplate(),\n        minutes = getMinutesFromTemplate();\n\n      ngModelCtrl.$setDirty();\n\n      if (angular.isDefined(hours) && angular.isDefined(minutes)) {\n        selected.setHours(hours);\n        selected.setMinutes(minutes);\n        if (selected < min || selected > max) {\n          invalidate(true);\n        } else {\n          refresh('h');\n        }\n      } else {\n        invalidate(true);\n      }\n    };\n\n    hoursInputEl.on('blur', function(e) {\n      ngModelCtrl.$setTouched();\n      if (modelIsEmpty()) {\n        makeValid();\n      } else if ($scope.hours === null || $scope.hours === '') {\n        invalidate(true);\n      } else if (!$scope.invalidHours && $scope.hours < 10) {\n        $scope.$apply(function() {\n          $scope.hours = pad($scope.hours, !padHours);\n        });\n      }\n    });\n\n    $scope.updateMinutes = function() {\n      var minutes = getMinutesFromTemplate(),\n        hours = getHoursFromTemplate();\n\n      ngModelCtrl.$setDirty();\n\n      if (angular.isDefined(minutes) && angular.isDefined(hours)) {\n        selected.setHours(hours);\n        selected.setMinutes(minutes);\n        if (selected < min || selected > max) {\n          invalidate(undefined, true);\n        } else {\n          refresh('m');\n        }\n      } else {\n        invalidate(undefined, true);\n      }\n    };\n\n    minutesInputEl.on('blur', function(e) {\n      ngModelCtrl.$setTouched();\n      if (modelIsEmpty()) {\n        makeValid();\n      } else if ($scope.minutes === null) {\n        invalidate(undefined, true);\n      } else if (!$scope.invalidMinutes && $scope.minutes < 10) {\n        $scope.$apply(function() {\n          $scope.minutes = pad($scope.minutes);\n        });\n      }\n    });\n\n    $scope.updateSeconds = function() {\n      var seconds = getSecondsFromTemplate();\n\n      ngModelCtrl.$setDirty();\n\n      if (angular.isDefined(seconds)) {\n        selected.setSeconds(seconds);\n        refresh('s');\n      } else {\n        invalidate(undefined, undefined, true);\n      }\n    };\n\n    secondsInputEl.on('blur', function(e) {\n      if (modelIsEmpty()) {\n        makeValid();\n      } else if (!$scope.invalidSeconds && $scope.seconds < 10) {\n        $scope.$apply( function() {\n          $scope.seconds = pad($scope.seconds);\n        });\n      }\n    });\n\n  };\n\n  this.render = function() {\n    var date = ngModelCtrl.$viewValue;\n\n    if (isNaN(date)) {\n      ngModelCtrl.$setValidity('time', false);\n      $log.error('Timepicker directive: \"ng-model\" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');\n    } else {\n      if (date) {\n        selected = date;\n      }\n\n      if (selected < min || selected > max) {\n        ngModelCtrl.$setValidity('time', false);\n        $scope.invalidHours = true;\n        $scope.invalidMinutes = true;\n      } else {\n        makeValid();\n      }\n      updateTemplate();\n    }\n  };\n\n  // Call internally when we know that model is valid.\n  function refresh(keyboardChange) {\n    makeValid();\n    ngModelCtrl.$setViewValue(new Date(selected));\n    updateTemplate(keyboardChange);\n  }\n\n  function makeValid() {\n    if (hoursModelCtrl) {\n      hoursModelCtrl.$setValidity('hours', true);\n    }\n\n    if (minutesModelCtrl) {\n      minutesModelCtrl.$setValidity('minutes', true);\n    }\n\n    if (secondsModelCtrl) {\n      secondsModelCtrl.$setValidity('seconds', true);\n    }\n\n    ngModelCtrl.$setValidity('time', true);\n    $scope.invalidHours = false;\n    $scope.invalidMinutes = false;\n    $scope.invalidSeconds = false;\n  }\n\n  function updateTemplate(keyboardChange) {\n    if (!ngModelCtrl.$modelValue) {\n      $scope.hours = null;\n      $scope.minutes = null;\n      $scope.seconds = null;\n      $scope.meridian = meridians[0];\n    } else {\n      var hours = selected.getHours(),\n        minutes = selected.getMinutes(),\n        seconds = selected.getSeconds();\n\n      if ($scope.showMeridian) {\n        hours = hours === 0 || hours === 12 ? 12 : hours % 12; // Convert 24 to 12 hour system\n      }\n\n      $scope.hours = keyboardChange === 'h' ? hours : pad(hours, !padHours);\n      if (keyboardChange !== 'm') {\n        $scope.minutes = pad(minutes);\n      }\n      $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];\n\n      if (keyboardChange !== 's') {\n        $scope.seconds = pad(seconds);\n      }\n      $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];\n    }\n  }\n\n  function addSecondsToSelected(seconds) {\n    selected = addSeconds(selected, seconds);\n    refresh();\n  }\n\n  function addMinutes(selected, minutes) {\n    return addSeconds(selected, minutes*60);\n  }\n\n  function addSeconds(date, seconds) {\n    var dt = new Date(date.getTime() + seconds * 1000);\n    var newDate = new Date(date);\n    newDate.setHours(dt.getHours(), dt.getMinutes(), dt.getSeconds());\n    return newDate;\n  }\n\n  function modelIsEmpty() {\n    return ($scope.hours === null || $scope.hours === '') &&\n      ($scope.minutes === null || $scope.minutes === '') &&\n      (!$scope.showSeconds || $scope.showSeconds && ($scope.seconds === null || $scope.seconds === ''));\n  }\n\n  $scope.showSpinners = angular.isDefined($attrs.showSpinners) ?\n    $scope.$parent.$eval($attrs.showSpinners) : timepickerConfig.showSpinners;\n\n  $scope.incrementHours = function() {\n    if (!$scope.noIncrementHours()) {\n      addSecondsToSelected(hourStep * 60 * 60);\n    }\n  };\n\n  $scope.decrementHours = function() {\n    if (!$scope.noDecrementHours()) {\n      addSecondsToSelected(-hourStep * 60 * 60);\n    }\n  };\n\n  $scope.incrementMinutes = function() {\n    if (!$scope.noIncrementMinutes()) {\n      addSecondsToSelected(minuteStep * 60);\n    }\n  };\n\n  $scope.decrementMinutes = function() {\n    if (!$scope.noDecrementMinutes()) {\n      addSecondsToSelected(-minuteStep * 60);\n    }\n  };\n\n  $scope.incrementSeconds = function() {\n    if (!$scope.noIncrementSeconds()) {\n      addSecondsToSelected(secondStep);\n    }\n  };\n\n  $scope.decrementSeconds = function() {\n    if (!$scope.noDecrementSeconds()) {\n      addSecondsToSelected(-secondStep);\n    }\n  };\n\n  $scope.toggleMeridian = function() {\n    var minutes = getMinutesFromTemplate(),\n        hours = getHoursFromTemplate();\n\n    if (!$scope.noToggleMeridian()) {\n      if (angular.isDefined(minutes) && angular.isDefined(hours)) {\n        addSecondsToSelected(12 * 60 * (selected.getHours() < 12 ? 60 : -60));\n      } else {\n        $scope.meridian = $scope.meridian === meridians[0] ? meridians[1] : meridians[0];\n      }\n    }\n  };\n\n  $scope.blur = function() {\n    ngModelCtrl.$setTouched();\n  };\n\n  $scope.$on('$destroy', function() {\n    while (watchers.length) {\n      watchers.shift()();\n    }\n  });\n}])\n\n.directive('uibTimepicker', ['uibTimepickerConfig', function(uibTimepickerConfig) {\n  return {\n    require: ['uibTimepicker', '?^ngModel'],\n    restrict: 'A',\n    controller: 'UibTimepickerController',\n    controllerAs: 'timepicker',\n    scope: {},\n    templateUrl: function(element, attrs) {\n      return attrs.templateUrl || uibTimepickerConfig.templateUrl;\n    },\n    link: function(scope, element, attrs, ctrls) {\n      var timepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];\n\n      if (ngModelCtrl) {\n        timepickerCtrl.init(ngModelCtrl, element.find('input'));\n      }\n    }\n  };\n}]);\n\nangular.module('ui.bootstrap.typeahead', ['ui.bootstrap.debounce', 'ui.bootstrap.position'])\n\n/**\n * A helper service that can parse typeahead's syntax (string provided by users)\n * Extracted to a separate service for ease of unit testing\n */\n  .factory('uibTypeaheadParser', ['$parse', function($parse) {\n    //                      000001111111100000000000002222222200000000000000003333333333333330000000000044444444000\n    var TYPEAHEAD_REGEXP = /^\\s*([\\s\\S]+?)(?:\\s+as\\s+([\\s\\S]+?))?\\s+for\\s+(?:([\\$\\w][\\$\\w\\d]*))\\s+in\\s+([\\s\\S]+?)$/;\n    return {\n      parse: function(input) {\n        var match = input.match(TYPEAHEAD_REGEXP);\n        if (!match) {\n          throw new Error(\n            'Expected typeahead specification in form of \"_modelValue_ (as _label_)? for _item_ in _collection_\"' +\n              ' but got \"' + input + '\".');\n        }\n\n        return {\n          itemName: match[3],\n          source: $parse(match[4]),\n          viewMapper: $parse(match[2] || match[1]),\n          modelMapper: $parse(match[1])\n        };\n      }\n    };\n  }])\n\n  .controller('UibTypeaheadController', ['$scope', '$element', '$attrs', '$compile', '$parse', '$q', '$timeout', '$document', '$window', '$rootScope', '$$debounce', '$uibPosition', 'uibTypeaheadParser',\n    function(originalScope, element, attrs, $compile, $parse, $q, $timeout, $document, $window, $rootScope, $$debounce, $position, typeaheadParser) {\n    var HOT_KEYS = [9, 13, 27, 38, 40];\n    var eventDebounceTime = 200;\n    var modelCtrl, ngModelOptions;\n    //SUPPORTED ATTRIBUTES (OPTIONS)\n\n    //minimal no of characters that needs to be entered before typeahead kicks-in\n    var minLength = originalScope.$eval(attrs.typeaheadMinLength);\n    if (!minLength && minLength !== 0) {\n      minLength = 1;\n    }\n\n    originalScope.$watch(attrs.typeaheadMinLength, function (newVal) {\n        minLength = !newVal && newVal !== 0 ? 1 : newVal;\n    });\n\n    //minimal wait time after last character typed before typeahead kicks-in\n    var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;\n\n    //should it restrict model values to the ones selected from the popup only?\n    var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;\n    originalScope.$watch(attrs.typeaheadEditable, function (newVal) {\n      isEditable = newVal !== false;\n    });\n\n    //binding to a variable that indicates if matches are being retrieved asynchronously\n    var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;\n\n    //a function to determine if an event should cause selection\n    var isSelectEvent = attrs.typeaheadShouldSelect ? $parse(attrs.typeaheadShouldSelect) : function(scope, vals) {\n      var evt = vals.$event;\n      return evt.which === 13 || evt.which === 9;\n    };\n\n    //a callback executed when a match is selected\n    var onSelectCallback = $parse(attrs.typeaheadOnSelect);\n\n    //should it select highlighted popup value when losing focus?\n    var isSelectOnBlur = angular.isDefined(attrs.typeaheadSelectOnBlur) ? originalScope.$eval(attrs.typeaheadSelectOnBlur) : false;\n\n    //binding to a variable that indicates if there were no results after the query is completed\n    var isNoResultsSetter = $parse(attrs.typeaheadNoResults).assign || angular.noop;\n\n    var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;\n\n    var appendToBody = attrs.typeaheadAppendToBody ? originalScope.$eval(attrs.typeaheadAppendToBody) : false;\n\n    var appendTo = attrs.typeaheadAppendTo ?\n      originalScope.$eval(attrs.typeaheadAppendTo) : null;\n\n    var focusFirst = originalScope.$eval(attrs.typeaheadFocusFirst) !== false;\n\n    //If input matches an item of the list exactly, select it automatically\n    var selectOnExact = attrs.typeaheadSelectOnExact ? originalScope.$eval(attrs.typeaheadSelectOnExact) : false;\n\n    //binding to a variable that indicates if dropdown is open\n    var isOpenSetter = $parse(attrs.typeaheadIsOpen).assign || angular.noop;\n\n    var showHint = originalScope.$eval(attrs.typeaheadShowHint) || false;\n\n    //INTERNAL VARIABLES\n\n    //model setter executed upon match selection\n    var parsedModel = $parse(attrs.ngModel);\n    var invokeModelSetter = $parse(attrs.ngModel + '($$$p)');\n    var $setModelValue = function(scope, newValue) {\n      if (angular.isFunction(parsedModel(originalScope)) &&\n        ngModelOptions.getOption('getterSetter')) {\n        return invokeModelSetter(scope, {$$$p: newValue});\n      }\n\n      return parsedModel.assign(scope, newValue);\n    };\n\n    //expressions used by typeahead\n    var parserResult = typeaheadParser.parse(attrs.uibTypeahead);\n\n    var hasFocus;\n\n    //Used to avoid bug in iOS webview where iOS keyboard does not fire\n    //mousedown & mouseup events\n    //Issue #3699\n    var selected;\n\n    //create a child scope for the typeahead directive so we are not polluting original scope\n    //with typeahead-specific data (matches, query etc.)\n    var scope = originalScope.$new();\n    var offDestroy = originalScope.$on('$destroy', function() {\n      scope.$destroy();\n    });\n    scope.$on('$destroy', offDestroy);\n\n    // WAI-ARIA\n    var popupId = 'typeahead-' + scope.$id + '-' + Math.floor(Math.random() * 10000);\n    element.attr({\n      'aria-autocomplete': 'list',\n      'aria-expanded': false,\n      'aria-owns': popupId\n    });\n\n    var inputsContainer, hintInputElem;\n    //add read-only input to show hint\n    if (showHint) {\n      inputsContainer = angular.element('<div></div>');\n      inputsContainer.css('position', 'relative');\n      element.after(inputsContainer);\n      hintInputElem = element.clone();\n      hintInputElem.attr('placeholder', '');\n      hintInputElem.attr('tabindex', '-1');\n      hintInputElem.val('');\n      hintInputElem.css({\n        'position': 'absolute',\n        'top': '0px',\n        'left': '0px',\n        'border-color': 'transparent',\n        'box-shadow': 'none',\n        'opacity': 1,\n        'background': 'none 0% 0% / auto repeat scroll padding-box border-box rgb(255, 255, 255)',\n        'color': '#999'\n      });\n      element.css({\n        'position': 'relative',\n        'vertical-align': 'top',\n        'background-color': 'transparent'\n      });\n\n      if (hintInputElem.attr('id')) {\n        hintInputElem.removeAttr('id'); // remove duplicate id if present.\n      }\n      inputsContainer.append(hintInputElem);\n      hintInputElem.after(element);\n    }\n\n    //pop-up element used to display matches\n    var popUpEl = angular.element('<div uib-typeahead-popup></div>');\n    popUpEl.attr({\n      id: popupId,\n      matches: 'matches',\n      active: 'activeIdx',\n      select: 'select(activeIdx, evt)',\n      'move-in-progress': 'moveInProgress',\n      query: 'query',\n      position: 'position',\n      'assign-is-open': 'assignIsOpen(isOpen)',\n      debounce: 'debounceUpdate'\n    });\n    //custom item template\n    if (angular.isDefined(attrs.typeaheadTemplateUrl)) {\n      popUpEl.attr('template-url', attrs.typeaheadTemplateUrl);\n    }\n\n    if (angular.isDefined(attrs.typeaheadPopupTemplateUrl)) {\n      popUpEl.attr('popup-template-url', attrs.typeaheadPopupTemplateUrl);\n    }\n\n    var resetHint = function() {\n      if (showHint) {\n        hintInputElem.val('');\n      }\n    };\n\n    var resetMatches = function() {\n      scope.matches = [];\n      scope.activeIdx = -1;\n      element.attr('aria-expanded', false);\n      resetHint();\n    };\n\n    var getMatchId = function(index) {\n      return popupId + '-option-' + index;\n    };\n\n    // Indicate that the specified match is the active (pre-selected) item in the list owned by this typeahead.\n    // This attribute is added or removed automatically when the `activeIdx` changes.\n    scope.$watch('activeIdx', function(index) {\n      if (index < 0) {\n        element.removeAttr('aria-activedescendant');\n      } else {\n        element.attr('aria-activedescendant', getMatchId(index));\n      }\n    });\n\n    var inputIsExactMatch = function(inputValue, index) {\n      if (scope.matches.length > index && inputValue) {\n        return inputValue.toUpperCase() === scope.matches[index].label.toUpperCase();\n      }\n\n      return false;\n    };\n\n    var getMatchesAsync = function(inputValue, evt) {\n      var locals = {$viewValue: inputValue};\n      isLoadingSetter(originalScope, true);\n      isNoResultsSetter(originalScope, false);\n      $q.when(parserResult.source(originalScope, locals)).then(function(matches) {\n        //it might happen that several async queries were in progress if a user were typing fast\n        //but we are interested only in responses that correspond to the current view value\n        var onCurrentRequest = inputValue === modelCtrl.$viewValue;\n        if (onCurrentRequest && hasFocus) {\n          if (matches && matches.length > 0) {\n            scope.activeIdx = focusFirst ? 0 : -1;\n            isNoResultsSetter(originalScope, false);\n            scope.matches.length = 0;\n\n            //transform labels\n            for (var i = 0; i < matches.length; i++) {\n              locals[parserResult.itemName] = matches[i];\n              scope.matches.push({\n                id: getMatchId(i),\n                label: parserResult.viewMapper(scope, locals),\n                model: matches[i]\n              });\n            }\n\n            scope.query = inputValue;\n            //position pop-up with matches - we need to re-calculate its position each time we are opening a window\n            //with matches as a pop-up might be absolute-positioned and position of an input might have changed on a page\n            //due to other elements being rendered\n            recalculatePosition();\n\n            element.attr('aria-expanded', true);\n\n            //Select the single remaining option if user input matches\n            if (selectOnExact && scope.matches.length === 1 && inputIsExactMatch(inputValue, 0)) {\n              if (angular.isNumber(scope.debounceUpdate) || angular.isObject(scope.debounceUpdate)) {\n                $$debounce(function() {\n                  scope.select(0, evt);\n                }, angular.isNumber(scope.debounceUpdate) ? scope.debounceUpdate : scope.debounceUpdate['default']);\n              } else {\n                scope.select(0, evt);\n              }\n            }\n\n            if (showHint) {\n              var firstLabel = scope.matches[0].label;\n              if (angular.isString(inputValue) &&\n                inputValue.length > 0 &&\n                firstLabel.slice(0, inputValue.length).toUpperCase() === inputValue.toUpperCase()) {\n                hintInputElem.val(inputValue + firstLabel.slice(inputValue.length));\n              } else {\n                hintInputElem.val('');\n              }\n            }\n          } else {\n            resetMatches();\n            isNoResultsSetter(originalScope, true);\n          }\n        }\n        if (onCurrentRequest) {\n          isLoadingSetter(originalScope, false);\n        }\n      }, function() {\n        resetMatches();\n        isLoadingSetter(originalScope, false);\n        isNoResultsSetter(originalScope, true);\n      });\n    };\n\n    // bind events only if appendToBody params exist - performance feature\n    if (appendToBody) {\n      angular.element($window).on('resize', fireRecalculating);\n      $document.find('body').on('scroll', fireRecalculating);\n    }\n\n    // Declare the debounced function outside recalculating for\n    // proper debouncing\n    var debouncedRecalculate = $$debounce(function() {\n      // if popup is visible\n      if (scope.matches.length) {\n        recalculatePosition();\n      }\n\n      scope.moveInProgress = false;\n    }, eventDebounceTime);\n\n    // Default progress type\n    scope.moveInProgress = false;\n\n    function fireRecalculating() {\n      if (!scope.moveInProgress) {\n        scope.moveInProgress = true;\n        scope.$digest();\n      }\n\n      debouncedRecalculate();\n    }\n\n    // recalculate actual position and set new values to scope\n    // after digest loop is popup in right position\n    function recalculatePosition() {\n      scope.position = appendToBody ? $position.offset(element) : $position.position(element);\n      scope.position.top += element.prop('offsetHeight');\n    }\n\n    //we need to propagate user's query so we can higlight matches\n    scope.query = undefined;\n\n    //Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later\n    var timeoutPromise;\n\n    var scheduleSearchWithTimeout = function(inputValue) {\n      timeoutPromise = $timeout(function() {\n        getMatchesAsync(inputValue);\n      }, waitTime);\n    };\n\n    var cancelPreviousTimeout = function() {\n      if (timeoutPromise) {\n        $timeout.cancel(timeoutPromise);\n      }\n    };\n\n    resetMatches();\n\n    scope.assignIsOpen = function (isOpen) {\n      isOpenSetter(originalScope, isOpen);\n    };\n\n    scope.select = function(activeIdx, evt) {\n      //called from within the $digest() cycle\n      var locals = {};\n      var model, item;\n\n      selected = true;\n      locals[parserResult.itemName] = item = scope.matches[activeIdx].model;\n      model = parserResult.modelMapper(originalScope, locals);\n      $setModelValue(originalScope, model);\n      modelCtrl.$setValidity('editable', true);\n      modelCtrl.$setValidity('parse', true);\n\n      onSelectCallback(originalScope, {\n        $item: item,\n        $model: model,\n        $label: parserResult.viewMapper(originalScope, locals),\n        $event: evt\n      });\n\n      resetMatches();\n\n      //return focus to the input element if a match was selected via a mouse click event\n      // use timeout to avoid $rootScope:inprog error\n      if (scope.$eval(attrs.typeaheadFocusOnSelect) !== false) {\n        $timeout(function() { element[0].focus(); }, 0, false);\n      }\n    };\n\n    //bind keyboard events: arrows up(38) / down(40), enter(13) and tab(9), esc(27)\n    element.on('keydown', function(evt) {\n      //typeahead is open and an \"interesting\" key was pressed\n      if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {\n        return;\n      }\n\n      var shouldSelect = isSelectEvent(originalScope, {$event: evt});\n\n      /**\n       * if there's nothing selected (i.e. focusFirst) and enter or tab is hit\n       * or\n       * shift + tab is pressed to bring focus to the previous element\n       * then clear the results\n       */\n      if (scope.activeIdx === -1 && shouldSelect || evt.which === 9 && !!evt.shiftKey) {\n        resetMatches();\n        scope.$digest();\n        return;\n      }\n\n      evt.preventDefault();\n      var target;\n      switch (evt.which) {\n        case 27: // escape\n          evt.stopPropagation();\n\n          resetMatches();\n          originalScope.$digest();\n          break;\n        case 38: // up arrow\n          scope.activeIdx = (scope.activeIdx > 0 ? scope.activeIdx : scope.matches.length) - 1;\n          scope.$digest();\n          target = popUpEl[0].querySelectorAll('.uib-typeahead-match')[scope.activeIdx];\n          target.parentNode.scrollTop = target.offsetTop;\n          break;\n        case 40: // down arrow\n          scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;\n          scope.$digest();\n          target = popUpEl[0].querySelectorAll('.uib-typeahead-match')[scope.activeIdx];\n          target.parentNode.scrollTop = target.offsetTop;\n          break;\n        default:\n          if (shouldSelect) {\n            scope.$apply(function() {\n              if (angular.isNumber(scope.debounceUpdate) || angular.isObject(scope.debounceUpdate)) {\n                $$debounce(function() {\n                  scope.select(scope.activeIdx, evt);\n                }, angular.isNumber(scope.debounceUpdate) ? scope.debounceUpdate : scope.debounceUpdate['default']);\n              } else {\n                scope.select(scope.activeIdx, evt);\n              }\n            });\n          }\n      }\n    });\n\n    element.on('focus', function (evt) {\n      hasFocus = true;\n      if (minLength === 0 && !modelCtrl.$viewValue) {\n        $timeout(function() {\n          getMatchesAsync(modelCtrl.$viewValue, evt);\n        }, 0);\n      }\n    });\n\n    element.on('blur', function(evt) {\n      if (isSelectOnBlur && scope.matches.length && scope.activeIdx !== -1 && !selected) {\n        selected = true;\n        scope.$apply(function() {\n          if (angular.isObject(scope.debounceUpdate) && angular.isNumber(scope.debounceUpdate.blur)) {\n            $$debounce(function() {\n              scope.select(scope.activeIdx, evt);\n            }, scope.debounceUpdate.blur);\n          } else {\n            scope.select(scope.activeIdx, evt);\n          }\n        });\n      }\n      if (!isEditable && modelCtrl.$error.editable) {\n        modelCtrl.$setViewValue();\n        scope.$apply(function() {\n          // Reset validity as we are clearing\n          modelCtrl.$setValidity('editable', true);\n          modelCtrl.$setValidity('parse', true);\n        });\n        element.val('');\n      }\n      hasFocus = false;\n      selected = false;\n    });\n\n    // Keep reference to click handler to unbind it.\n    var dismissClickHandler = function(evt) {\n      // Issue #3973\n      // Firefox treats right click as a click on document\n      if (element[0] !== evt.target && evt.which !== 3 && scope.matches.length !== 0) {\n        resetMatches();\n        if (!$rootScope.$$phase) {\n          originalScope.$digest();\n        }\n      }\n    };\n\n    $document.on('click', dismissClickHandler);\n\n    originalScope.$on('$destroy', function() {\n      $document.off('click', dismissClickHandler);\n      if (appendToBody || appendTo) {\n        $popup.remove();\n      }\n\n      if (appendToBody) {\n        angular.element($window).off('resize', fireRecalculating);\n        $document.find('body').off('scroll', fireRecalculating);\n      }\n      // Prevent jQuery cache memory leak\n      popUpEl.remove();\n\n      if (showHint) {\n          inputsContainer.remove();\n      }\n    });\n\n    var $popup = $compile(popUpEl)(scope);\n\n    if (appendToBody) {\n      $document.find('body').append($popup);\n    } else if (appendTo) {\n      angular.element(appendTo).eq(0).append($popup);\n    } else {\n      element.after($popup);\n    }\n\n    this.init = function(_modelCtrl) {\n      modelCtrl = _modelCtrl;\n      ngModelOptions = extractOptions(modelCtrl);\n\n      scope.debounceUpdate = $parse(ngModelOptions.getOption('debounce'))(originalScope);\n\n      //plug into $parsers pipeline to open a typeahead on view changes initiated from DOM\n      //$parsers kick-in on all the changes coming from the view as well as manually triggered by $setViewValue\n      modelCtrl.$parsers.unshift(function(inputValue) {\n        hasFocus = true;\n\n        if (minLength === 0 || inputValue && inputValue.length >= minLength) {\n          if (waitTime > 0) {\n            cancelPreviousTimeout();\n            scheduleSearchWithTimeout(inputValue);\n          } else {\n            getMatchesAsync(inputValue);\n          }\n        } else {\n          isLoadingSetter(originalScope, false);\n          cancelPreviousTimeout();\n          resetMatches();\n        }\n\n        if (isEditable) {\n          return inputValue;\n        }\n\n        if (!inputValue) {\n          // Reset in case user had typed something previously.\n          modelCtrl.$setValidity('editable', true);\n          return null;\n        }\n\n        modelCtrl.$setValidity('editable', false);\n        return undefined;\n      });\n\n      modelCtrl.$formatters.push(function(modelValue) {\n        var candidateViewValue, emptyViewValue;\n        var locals = {};\n\n        // The validity may be set to false via $parsers (see above) if\n        // the model is restricted to selected values. If the model\n        // is set manually it is considered to be valid.\n        if (!isEditable) {\n          modelCtrl.$setValidity('editable', true);\n        }\n\n        if (inputFormatter) {\n          locals.$model = modelValue;\n          return inputFormatter(originalScope, locals);\n        }\n\n        //it might happen that we don't have enough info to properly render input value\n        //we need to check for this situation and simply return model value if we can't apply custom formatting\n        locals[parserResult.itemName] = modelValue;\n        candidateViewValue = parserResult.viewMapper(originalScope, locals);\n        locals[parserResult.itemName] = undefined;\n        emptyViewValue = parserResult.viewMapper(originalScope, locals);\n\n        return candidateViewValue !== emptyViewValue ? candidateViewValue : modelValue;\n      });\n    };\n\n    function extractOptions(ngModelCtrl) {\n      var ngModelOptions;\n\n      if (angular.version.minor < 6) { // in angular < 1.6 $options could be missing\n        // guarantee a value\n        ngModelOptions = ngModelCtrl.$options || {};\n\n        // mimic 1.6+ api\n        ngModelOptions.getOption = function (key) {\n          return ngModelOptions[key];\n        };\n      } else { // in angular >=1.6 $options is always present\n        ngModelOptions = ngModelCtrl.$options;\n      }\n\n      return ngModelOptions;\n    }\n  }])\n\n  .directive('uibTypeahead', function() {\n    return {\n      controller: 'UibTypeaheadController',\n      require: ['ngModel', 'uibTypeahead'],\n      link: function(originalScope, element, attrs, ctrls) {\n        ctrls[1].init(ctrls[0]);\n      }\n    };\n  })\n\n  .directive('uibTypeaheadPopup', ['$$debounce', function($$debounce) {\n    return {\n      scope: {\n        matches: '=',\n        query: '=',\n        active: '=',\n        position: '&',\n        moveInProgress: '=',\n        select: '&',\n        assignIsOpen: '&',\n        debounce: '&'\n      },\n      replace: true,\n      templateUrl: function(element, attrs) {\n        return attrs.popupTemplateUrl || 'uib/template/typeahead/typeahead-popup.html';\n      },\n      link: function(scope, element, attrs) {\n        scope.templateUrl = attrs.templateUrl;\n\n        scope.isOpen = function() {\n          var isDropdownOpen = scope.matches.length > 0;\n          scope.assignIsOpen({ isOpen: isDropdownOpen });\n          return isDropdownOpen;\n        };\n\n        scope.isActive = function(matchIdx) {\n          return scope.active === matchIdx;\n        };\n\n        scope.selectActive = function(matchIdx) {\n          scope.active = matchIdx;\n        };\n\n        scope.selectMatch = function(activeIdx, evt) {\n          var debounce = scope.debounce();\n          if (angular.isNumber(debounce) || angular.isObject(debounce)) {\n            $$debounce(function() {\n              scope.select({activeIdx: activeIdx, evt: evt});\n            }, angular.isNumber(debounce) ? debounce : debounce['default']);\n          } else {\n            scope.select({activeIdx: activeIdx, evt: evt});\n          }\n        };\n      }\n    };\n  }])\n\n  .directive('uibTypeaheadMatch', ['$templateRequest', '$compile', '$parse', function($templateRequest, $compile, $parse) {\n    return {\n      scope: {\n        index: '=',\n        match: '=',\n        query: '='\n      },\n      link: function(scope, element, attrs) {\n        var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || 'uib/template/typeahead/typeahead-match.html';\n        $templateRequest(tplUrl).then(function(tplContent) {\n          var tplEl = angular.element(tplContent.trim());\n          element.replaceWith(tplEl);\n          $compile(tplEl)(scope);\n        });\n      }\n    };\n  }])\n\n  .filter('uibTypeaheadHighlight', ['$sce', '$injector', '$log', function($sce, $injector, $log) {\n    var isSanitizePresent;\n    isSanitizePresent = $injector.has('$sanitize');\n\n    function escapeRegexp(queryToEscape) {\n      // Regex: capture the whole query string and replace it with the string that will be used to match\n      // the results, for example if the capture is \"a\" the result will be \\a\n      return queryToEscape.replace(/([.?*+^$[\\]\\\\(){}|-])/g, '\\\\$1');\n    }\n\n    function containsHtml(matchItem) {\n      return /<.*>/g.test(matchItem);\n    }\n\n    return function(matchItem, query) {\n      if (!isSanitizePresent && containsHtml(matchItem)) {\n        $log.warn('Unsafe use of typeahead please use ngSanitize'); // Warn the user about the danger\n      }\n      matchItem = query ? ('' + matchItem).replace(new RegExp(escapeRegexp(query), 'gi'), '<strong>$&</strong>') : matchItem; // Replaces the capture string with a the same string inside of a \"strong\" tag\n      if (!isSanitizePresent) {\n        matchItem = $sce.trustAsHtml(matchItem); // If $sanitize is not present we pack the string in a $sce object for the ng-bind-html directive\n      }\n      return matchItem;\n    };\n  }]);\n\nangular.module(\"uib/template/accordion/accordion-group.html\", []).run([\"$templateCache\", function ($templateCache) {\n  $templateCache.put(\"uib/template/accordion/accordion-group.html\",\n    \"<div role=\\\"tab\\\" id=\\\"{{::headingId}}\\\" aria-selected=\\\"{{isOpen}}\\\" class=\\\"panel-heading\\\" ng-keypress=\\\"toggleOpen($event)\\\">\\n\" +\n    \"  <h4 class=\\\"panel-title\\\">\\n\" +\n    \"    <a role=\\\"button\\\" data-toggle=\\\"collapse\\\" href aria-expanded=\\\"{{isOpen}}\\\" aria-controls=\\\"{{::panelId}}\\\" tabindex=\\\"0\\\" class=\\\"accordion-toggle\\\" ng-click=\\\"toggleOpen()\\\" uib-accordion-transclude=\\\"heading\\\" ng-disabled=\\\"isDisabled\\\" uib-tabindex-toggle><span uib-accordion-header ng-class=\\\"{'text-muted': isDisabled}\\\">{{heading}}</span></a>\\n\" +\n    \"  </h4>\\n\" +\n    \"</div>\\n\" +\n    \"<div id=\\\"{{::panelId}}\\\" aria-labelledby=\\\"{{::headingId}}\\\" aria-hidden=\\\"{{!isOpen}}\\\" role=\\\"tabpanel\\\" class=\\\"panel-collapse collapse\\\" uib-collapse=\\\"!isOpen\\\">\\n\" +\n    \"  <div class=\\\"panel-body\\\" ng-transclude></div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/accordion/accordion.html\", []).run([\"$templateCache\", function ($templateCache) {\n  $templateCache.put(\"uib/template/accordion/accordion.html\",\n    \"<div role=\\\"tablist\\\" class=\\\"panel-group\\\" ng-transclude></div>\");\n}]);\n\nangular.module(\"uib/template/alert/alert.html\", []).run([\"$templateCache\", function ($templateCache) {\n  $templateCache.put(\"uib/template/alert/alert.html\",\n    \"<button ng-show=\\\"closeable\\\" type=\\\"button\\\" class=\\\"close\\\" ng-click=\\\"close({$event: $event})\\\">\\n\" +\n    \"  <span aria-hidden=\\\"true\\\">&times;</span>\\n\" +\n    \"  <span class=\\\"sr-only\\\">Close</span>\\n\" +\n    \"</button>\\n\" +\n    \"<div ng-transclude></div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/carousel/carousel.html\", []).run([\"$templateCache\", function ($templateCache) {\n  $templateCache.put(\"uib/template/carousel/carousel.html\",\n    \"<div class=\\\"carousel-inner\\\" ng-transclude></div>\\n\" +\n    \"<a role=\\\"button\\\" href class=\\\"left carousel-control\\\" ng-click=\\\"prev()\\\" ng-class=\\\"{ disabled: isPrevDisabled() }\\\" ng-show=\\\"slides.length > 1\\\">\\n\" +\n    \"  <span aria-hidden=\\\"true\\\" class=\\\"glyphicon glyphicon-chevron-left\\\"></span>\\n\" +\n    \"  <span class=\\\"sr-only\\\">previous</span>\\n\" +\n    \"</a>\\n\" +\n    \"<a role=\\\"button\\\" href class=\\\"right carousel-control\\\" ng-click=\\\"next()\\\" ng-class=\\\"{ disabled: isNextDisabled() }\\\" ng-show=\\\"slides.length > 1\\\">\\n\" +\n    \"  <span aria-hidden=\\\"true\\\" class=\\\"glyphicon glyphicon-chevron-right\\\"></span>\\n\" +\n    \"  <span class=\\\"sr-only\\\">next</span>\\n\" +\n    \"</a>\\n\" +\n    \"<ol class=\\\"carousel-indicators\\\" ng-show=\\\"slides.length > 1\\\">\\n\" +\n    \"  <li ng-repeat=\\\"slide in slides | orderBy:indexOfSlide track by $index\\\" ng-class=\\\"{ active: isActive(slide) }\\\" ng-click=\\\"select(slide)\\\">\\n\" +\n    \"    <span class=\\\"sr-only\\\">slide {{ $index + 1 }} of {{ slides.length }}<span ng-if=\\\"isActive(slide)\\\">, currently active</span></span>\\n\" +\n    \"  </li>\\n\" +\n    \"</ol>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/carousel/slide.html\", []).run([\"$templateCache\", function ($templateCache) {\n  $templateCache.put(\"uib/template/carousel/slide.html\",\n    \"<div class=\\\"text-center\\\" ng-transclude></div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/datepicker/datepicker.html\", []).run([\"$templateCache\", function ($templateCache) {\n  $templateCache.put(\"uib/template/datepicker/datepicker.html\",\n    \"<div ng-switch=\\\"datepickerMode\\\">\\n\" +\n    \"  <div uib-daypicker ng-switch-when=\\\"day\\\" tabindex=\\\"0\\\" class=\\\"uib-daypicker\\\"></div>\\n\" +\n    \"  <div uib-monthpicker ng-switch-when=\\\"month\\\" tabindex=\\\"0\\\" class=\\\"uib-monthpicker\\\"></div>\\n\" +\n    \"  <div uib-yearpicker ng-switch-when=\\\"year\\\" tabindex=\\\"0\\\" class=\\\"uib-yearpicker\\\"></div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/datepicker/day.html\", []).run([\"$templateCache\", function ($templateCache) {\n  $templateCache.put(\"uib/template/datepicker/day.html\",\n    \"<table role=\\\"grid\\\" aria-labelledby=\\\"{{::uniqueId}}-title\\\" aria-activedescendant=\\\"{{activeDateId}}\\\">\\n\" +\n    \"  <thead>\\n\" +\n    \"    <tr>\\n\" +\n    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-left uib-left\\\" ng-click=\\\"move(-1)\\\" tabindex=\\\"-1\\\"><i aria-hidden=\\\"true\\\" class=\\\"glyphicon glyphicon-chevron-left\\\"></i><span class=\\\"sr-only\\\">previous</span></button></th>\\n\" +\n    \"      <th colspan=\\\"{{::5 + showWeeks}}\\\"><button id=\\\"{{::uniqueId}}-title\\\" role=\\\"heading\\\" aria-live=\\\"assertive\\\" aria-atomic=\\\"true\\\" type=\\\"button\\\" class=\\\"btn btn-default btn-sm uib-title\\\" ng-click=\\\"toggleMode()\\\" ng-disabled=\\\"datepickerMode === maxMode\\\" tabindex=\\\"-1\\\"><strong>{{title}}</strong></button></th>\\n\" +\n    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-right uib-right\\\" ng-click=\\\"move(1)\\\" tabindex=\\\"-1\\\"><i aria-hidden=\\\"true\\\" class=\\\"glyphicon glyphicon-chevron-right\\\"></i><span class=\\\"sr-only\\\">next</span></button></th>\\n\" +\n    \"    </tr>\\n\" +\n    \"    <tr>\\n\" +\n    \"      <th ng-if=\\\"showWeeks\\\" class=\\\"text-center\\\"></th>\\n\" +\n    \"      <th ng-repeat=\\\"label in ::labels track by $index\\\" class=\\\"text-center\\\"><small aria-label=\\\"{{::label.full}}\\\">{{::label.abbr}}</small></th>\\n\" +\n    \"    </tr>\\n\" +\n    \"  </thead>\\n\" +\n    \"  <tbody>\\n\" +\n    \"    <tr class=\\\"uib-weeks\\\" ng-repeat=\\\"row in rows track by $index\\\" role=\\\"row\\\">\\n\" +\n    \"      <td ng-if=\\\"showWeeks\\\" class=\\\"text-center h6\\\"><em>{{ weekNumbers[$index] }}</em></td>\\n\" +\n    \"      <td ng-repeat=\\\"dt in row\\\" class=\\\"uib-day text-center\\\" role=\\\"gridcell\\\"\\n\" +\n    \"        id=\\\"{{::dt.uid}}\\\"\\n\" +\n    \"        ng-class=\\\"::dt.customClass\\\">\\n\" +\n    \"        <button type=\\\"button\\\" class=\\\"btn btn-default btn-sm\\\"\\n\" +\n    \"          uib-is-class=\\\"\\n\" +\n    \"            'btn-info' for selectedDt,\\n\" +\n    \"            'active' for activeDt\\n\" +\n    \"            on dt\\\"\\n\" +\n    \"          ng-click=\\\"select(dt.date)\\\"\\n\" +\n    \"          ng-disabled=\\\"::dt.disabled\\\"\\n\" +\n    \"          tabindex=\\\"-1\\\"><span ng-class=\\\"::{'text-muted': dt.secondary, 'text-info': dt.current}\\\">{{::dt.label}}</span></button>\\n\" +\n    \"      </td>\\n\" +\n    \"    </tr>\\n\" +\n    \"  </tbody>\\n\" +\n    \"</table>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/datepicker/month.html\", []).run([\"$templateCache\", function ($templateCache) {\n  $templateCache.put(\"uib/template/datepicker/month.html\",\n    \"<table role=\\\"grid\\\" aria-labelledby=\\\"{{::uniqueId}}-title\\\" aria-activedescendant=\\\"{{activeDateId}}\\\">\\n\" +\n    \"  <thead>\\n\" +\n    \"    <tr>\\n\" +\n    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-left uib-left\\\" ng-click=\\\"move(-1)\\\" tabindex=\\\"-1\\\"><i aria-hidden=\\\"true\\\" class=\\\"glyphicon glyphicon-chevron-left\\\"></i><span class=\\\"sr-only\\\">previous</span></button></th>\\n\" +\n    \"      <th colspan=\\\"{{::yearHeaderColspan}}\\\"><button id=\\\"{{::uniqueId}}-title\\\" role=\\\"heading\\\" aria-live=\\\"assertive\\\" aria-atomic=\\\"true\\\" type=\\\"button\\\" class=\\\"btn btn-default btn-sm uib-title\\\" ng-click=\\\"toggleMode()\\\" ng-disabled=\\\"datepickerMode === maxMode\\\" tabindex=\\\"-1\\\"><strong>{{title}}</strong></button></th>\\n\" +\n    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-right uib-right\\\" ng-click=\\\"move(1)\\\" tabindex=\\\"-1\\\"><i aria-hidden=\\\"true\\\" class=\\\"glyphicon glyphicon-chevron-right\\\"></i><span class=\\\"sr-only\\\">next</span></i></button></th>\\n\" +\n    \"    </tr>\\n\" +\n    \"  </thead>\\n\" +\n    \"  <tbody>\\n\" +\n    \"    <tr class=\\\"uib-months\\\" ng-repeat=\\\"row in rows track by $index\\\" role=\\\"row\\\">\\n\" +\n    \"      <td ng-repeat=\\\"dt in row\\\" class=\\\"uib-month text-center\\\" role=\\\"gridcell\\\"\\n\" +\n    \"        id=\\\"{{::dt.uid}}\\\"\\n\" +\n    \"        ng-class=\\\"::dt.customClass\\\">\\n\" +\n    \"        <button type=\\\"button\\\" class=\\\"btn btn-default\\\"\\n\" +\n    \"          uib-is-class=\\\"\\n\" +\n    \"            'btn-info' for selectedDt,\\n\" +\n    \"            'active' for activeDt\\n\" +\n    \"            on dt\\\"\\n\" +\n    \"          ng-click=\\\"select(dt.date)\\\"\\n\" +\n    \"          ng-disabled=\\\"::dt.disabled\\\"\\n\" +\n    \"          tabindex=\\\"-1\\\"><span ng-class=\\\"::{'text-info': dt.current}\\\">{{::dt.label}}</span></button>\\n\" +\n    \"      </td>\\n\" +\n    \"    </tr>\\n\" +\n    \"  </tbody>\\n\" +\n    \"</table>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/datepicker/popup.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/datepicker/popup.html\",\n    \"<div>\\n\" +\n    \"  <ul class=\\\"uib-datepicker-popup dropdown-menu uib-position-measure\\\" dropdown-nested ng-if=\\\"isOpen\\\" ng-keydown=\\\"keydown($event)\\\" ng-click=\\\"$event.stopPropagation()\\\">\\n\" +\n    \"    <li ng-transclude></li>\\n\" +\n    \"    <li ng-if=\\\"showButtonBar\\\" class=\\\"uib-button-bar\\\">\\n\" +\n    \"      <span class=\\\"btn-group pull-left\\\">\\n\" +\n    \"        <button type=\\\"button\\\" class=\\\"btn btn-sm btn-info uib-datepicker-current\\\" ng-click=\\\"select('today', $event)\\\" ng-disabled=\\\"isDisabled('today')\\\">{{ getText('current') }}</button>\\n\" +\n    \"        <button type=\\\"button\\\" class=\\\"btn btn-sm btn-danger uib-clear\\\" ng-click=\\\"select(null, $event)\\\">{{ getText('clear') }}</button>\\n\" +\n    \"      </span>\\n\" +\n    \"      <button type=\\\"button\\\" class=\\\"btn btn-sm btn-success pull-right uib-close\\\" ng-click=\\\"close($event)\\\">{{ getText('close') }}</button>\\n\" +\n    \"    </li>\\n\" +\n    \"  </ul>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/datepicker/year.html\", []).run([\"$templateCache\", function ($templateCache) {\n  $templateCache.put(\"uib/template/datepicker/year.html\",\n    \"<table role=\\\"grid\\\" aria-labelledby=\\\"{{::uniqueId}}-title\\\" aria-activedescendant=\\\"{{activeDateId}}\\\">\\n\" +\n    \"  <thead>\\n\" +\n    \"    <tr>\\n\" +\n    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-left uib-left\\\" ng-click=\\\"move(-1)\\\" tabindex=\\\"-1\\\"><i aria-hidden=\\\"true\\\" class=\\\"glyphicon glyphicon-chevron-left\\\"></i><span class=\\\"sr-only\\\">previous</span></button></th>\\n\" +\n    \"      <th colspan=\\\"{{::columns - 2}}\\\"><button id=\\\"{{::uniqueId}}-title\\\" role=\\\"heading\\\" aria-live=\\\"assertive\\\" aria-atomic=\\\"true\\\" type=\\\"button\\\" class=\\\"btn btn-default btn-sm uib-title\\\" ng-click=\\\"toggleMode()\\\" ng-disabled=\\\"datepickerMode === maxMode\\\" tabindex=\\\"-1\\\"><strong>{{title}}</strong></button></th>\\n\" +\n    \"      <th><button type=\\\"button\\\" class=\\\"btn btn-default btn-sm pull-right uib-right\\\" ng-click=\\\"move(1)\\\" tabindex=\\\"-1\\\"><i aria-hidden=\\\"true\\\" class=\\\"glyphicon glyphicon-chevron-right\\\"></i><span class=\\\"sr-only\\\">next</span></button></th>\\n\" +\n    \"    </tr>\\n\" +\n    \"  </thead>\\n\" +\n    \"  <tbody>\\n\" +\n    \"    <tr class=\\\"uib-years\\\" ng-repeat=\\\"row in rows track by $index\\\" role=\\\"row\\\">\\n\" +\n    \"      <td ng-repeat=\\\"dt in row\\\" class=\\\"uib-year text-center\\\" role=\\\"gridcell\\\"\\n\" +\n    \"        id=\\\"{{::dt.uid}}\\\"\\n\" +\n    \"        ng-class=\\\"::dt.customClass\\\">\\n\" +\n    \"        <button type=\\\"button\\\" class=\\\"btn btn-default\\\"\\n\" +\n    \"          uib-is-class=\\\"\\n\" +\n    \"            'btn-info' for selectedDt,\\n\" +\n    \"            'active' for activeDt\\n\" +\n    \"            on dt\\\"\\n\" +\n    \"          ng-click=\\\"select(dt.date)\\\"\\n\" +\n    \"          ng-disabled=\\\"::dt.disabled\\\"\\n\" +\n    \"          tabindex=\\\"-1\\\"><span ng-class=\\\"::{'text-info': dt.current}\\\">{{::dt.label}}</span></button>\\n\" +\n    \"      </td>\\n\" +\n    \"    </tr>\\n\" +\n    \"  </tbody>\\n\" +\n    \"</table>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/datepickerPopup/popup.html\", []).run([\"$templateCache\", function ($templateCache) {\n  $templateCache.put(\"uib/template/datepickerPopup/popup.html\",\n    \"<ul role=\\\"presentation\\\" class=\\\"uib-datepicker-popup dropdown-menu uib-position-measure\\\" dropdown-nested ng-if=\\\"isOpen\\\" ng-keydown=\\\"keydown($event)\\\" ng-click=\\\"$event.stopPropagation()\\\">\\n\" +\n    \"  <li ng-transclude></li>\\n\" +\n    \"  <li ng-if=\\\"showButtonBar\\\" class=\\\"uib-button-bar\\\">\\n\" +\n    \"    <span class=\\\"btn-group pull-left\\\">\\n\" +\n    \"      <button type=\\\"button\\\" class=\\\"btn btn-sm btn-info uib-datepicker-current\\\" ng-click=\\\"select('today', $event)\\\" ng-disabled=\\\"isDisabled('today')\\\">{{ getText('current') }}</button>\\n\" +\n    \"      <button type=\\\"button\\\" class=\\\"btn btn-sm btn-danger uib-clear\\\" ng-click=\\\"select(null, $event)\\\">{{ getText('clear') }}</button>\\n\" +\n    \"    </span>\\n\" +\n    \"    <button type=\\\"button\\\" class=\\\"btn btn-sm btn-success pull-right uib-close\\\" ng-click=\\\"close($event)\\\">{{ getText('close') }}</button>\\n\" +\n    \"  </li>\\n\" +\n    \"</ul>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/modal/backdrop.html\", []).run([\"$templateCache\", function($templateCache) {\n  $templateCache.put(\"uib/template/modal/backdrop.html\",\n    \"<div class=\\\"modal-backdrop\\\"\\n\" +\n    \"     uib-modal-animation-class=\\\"fade\\\"\\n\" +\n    \"     modal-in-class=\\\"in\\\"\\n\" +\n    \"     ng-style=\\\"{'z-index': 1040 + (index && 1 || 0) + index*10}\\\"\\n\" +\n    \"></div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/modal/window.html\", []).run([\"$templateCache\", function ($templateCache) {\n  $templateCache.put(\"uib/template/modal/window.html\",\n    \"<div class=\\\"modal-dialog {{size ? 'modal-' + size : ''}}\\\"><div class=\\\"modal-content\\\" uib-modal-transclude></div></div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/pager/pager.html\", []).run([\"$templateCache\", function ($templateCache) {\n  $templateCache.put(\"uib/template/pager/pager.html\",\n    \"<li ng-class=\\\"{disabled: noPrevious()||ngDisabled, previous: align}\\\"><a href ng-click=\\\"selectPage(page - 1, $event)\\\" ng-disabled=\\\"noPrevious()||ngDisabled\\\" uib-tabindex-toggle>{{::getText('previous')}}</a></li>\\n\" +\n    \"<li ng-class=\\\"{disabled: noNext()||ngDisabled, next: align}\\\"><a href ng-click=\\\"selectPage(page + 1, $event)\\\" ng-disabled=\\\"noNext()||ngDisabled\\\" uib-tabindex-toggle>{{::getText('next')}}</a></li>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/pagination/pagination.html\", []).run([\"$templateCache\", function ($templateCache) {\n  $templateCache.put(\"uib/template/pagination/pagination.html\",\n    \"<li role=\\\"menuitem\\\" ng-if=\\\"::boundaryLinks\\\" ng-class=\\\"{disabled: noPrevious()||ngDisabled}\\\" class=\\\"pagination-first\\\"><a href ng-click=\\\"selectPage(1, $event)\\\" ng-disabled=\\\"noPrevious()||ngDisabled\\\" uib-tabindex-toggle>{{::getText('first')}}</a></li>\\n\" +\n    \"<li role=\\\"menuitem\\\" ng-if=\\\"::directionLinks\\\" ng-class=\\\"{disabled: noPrevious()||ngDisabled}\\\" class=\\\"pagination-prev\\\"><a href ng-click=\\\"selectPage(page - 1, $event)\\\" ng-disabled=\\\"noPrevious()||ngDisabled\\\" uib-tabindex-toggle>{{::getText('previous')}}</a></li>\\n\" +\n    \"<li role=\\\"menuitem\\\" ng-repeat=\\\"page in pages track by $index\\\" ng-class=\\\"{active: page.active,disabled: ngDisabled&&!page.active}\\\" class=\\\"pagination-page\\\"><a href ng-click=\\\"selectPage(page.number, $event)\\\" ng-disabled=\\\"ngDisabled&&!page.active\\\" uib-tabindex-toggle>{{page.text}}</a></li>\\n\" +\n    \"<li role=\\\"menuitem\\\" ng-if=\\\"::directionLinks\\\" ng-class=\\\"{disabled: noNext()||ngDisabled}\\\" class=\\\"pagination-next\\\"><a href ng-click=\\\"selectPage(page + 1, $event)\\\" ng-disabled=\\\"noNext()||ngDisabled\\\" uib-tabindex-toggle>{{::getText('next')}}</a></li>\\n\" +\n    \"<li role=\\\"menuitem\\\" ng-if=\\\"::boundaryLinks\\\" ng-class=\\\"{disabled: noNext()||ngDisabled}\\\" class=\\\"pagination-last\\\"><a href ng-click=\\\"selectPage(totalPages, $event)\\\" ng-disabled=\\\"noNext()||ngDisabled\\\" uib-tabindex-toggle>{{::getText('last')}}</a></li>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/tooltip/tooltip-html-popup.html\", []).run([\"$templateCache\", function ($templateCache) {\n  $templateCache.put(\"uib/template/tooltip/tooltip-html-popup.html\",\n    \"<div class=\\\"tooltip-arrow\\\"></div>\\n\" +\n    \"<div class=\\\"tooltip-inner\\\" ng-bind-html=\\\"contentExp()\\\"></div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/tooltip/tooltip-popup.html\", []).run([\"$templateCache\", function ($templateCache) {\n  $templateCache.put(\"uib/template/tooltip/tooltip-popup.html\",\n    \"<div class=\\\"tooltip-arrow\\\"></div>\\n\" +\n    \"<div class=\\\"tooltip-inner\\\" ng-bind=\\\"content\\\"></div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/tooltip/tooltip-template-popup.html\", []).run([\"$templateCache\", function ($templateCache) {\n  $templateCache.put(\"uib/template/tooltip/tooltip-template-popup.html\",\n    \"<div class=\\\"tooltip-arrow\\\"></div>\\n\" +\n    \"<div class=\\\"tooltip-inner\\\"\\n\" +\n    \"  uib-tooltip-template-transclude=\\\"contentExp()\\\"\\n\" +\n    \"  tooltip-template-transclude-scope=\\\"originScope()\\\"></div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/popover/popover-html.html\", []).run([\"$templateCache\", function ($templateCache) {\n  $templateCache.put(\"uib/template/popover/popover-html.html\",\n    \"<div class=\\\"arrow\\\"></div>\\n\" +\n    \"\\n\" +\n    \"<div class=\\\"popover-inner\\\">\\n\" +\n    \"    <h3 class=\\\"popover-title\\\" ng-bind=\\\"uibTitle\\\" ng-if=\\\"uibTitle\\\"></h3>\\n\" +\n    \"    <div class=\\\"popover-content\\\" ng-bind-html=\\\"contentExp()\\\"></div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/popover/popover-template.html\", []).run([\"$templateCache\", function ($templateCache) {\n  $templateCache.put(\"uib/template/popover/popover-template.html\",\n    \"<div class=\\\"arrow\\\"></div>\\n\" +\n    \"\\n\" +\n    \"<div class=\\\"popover-inner\\\">\\n\" +\n    \"    <h3 class=\\\"popover-title\\\" ng-bind=\\\"uibTitle\\\" ng-if=\\\"uibTitle\\\"></h3>\\n\" +\n    \"    <div class=\\\"popover-content\\\"\\n\" +\n    \"      uib-tooltip-template-transclude=\\\"contentExp()\\\"\\n\" +\n    \"      tooltip-template-transclude-scope=\\\"originScope()\\\"></div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/popover/popover.html\", []).run([\"$templateCache\", function ($templateCache) {\n  $templateCache.put(\"uib/template/popover/popover.html\",\n    \"<div class=\\\"arrow\\\"></div>\\n\" +\n    \"\\n\" +\n    \"<div class=\\\"popover-inner\\\">\\n\" +\n    \"    <h3 class=\\\"popover-title\\\" ng-bind=\\\"uibTitle\\\" ng-if=\\\"uibTitle\\\"></h3>\\n\" +\n    \"    <div class=\\\"popover-content\\\" ng-bind=\\\"content\\\"></div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/progressbar/bar.html\", []).run([\"$templateCache\", function ($templateCache) {\n  $templateCache.put(\"uib/template/progressbar/bar.html\",\n    \"<div class=\\\"progress-bar\\\" ng-class=\\\"type && 'progress-bar-' + type\\\" role=\\\"progressbar\\\" aria-valuenow=\\\"{{value}}\\\" aria-valuemin=\\\"0\\\" aria-valuemax=\\\"{{max}}\\\" ng-style=\\\"{width: (percent < 100 ? percent : 100) + '%'}\\\" aria-valuetext=\\\"{{percent | number:0}}%\\\" aria-labelledby=\\\"{{::title}}\\\" ng-transclude></div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/progressbar/progress.html\", []).run([\"$templateCache\", function ($templateCache) {\n  $templateCache.put(\"uib/template/progressbar/progress.html\",\n    \"<div class=\\\"progress\\\" ng-transclude aria-labelledby=\\\"{{::title}}\\\"></div>\");\n}]);\n\nangular.module(\"uib/template/progressbar/progressbar.html\", []).run([\"$templateCache\", function ($templateCache) {\n  $templateCache.put(\"uib/template/progressbar/progressbar.html\",\n    \"<div class=\\\"progress\\\">\\n\" +\n    \"  <div class=\\\"progress-bar\\\" ng-class=\\\"type && 'progress-bar-' + type\\\" role=\\\"progressbar\\\" aria-valuenow=\\\"{{value}}\\\" aria-valuemin=\\\"0\\\" aria-valuemax=\\\"{{max}}\\\" ng-style=\\\"{width: (percent < 100 ? percent : 100) + '%'}\\\" aria-valuetext=\\\"{{percent | number:0}}%\\\" aria-labelledby=\\\"{{::title}}\\\" ng-transclude></div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/rating/rating.html\", []).run([\"$templateCache\", function ($templateCache) {\n  $templateCache.put(\"uib/template/rating/rating.html\",\n    \"<span ng-mouseleave=\\\"reset()\\\" ng-keydown=\\\"onKeydown($event)\\\" tabindex=\\\"0\\\" role=\\\"slider\\\" aria-valuemin=\\\"0\\\" aria-valuemax=\\\"{{range.length}}\\\" aria-valuenow=\\\"{{value}}\\\" aria-valuetext=\\\"{{title}}\\\">\\n\" +\n    \"    <span ng-repeat-start=\\\"r in range track by $index\\\" class=\\\"sr-only\\\">({{ $index < value ? '*' : ' ' }})</span>\\n\" +\n    \"    <i ng-repeat-end ng-mouseenter=\\\"enter($index + 1)\\\" ng-click=\\\"rate($index + 1)\\\" class=\\\"glyphicon\\\" ng-class=\\\"$index < value && (r.stateOn || 'glyphicon-star') || (r.stateOff || 'glyphicon-star-empty')\\\" ng-attr-title=\\\"{{r.title}}\\\"></i>\\n\" +\n    \"</span>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/tabs/tab.html\", []).run([\"$templateCache\", function ($templateCache) {\n  $templateCache.put(\"uib/template/tabs/tab.html\",\n    \"<li ng-class=\\\"[{active: active, disabled: disabled}, classes]\\\" class=\\\"uib-tab nav-item\\\">\\n\" +\n    \"  <a href ng-click=\\\"select($event)\\\" class=\\\"nav-link\\\" uib-tab-heading-transclude>{{heading}}</a>\\n\" +\n    \"</li>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/tabs/tabset.html\", []).run([\"$templateCache\", function ($templateCache) {\n  $templateCache.put(\"uib/template/tabs/tabset.html\",\n    \"<div>\\n\" +\n    \"  <ul class=\\\"nav nav-{{tabset.type || 'tabs'}}\\\" ng-class=\\\"{'nav-stacked': vertical, 'nav-justified': justified}\\\" ng-transclude></ul>\\n\" +\n    \"  <div class=\\\"tab-content\\\">\\n\" +\n    \"    <div class=\\\"tab-pane\\\"\\n\" +\n    \"         ng-repeat=\\\"tab in tabset.tabs\\\"\\n\" +\n    \"         ng-class=\\\"{active: tabset.active === tab.index}\\\"\\n\" +\n    \"         uib-tab-content-transclude=\\\"tab\\\">\\n\" +\n    \"    </div>\\n\" +\n    \"  </div>\\n\" +\n    \"</div>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/timepicker/timepicker.html\", []).run([\"$templateCache\", function ($templateCache) {\n  $templateCache.put(\"uib/template/timepicker/timepicker.html\",\n    \"<table class=\\\"uib-timepicker\\\">\\n\" +\n    \"  <tbody>\\n\" +\n    \"    <tr class=\\\"text-center\\\" ng-show=\\\"::showSpinners\\\">\\n\" +\n    \"      <td class=\\\"uib-increment hours\\\"><a ng-click=\\\"incrementHours()\\\" ng-class=\\\"{disabled: noIncrementHours()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noIncrementHours()\\\" tabindex=\\\"-1\\\"><span class=\\\"glyphicon glyphicon-chevron-up\\\"></span></a></td>\\n\" +\n    \"      <td>&nbsp;</td>\\n\" +\n    \"      <td class=\\\"uib-increment minutes\\\"><a ng-click=\\\"incrementMinutes()\\\" ng-class=\\\"{disabled: noIncrementMinutes()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noIncrementMinutes()\\\" tabindex=\\\"-1\\\"><span class=\\\"glyphicon glyphicon-chevron-up\\\"></span></a></td>\\n\" +\n    \"      <td ng-show=\\\"showSeconds\\\">&nbsp;</td>\\n\" +\n    \"      <td ng-show=\\\"showSeconds\\\" class=\\\"uib-increment seconds\\\"><a ng-click=\\\"incrementSeconds()\\\" ng-class=\\\"{disabled: noIncrementSeconds()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noIncrementSeconds()\\\" tabindex=\\\"-1\\\"><span class=\\\"glyphicon glyphicon-chevron-up\\\"></span></a></td>\\n\" +\n    \"      <td ng-show=\\\"showMeridian\\\"></td>\\n\" +\n    \"    </tr>\\n\" +\n    \"    <tr>\\n\" +\n    \"      <td class=\\\"form-group uib-time hours\\\" ng-class=\\\"{'has-error': invalidHours}\\\">\\n\" +\n    \"        <input type=\\\"text\\\" placeholder=\\\"HH\\\" ng-model=\\\"hours\\\" ng-change=\\\"updateHours()\\\" class=\\\"form-control text-center\\\" ng-readonly=\\\"::readonlyInput\\\" maxlength=\\\"2\\\" tabindex=\\\"{{::tabindex}}\\\" ng-disabled=\\\"noIncrementHours()\\\" ng-blur=\\\"blur()\\\">\\n\" +\n    \"      </td>\\n\" +\n    \"      <td class=\\\"uib-separator\\\">:</td>\\n\" +\n    \"      <td class=\\\"form-group uib-time minutes\\\" ng-class=\\\"{'has-error': invalidMinutes}\\\">\\n\" +\n    \"        <input type=\\\"text\\\" placeholder=\\\"MM\\\" ng-model=\\\"minutes\\\" ng-change=\\\"updateMinutes()\\\" class=\\\"form-control text-center\\\" ng-readonly=\\\"::readonlyInput\\\" maxlength=\\\"2\\\" tabindex=\\\"{{::tabindex}}\\\" ng-disabled=\\\"noIncrementMinutes()\\\" ng-blur=\\\"blur()\\\">\\n\" +\n    \"      </td>\\n\" +\n    \"      <td ng-show=\\\"showSeconds\\\" class=\\\"uib-separator\\\">:</td>\\n\" +\n    \"      <td class=\\\"form-group uib-time seconds\\\" ng-class=\\\"{'has-error': invalidSeconds}\\\" ng-show=\\\"showSeconds\\\">\\n\" +\n    \"        <input type=\\\"text\\\" placeholder=\\\"SS\\\" ng-model=\\\"seconds\\\" ng-change=\\\"updateSeconds()\\\" class=\\\"form-control text-center\\\" ng-readonly=\\\"readonlyInput\\\" maxlength=\\\"2\\\" tabindex=\\\"{{::tabindex}}\\\" ng-disabled=\\\"noIncrementSeconds()\\\" ng-blur=\\\"blur()\\\">\\n\" +\n    \"      </td>\\n\" +\n    \"      <td ng-show=\\\"showMeridian\\\" class=\\\"uib-time am-pm\\\"><button type=\\\"button\\\" ng-class=\\\"{disabled: noToggleMeridian()}\\\" class=\\\"btn btn-default text-center\\\" ng-click=\\\"toggleMeridian()\\\" ng-disabled=\\\"noToggleMeridian()\\\" tabindex=\\\"{{::tabindex}}\\\">{{meridian}}</button></td>\\n\" +\n    \"    </tr>\\n\" +\n    \"    <tr class=\\\"text-center\\\" ng-show=\\\"::showSpinners\\\">\\n\" +\n    \"      <td class=\\\"uib-decrement hours\\\"><a ng-click=\\\"decrementHours()\\\" ng-class=\\\"{disabled: noDecrementHours()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noDecrementHours()\\\" tabindex=\\\"-1\\\"><span class=\\\"glyphicon glyphicon-chevron-down\\\"></span></a></td>\\n\" +\n    \"      <td>&nbsp;</td>\\n\" +\n    \"      <td class=\\\"uib-decrement minutes\\\"><a ng-click=\\\"decrementMinutes()\\\" ng-class=\\\"{disabled: noDecrementMinutes()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noDecrementMinutes()\\\" tabindex=\\\"-1\\\"><span class=\\\"glyphicon glyphicon-chevron-down\\\"></span></a></td>\\n\" +\n    \"      <td ng-show=\\\"showSeconds\\\">&nbsp;</td>\\n\" +\n    \"      <td ng-show=\\\"showSeconds\\\" class=\\\"uib-decrement seconds\\\"><a ng-click=\\\"decrementSeconds()\\\" ng-class=\\\"{disabled: noDecrementSeconds()}\\\" class=\\\"btn btn-link\\\" ng-disabled=\\\"noDecrementSeconds()\\\" tabindex=\\\"-1\\\"><span class=\\\"glyphicon glyphicon-chevron-down\\\"></span></a></td>\\n\" +\n    \"      <td ng-show=\\\"showMeridian\\\"></td>\\n\" +\n    \"    </tr>\\n\" +\n    \"  </tbody>\\n\" +\n    \"</table>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/typeahead/typeahead-match.html\", []).run([\"$templateCache\", function ($templateCache) {\n  $templateCache.put(\"uib/template/typeahead/typeahead-match.html\",\n    \"<a href\\n\" +\n    \"   tabindex=\\\"-1\\\"\\n\" +\n    \"   ng-bind-html=\\\"match.label | uibTypeaheadHighlight:query\\\"\\n\" +\n    \"   ng-attr-title=\\\"{{match.label}}\\\"></a>\\n\" +\n    \"\");\n}]);\n\nangular.module(\"uib/template/typeahead/typeahead-popup.html\", []).run([\"$templateCache\", function ($templateCache) {\n  $templateCache.put(\"uib/template/typeahead/typeahead-popup.html\",\n    \"<ul class=\\\"dropdown-menu\\\" ng-show=\\\"isOpen() && !moveInProgress\\\" ng-style=\\\"{top: position().top+'px', left: position().left+'px'}\\\" role=\\\"listbox\\\" aria-hidden=\\\"{{!isOpen()}}\\\">\\n\" +\n    \"    <li class=\\\"uib-typeahead-match\\\" ng-repeat=\\\"match in matches track by $index\\\" ng-class=\\\"{active: isActive($index) }\\\" ng-mouseenter=\\\"selectActive($index)\\\" ng-click=\\\"selectMatch($index, $event)\\\" role=\\\"option\\\" id=\\\"{{::match.id}}\\\">\\n\" +\n    \"        <div uib-typeahead-match index=\\\"$index\\\" match=\\\"match\\\" query=\\\"query\\\" template-url=\\\"templateUrl\\\"></div>\\n\" +\n    \"    </li>\\n\" +\n    \"</ul>\\n\" +\n    \"\");\n}]);\nangular.module('ui.bootstrap.carousel').run(function() {!angular.$$csp().noInlineStyle && !angular.$$uibCarouselCss && angular.element(document).find('head').prepend('<style type=\"text/css\">.ng-animate.item:not(.left):not(.right){-webkit-transition:0s ease-in-out left;transition:0s ease-in-out left}</style>'); angular.$$uibCarouselCss = true; });\nangular.module('ui.bootstrap.datepicker').run(function() {!angular.$$csp().noInlineStyle && !angular.$$uibDatepickerCss && angular.element(document).find('head').prepend('<style type=\"text/css\">.uib-datepicker .uib-title{width:100%;}.uib-day button,.uib-month button,.uib-year button{min-width:100%;}.uib-left,.uib-right{width:100%}</style>'); angular.$$uibDatepickerCss = true; });\nangular.module('ui.bootstrap.position').run(function() {!angular.$$csp().noInlineStyle && !angular.$$uibPositionCss && angular.element(document).find('head').prepend('<style type=\"text/css\">.uib-position-measure{display:block !important;visibility:hidden !important;position:absolute !important;top:-9999px !important;left:-9999px !important;}.uib-position-scrollbar-measure{position:absolute !important;top:-9999px !important;width:50px !important;height:50px !important;overflow:scroll !important;}.uib-position-body-scrollbar-measure{overflow:scroll !important;}</style>'); angular.$$uibPositionCss = true; });\nangular.module('ui.bootstrap.datepickerPopup').run(function() {!angular.$$csp().noInlineStyle && !angular.$$uibDatepickerpopupCss && angular.element(document).find('head').prepend('<style type=\"text/css\">.uib-datepicker-popup.dropdown-menu{display:block;float:none;margin:0;}.uib-button-bar{padding:10px 9px 2px;}</style>'); angular.$$uibDatepickerpopupCss = true; });\nangular.module('ui.bootstrap.tooltip').run(function() {!angular.$$csp().noInlineStyle && !angular.$$uibTooltipCss && angular.element(document).find('head').prepend('<style type=\"text/css\">[uib-tooltip-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-popup].tooltip.right-bottom > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.right-bottom > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.right-bottom > .tooltip-arrow,[uib-popover-popup].popover.top-left > .arrow,[uib-popover-popup].popover.top-right > .arrow,[uib-popover-popup].popover.bottom-left > .arrow,[uib-popover-popup].popover.bottom-right > .arrow,[uib-popover-popup].popover.left-top > .arrow,[uib-popover-popup].popover.left-bottom > .arrow,[uib-popover-popup].popover.right-top > .arrow,[uib-popover-popup].popover.right-bottom > .arrow,[uib-popover-html-popup].popover.top-left > .arrow,[uib-popover-html-popup].popover.top-right > .arrow,[uib-popover-html-popup].popover.bottom-left > .arrow,[uib-popover-html-popup].popover.bottom-right > .arrow,[uib-popover-html-popup].popover.left-top > .arrow,[uib-popover-html-popup].popover.left-bottom > .arrow,[uib-popover-html-popup].popover.right-top > .arrow,[uib-popover-html-popup].popover.right-bottom > .arrow,[uib-popover-template-popup].popover.top-left > .arrow,[uib-popover-template-popup].popover.top-right > .arrow,[uib-popover-template-popup].popover.bottom-left > .arrow,[uib-popover-template-popup].popover.bottom-right > .arrow,[uib-popover-template-popup].popover.left-top > .arrow,[uib-popover-template-popup].popover.left-bottom > .arrow,[uib-popover-template-popup].popover.right-top > .arrow,[uib-popover-template-popup].popover.right-bottom > .arrow{top:auto;bottom:auto;left:auto;right:auto;margin:0;}[uib-popover-popup].popover,[uib-popover-html-popup].popover,[uib-popover-template-popup].popover{display:block !important;}</style>'); angular.$$uibTooltipCss = true; });\nangular.module('ui.bootstrap.timepicker').run(function() {!angular.$$csp().noInlineStyle && !angular.$$uibTimepickerCss && angular.element(document).find('head').prepend('<style type=\"text/css\">.uib-time input{width:50px;}</style>'); angular.$$uibTimepickerCss = true; });\nangular.module('ui.bootstrap.typeahead').run(function() {!angular.$$csp().noInlineStyle && !angular.$$uibTypeaheadCss && angular.element(document).find('head').prepend('<style type=\"text/css\">[uib-typeahead-popup].dropdown-menu{display:block;}</style>'); angular.$$uibTypeaheadCss = true; });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTM1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FuZ3VsYXItdWktYm9vdHN0cmFwL2Rpc3QvdWktYm9vdHN0cmFwLXRwbHMuanM/YzE0NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogYW5ndWxhci11aS1ib290c3RyYXBcbiAqIGh0dHA6Ly9hbmd1bGFyLXVpLmdpdGh1Yi5pby9ib290c3RyYXAvXG5cbiAqIFZlcnNpb246IDIuNS42IC0gMjAxNy0xMC0xNFxuICogTGljZW5zZTogTUlUXG4gKi9hbmd1bGFyLm1vZHVsZShcInVpLmJvb3RzdHJhcFwiLCBbXCJ1aS5ib290c3RyYXAudHBsc1wiLCBcInVpLmJvb3RzdHJhcC5jb2xsYXBzZVwiLFwidWkuYm9vdHN0cmFwLnRhYmluZGV4XCIsXCJ1aS5ib290c3RyYXAuYWNjb3JkaW9uXCIsXCJ1aS5ib290c3RyYXAuYWxlcnRcIixcInVpLmJvb3RzdHJhcC5idXR0b25zXCIsXCJ1aS5ib290c3RyYXAuY2Fyb3VzZWxcIixcInVpLmJvb3RzdHJhcC5kYXRlcGFyc2VyXCIsXCJ1aS5ib290c3RyYXAuaXNDbGFzc1wiLFwidWkuYm9vdHN0cmFwLmRhdGVwaWNrZXJcIixcInVpLmJvb3RzdHJhcC5wb3NpdGlvblwiLFwidWkuYm9vdHN0cmFwLmRhdGVwaWNrZXJQb3B1cFwiLFwidWkuYm9vdHN0cmFwLmRlYm91bmNlXCIsXCJ1aS5ib290c3RyYXAubXVsdGlNYXBcIixcInVpLmJvb3RzdHJhcC5kcm9wZG93blwiLFwidWkuYm9vdHN0cmFwLnN0YWNrZWRNYXBcIixcInVpLmJvb3RzdHJhcC5tb2RhbFwiLFwidWkuYm9vdHN0cmFwLnBhZ2luZ1wiLFwidWkuYm9vdHN0cmFwLnBhZ2VyXCIsXCJ1aS5ib290c3RyYXAucGFnaW5hdGlvblwiLFwidWkuYm9vdHN0cmFwLnRvb2x0aXBcIixcInVpLmJvb3RzdHJhcC5wb3BvdmVyXCIsXCJ1aS5ib290c3RyYXAucHJvZ3Jlc3NiYXJcIixcInVpLmJvb3RzdHJhcC5yYXRpbmdcIixcInVpLmJvb3RzdHJhcC50YWJzXCIsXCJ1aS5ib290c3RyYXAudGltZXBpY2tlclwiLFwidWkuYm9vdHN0cmFwLnR5cGVhaGVhZFwiXSk7XG5hbmd1bGFyLm1vZHVsZShcInVpLmJvb3RzdHJhcC50cGxzXCIsIFtcInVpYi90ZW1wbGF0ZS9hY2NvcmRpb24vYWNjb3JkaW9uLWdyb3VwLmh0bWxcIixcInVpYi90ZW1wbGF0ZS9hY2NvcmRpb24vYWNjb3JkaW9uLmh0bWxcIixcInVpYi90ZW1wbGF0ZS9hbGVydC9hbGVydC5odG1sXCIsXCJ1aWIvdGVtcGxhdGUvY2Fyb3VzZWwvY2Fyb3VzZWwuaHRtbFwiLFwidWliL3RlbXBsYXRlL2Nhcm91c2VsL3NsaWRlLmh0bWxcIixcInVpYi90ZW1wbGF0ZS9kYXRlcGlja2VyL2RhdGVwaWNrZXIuaHRtbFwiLFwidWliL3RlbXBsYXRlL2RhdGVwaWNrZXIvZGF5Lmh0bWxcIixcInVpYi90ZW1wbGF0ZS9kYXRlcGlja2VyL21vbnRoLmh0bWxcIixcInVpYi90ZW1wbGF0ZS9kYXRlcGlja2VyL3llYXIuaHRtbFwiLFwidWliL3RlbXBsYXRlL2RhdGVwaWNrZXJQb3B1cC9wb3B1cC5odG1sXCIsXCJ1aWIvdGVtcGxhdGUvbW9kYWwvd2luZG93Lmh0bWxcIixcInVpYi90ZW1wbGF0ZS9wYWdlci9wYWdlci5odG1sXCIsXCJ1aWIvdGVtcGxhdGUvcGFnaW5hdGlvbi9wYWdpbmF0aW9uLmh0bWxcIixcInVpYi90ZW1wbGF0ZS90b29sdGlwL3Rvb2x0aXAtaHRtbC1wb3B1cC5odG1sXCIsXCJ1aWIvdGVtcGxhdGUvdG9vbHRpcC90b29sdGlwLXBvcHVwLmh0bWxcIixcInVpYi90ZW1wbGF0ZS90b29sdGlwL3Rvb2x0aXAtdGVtcGxhdGUtcG9wdXAuaHRtbFwiLFwidWliL3RlbXBsYXRlL3BvcG92ZXIvcG9wb3Zlci1odG1sLmh0bWxcIixcInVpYi90ZW1wbGF0ZS9wb3BvdmVyL3BvcG92ZXItdGVtcGxhdGUuaHRtbFwiLFwidWliL3RlbXBsYXRlL3BvcG92ZXIvcG9wb3Zlci5odG1sXCIsXCJ1aWIvdGVtcGxhdGUvcHJvZ3Jlc3NiYXIvYmFyLmh0bWxcIixcInVpYi90ZW1wbGF0ZS9wcm9ncmVzc2Jhci9wcm9ncmVzcy5odG1sXCIsXCJ1aWIvdGVtcGxhdGUvcHJvZ3Jlc3NiYXIvcHJvZ3Jlc3NiYXIuaHRtbFwiLFwidWliL3RlbXBsYXRlL3JhdGluZy9yYXRpbmcuaHRtbFwiLFwidWliL3RlbXBsYXRlL3RhYnMvdGFiLmh0bWxcIixcInVpYi90ZW1wbGF0ZS90YWJzL3RhYnNldC5odG1sXCIsXCJ1aWIvdGVtcGxhdGUvdGltZXBpY2tlci90aW1lcGlja2VyLmh0bWxcIixcInVpYi90ZW1wbGF0ZS90eXBlYWhlYWQvdHlwZWFoZWFkLW1hdGNoLmh0bWxcIixcInVpYi90ZW1wbGF0ZS90eXBlYWhlYWQvdHlwZWFoZWFkLXBvcHVwLmh0bWxcIl0pO1xuYW5ndWxhci5tb2R1bGUoJ3VpLmJvb3RzdHJhcC5jb2xsYXBzZScsIFtdKVxuXG4gIC5kaXJlY3RpdmUoJ3VpYkNvbGxhcHNlJywgWyckYW5pbWF0ZScsICckcScsICckcGFyc2UnLCAnJGluamVjdG9yJywgZnVuY3Rpb24oJGFuaW1hdGUsICRxLCAkcGFyc2UsICRpbmplY3Rvcikge1xuICAgIHZhciAkYW5pbWF0ZUNzcyA9ICRpbmplY3Rvci5oYXMoJyRhbmltYXRlQ3NzJykgPyAkaW5qZWN0b3IuZ2V0KCckYW5pbWF0ZUNzcycpIDogbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgICAgIHZhciBleHBhbmRpbmdFeHByID0gJHBhcnNlKGF0dHJzLmV4cGFuZGluZyksXG4gICAgICAgICAgZXhwYW5kZWRFeHByID0gJHBhcnNlKGF0dHJzLmV4cGFuZGVkKSxcbiAgICAgICAgICBjb2xsYXBzaW5nRXhwciA9ICRwYXJzZShhdHRycy5jb2xsYXBzaW5nKSxcbiAgICAgICAgICBjb2xsYXBzZWRFeHByID0gJHBhcnNlKGF0dHJzLmNvbGxhcHNlZCksXG4gICAgICAgICAgaG9yaXpvbnRhbCA9IGZhbHNlLFxuICAgICAgICAgIGNzcyA9IHt9LFxuICAgICAgICAgIGNzc1RvID0ge307XG5cbiAgICAgICAgaW5pdCgpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICAgICAgaG9yaXpvbnRhbCA9ICEhKCdob3Jpem9udGFsJyBpbiBhdHRycyk7XG4gICAgICAgICAgaWYgKGhvcml6b250YWwpIHtcbiAgICAgICAgICAgIGNzcyA9IHtcbiAgICAgICAgICAgICAgd2lkdGg6ICcnXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY3NzVG8gPSB7d2lkdGg6ICcwJ307XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNzcyA9IHtcbiAgICAgICAgICAgICAgaGVpZ2h0OiAnJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNzc1RvID0ge2hlaWdodDogJzAnfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFzY29wZS4kZXZhbChhdHRycy51aWJDb2xsYXBzZSkpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuYWRkQ2xhc3MoJ2luJylcbiAgICAgICAgICAgICAgLmFkZENsYXNzKCdjb2xsYXBzZScpXG4gICAgICAgICAgICAgIC5hdHRyKCdhcmlhLWV4cGFuZGVkJywgdHJ1ZSlcbiAgICAgICAgICAgICAgLmF0dHIoJ2FyaWEtaGlkZGVuJywgZmFsc2UpXG4gICAgICAgICAgICAgIC5jc3MoY3NzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBnZXRTY3JvbGxGcm9tRWxlbWVudChlbGVtZW50KSB7XG4gICAgICAgICAgaWYgKGhvcml6b250YWwpIHtcbiAgICAgICAgICAgIHJldHVybiB7d2lkdGg6IGVsZW1lbnQuc2Nyb2xsV2lkdGggKyAncHgnfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHtoZWlnaHQ6IGVsZW1lbnQuc2Nyb2xsSGVpZ2h0ICsgJ3B4J307XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBleHBhbmQoKSB7XG4gICAgICAgICAgaWYgKGVsZW1lbnQuaGFzQ2xhc3MoJ2NvbGxhcHNlJykgJiYgZWxlbWVudC5oYXNDbGFzcygnaW4nKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgICRxLnJlc29sdmUoZXhwYW5kaW5nRXhwcihzY29wZSkpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVDbGFzcygnY29sbGFwc2UnKVxuICAgICAgICAgICAgICAgIC5hZGRDbGFzcygnY29sbGFwc2luZycpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCB0cnVlKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdhcmlhLWhpZGRlbicsIGZhbHNlKTtcblxuICAgICAgICAgICAgICBpZiAoJGFuaW1hdGVDc3MpIHtcbiAgICAgICAgICAgICAgICAkYW5pbWF0ZUNzcyhlbGVtZW50LCB7XG4gICAgICAgICAgICAgICAgICBhZGRDbGFzczogJ2luJyxcbiAgICAgICAgICAgICAgICAgIGVhc2luZzogJ2Vhc2UnLFxuICAgICAgICAgICAgICAgICAgY3NzOiB7XG4gICAgICAgICAgICAgICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJ1xuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHRvOiBnZXRTY3JvbGxGcm9tRWxlbWVudChlbGVtZW50WzBdKVxuICAgICAgICAgICAgICAgIH0pLnN0YXJ0KClbJ2ZpbmFsbHknXShleHBhbmREb25lKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkYW5pbWF0ZS5hZGRDbGFzcyhlbGVtZW50LCAnaW4nLCB7XG4gICAgICAgICAgICAgICAgICBjc3M6IHtcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgdG86IGdldFNjcm9sbEZyb21FbGVtZW50KGVsZW1lbnRbMF0pXG4gICAgICAgICAgICAgICAgfSkudGhlbihleHBhbmREb25lKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgYW5ndWxhci5ub29wKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGV4cGFuZERvbmUoKSB7XG4gICAgICAgICAgZWxlbWVudC5yZW1vdmVDbGFzcygnY29sbGFwc2luZycpXG4gICAgICAgICAgICAuYWRkQ2xhc3MoJ2NvbGxhcHNlJylcbiAgICAgICAgICAgIC5jc3MoY3NzKTtcbiAgICAgICAgICBleHBhbmRlZEV4cHIoc2NvcGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY29sbGFwc2UoKSB7XG4gICAgICAgICAgaWYgKCFlbGVtZW50Lmhhc0NsYXNzKCdjb2xsYXBzZScpICYmICFlbGVtZW50Lmhhc0NsYXNzKCdpbicpKSB7XG4gICAgICAgICAgICByZXR1cm4gY29sbGFwc2VEb25lKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgJHEucmVzb2x2ZShjb2xsYXBzaW5nRXhwcihzY29wZSkpXG4gICAgICAgICAgICAudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgZWxlbWVudFxuICAgICAgICAgICAgICAvLyBJTVBPUlRBTlQ6IFRoZSB3aWR0aCBtdXN0IGJlIHNldCBiZWZvcmUgYWRkaW5nIFwiY29sbGFwc2luZ1wiIGNsYXNzLlxuICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIHRoZSBicm93c2VyIGF0dGVtcHRzIHRvIGFuaW1hdGUgZnJvbSB3aWR0aCAwIChpblxuICAgICAgICAgICAgICAvLyBjb2xsYXBzaW5nIGNsYXNzKSB0byB0aGUgZ2l2ZW4gd2lkdGggaGVyZS5cbiAgICAgICAgICAgICAgICAuY3NzKGdldFNjcm9sbEZyb21FbGVtZW50KGVsZW1lbnRbMF0pKVxuICAgICAgICAgICAgICAgIC8vIGluaXRpYWxseSBhbGwgcGFuZWwgY29sbGFwc2UgaGF2ZSB0aGUgY29sbGFwc2UgY2xhc3MsIHRoaXMgcmVtb3ZhbFxuICAgICAgICAgICAgICAgIC8vIHByZXZlbnRzIHRoZSBhbmltYXRpb24gZnJvbSBqdW1waW5nIHRvIGNvbGxhcHNlZCBzdGF0ZVxuICAgICAgICAgICAgICAgIC5yZW1vdmVDbGFzcygnY29sbGFwc2UnKVxuICAgICAgICAgICAgICAgIC5hZGRDbGFzcygnY29sbGFwc2luZycpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCBmYWxzZSlcbiAgICAgICAgICAgICAgICAuYXR0cignYXJpYS1oaWRkZW4nLCB0cnVlKTtcblxuICAgICAgICAgICAgICBpZiAoJGFuaW1hdGVDc3MpIHtcbiAgICAgICAgICAgICAgICAkYW5pbWF0ZUNzcyhlbGVtZW50LCB7XG4gICAgICAgICAgICAgICAgICByZW1vdmVDbGFzczogJ2luJyxcbiAgICAgICAgICAgICAgICAgIHRvOiBjc3NUb1xuICAgICAgICAgICAgICAgIH0pLnN0YXJ0KClbJ2ZpbmFsbHknXShjb2xsYXBzZURvbmUpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICRhbmltYXRlLnJlbW92ZUNsYXNzKGVsZW1lbnQsICdpbicsIHtcbiAgICAgICAgICAgICAgICAgIHRvOiBjc3NUb1xuICAgICAgICAgICAgICAgIH0pLnRoZW4oY29sbGFwc2VEb25lKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgYW5ndWxhci5ub29wKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNvbGxhcHNlRG9uZSgpIHtcbiAgICAgICAgICBlbGVtZW50LmNzcyhjc3NUbyk7IC8vIFJlcXVpcmVkIHNvIHRoYXQgY29sbGFwc2Ugd29ya3Mgd2hlbiBhbmltYXRpb24gaXMgZGlzYWJsZWRcbiAgICAgICAgICBlbGVtZW50LnJlbW92ZUNsYXNzKCdjb2xsYXBzaW5nJylcbiAgICAgICAgICAgIC5hZGRDbGFzcygnY29sbGFwc2UnKTtcbiAgICAgICAgICBjb2xsYXBzZWRFeHByKHNjb3BlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNjb3BlLiR3YXRjaChhdHRycy51aWJDb2xsYXBzZSwgZnVuY3Rpb24oc2hvdWxkQ29sbGFwc2UpIHtcbiAgICAgICAgICBpZiAoc2hvdWxkQ29sbGFwc2UpIHtcbiAgICAgICAgICAgIGNvbGxhcHNlKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4cGFuZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfV0pO1xuXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLnRhYmluZGV4JywgW10pXG5cbi5kaXJlY3RpdmUoJ3VpYlRhYmluZGV4VG9nZ2xlJywgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgcmVzdHJpY3Q6ICdBJyxcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbSwgYXR0cnMpIHtcbiAgICAgIGF0dHJzLiRvYnNlcnZlKCdkaXNhYmxlZCcsIGZ1bmN0aW9uKGRpc2FibGVkKSB7XG4gICAgICAgIGF0dHJzLiRzZXQoJ3RhYmluZGV4JywgZGlzYWJsZWQgPyAtMSA6IG51bGwpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xufSk7XG5cbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAuYWNjb3JkaW9uJywgWyd1aS5ib290c3RyYXAuY29sbGFwc2UnLCAndWkuYm9vdHN0cmFwLnRhYmluZGV4J10pXG5cbi5jb25zdGFudCgndWliQWNjb3JkaW9uQ29uZmlnJywge1xuICBjbG9zZU90aGVyczogdHJ1ZVxufSlcblxuLmNvbnRyb2xsZXIoJ1VpYkFjY29yZGlvbkNvbnRyb2xsZXInLCBbJyRzY29wZScsICckYXR0cnMnLCAndWliQWNjb3JkaW9uQ29uZmlnJywgZnVuY3Rpb24oJHNjb3BlLCAkYXR0cnMsIGFjY29yZGlvbkNvbmZpZykge1xuICAvLyBUaGlzIGFycmF5IGtlZXBzIHRyYWNrIG9mIHRoZSBhY2NvcmRpb24gZ3JvdXBzXG4gIHRoaXMuZ3JvdXBzID0gW107XG5cbiAgLy8gRW5zdXJlIHRoYXQgYWxsIHRoZSBncm91cHMgaW4gdGhpcyBhY2NvcmRpb24gYXJlIGNsb3NlZCwgdW5sZXNzIGNsb3NlLW90aGVycyBleHBsaWNpdGx5IHNheXMgbm90IHRvXG4gIHRoaXMuY2xvc2VPdGhlcnMgPSBmdW5jdGlvbihvcGVuR3JvdXApIHtcbiAgICB2YXIgY2xvc2VPdGhlcnMgPSBhbmd1bGFyLmlzRGVmaW5lZCgkYXR0cnMuY2xvc2VPdGhlcnMpID9cbiAgICAgICRzY29wZS4kZXZhbCgkYXR0cnMuY2xvc2VPdGhlcnMpIDogYWNjb3JkaW9uQ29uZmlnLmNsb3NlT3RoZXJzO1xuICAgIGlmIChjbG9zZU90aGVycykge1xuICAgICAgYW5ndWxhci5mb3JFYWNoKHRoaXMuZ3JvdXBzLCBmdW5jdGlvbihncm91cCkge1xuICAgICAgICBpZiAoZ3JvdXAgIT09IG9wZW5Hcm91cCkge1xuICAgICAgICAgIGdyb3VwLmlzT3BlbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgLy8gVGhpcyBpcyBjYWxsZWQgZnJvbSB0aGUgYWNjb3JkaW9uLWdyb3VwIGRpcmVjdGl2ZSB0byBhZGQgaXRzZWxmIHRvIHRoZSBhY2NvcmRpb25cbiAgdGhpcy5hZGRHcm91cCA9IGZ1bmN0aW9uKGdyb3VwU2NvcGUpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgdGhpcy5ncm91cHMucHVzaChncm91cFNjb3BlKTtcblxuICAgIGdyb3VwU2NvcGUuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICB0aGF0LnJlbW92ZUdyb3VwKGdyb3VwU2NvcGUpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIFRoaXMgaXMgY2FsbGVkIGZyb20gdGhlIGFjY29yZGlvbi1ncm91cCBkaXJlY3RpdmUgd2hlbiB0byByZW1vdmUgaXRzZWxmXG4gIHRoaXMucmVtb3ZlR3JvdXAgPSBmdW5jdGlvbihncm91cCkge1xuICAgIHZhciBpbmRleCA9IHRoaXMuZ3JvdXBzLmluZGV4T2YoZ3JvdXApO1xuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIHRoaXMuZ3JvdXBzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICB9O1xufV0pXG5cbi8vIFRoZSBhY2NvcmRpb24gZGlyZWN0aXZlIHNpbXBseSBzZXRzIHVwIHRoZSBkaXJlY3RpdmUgY29udHJvbGxlclxuLy8gYW5kIGFkZHMgYW4gYWNjb3JkaW9uIENTUyBjbGFzcyB0byBpdHNlbGYgZWxlbWVudC5cbi5kaXJlY3RpdmUoJ3VpYkFjY29yZGlvbicsIGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIGNvbnRyb2xsZXI6ICdVaWJBY2NvcmRpb25Db250cm9sbGVyJyxcbiAgICBjb250cm9sbGVyQXM6ICdhY2NvcmRpb24nLFxuICAgIHRyYW5zY2x1ZGU6IHRydWUsXG4gICAgdGVtcGxhdGVVcmw6IGZ1bmN0aW9uKGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgICByZXR1cm4gYXR0cnMudGVtcGxhdGVVcmwgfHwgJ3VpYi90ZW1wbGF0ZS9hY2NvcmRpb24vYWNjb3JkaW9uLmh0bWwnO1xuICAgIH1cbiAgfTtcbn0pXG5cbi8vIFRoZSBhY2NvcmRpb24tZ3JvdXAgZGlyZWN0aXZlIGluZGljYXRlcyBhIGJsb2NrIG9mIGh0bWwgdGhhdCB3aWxsIGV4cGFuZCBhbmQgY29sbGFwc2UgaW4gYW4gYWNjb3JkaW9uXG4uZGlyZWN0aXZlKCd1aWJBY2NvcmRpb25Hcm91cCcsIGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHJlcXVpcmU6ICdedWliQWNjb3JkaW9uJywgICAgICAgICAvLyBXZSBuZWVkIHRoaXMgZGlyZWN0aXZlIHRvIGJlIGluc2lkZSBhbiBhY2NvcmRpb25cbiAgICB0cmFuc2NsdWRlOiB0cnVlLCAgICAgICAgICAgICAgLy8gSXQgdHJhbnNjbHVkZXMgdGhlIGNvbnRlbnRzIG9mIHRoZSBkaXJlY3RpdmUgaW50byB0aGUgdGVtcGxhdGVcbiAgICByZXN0cmljdDogJ0EnLFxuICAgIHRlbXBsYXRlVXJsOiBmdW5jdGlvbihlbGVtZW50LCBhdHRycykge1xuICAgICAgcmV0dXJuIGF0dHJzLnRlbXBsYXRlVXJsIHx8ICd1aWIvdGVtcGxhdGUvYWNjb3JkaW9uL2FjY29yZGlvbi1ncm91cC5odG1sJztcbiAgICB9LFxuICAgIHNjb3BlOiB7XG4gICAgICBoZWFkaW5nOiAnQCcsICAgICAgICAgICAgICAgLy8gSW50ZXJwb2xhdGUgdGhlIGhlYWRpbmcgYXR0cmlidXRlIG9udG8gdGhpcyBzY29wZVxuICAgICAgcGFuZWxDbGFzczogJ0A/JywgICAgICAgICAgIC8vIERpdHRvIHdpdGggcGFuZWxDbGFzc1xuICAgICAgaXNPcGVuOiAnPT8nLFxuICAgICAgaXNEaXNhYmxlZDogJz0/J1xuICAgIH0sXG4gICAgY29udHJvbGxlcjogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnNldEhlYWRpbmcgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgIHRoaXMuaGVhZGluZyA9IGVsZW1lbnQ7XG4gICAgICB9O1xuICAgIH0sXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBhY2NvcmRpb25DdHJsKSB7XG4gICAgICBlbGVtZW50LmFkZENsYXNzKCdwYW5lbCcpO1xuICAgICAgYWNjb3JkaW9uQ3RybC5hZGRHcm91cChzY29wZSk7XG5cbiAgICAgIHNjb3BlLm9wZW5DbGFzcyA9IGF0dHJzLm9wZW5DbGFzcyB8fCAncGFuZWwtb3Blbic7XG4gICAgICBzY29wZS5wYW5lbENsYXNzID0gYXR0cnMucGFuZWxDbGFzcyB8fCAncGFuZWwtZGVmYXVsdCc7XG4gICAgICBzY29wZS4kd2F0Y2goJ2lzT3BlbicsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGVsZW1lbnQudG9nZ2xlQ2xhc3Moc2NvcGUub3BlbkNsYXNzLCAhIXZhbHVlKTtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgYWNjb3JkaW9uQ3RybC5jbG9zZU90aGVycyhzY29wZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBzY29wZS50b2dnbGVPcGVuID0gZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgIGlmICghc2NvcGUuaXNEaXNhYmxlZCkge1xuICAgICAgICAgIGlmICghJGV2ZW50IHx8ICRldmVudC53aGljaCA9PT0gMzIpIHtcbiAgICAgICAgICAgIHNjb3BlLmlzT3BlbiA9ICFzY29wZS5pc09wZW47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB2YXIgaWQgPSAnYWNjb3JkaW9uZ3JvdXAtJyArIHNjb3BlLiRpZCArICctJyArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwKTtcbiAgICAgIHNjb3BlLmhlYWRpbmdJZCA9IGlkICsgJy10YWInO1xuICAgICAgc2NvcGUucGFuZWxJZCA9IGlkICsgJy1wYW5lbCc7XG4gICAgfVxuICB9O1xufSlcblxuLy8gVXNlIGFjY29yZGlvbi1oZWFkaW5nIGJlbG93IGFuIGFjY29yZGlvbi1ncm91cCB0byBwcm92aWRlIGEgaGVhZGluZyBjb250YWluaW5nIEhUTUxcbi5kaXJlY3RpdmUoJ3VpYkFjY29yZGlvbkhlYWRpbmcnLCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICB0cmFuc2NsdWRlOiB0cnVlLCAgIC8vIEdyYWIgdGhlIGNvbnRlbnRzIHRvIGJlIHVzZWQgYXMgdGhlIGhlYWRpbmdcbiAgICB0ZW1wbGF0ZTogJycsICAgICAgIC8vIEluIGVmZmVjdCByZW1vdmUgdGhpcyBlbGVtZW50IVxuICAgIHJlcGxhY2U6IHRydWUsXG4gICAgcmVxdWlyZTogJ151aWJBY2NvcmRpb25Hcm91cCcsXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBhY2NvcmRpb25Hcm91cEN0cmwsIHRyYW5zY2x1ZGUpIHtcbiAgICAgIC8vIFBhc3MgdGhlIGhlYWRpbmcgdG8gdGhlIGFjY29yZGlvbi1ncm91cCBjb250cm9sbGVyXG4gICAgICAvLyBzbyB0aGF0IGl0IGNhbiBiZSB0cmFuc2NsdWRlZCBpbnRvIHRoZSByaWdodCBwbGFjZSBpbiB0aGUgdGVtcGxhdGVcbiAgICAgIC8vIFtUaGUgc2Vjb25kIHBhcmFtZXRlciB0byB0cmFuc2NsdWRlIGNhdXNlcyB0aGUgZWxlbWVudHMgdG8gYmUgY2xvbmVkIHNvIHRoYXQgdGhleSB3b3JrIGluIG5nLXJlcGVhdF1cbiAgICAgIGFjY29yZGlvbkdyb3VwQ3RybC5zZXRIZWFkaW5nKHRyYW5zY2x1ZGUoc2NvcGUsIGFuZ3VsYXIubm9vcCkpO1xuICAgIH1cbiAgfTtcbn0pXG5cbi8vIFVzZSBpbiB0aGUgYWNjb3JkaW9uLWdyb3VwIHRlbXBsYXRlIHRvIGluZGljYXRlIHdoZXJlIHlvdSB3YW50IHRoZSBoZWFkaW5nIHRvIGJlIHRyYW5zY2x1ZGVkXG4vLyBZb3UgbXVzdCBwcm92aWRlIHRoZSBwcm9wZXJ0eSBvbiB0aGUgYWNjb3JkaW9uLWdyb3VwIGNvbnRyb2xsZXIgdGhhdCB3aWxsIGhvbGQgdGhlIHRyYW5zY2x1ZGVkIGVsZW1lbnRcbi5kaXJlY3RpdmUoJ3VpYkFjY29yZGlvblRyYW5zY2x1ZGUnLCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICByZXF1aXJlOiAnXnVpYkFjY29yZGlvbkdyb3VwJyxcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIGNvbnRyb2xsZXIpIHtcbiAgICAgIHNjb3BlLiR3YXRjaChmdW5jdGlvbigpIHsgcmV0dXJuIGNvbnRyb2xsZXJbYXR0cnMudWliQWNjb3JkaW9uVHJhbnNjbHVkZV07IH0sIGZ1bmN0aW9uKGhlYWRpbmcpIHtcbiAgICAgICAgaWYgKGhlYWRpbmcpIHtcbiAgICAgICAgICB2YXIgZWxlbSA9IGFuZ3VsYXIuZWxlbWVudChlbGVtZW50WzBdLnF1ZXJ5U2VsZWN0b3IoZ2V0SGVhZGVyU2VsZWN0b3JzKCkpKTtcbiAgICAgICAgICBlbGVtLmh0bWwoJycpO1xuICAgICAgICAgIGVsZW0uYXBwZW5kKGhlYWRpbmcpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gZ2V0SGVhZGVyU2VsZWN0b3JzKCkge1xuICAgICAgcmV0dXJuICd1aWItYWNjb3JkaW9uLWhlYWRlciwnICtcbiAgICAgICAgICAnZGF0YS11aWItYWNjb3JkaW9uLWhlYWRlciwnICtcbiAgICAgICAgICAneC11aWItYWNjb3JkaW9uLWhlYWRlciwnICtcbiAgICAgICAgICAndWliXFxcXDphY2NvcmRpb24taGVhZGVyLCcgK1xuICAgICAgICAgICdbdWliLWFjY29yZGlvbi1oZWFkZXJdLCcgK1xuICAgICAgICAgICdbZGF0YS11aWItYWNjb3JkaW9uLWhlYWRlcl0sJyArXG4gICAgICAgICAgJ1t4LXVpYi1hY2NvcmRpb24taGVhZGVyXSc7XG4gIH1cbn0pO1xuXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLmFsZXJ0JywgW10pXG5cbi5jb250cm9sbGVyKCdVaWJBbGVydENvbnRyb2xsZXInLCBbJyRzY29wZScsICckZWxlbWVudCcsICckYXR0cnMnLCAnJGludGVycG9sYXRlJywgJyR0aW1lb3V0JywgZnVuY3Rpb24oJHNjb3BlLCAkZWxlbWVudCwgJGF0dHJzLCAkaW50ZXJwb2xhdGUsICR0aW1lb3V0KSB7XG4gICRzY29wZS5jbG9zZWFibGUgPSAhISRhdHRycy5jbG9zZTtcbiAgJGVsZW1lbnQuYWRkQ2xhc3MoJ2FsZXJ0Jyk7XG4gICRhdHRycy4kc2V0KCdyb2xlJywgJ2FsZXJ0Jyk7XG4gIGlmICgkc2NvcGUuY2xvc2VhYmxlKSB7XG4gICAgJGVsZW1lbnQuYWRkQ2xhc3MoJ2FsZXJ0LWRpc21pc3NpYmxlJyk7XG4gIH1cblxuICB2YXIgZGlzbWlzc09uVGltZW91dCA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRhdHRycy5kaXNtaXNzT25UaW1lb3V0KSA/XG4gICAgJGludGVycG9sYXRlKCRhdHRycy5kaXNtaXNzT25UaW1lb3V0KSgkc2NvcGUuJHBhcmVudCkgOiBudWxsO1xuXG4gIGlmIChkaXNtaXNzT25UaW1lb3V0KSB7XG4gICAgJHRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAkc2NvcGUuY2xvc2UoKTtcbiAgICB9LCBwYXJzZUludChkaXNtaXNzT25UaW1lb3V0LCAxMCkpO1xuICB9XG59XSlcblxuLmRpcmVjdGl2ZSgndWliQWxlcnQnLCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICBjb250cm9sbGVyOiAnVWliQWxlcnRDb250cm9sbGVyJyxcbiAgICBjb250cm9sbGVyQXM6ICdhbGVydCcsXG4gICAgcmVzdHJpY3Q6ICdBJyxcbiAgICB0ZW1wbGF0ZVVybDogZnVuY3Rpb24oZWxlbWVudCwgYXR0cnMpIHtcbiAgICAgIHJldHVybiBhdHRycy50ZW1wbGF0ZVVybCB8fCAndWliL3RlbXBsYXRlL2FsZXJ0L2FsZXJ0Lmh0bWwnO1xuICAgIH0sXG4gICAgdHJhbnNjbHVkZTogdHJ1ZSxcbiAgICBzY29wZToge1xuICAgICAgY2xvc2U6ICcmJ1xuICAgIH1cbiAgfTtcbn0pO1xuXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLmJ1dHRvbnMnLCBbXSlcblxuLmNvbnN0YW50KCd1aWJCdXR0b25Db25maWcnLCB7XG4gIGFjdGl2ZUNsYXNzOiAnYWN0aXZlJyxcbiAgdG9nZ2xlRXZlbnQ6ICdjbGljaydcbn0pXG5cbi5jb250cm9sbGVyKCdVaWJCdXR0b25zQ29udHJvbGxlcicsIFsndWliQnV0dG9uQ29uZmlnJywgZnVuY3Rpb24oYnV0dG9uQ29uZmlnKSB7XG4gIHRoaXMuYWN0aXZlQ2xhc3MgPSBidXR0b25Db25maWcuYWN0aXZlQ2xhc3MgfHwgJ2FjdGl2ZSc7XG4gIHRoaXMudG9nZ2xlRXZlbnQgPSBidXR0b25Db25maWcudG9nZ2xlRXZlbnQgfHwgJ2NsaWNrJztcbn1dKVxuXG4uZGlyZWN0aXZlKCd1aWJCdG5SYWRpbycsIFsnJHBhcnNlJywgZnVuY3Rpb24oJHBhcnNlKSB7XG4gIHJldHVybiB7XG4gICAgcmVxdWlyZTogWyd1aWJCdG5SYWRpbycsICduZ01vZGVsJ10sXG4gICAgY29udHJvbGxlcjogJ1VpYkJ1dHRvbnNDb250cm9sbGVyJyxcbiAgICBjb250cm9sbGVyQXM6ICdidXR0b25zJyxcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIGN0cmxzKSB7XG4gICAgICB2YXIgYnV0dG9uc0N0cmwgPSBjdHJsc1swXSwgbmdNb2RlbEN0cmwgPSBjdHJsc1sxXTtcbiAgICAgIHZhciB1bmNoZWNrYWJsZUV4cHIgPSAkcGFyc2UoYXR0cnMudWliVW5jaGVja2FibGUpO1xuXG4gICAgICBlbGVtZW50LmZpbmQoJ2lucHV0JykuY3NzKHtkaXNwbGF5OiAnbm9uZSd9KTtcblxuICAgICAgLy9tb2RlbCAtPiBVSVxuICAgICAgbmdNb2RlbEN0cmwuJHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBlbGVtZW50LnRvZ2dsZUNsYXNzKGJ1dHRvbnNDdHJsLmFjdGl2ZUNsYXNzLCBhbmd1bGFyLmVxdWFscyhuZ01vZGVsQ3RybC4kbW9kZWxWYWx1ZSwgc2NvcGUuJGV2YWwoYXR0cnMudWliQnRuUmFkaW8pKSk7XG4gICAgICB9O1xuXG4gICAgICAvL3VpLT5tb2RlbFxuICAgICAgZWxlbWVudC5vbihidXR0b25zQ3RybC50b2dnbGVFdmVudCwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChhdHRycy5kaXNhYmxlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpc0FjdGl2ZSA9IGVsZW1lbnQuaGFzQ2xhc3MoYnV0dG9uc0N0cmwuYWN0aXZlQ2xhc3MpO1xuXG4gICAgICAgIGlmICghaXNBY3RpdmUgfHwgYW5ndWxhci5pc0RlZmluZWQoYXR0cnMudW5jaGVja2FibGUpKSB7XG4gICAgICAgICAgc2NvcGUuJGFwcGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgbmdNb2RlbEN0cmwuJHNldFZpZXdWYWx1ZShpc0FjdGl2ZSA/IG51bGwgOiBzY29wZS4kZXZhbChhdHRycy51aWJCdG5SYWRpbykpO1xuICAgICAgICAgICAgbmdNb2RlbEN0cmwuJHJlbmRlcigpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKGF0dHJzLnVpYlVuY2hlY2thYmxlKSB7XG4gICAgICAgIHNjb3BlLiR3YXRjaCh1bmNoZWNrYWJsZUV4cHIsIGZ1bmN0aW9uKHVuY2hlY2thYmxlKSB7XG4gICAgICAgICAgYXR0cnMuJHNldCgndW5jaGVja2FibGUnLCB1bmNoZWNrYWJsZSA/ICcnIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufV0pXG5cbi5kaXJlY3RpdmUoJ3VpYkJ0bkNoZWNrYm94JywgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgcmVxdWlyZTogWyd1aWJCdG5DaGVja2JveCcsICduZ01vZGVsJ10sXG4gICAgY29udHJvbGxlcjogJ1VpYkJ1dHRvbnNDb250cm9sbGVyJyxcbiAgICBjb250cm9sbGVyQXM6ICdidXR0b24nLFxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgY3RybHMpIHtcbiAgICAgIHZhciBidXR0b25zQ3RybCA9IGN0cmxzWzBdLCBuZ01vZGVsQ3RybCA9IGN0cmxzWzFdO1xuXG4gICAgICBlbGVtZW50LmZpbmQoJ2lucHV0JykuY3NzKHtkaXNwbGF5OiAnbm9uZSd9KTtcblxuICAgICAgZnVuY3Rpb24gZ2V0VHJ1ZVZhbHVlKCkge1xuICAgICAgICByZXR1cm4gZ2V0Q2hlY2tib3hWYWx1ZShhdHRycy5idG5DaGVja2JveFRydWUsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBnZXRGYWxzZVZhbHVlKCkge1xuICAgICAgICByZXR1cm4gZ2V0Q2hlY2tib3hWYWx1ZShhdHRycy5idG5DaGVja2JveEZhbHNlLCBmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGdldENoZWNrYm94VmFsdWUoYXR0cmlidXRlLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGFuZ3VsYXIuaXNEZWZpbmVkKGF0dHJpYnV0ZSkgPyBzY29wZS4kZXZhbChhdHRyaWJ1dGUpIDogZGVmYXVsdFZhbHVlO1xuICAgICAgfVxuXG4gICAgICAvL21vZGVsIC0+IFVJXG4gICAgICBuZ01vZGVsQ3RybC4kcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGVsZW1lbnQudG9nZ2xlQ2xhc3MoYnV0dG9uc0N0cmwuYWN0aXZlQ2xhc3MsIGFuZ3VsYXIuZXF1YWxzKG5nTW9kZWxDdHJsLiRtb2RlbFZhbHVlLCBnZXRUcnVlVmFsdWUoKSkpO1xuICAgICAgfTtcblxuICAgICAgLy91aS0+bW9kZWxcbiAgICAgIGVsZW1lbnQub24oYnV0dG9uc0N0cmwudG9nZ2xlRXZlbnQsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoYXR0cnMuZGlzYWJsZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBzY29wZS4kYXBwbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgbmdNb2RlbEN0cmwuJHNldFZpZXdWYWx1ZShlbGVtZW50Lmhhc0NsYXNzKGJ1dHRvbnNDdHJsLmFjdGl2ZUNsYXNzKSA/IGdldEZhbHNlVmFsdWUoKSA6IGdldFRydWVWYWx1ZSgpKTtcbiAgICAgICAgICBuZ01vZGVsQ3RybC4kcmVuZGVyKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xufSk7XG5cbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAuY2Fyb3VzZWwnLCBbXSlcblxuLmNvbnRyb2xsZXIoJ1VpYkNhcm91c2VsQ29udHJvbGxlcicsIFsnJHNjb3BlJywgJyRlbGVtZW50JywgJyRpbnRlcnZhbCcsICckdGltZW91dCcsICckYW5pbWF0ZScsIGZ1bmN0aW9uKCRzY29wZSwgJGVsZW1lbnQsICRpbnRlcnZhbCwgJHRpbWVvdXQsICRhbmltYXRlKSB7XG4gIHZhciBzZWxmID0gdGhpcyxcbiAgICBzbGlkZXMgPSBzZWxmLnNsaWRlcyA9ICRzY29wZS5zbGlkZXMgPSBbXSxcbiAgICBTTElERV9ESVJFQ1RJT04gPSAndWliLXNsaWRlRGlyZWN0aW9uJyxcbiAgICBjdXJyZW50SW5kZXggPSAkc2NvcGUuYWN0aXZlLFxuICAgIGN1cnJlbnRJbnRlcnZhbCwgaXNQbGF5aW5nO1xuXG4gIHZhciBkZXN0cm95ZWQgPSBmYWxzZTtcbiAgJGVsZW1lbnQuYWRkQ2xhc3MoJ2Nhcm91c2VsJyk7XG5cbiAgc2VsZi5hZGRTbGlkZSA9IGZ1bmN0aW9uKHNsaWRlLCBlbGVtZW50KSB7XG4gICAgc2xpZGVzLnB1c2goe1xuICAgICAgc2xpZGU6IHNsaWRlLFxuICAgICAgZWxlbWVudDogZWxlbWVudFxuICAgIH0pO1xuICAgIHNsaWRlcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgIHJldHVybiArYS5zbGlkZS5pbmRleCAtICtiLnNsaWRlLmluZGV4O1xuICAgIH0pO1xuICAgIC8vaWYgdGhpcyBpcyB0aGUgZmlyc3Qgc2xpZGUgb3IgdGhlIHNsaWRlIGlzIHNldCB0byBhY3RpdmUsIHNlbGVjdCBpdFxuICAgIGlmIChzbGlkZS5pbmRleCA9PT0gJHNjb3BlLmFjdGl2ZSB8fCBzbGlkZXMubGVuZ3RoID09PSAxICYmICFhbmd1bGFyLmlzTnVtYmVyKCRzY29wZS5hY3RpdmUpKSB7XG4gICAgICBpZiAoJHNjb3BlLiRjdXJyZW50VHJhbnNpdGlvbikge1xuICAgICAgICAkc2NvcGUuJGN1cnJlbnRUcmFuc2l0aW9uID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgY3VycmVudEluZGV4ID0gc2xpZGUuaW5kZXg7XG4gICAgICAkc2NvcGUuYWN0aXZlID0gc2xpZGUuaW5kZXg7XG4gICAgICBzZXRBY3RpdmUoY3VycmVudEluZGV4KTtcbiAgICAgIHNlbGYuc2VsZWN0KHNsaWRlc1tmaW5kU2xpZGVJbmRleChzbGlkZSldKTtcbiAgICAgIGlmIChzbGlkZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICRzY29wZS5wbGF5KCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHNlbGYuZ2V0Q3VycmVudEluZGV4ID0gZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGlkZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChzbGlkZXNbaV0uc2xpZGUuaW5kZXggPT09IGN1cnJlbnRJbmRleCkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgc2VsZi5uZXh0ID0gJHNjb3BlLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbmV3SW5kZXggPSAoc2VsZi5nZXRDdXJyZW50SW5kZXgoKSArIDEpICUgc2xpZGVzLmxlbmd0aDtcblxuICAgIGlmIChuZXdJbmRleCA9PT0gMCAmJiAkc2NvcGUubm9XcmFwKCkpIHtcbiAgICAgICRzY29wZS5wYXVzZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHJldHVybiBzZWxmLnNlbGVjdChzbGlkZXNbbmV3SW5kZXhdLCAnbmV4dCcpO1xuICB9O1xuXG4gIHNlbGYucHJldiA9ICRzY29wZS5wcmV2ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG5ld0luZGV4ID0gc2VsZi5nZXRDdXJyZW50SW5kZXgoKSAtIDEgPCAwID8gc2xpZGVzLmxlbmd0aCAtIDEgOiBzZWxmLmdldEN1cnJlbnRJbmRleCgpIC0gMTtcblxuICAgIGlmICgkc2NvcGUubm9XcmFwKCkgJiYgbmV3SW5kZXggPT09IHNsaWRlcy5sZW5ndGggLSAxKSB7XG4gICAgICAkc2NvcGUucGF1c2UoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZi5zZWxlY3Qoc2xpZGVzW25ld0luZGV4XSwgJ3ByZXYnKTtcbiAgfTtcblxuICBzZWxmLnJlbW92ZVNsaWRlID0gZnVuY3Rpb24oc2xpZGUpIHtcbiAgICB2YXIgaW5kZXggPSBmaW5kU2xpZGVJbmRleChzbGlkZSk7XG5cbiAgICAvL2dldCB0aGUgaW5kZXggb2YgdGhlIHNsaWRlIGluc2lkZSB0aGUgY2Fyb3VzZWxcbiAgICBzbGlkZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICBpZiAoc2xpZGVzLmxlbmd0aCA+IDAgJiYgY3VycmVudEluZGV4ID09PSBpbmRleCkge1xuICAgICAgaWYgKGluZGV4ID49IHNsaWRlcy5sZW5ndGgpIHtcbiAgICAgICAgY3VycmVudEluZGV4ID0gc2xpZGVzLmxlbmd0aCAtIDE7XG4gICAgICAgICRzY29wZS5hY3RpdmUgPSBjdXJyZW50SW5kZXg7XG4gICAgICAgIHNldEFjdGl2ZShjdXJyZW50SW5kZXgpO1xuICAgICAgICBzZWxmLnNlbGVjdChzbGlkZXNbc2xpZGVzLmxlbmd0aCAtIDFdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnRJbmRleCA9IGluZGV4O1xuICAgICAgICAkc2NvcGUuYWN0aXZlID0gY3VycmVudEluZGV4O1xuICAgICAgICBzZXRBY3RpdmUoY3VycmVudEluZGV4KTtcbiAgICAgICAgc2VsZi5zZWxlY3Qoc2xpZGVzW2luZGV4XSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjdXJyZW50SW5kZXggPiBpbmRleCkge1xuICAgICAgY3VycmVudEluZGV4LS07XG4gICAgICAkc2NvcGUuYWN0aXZlID0gY3VycmVudEluZGV4O1xuICAgIH1cblxuICAgIC8vY2xlYW4gdGhlIGFjdGl2ZSB2YWx1ZSB3aGVuIG5vIG1vcmUgc2xpZGVcbiAgICBpZiAoc2xpZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY3VycmVudEluZGV4ID0gbnVsbDtcbiAgICAgICRzY29wZS5hY3RpdmUgPSBudWxsO1xuICAgIH1cbiAgfTtcblxuICAvKiBkaXJlY3Rpb246IFwicHJldlwiIG9yIFwibmV4dFwiICovXG4gIHNlbGYuc2VsZWN0ID0gJHNjb3BlLnNlbGVjdCA9IGZ1bmN0aW9uKG5leHRTbGlkZSwgZGlyZWN0aW9uKSB7XG4gICAgdmFyIG5leHRJbmRleCA9IGZpbmRTbGlkZUluZGV4KG5leHRTbGlkZS5zbGlkZSk7XG4gICAgLy9EZWNpZGUgZGlyZWN0aW9uIGlmIGl0J3Mgbm90IGdpdmVuXG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBkaXJlY3Rpb24gPSBuZXh0SW5kZXggPiBzZWxmLmdldEN1cnJlbnRJbmRleCgpID8gJ25leHQnIDogJ3ByZXYnO1xuICAgIH1cbiAgICAvL1ByZXZlbnQgdGhpcyB1c2VyLXRyaWdnZXJlZCB0cmFuc2l0aW9uIGZyb20gb2NjdXJyaW5nIGlmIHRoZXJlIGlzIGFscmVhZHkgb25lIGluIHByb2dyZXNzXG4gICAgaWYgKG5leHRTbGlkZS5zbGlkZS5pbmRleCAhPT0gY3VycmVudEluZGV4ICYmXG4gICAgICAhJHNjb3BlLiRjdXJyZW50VHJhbnNpdGlvbikge1xuICAgICAgZ29OZXh0KG5leHRTbGlkZS5zbGlkZSwgbmV4dEluZGV4LCBkaXJlY3Rpb24pO1xuICAgIH1cbiAgfTtcblxuICAvKiBBbGxvdyBvdXRzaWRlIHBlb3BsZSB0byBjYWxsIGluZGV4T2Ygb24gc2xpZGVzIGFycmF5ICovXG4gICRzY29wZS5pbmRleE9mU2xpZGUgPSBmdW5jdGlvbihzbGlkZSkge1xuICAgIHJldHVybiArc2xpZGUuc2xpZGUuaW5kZXg7XG4gIH07XG5cbiAgJHNjb3BlLmlzQWN0aXZlID0gZnVuY3Rpb24oc2xpZGUpIHtcbiAgICByZXR1cm4gJHNjb3BlLmFjdGl2ZSA9PT0gc2xpZGUuc2xpZGUuaW5kZXg7XG4gIH07XG5cbiAgJHNjb3BlLmlzUHJldkRpc2FibGVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICRzY29wZS5hY3RpdmUgPT09IDAgJiYgJHNjb3BlLm5vV3JhcCgpO1xuICB9O1xuXG4gICRzY29wZS5pc05leHREaXNhYmxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAkc2NvcGUuYWN0aXZlID09PSBzbGlkZXMubGVuZ3RoIC0gMSAmJiAkc2NvcGUubm9XcmFwKCk7XG4gIH07XG5cbiAgJHNjb3BlLnBhdXNlID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCEkc2NvcGUubm9QYXVzZSkge1xuICAgICAgaXNQbGF5aW5nID0gZmFsc2U7XG4gICAgICByZXNldFRpbWVyKCk7XG4gICAgfVxuICB9O1xuXG4gICRzY29wZS5wbGF5ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCFpc1BsYXlpbmcpIHtcbiAgICAgIGlzUGxheWluZyA9IHRydWU7XG4gICAgICByZXN0YXJ0VGltZXIoKTtcbiAgICB9XG4gIH07XG5cbiAgJGVsZW1lbnQub24oJ21vdXNlZW50ZXInLCAkc2NvcGUucGF1c2UpO1xuICAkZWxlbWVudC5vbignbW91c2VsZWF2ZScsICRzY29wZS5wbGF5KTtcblxuICAkc2NvcGUuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uKCkge1xuICAgIGRlc3Ryb3llZCA9IHRydWU7XG4gICAgcmVzZXRUaW1lcigpO1xuICB9KTtcblxuICAkc2NvcGUuJHdhdGNoKCdub1RyYW5zaXRpb24nLCBmdW5jdGlvbihub1RyYW5zaXRpb24pIHtcbiAgICAkYW5pbWF0ZS5lbmFibGVkKCRlbGVtZW50LCAhbm9UcmFuc2l0aW9uKTtcbiAgfSk7XG5cbiAgJHNjb3BlLiR3YXRjaCgnaW50ZXJ2YWwnLCByZXN0YXJ0VGltZXIpO1xuXG4gICRzY29wZS4kd2F0Y2hDb2xsZWN0aW9uKCdzbGlkZXMnLCByZXNldFRyYW5zaXRpb24pO1xuXG4gICRzY29wZS4kd2F0Y2goJ2FjdGl2ZScsIGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgaWYgKGFuZ3VsYXIuaXNOdW1iZXIoaW5kZXgpICYmIGN1cnJlbnRJbmRleCAhPT0gaW5kZXgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChzbGlkZXNbaV0uc2xpZGUuaW5kZXggPT09IGluZGV4KSB7XG4gICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBzbGlkZSA9IHNsaWRlc1tpbmRleF07XG4gICAgICBpZiAoc2xpZGUpIHtcbiAgICAgICAgc2V0QWN0aXZlKGluZGV4KTtcbiAgICAgICAgc2VsZi5zZWxlY3Qoc2xpZGVzW2luZGV4XSk7XG4gICAgICAgIGN1cnJlbnRJbmRleCA9IGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgZnVuY3Rpb24gZ2V0U2xpZGVCeUluZGV4KGluZGV4KSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBzbGlkZXMubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgICBpZiAoc2xpZGVzW2ldLmluZGV4ID09PSBpbmRleCkge1xuICAgICAgICByZXR1cm4gc2xpZGVzW2ldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldEFjdGl2ZShpbmRleCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzbGlkZXNbaV0uc2xpZGUuYWN0aXZlID0gaSA9PT0gaW5kZXg7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ29OZXh0KHNsaWRlLCBpbmRleCwgZGlyZWN0aW9uKSB7XG4gICAgaWYgKGRlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGFuZ3VsYXIuZXh0ZW5kKHNsaWRlLCB7ZGlyZWN0aW9uOiBkaXJlY3Rpb259KTtcbiAgICBhbmd1bGFyLmV4dGVuZChzbGlkZXNbY3VycmVudEluZGV4XS5zbGlkZSB8fCB7fSwge2RpcmVjdGlvbjogZGlyZWN0aW9ufSk7XG4gICAgaWYgKCRhbmltYXRlLmVuYWJsZWQoJGVsZW1lbnQpICYmICEkc2NvcGUuJGN1cnJlbnRUcmFuc2l0aW9uICYmXG4gICAgICBzbGlkZXNbaW5kZXhdLmVsZW1lbnQgJiYgc2VsZi5zbGlkZXMubGVuZ3RoID4gMSkge1xuICAgICAgc2xpZGVzW2luZGV4XS5lbGVtZW50LmRhdGEoU0xJREVfRElSRUNUSU9OLCBzbGlkZS5kaXJlY3Rpb24pO1xuICAgICAgdmFyIGN1cnJlbnRJZHggPSBzZWxmLmdldEN1cnJlbnRJbmRleCgpO1xuXG4gICAgICBpZiAoYW5ndWxhci5pc051bWJlcihjdXJyZW50SWR4KSAmJiBzbGlkZXNbY3VycmVudElkeF0uZWxlbWVudCkge1xuICAgICAgICBzbGlkZXNbY3VycmVudElkeF0uZWxlbWVudC5kYXRhKFNMSURFX0RJUkVDVElPTiwgc2xpZGUuZGlyZWN0aW9uKTtcbiAgICAgIH1cblxuICAgICAgJHNjb3BlLiRjdXJyZW50VHJhbnNpdGlvbiA9IHRydWU7XG4gICAgICAkYW5pbWF0ZS5vbignYWRkQ2xhc3MnLCBzbGlkZXNbaW5kZXhdLmVsZW1lbnQsIGZ1bmN0aW9uKGVsZW1lbnQsIHBoYXNlKSB7XG4gICAgICAgIGlmIChwaGFzZSA9PT0gJ2Nsb3NlJykge1xuICAgICAgICAgICRzY29wZS4kY3VycmVudFRyYW5zaXRpb24gPSBudWxsO1xuICAgICAgICAgICRhbmltYXRlLm9mZignYWRkQ2xhc3MnLCBlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgJHNjb3BlLmFjdGl2ZSA9IHNsaWRlLmluZGV4O1xuICAgIGN1cnJlbnRJbmRleCA9IHNsaWRlLmluZGV4O1xuICAgIHNldEFjdGl2ZShpbmRleCk7XG5cbiAgICAvL2V2ZXJ5IHRpbWUgeW91IGNoYW5nZSBzbGlkZXMsIHJlc2V0IHRoZSB0aW1lclxuICAgIHJlc3RhcnRUaW1lcigpO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluZFNsaWRlSW5kZXgoc2xpZGUpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHNsaWRlc1tpXS5zbGlkZSA9PT0gc2xpZGUpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUaW1lcigpIHtcbiAgICBpZiAoY3VycmVudEludGVydmFsKSB7XG4gICAgICAkaW50ZXJ2YWwuY2FuY2VsKGN1cnJlbnRJbnRlcnZhbCk7XG4gICAgICBjdXJyZW50SW50ZXJ2YWwgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJhbnNpdGlvbihzbGlkZXMpIHtcbiAgICBpZiAoIXNsaWRlcy5sZW5ndGgpIHtcbiAgICAgICRzY29wZS4kY3VycmVudFRyYW5zaXRpb24gPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc3RhcnRUaW1lcigpIHtcbiAgICByZXNldFRpbWVyKCk7XG4gICAgdmFyIGludGVydmFsID0gKyRzY29wZS5pbnRlcnZhbDtcbiAgICBpZiAoIWlzTmFOKGludGVydmFsKSAmJiBpbnRlcnZhbCA+IDApIHtcbiAgICAgIGN1cnJlbnRJbnRlcnZhbCA9ICRpbnRlcnZhbCh0aW1lckZuLCBpbnRlcnZhbCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdGltZXJGbigpIHtcbiAgICB2YXIgaW50ZXJ2YWwgPSArJHNjb3BlLmludGVydmFsO1xuICAgIGlmIChpc1BsYXlpbmcgJiYgIWlzTmFOKGludGVydmFsKSAmJiBpbnRlcnZhbCA+IDAgJiYgc2xpZGVzLmxlbmd0aCkge1xuICAgICAgJHNjb3BlLm5leHQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgJHNjb3BlLnBhdXNlKCk7XG4gICAgfVxuICB9XG59XSlcblxuLmRpcmVjdGl2ZSgndWliQ2Fyb3VzZWwnLCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICB0cmFuc2NsdWRlOiB0cnVlLFxuICAgIGNvbnRyb2xsZXI6ICdVaWJDYXJvdXNlbENvbnRyb2xsZXInLFxuICAgIGNvbnRyb2xsZXJBczogJ2Nhcm91c2VsJyxcbiAgICByZXN0cmljdDogJ0EnLFxuICAgIHRlbXBsYXRlVXJsOiBmdW5jdGlvbihlbGVtZW50LCBhdHRycykge1xuICAgICAgcmV0dXJuIGF0dHJzLnRlbXBsYXRlVXJsIHx8ICd1aWIvdGVtcGxhdGUvY2Fyb3VzZWwvY2Fyb3VzZWwuaHRtbCc7XG4gICAgfSxcbiAgICBzY29wZToge1xuICAgICAgYWN0aXZlOiAnPScsXG4gICAgICBpbnRlcnZhbDogJz0nLFxuICAgICAgbm9UcmFuc2l0aW9uOiAnPScsXG4gICAgICBub1BhdXNlOiAnPScsXG4gICAgICBub1dyYXA6ICcmJ1xuICAgIH1cbiAgfTtcbn0pXG5cbi5kaXJlY3RpdmUoJ3VpYlNsaWRlJywgWyckYW5pbWF0ZScsIGZ1bmN0aW9uKCRhbmltYXRlKSB7XG4gIHJldHVybiB7XG4gICAgcmVxdWlyZTogJ151aWJDYXJvdXNlbCcsXG4gICAgcmVzdHJpY3Q6ICdBJyxcbiAgICB0cmFuc2NsdWRlOiB0cnVlLFxuICAgIHRlbXBsYXRlVXJsOiBmdW5jdGlvbihlbGVtZW50LCBhdHRycykge1xuICAgICAgcmV0dXJuIGF0dHJzLnRlbXBsYXRlVXJsIHx8ICd1aWIvdGVtcGxhdGUvY2Fyb3VzZWwvc2xpZGUuaHRtbCc7XG4gICAgfSxcbiAgICBzY29wZToge1xuICAgICAgYWN0dWFsOiAnPT8nLFxuICAgICAgaW5kZXg6ICc9PydcbiAgICB9LFxuICAgIGxpbms6IGZ1bmN0aW9uIChzY29wZSwgZWxlbWVudCwgYXR0cnMsIGNhcm91c2VsQ3RybCkge1xuICAgICAgZWxlbWVudC5hZGRDbGFzcygnaXRlbScpO1xuICAgICAgY2Fyb3VzZWxDdHJsLmFkZFNsaWRlKHNjb3BlLCBlbGVtZW50KTtcbiAgICAgIC8vd2hlbiB0aGUgc2NvcGUgaXMgZGVzdHJveWVkIHRoZW4gcmVtb3ZlIHRoZSBzbGlkZSBmcm9tIHRoZSBjdXJyZW50IHNsaWRlcyBhcnJheVxuICAgICAgc2NvcGUuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uKCkge1xuICAgICAgICBjYXJvdXNlbEN0cmwucmVtb3ZlU2xpZGUoc2NvcGUpO1xuICAgICAgfSk7XG5cbiAgICAgIHNjb3BlLiR3YXRjaCgnYWN0aXZlJywgZnVuY3Rpb24oYWN0aXZlKSB7XG4gICAgICAgICRhbmltYXRlW2FjdGl2ZSA/ICdhZGRDbGFzcycgOiAncmVtb3ZlQ2xhc3MnXShlbGVtZW50LCAnYWN0aXZlJyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59XSlcblxuLmFuaW1hdGlvbignLml0ZW0nLCBbJyRhbmltYXRlQ3NzJyxcbmZ1bmN0aW9uKCRhbmltYXRlQ3NzKSB7XG4gIHZhciBTTElERV9ESVJFQ1RJT04gPSAndWliLXNsaWRlRGlyZWN0aW9uJztcblxuICBmdW5jdGlvbiByZW1vdmVDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUsIGNhbGxiYWNrKSB7XG4gICAgZWxlbWVudC5yZW1vdmVDbGFzcyhjbGFzc05hbWUpO1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGJlZm9yZUFkZENsYXNzOiBmdW5jdGlvbihlbGVtZW50LCBjbGFzc05hbWUsIGRvbmUpIHtcbiAgICAgIGlmIChjbGFzc05hbWUgPT09ICdhY3RpdmUnKSB7XG4gICAgICAgIHZhciBzdG9wcGVkID0gZmFsc2U7XG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSBlbGVtZW50LmRhdGEoU0xJREVfRElSRUNUSU9OKTtcbiAgICAgICAgdmFyIGRpcmVjdGlvbkNsYXNzID0gZGlyZWN0aW9uID09PSAnbmV4dCcgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgICAgICB2YXIgcmVtb3ZlQ2xhc3NGbiA9IHJlbW92ZUNsYXNzLmJpbmQodGhpcywgZWxlbWVudCxcbiAgICAgICAgICBkaXJlY3Rpb25DbGFzcyArICcgJyArIGRpcmVjdGlvbiwgZG9uZSk7XG4gICAgICAgIGVsZW1lbnQuYWRkQ2xhc3MoZGlyZWN0aW9uKTtcblxuICAgICAgICAkYW5pbWF0ZUNzcyhlbGVtZW50LCB7YWRkQ2xhc3M6IGRpcmVjdGlvbkNsYXNzfSlcbiAgICAgICAgICAuc3RhcnQoKVxuICAgICAgICAgIC5kb25lKHJlbW92ZUNsYXNzRm4pO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBzdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGRvbmUoKTtcbiAgICB9LFxuICAgIGJlZm9yZVJlbW92ZUNsYXNzOiBmdW5jdGlvbiAoZWxlbWVudCwgY2xhc3NOYW1lLCBkb25lKSB7XG4gICAgICBpZiAoY2xhc3NOYW1lID09PSAnYWN0aXZlJykge1xuICAgICAgICB2YXIgc3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgZGlyZWN0aW9uID0gZWxlbWVudC5kYXRhKFNMSURFX0RJUkVDVElPTik7XG4gICAgICAgIHZhciBkaXJlY3Rpb25DbGFzcyA9IGRpcmVjdGlvbiA9PT0gJ25leHQnID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICAgICAgdmFyIHJlbW92ZUNsYXNzRm4gPSByZW1vdmVDbGFzcy5iaW5kKHRoaXMsIGVsZW1lbnQsIGRpcmVjdGlvbkNsYXNzLCBkb25lKTtcblxuICAgICAgICAkYW5pbWF0ZUNzcyhlbGVtZW50LCB7YWRkQ2xhc3M6IGRpcmVjdGlvbkNsYXNzfSlcbiAgICAgICAgICAuc3RhcnQoKVxuICAgICAgICAgIC5kb25lKHJlbW92ZUNsYXNzRm4pO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBzdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGRvbmUoKTtcbiAgICB9XG4gIH07XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAuZGF0ZXBhcnNlcicsIFtdKVxuXG4uc2VydmljZSgndWliRGF0ZVBhcnNlcicsIFsnJGxvZycsICckbG9jYWxlJywgJ2RhdGVGaWx0ZXInLCAnb3JkZXJCeUZpbHRlcicsICdmaWx0ZXJGaWx0ZXInLCBmdW5jdGlvbigkbG9nLCAkbG9jYWxlLCBkYXRlRmlsdGVyLCBvcmRlckJ5RmlsdGVyLCBmaWx0ZXJGaWx0ZXIpIHtcbiAgLy8gUHVsbGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL21ib3N0b2NrL2QzL2Jsb2IvbWFzdGVyL3NyYy9mb3JtYXQvcmVxdW90ZS5qc1xuICB2YXIgU1BFQ0lBTF9DSEFSQUNURVJTX1JFR0VYUCA9IC9bXFxcXFxcXlxcJFxcKlxcK1xcP1xcfFxcW1xcXVxcKFxcKVxcLlxce1xcfV0vZztcblxuICB2YXIgbG9jYWxlSWQ7XG4gIHZhciBmb3JtYXRDb2RlVG9SZWdleDtcblxuICB0aGlzLmluaXQgPSBmdW5jdGlvbigpIHtcbiAgICBsb2NhbGVJZCA9ICRsb2NhbGUuaWQ7XG5cbiAgICB0aGlzLnBhcnNlcnMgPSB7fTtcbiAgICB0aGlzLmZvcm1hdHRlcnMgPSB7fTtcblxuICAgIGZvcm1hdENvZGVUb1JlZ2V4ID0gW1xuICAgICAge1xuICAgICAgICBrZXk6ICd5eXl5JyxcbiAgICAgICAgcmVnZXg6ICdcXFxcZHs0fScsXG4gICAgICAgIGFwcGx5OiBmdW5jdGlvbih2YWx1ZSkgeyB0aGlzLnllYXIgPSArdmFsdWU7IH0sXG4gICAgICAgIGZvcm1hdHRlcjogZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgICAgIHZhciBfZGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgX2RhdGUuc2V0RnVsbFllYXIoTWF0aC5hYnMoZGF0ZS5nZXRGdWxsWWVhcigpKSk7XG4gICAgICAgICAgcmV0dXJuIGRhdGVGaWx0ZXIoX2RhdGUsICd5eXl5Jyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGtleTogJ3l5JyxcbiAgICAgICAgcmVnZXg6ICdcXFxcZHsyfScsXG4gICAgICAgIGFwcGx5OiBmdW5jdGlvbih2YWx1ZSkgeyB2YWx1ZSA9ICt2YWx1ZTsgdGhpcy55ZWFyID0gdmFsdWUgPCA2OSA/IHZhbHVlICsgMjAwMCA6IHZhbHVlICsgMTkwMDsgfSxcbiAgICAgICAgZm9ybWF0dGVyOiBmdW5jdGlvbihkYXRlKSB7XG4gICAgICAgICAgdmFyIF9kYXRlID0gbmV3IERhdGUoKTtcbiAgICAgICAgICBfZGF0ZS5zZXRGdWxsWWVhcihNYXRoLmFicyhkYXRlLmdldEZ1bGxZZWFyKCkpKTtcbiAgICAgICAgICByZXR1cm4gZGF0ZUZpbHRlcihfZGF0ZSwgJ3l5Jyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGtleTogJ3knLFxuICAgICAgICByZWdleDogJ1xcXFxkezEsNH0nLFxuICAgICAgICBhcHBseTogZnVuY3Rpb24odmFsdWUpIHsgdGhpcy55ZWFyID0gK3ZhbHVlOyB9LFxuICAgICAgICBmb3JtYXR0ZXI6IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgICAgICB2YXIgX2RhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgIF9kYXRlLnNldEZ1bGxZZWFyKE1hdGguYWJzKGRhdGUuZ2V0RnVsbFllYXIoKSkpO1xuICAgICAgICAgIHJldHVybiBkYXRlRmlsdGVyKF9kYXRlLCAneScpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBrZXk6ICdNIScsXG4gICAgICAgIHJlZ2V4OiAnMD9bMS05XXwxWzAtMl0nLFxuICAgICAgICBhcHBseTogZnVuY3Rpb24odmFsdWUpIHsgdGhpcy5tb250aCA9IHZhbHVlIC0gMTsgfSxcbiAgICAgICAgZm9ybWF0dGVyOiBmdW5jdGlvbihkYXRlKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gZGF0ZS5nZXRNb250aCgpO1xuICAgICAgICAgIGlmICgvXlswLTldJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRlRmlsdGVyKGRhdGUsICdNTScpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBkYXRlRmlsdGVyKGRhdGUsICdNJyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGtleTogJ01NTU0nLFxuICAgICAgICByZWdleDogJGxvY2FsZS5EQVRFVElNRV9GT1JNQVRTLk1PTlRILmpvaW4oJ3wnKSxcbiAgICAgICAgYXBwbHk6IGZ1bmN0aW9uKHZhbHVlKSB7IHRoaXMubW9udGggPSAkbG9jYWxlLkRBVEVUSU1FX0ZPUk1BVFMuTU9OVEguaW5kZXhPZih2YWx1ZSk7IH0sXG4gICAgICAgIGZvcm1hdHRlcjogZnVuY3Rpb24oZGF0ZSkgeyByZXR1cm4gZGF0ZUZpbHRlcihkYXRlLCAnTU1NTScpOyB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBrZXk6ICdNTU0nLFxuICAgICAgICByZWdleDogJGxvY2FsZS5EQVRFVElNRV9GT1JNQVRTLlNIT1JUTU9OVEguam9pbignfCcpLFxuICAgICAgICBhcHBseTogZnVuY3Rpb24odmFsdWUpIHsgdGhpcy5tb250aCA9ICRsb2NhbGUuREFURVRJTUVfRk9STUFUUy5TSE9SVE1PTlRILmluZGV4T2YodmFsdWUpOyB9LFxuICAgICAgICBmb3JtYXR0ZXI6IGZ1bmN0aW9uKGRhdGUpIHsgcmV0dXJuIGRhdGVGaWx0ZXIoZGF0ZSwgJ01NTScpOyB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBrZXk6ICdNTScsXG4gICAgICAgIHJlZ2V4OiAnMFsxLTldfDFbMC0yXScsXG4gICAgICAgIGFwcGx5OiBmdW5jdGlvbih2YWx1ZSkgeyB0aGlzLm1vbnRoID0gdmFsdWUgLSAxOyB9LFxuICAgICAgICBmb3JtYXR0ZXI6IGZ1bmN0aW9uKGRhdGUpIHsgcmV0dXJuIGRhdGVGaWx0ZXIoZGF0ZSwgJ01NJyk7IH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGtleTogJ00nLFxuICAgICAgICByZWdleDogJ1sxLTldfDFbMC0yXScsXG4gICAgICAgIGFwcGx5OiBmdW5jdGlvbih2YWx1ZSkgeyB0aGlzLm1vbnRoID0gdmFsdWUgLSAxOyB9LFxuICAgICAgICBmb3JtYXR0ZXI6IGZ1bmN0aW9uKGRhdGUpIHsgcmV0dXJuIGRhdGVGaWx0ZXIoZGF0ZSwgJ00nKTsgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAga2V5OiAnZCEnLFxuICAgICAgICByZWdleDogJ1swLTJdP1swLTldezF9fDNbMC0xXXsxfScsXG4gICAgICAgIGFwcGx5OiBmdW5jdGlvbih2YWx1ZSkgeyB0aGlzLmRhdGUgPSArdmFsdWU7IH0sXG4gICAgICAgIGZvcm1hdHRlcjogZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGRhdGUuZ2V0RGF0ZSgpO1xuICAgICAgICAgIGlmICgvXlsxLTldJC8udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRlRmlsdGVyKGRhdGUsICdkZCcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBkYXRlRmlsdGVyKGRhdGUsICdkJyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGtleTogJ2RkJyxcbiAgICAgICAgcmVnZXg6ICdbMC0yXVswLTldezF9fDNbMC0xXXsxfScsXG4gICAgICAgIGFwcGx5OiBmdW5jdGlvbih2YWx1ZSkgeyB0aGlzLmRhdGUgPSArdmFsdWU7IH0sXG4gICAgICAgIGZvcm1hdHRlcjogZnVuY3Rpb24oZGF0ZSkgeyByZXR1cm4gZGF0ZUZpbHRlcihkYXRlLCAnZGQnKTsgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAga2V5OiAnZCcsXG4gICAgICAgIHJlZ2V4OiAnWzEtMl0/WzAtOV17MX18M1swLTFdezF9JyxcbiAgICAgICAgYXBwbHk6IGZ1bmN0aW9uKHZhbHVlKSB7IHRoaXMuZGF0ZSA9ICt2YWx1ZTsgfSxcbiAgICAgICAgZm9ybWF0dGVyOiBmdW5jdGlvbihkYXRlKSB7IHJldHVybiBkYXRlRmlsdGVyKGRhdGUsICdkJyk7IH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGtleTogJ0VFRUUnLFxuICAgICAgICByZWdleDogJGxvY2FsZS5EQVRFVElNRV9GT1JNQVRTLkRBWS5qb2luKCd8JyksXG4gICAgICAgIGZvcm1hdHRlcjogZnVuY3Rpb24oZGF0ZSkgeyByZXR1cm4gZGF0ZUZpbHRlcihkYXRlLCAnRUVFRScpOyB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBrZXk6ICdFRUUnLFxuICAgICAgICByZWdleDogJGxvY2FsZS5EQVRFVElNRV9GT1JNQVRTLlNIT1JUREFZLmpvaW4oJ3wnKSxcbiAgICAgICAgZm9ybWF0dGVyOiBmdW5jdGlvbihkYXRlKSB7IHJldHVybiBkYXRlRmlsdGVyKGRhdGUsICdFRUUnKTsgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAga2V5OiAnSEgnLFxuICAgICAgICByZWdleDogJyg/OjB8MSlbMC05XXwyWzAtM10nLFxuICAgICAgICBhcHBseTogZnVuY3Rpb24odmFsdWUpIHsgdGhpcy5ob3VycyA9ICt2YWx1ZTsgfSxcbiAgICAgICAgZm9ybWF0dGVyOiBmdW5jdGlvbihkYXRlKSB7IHJldHVybiBkYXRlRmlsdGVyKGRhdGUsICdISCcpOyB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBrZXk6ICdoaCcsXG4gICAgICAgIHJlZ2V4OiAnMFswLTldfDFbMC0yXScsXG4gICAgICAgIGFwcGx5OiBmdW5jdGlvbih2YWx1ZSkgeyB0aGlzLmhvdXJzID0gK3ZhbHVlOyB9LFxuICAgICAgICBmb3JtYXR0ZXI6IGZ1bmN0aW9uKGRhdGUpIHsgcmV0dXJuIGRhdGVGaWx0ZXIoZGF0ZSwgJ2hoJyk7IH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGtleTogJ0gnLFxuICAgICAgICByZWdleDogJzE/WzAtOV18MlswLTNdJyxcbiAgICAgICAgYXBwbHk6IGZ1bmN0aW9uKHZhbHVlKSB7IHRoaXMuaG91cnMgPSArdmFsdWU7IH0sXG4gICAgICAgIGZvcm1hdHRlcjogZnVuY3Rpb24oZGF0ZSkgeyByZXR1cm4gZGF0ZUZpbHRlcihkYXRlLCAnSCcpOyB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBrZXk6ICdoJyxcbiAgICAgICAgcmVnZXg6ICdbMC05XXwxWzAtMl0nLFxuICAgICAgICBhcHBseTogZnVuY3Rpb24odmFsdWUpIHsgdGhpcy5ob3VycyA9ICt2YWx1ZTsgfSxcbiAgICAgICAgZm9ybWF0dGVyOiBmdW5jdGlvbihkYXRlKSB7IHJldHVybiBkYXRlRmlsdGVyKGRhdGUsICdoJyk7IH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGtleTogJ21tJyxcbiAgICAgICAgcmVnZXg6ICdbMC01XVswLTldJyxcbiAgICAgICAgYXBwbHk6IGZ1bmN0aW9uKHZhbHVlKSB7IHRoaXMubWludXRlcyA9ICt2YWx1ZTsgfSxcbiAgICAgICAgZm9ybWF0dGVyOiBmdW5jdGlvbihkYXRlKSB7IHJldHVybiBkYXRlRmlsdGVyKGRhdGUsICdtbScpOyB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBrZXk6ICdtJyxcbiAgICAgICAgcmVnZXg6ICdbMC05XXxbMS01XVswLTldJyxcbiAgICAgICAgYXBwbHk6IGZ1bmN0aW9uKHZhbHVlKSB7IHRoaXMubWludXRlcyA9ICt2YWx1ZTsgfSxcbiAgICAgICAgZm9ybWF0dGVyOiBmdW5jdGlvbihkYXRlKSB7IHJldHVybiBkYXRlRmlsdGVyKGRhdGUsICdtJyk7IH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGtleTogJ3NzcycsXG4gICAgICAgIHJlZ2V4OiAnWzAtOV1bMC05XVswLTldJyxcbiAgICAgICAgYXBwbHk6IGZ1bmN0aW9uKHZhbHVlKSB7IHRoaXMubWlsbGlzZWNvbmRzID0gK3ZhbHVlOyB9LFxuICAgICAgICBmb3JtYXR0ZXI6IGZ1bmN0aW9uKGRhdGUpIHsgcmV0dXJuIGRhdGVGaWx0ZXIoZGF0ZSwgJ3NzcycpOyB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBrZXk6ICdzcycsXG4gICAgICAgIHJlZ2V4OiAnWzAtNV1bMC05XScsXG4gICAgICAgIGFwcGx5OiBmdW5jdGlvbih2YWx1ZSkgeyB0aGlzLnNlY29uZHMgPSArdmFsdWU7IH0sXG4gICAgICAgIGZvcm1hdHRlcjogZnVuY3Rpb24oZGF0ZSkgeyByZXR1cm4gZGF0ZUZpbHRlcihkYXRlLCAnc3MnKTsgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAga2V5OiAncycsXG4gICAgICAgIHJlZ2V4OiAnWzAtOV18WzEtNV1bMC05XScsXG4gICAgICAgIGFwcGx5OiBmdW5jdGlvbih2YWx1ZSkgeyB0aGlzLnNlY29uZHMgPSArdmFsdWU7IH0sXG4gICAgICAgIGZvcm1hdHRlcjogZnVuY3Rpb24oZGF0ZSkgeyByZXR1cm4gZGF0ZUZpbHRlcihkYXRlLCAncycpOyB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBrZXk6ICdhJyxcbiAgICAgICAgcmVnZXg6ICRsb2NhbGUuREFURVRJTUVfRk9STUFUUy5BTVBNUy5qb2luKCd8JyksXG4gICAgICAgIGFwcGx5OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIGlmICh0aGlzLmhvdXJzID09PSAxMikge1xuICAgICAgICAgICAgdGhpcy5ob3VycyA9IDA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHZhbHVlID09PSAnUE0nKSB7XG4gICAgICAgICAgICB0aGlzLmhvdXJzICs9IDEyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZm9ybWF0dGVyOiBmdW5jdGlvbihkYXRlKSB7IHJldHVybiBkYXRlRmlsdGVyKGRhdGUsICdhJyk7IH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGtleTogJ1onLFxuICAgICAgICByZWdleDogJ1srLV1cXFxcZHs0fScsXG4gICAgICAgIGFwcGx5OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIHZhciBtYXRjaGVzID0gdmFsdWUubWF0Y2goLyhbKy1dKShcXGR7Mn0pKFxcZHsyfSkvKSxcbiAgICAgICAgICAgIHNpZ24gPSBtYXRjaGVzWzFdLFxuICAgICAgICAgICAgaG91cnMgPSBtYXRjaGVzWzJdLFxuICAgICAgICAgICAgbWludXRlcyA9IG1hdGNoZXNbM107XG4gICAgICAgICAgdGhpcy5ob3VycyArPSB0b0ludChzaWduICsgaG91cnMpO1xuICAgICAgICAgIHRoaXMubWludXRlcyArPSB0b0ludChzaWduICsgbWludXRlcyk7XG4gICAgICAgIH0sXG4gICAgICAgIGZvcm1hdHRlcjogZnVuY3Rpb24oZGF0ZSkge1xuICAgICAgICAgIHJldHVybiBkYXRlRmlsdGVyKGRhdGUsICdaJyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGtleTogJ3d3JyxcbiAgICAgICAgcmVnZXg6ICdbMC00XVswLTldfDVbMC0zXScsXG4gICAgICAgIGZvcm1hdHRlcjogZnVuY3Rpb24oZGF0ZSkgeyByZXR1cm4gZGF0ZUZpbHRlcihkYXRlLCAnd3cnKTsgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAga2V5OiAndycsXG4gICAgICAgIHJlZ2V4OiAnWzAtOV18WzEtNF1bMC05XXw1WzAtM10nLFxuICAgICAgICBmb3JtYXR0ZXI6IGZ1bmN0aW9uKGRhdGUpIHsgcmV0dXJuIGRhdGVGaWx0ZXIoZGF0ZSwgJ3cnKTsgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAga2V5OiAnR0dHRycsXG4gICAgICAgIHJlZ2V4OiAkbG9jYWxlLkRBVEVUSU1FX0ZPUk1BVFMuRVJBTkFNRVMuam9pbignfCcpLnJlcGxhY2UoL1xccy9nLCAnXFxcXHMnKSxcbiAgICAgICAgZm9ybWF0dGVyOiBmdW5jdGlvbihkYXRlKSB7IHJldHVybiBkYXRlRmlsdGVyKGRhdGUsICdHR0dHJyk7IH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGtleTogJ0dHRycsXG4gICAgICAgIHJlZ2V4OiAkbG9jYWxlLkRBVEVUSU1FX0ZPUk1BVFMuRVJBUy5qb2luKCd8JyksXG4gICAgICAgIGZvcm1hdHRlcjogZnVuY3Rpb24oZGF0ZSkgeyByZXR1cm4gZGF0ZUZpbHRlcihkYXRlLCAnR0dHJyk7IH1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGtleTogJ0dHJyxcbiAgICAgICAgcmVnZXg6ICRsb2NhbGUuREFURVRJTUVfRk9STUFUUy5FUkFTLmpvaW4oJ3wnKSxcbiAgICAgICAgZm9ybWF0dGVyOiBmdW5jdGlvbihkYXRlKSB7IHJldHVybiBkYXRlRmlsdGVyKGRhdGUsICdHRycpOyB9XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBrZXk6ICdHJyxcbiAgICAgICAgcmVnZXg6ICRsb2NhbGUuREFURVRJTUVfRk9STUFUUy5FUkFTLmpvaW4oJ3wnKSxcbiAgICAgICAgZm9ybWF0dGVyOiBmdW5jdGlvbihkYXRlKSB7IHJldHVybiBkYXRlRmlsdGVyKGRhdGUsICdHJyk7IH1cbiAgICAgIH1cbiAgICBdO1xuXG4gICAgaWYgKGFuZ3VsYXIudmVyc2lvbi5tYWpvciA+PSAxICYmIGFuZ3VsYXIudmVyc2lvbi5taW5vciA+IDQpIHtcbiAgICAgIGZvcm1hdENvZGVUb1JlZ2V4LnB1c2goe1xuICAgICAgICBrZXk6ICdMTExMJyxcbiAgICAgICAgcmVnZXg6ICRsb2NhbGUuREFURVRJTUVfRk9STUFUUy5TVEFOREFMT05FTU9OVEguam9pbignfCcpLFxuICAgICAgICBhcHBseTogZnVuY3Rpb24odmFsdWUpIHsgdGhpcy5tb250aCA9ICRsb2NhbGUuREFURVRJTUVfRk9STUFUUy5TVEFOREFMT05FTU9OVEguaW5kZXhPZih2YWx1ZSk7IH0sXG4gICAgICAgIGZvcm1hdHRlcjogZnVuY3Rpb24oZGF0ZSkgeyByZXR1cm4gZGF0ZUZpbHRlcihkYXRlLCAnTExMTCcpOyB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgdGhpcy5pbml0KCk7XG5cbiAgZnVuY3Rpb24gZ2V0Rm9ybWF0Q29kZVRvUmVnZXgoa2V5KSB7XG4gICAgcmV0dXJuIGZpbHRlckZpbHRlcihmb3JtYXRDb2RlVG9SZWdleCwge2tleToga2V5fSwgdHJ1ZSlbMF07XG4gIH1cblxuICB0aGlzLmdldFBhcnNlciA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgZiA9IGdldEZvcm1hdENvZGVUb1JlZ2V4KGtleSk7XG4gICAgcmV0dXJuIGYgJiYgZi5hcHBseSB8fCBudWxsO1xuICB9O1xuXG4gIHRoaXMub3ZlcnJpZGVQYXJzZXIgPSBmdW5jdGlvbiAoa2V5LCBwYXJzZXIpIHtcbiAgICB2YXIgZiA9IGdldEZvcm1hdENvZGVUb1JlZ2V4KGtleSk7XG4gICAgaWYgKGYgJiYgYW5ndWxhci5pc0Z1bmN0aW9uKHBhcnNlcikpIHtcbiAgICAgIHRoaXMucGFyc2VycyA9IHt9O1xuICAgICAgZi5hcHBseSA9IHBhcnNlcjtcbiAgICB9XG4gIH0uYmluZCh0aGlzKTtcblxuICBmdW5jdGlvbiBjcmVhdGVQYXJzZXIoZm9ybWF0KSB7XG4gICAgdmFyIG1hcCA9IFtdLCByZWdleCA9IGZvcm1hdC5zcGxpdCgnJyk7XG5cbiAgICAvLyBjaGVjayBmb3IgbGl0ZXJhbCB2YWx1ZXNcbiAgICB2YXIgcXVvdGVJbmRleCA9IGZvcm1hdC5pbmRleE9mKCdcXCcnKTtcbiAgICBpZiAocXVvdGVJbmRleCA+IC0xKSB7XG4gICAgICB2YXIgaW5MaXRlcmFsID0gZmFsc2U7XG4gICAgICBmb3JtYXQgPSBmb3JtYXQuc3BsaXQoJycpO1xuICAgICAgZm9yICh2YXIgaSA9IHF1b3RlSW5kZXg7IGkgPCBmb3JtYXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGluTGl0ZXJhbCkge1xuICAgICAgICAgIGlmIChmb3JtYXRbaV0gPT09ICdcXCcnKSB7XG4gICAgICAgICAgICBpZiAoaSArIDEgPCBmb3JtYXQubGVuZ3RoICYmIGZvcm1hdFtpKzFdID09PSAnXFwnJykgeyAvLyBlc2NhcGVkIHNpbmdsZSBxdW90ZVxuICAgICAgICAgICAgICBmb3JtYXRbaSsxXSA9ICckJztcbiAgICAgICAgICAgICAgcmVnZXhbaSsxXSA9ICcnO1xuICAgICAgICAgICAgfSBlbHNlIHsgLy8gZW5kIG9mIGxpdGVyYWxcbiAgICAgICAgICAgICAgcmVnZXhbaV0gPSAnJztcbiAgICAgICAgICAgICAgaW5MaXRlcmFsID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvcm1hdFtpXSA9ICckJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoZm9ybWF0W2ldID09PSAnXFwnJykgeyAvLyBzdGFydCBvZiBsaXRlcmFsXG4gICAgICAgICAgICBmb3JtYXRbaV0gPSAnJCc7XG4gICAgICAgICAgICByZWdleFtpXSA9ICcnO1xuICAgICAgICAgICAgaW5MaXRlcmFsID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9ybWF0ID0gZm9ybWF0LmpvaW4oJycpO1xuICAgIH1cblxuICAgIGFuZ3VsYXIuZm9yRWFjaChmb3JtYXRDb2RlVG9SZWdleCwgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgdmFyIGluZGV4ID0gZm9ybWF0LmluZGV4T2YoZGF0YS5rZXkpO1xuXG4gICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICBmb3JtYXQgPSBmb3JtYXQuc3BsaXQoJycpO1xuXG4gICAgICAgIHJlZ2V4W2luZGV4XSA9ICcoJyArIGRhdGEucmVnZXggKyAnKSc7XG4gICAgICAgIGZvcm1hdFtpbmRleF0gPSAnJCc7IC8vIEN1c3RvbSBzeW1ib2wgdG8gZGVmaW5lIGNvbnN1bWVkIHBhcnQgb2YgZm9ybWF0XG4gICAgICAgIGZvciAodmFyIGkgPSBpbmRleCArIDEsIG4gPSBpbmRleCArIGRhdGEua2V5Lmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgIHJlZ2V4W2ldID0gJyc7XG4gICAgICAgICAgZm9ybWF0W2ldID0gJyQnO1xuICAgICAgICB9XG4gICAgICAgIGZvcm1hdCA9IGZvcm1hdC5qb2luKCcnKTtcblxuICAgICAgICBtYXAucHVzaCh7XG4gICAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICAgIGtleTogZGF0YS5rZXksXG4gICAgICAgICAgYXBwbHk6IGRhdGEuYXBwbHksXG4gICAgICAgICAgbWF0Y2hlcjogZGF0YS5yZWdleFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB7XG4gICAgICByZWdleDogbmV3IFJlZ0V4cCgnXicgKyByZWdleC5qb2luKCcnKSArICckJyksXG4gICAgICBtYXA6IG9yZGVyQnlGaWx0ZXIobWFwLCAnaW5kZXgnKVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVGb3JtYXR0ZXIoZm9ybWF0KSB7XG4gICAgdmFyIGZvcm1hdHRlcnMgPSBbXTtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGZvcm1hdHRlciwgbGl0ZXJhbElkeDtcbiAgICB3aGlsZSAoaSA8IGZvcm1hdC5sZW5ndGgpIHtcbiAgICAgIGlmIChhbmd1bGFyLmlzTnVtYmVyKGxpdGVyYWxJZHgpKSB7XG4gICAgICAgIGlmIChmb3JtYXQuY2hhckF0KGkpID09PSAnXFwnJykge1xuICAgICAgICAgIGlmIChpICsgMSA+PSBmb3JtYXQubGVuZ3RoIHx8IGZvcm1hdC5jaGFyQXQoaSArIDEpICE9PSAnXFwnJykge1xuICAgICAgICAgICAgZm9ybWF0dGVycy5wdXNoKGNvbnN0cnVjdExpdGVyYWxGb3JtYXR0ZXIoZm9ybWF0LCBsaXRlcmFsSWR4LCBpKSk7XG4gICAgICAgICAgICBsaXRlcmFsSWR4ID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaSA9PT0gZm9ybWF0Lmxlbmd0aCkge1xuICAgICAgICAgIHdoaWxlIChsaXRlcmFsSWR4IDwgZm9ybWF0Lmxlbmd0aCkge1xuICAgICAgICAgICAgZm9ybWF0dGVyID0gY29uc3RydWN0Rm9ybWF0dGVyRnJvbUlkeChmb3JtYXQsIGxpdGVyYWxJZHgpO1xuICAgICAgICAgICAgZm9ybWF0dGVycy5wdXNoKGZvcm1hdHRlcik7XG4gICAgICAgICAgICBsaXRlcmFsSWR4ID0gZm9ybWF0dGVyLmVuZElkeDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpKys7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoZm9ybWF0LmNoYXJBdChpKSA9PT0gJ1xcJycpIHtcbiAgICAgICAgbGl0ZXJhbElkeCA9IGk7XG4gICAgICAgIGkrKztcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGZvcm1hdHRlciA9IGNvbnN0cnVjdEZvcm1hdHRlckZyb21JZHgoZm9ybWF0LCBpKTtcblxuICAgICAgZm9ybWF0dGVycy5wdXNoKGZvcm1hdHRlci5wYXJzZXIpO1xuICAgICAgaSA9IGZvcm1hdHRlci5lbmRJZHg7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZvcm1hdHRlcnM7XG4gIH1cblxuICBmdW5jdGlvbiBjb25zdHJ1Y3RMaXRlcmFsRm9ybWF0dGVyKGZvcm1hdCwgbGl0ZXJhbElkeCwgZW5kSWR4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZvcm1hdC5zdWJzdHIobGl0ZXJhbElkeCArIDEsIGVuZElkeCAtIGxpdGVyYWxJZHggLSAxKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gY29uc3RydWN0Rm9ybWF0dGVyRnJvbUlkeChmb3JtYXQsIGkpIHtcbiAgICB2YXIgY3VycmVudFBvc1N0ciA9IGZvcm1hdC5zdWJzdHIoaSk7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBmb3JtYXRDb2RlVG9SZWdleC5sZW5ndGg7IGorKykge1xuICAgICAgaWYgKG5ldyBSZWdFeHAoJ14nICsgZm9ybWF0Q29kZVRvUmVnZXhbal0ua2V5KS50ZXN0KGN1cnJlbnRQb3NTdHIpKSB7XG4gICAgICAgIHZhciBkYXRhID0gZm9ybWF0Q29kZVRvUmVnZXhbal07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZW5kSWR4OiBpICsgZGF0YS5rZXkubGVuZ3RoLFxuICAgICAgICAgIHBhcnNlcjogZGF0YS5mb3JtYXR0ZXJcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZW5kSWR4OiBpICsgMSxcbiAgICAgIHBhcnNlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50UG9zU3RyLmNoYXJBdCgwKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgdGhpcy5maWx0ZXIgPSBmdW5jdGlvbihkYXRlLCBmb3JtYXQpIHtcbiAgICBpZiAoIWFuZ3VsYXIuaXNEYXRlKGRhdGUpIHx8IGlzTmFOKGRhdGUpIHx8ICFmb3JtYXQpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICBmb3JtYXQgPSAkbG9jYWxlLkRBVEVUSU1FX0ZPUk1BVFNbZm9ybWF0XSB8fCBmb3JtYXQ7XG5cbiAgICBpZiAoJGxvY2FsZS5pZCAhPT0gbG9jYWxlSWQpIHtcbiAgICAgIHRoaXMuaW5pdCgpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5mb3JtYXR0ZXJzW2Zvcm1hdF0pIHtcbiAgICAgIHRoaXMuZm9ybWF0dGVyc1tmb3JtYXRdID0gY3JlYXRlRm9ybWF0dGVyKGZvcm1hdCk7XG4gICAgfVxuXG4gICAgdmFyIGZvcm1hdHRlcnMgPSB0aGlzLmZvcm1hdHRlcnNbZm9ybWF0XTtcblxuICAgIHJldHVybiBmb3JtYXR0ZXJzLnJlZHVjZShmdW5jdGlvbihzdHIsIGZvcm1hdHRlcikge1xuICAgICAgcmV0dXJuIHN0ciArIGZvcm1hdHRlcihkYXRlKTtcbiAgICB9LCAnJyk7XG4gIH07XG5cbiAgdGhpcy5wYXJzZSA9IGZ1bmN0aW9uKGlucHV0LCBmb3JtYXQsIGJhc2VEYXRlKSB7XG4gICAgaWYgKCFhbmd1bGFyLmlzU3RyaW5nKGlucHV0KSB8fCAhZm9ybWF0KSB7XG4gICAgICByZXR1cm4gaW5wdXQ7XG4gICAgfVxuXG4gICAgZm9ybWF0ID0gJGxvY2FsZS5EQVRFVElNRV9GT1JNQVRTW2Zvcm1hdF0gfHwgZm9ybWF0O1xuICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKFNQRUNJQUxfQ0hBUkFDVEVSU19SRUdFWFAsICdcXFxcJCYnKTtcblxuICAgIGlmICgkbG9jYWxlLmlkICE9PSBsb2NhbGVJZCkge1xuICAgICAgdGhpcy5pbml0KCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnBhcnNlcnNbZm9ybWF0XSkge1xuICAgICAgdGhpcy5wYXJzZXJzW2Zvcm1hdF0gPSBjcmVhdGVQYXJzZXIoZm9ybWF0LCAnYXBwbHknKTtcbiAgICB9XG5cbiAgICB2YXIgcGFyc2VyID0gdGhpcy5wYXJzZXJzW2Zvcm1hdF0sXG4gICAgICAgIHJlZ2V4ID0gcGFyc2VyLnJlZ2V4LFxuICAgICAgICBtYXAgPSBwYXJzZXIubWFwLFxuICAgICAgICByZXN1bHRzID0gaW5wdXQubWF0Y2gocmVnZXgpLFxuICAgICAgICB0ek9mZnNldCA9IGZhbHNlO1xuICAgIGlmIChyZXN1bHRzICYmIHJlc3VsdHMubGVuZ3RoKSB7XG4gICAgICB2YXIgZmllbGRzLCBkdDtcbiAgICAgIGlmIChhbmd1bGFyLmlzRGF0ZShiYXNlRGF0ZSkgJiYgIWlzTmFOKGJhc2VEYXRlLmdldFRpbWUoKSkpIHtcbiAgICAgICAgZmllbGRzID0ge1xuICAgICAgICAgIHllYXI6IGJhc2VEYXRlLmdldEZ1bGxZZWFyKCksXG4gICAgICAgICAgbW9udGg6IGJhc2VEYXRlLmdldE1vbnRoKCksXG4gICAgICAgICAgZGF0ZTogYmFzZURhdGUuZ2V0RGF0ZSgpLFxuICAgICAgICAgIGhvdXJzOiBiYXNlRGF0ZS5nZXRIb3VycygpLFxuICAgICAgICAgIG1pbnV0ZXM6IGJhc2VEYXRlLmdldE1pbnV0ZXMoKSxcbiAgICAgICAgICBzZWNvbmRzOiBiYXNlRGF0ZS5nZXRTZWNvbmRzKCksXG4gICAgICAgICAgbWlsbGlzZWNvbmRzOiBiYXNlRGF0ZS5nZXRNaWxsaXNlY29uZHMoKVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGJhc2VEYXRlKSB7XG4gICAgICAgICAgJGxvZy53YXJuKCdkYXRlcGFyc2VyOicsICdiYXNlRGF0ZSBpcyBub3QgYSB2YWxpZCBkYXRlJyk7XG4gICAgICAgIH1cbiAgICAgICAgZmllbGRzID0geyB5ZWFyOiAxOTAwLCBtb250aDogMCwgZGF0ZTogMSwgaG91cnM6IDAsIG1pbnV0ZXM6IDAsIHNlY29uZHM6IDAsIG1pbGxpc2Vjb25kczogMCB9O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMSwgbiA9IHJlc3VsdHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIHZhciBtYXBwZXIgPSBtYXBbaSAtIDFdO1xuICAgICAgICBpZiAobWFwcGVyLm1hdGNoZXIgPT09ICdaJykge1xuICAgICAgICAgIHR6T2Zmc2V0ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXBwZXIuYXBwbHkpIHtcbiAgICAgICAgICBtYXBwZXIuYXBwbHkuY2FsbChmaWVsZHMsIHJlc3VsdHNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBkYXRlc2V0dGVyID0gdHpPZmZzZXQgPyBEYXRlLnByb3RvdHlwZS5zZXRVVENGdWxsWWVhciA6XG4gICAgICAgIERhdGUucHJvdG90eXBlLnNldEZ1bGxZZWFyO1xuICAgICAgdmFyIHRpbWVzZXR0ZXIgPSB0ek9mZnNldCA/IERhdGUucHJvdG90eXBlLnNldFVUQ0hvdXJzIDpcbiAgICAgICAgRGF0ZS5wcm90b3R5cGUuc2V0SG91cnM7XG5cbiAgICAgIGlmIChpc1ZhbGlkKGZpZWxkcy55ZWFyLCBmaWVsZHMubW9udGgsIGZpZWxkcy5kYXRlKSkge1xuICAgICAgICBpZiAoYW5ndWxhci5pc0RhdGUoYmFzZURhdGUpICYmICFpc05hTihiYXNlRGF0ZS5nZXRUaW1lKCkpICYmICF0ek9mZnNldCkge1xuICAgICAgICAgIGR0ID0gbmV3IERhdGUoYmFzZURhdGUpO1xuICAgICAgICAgIGRhdGVzZXR0ZXIuY2FsbChkdCwgZmllbGRzLnllYXIsIGZpZWxkcy5tb250aCwgZmllbGRzLmRhdGUpO1xuICAgICAgICAgIHRpbWVzZXR0ZXIuY2FsbChkdCwgZmllbGRzLmhvdXJzLCBmaWVsZHMubWludXRlcyxcbiAgICAgICAgICAgIGZpZWxkcy5zZWNvbmRzLCBmaWVsZHMubWlsbGlzZWNvbmRzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkdCA9IG5ldyBEYXRlKDApO1xuICAgICAgICAgIGRhdGVzZXR0ZXIuY2FsbChkdCwgZmllbGRzLnllYXIsIGZpZWxkcy5tb250aCwgZmllbGRzLmRhdGUpO1xuICAgICAgICAgIHRpbWVzZXR0ZXIuY2FsbChkdCwgZmllbGRzLmhvdXJzIHx8IDAsIGZpZWxkcy5taW51dGVzIHx8IDAsXG4gICAgICAgICAgICBmaWVsZHMuc2Vjb25kcyB8fCAwLCBmaWVsZHMubWlsbGlzZWNvbmRzIHx8IDApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkdDtcbiAgICB9XG4gIH07XG5cbiAgLy8gQ2hlY2sgaWYgZGF0ZSBpcyB2YWxpZCBmb3Igc3BlY2lmaWMgbW9udGggKGFuZCB5ZWFyIGZvciBGZWJydWFyeSkuXG4gIC8vIE1vbnRoOiAwID0gSmFuLCAxID0gRmViLCBldGNcbiAgZnVuY3Rpb24gaXNWYWxpZCh5ZWFyLCBtb250aCwgZGF0ZSkge1xuICAgIGlmIChkYXRlIDwgMSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChtb250aCA9PT0gMSAmJiBkYXRlID4gMjgpIHtcbiAgICAgIHJldHVybiBkYXRlID09PSAyOSAmJiAoeWVhciAlIDQgPT09IDAgJiYgeWVhciAlIDEwMCAhPT0gMCB8fCB5ZWFyICUgNDAwID09PSAwKTtcbiAgICB9XG5cbiAgICBpZiAobW9udGggPT09IDMgfHwgbW9udGggPT09IDUgfHwgbW9udGggPT09IDggfHwgbW9udGggPT09IDEwKSB7XG4gICAgICByZXR1cm4gZGF0ZSA8IDMxO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gdG9JbnQoc3RyKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHN0ciwgMTApO1xuICB9XG5cbiAgdGhpcy50b1RpbWV6b25lID0gdG9UaW1lem9uZTtcbiAgdGhpcy5mcm9tVGltZXpvbmUgPSBmcm9tVGltZXpvbmU7XG4gIHRoaXMudGltZXpvbmVUb09mZnNldCA9IHRpbWV6b25lVG9PZmZzZXQ7XG4gIHRoaXMuYWRkRGF0ZU1pbnV0ZXMgPSBhZGREYXRlTWludXRlcztcbiAgdGhpcy5jb252ZXJ0VGltZXpvbmVUb0xvY2FsID0gY29udmVydFRpbWV6b25lVG9Mb2NhbDtcblxuICBmdW5jdGlvbiB0b1RpbWV6b25lKGRhdGUsIHRpbWV6b25lKSB7XG4gICAgcmV0dXJuIGRhdGUgJiYgdGltZXpvbmUgPyBjb252ZXJ0VGltZXpvbmVUb0xvY2FsKGRhdGUsIHRpbWV6b25lKSA6IGRhdGU7XG4gIH1cblxuICBmdW5jdGlvbiBmcm9tVGltZXpvbmUoZGF0ZSwgdGltZXpvbmUpIHtcbiAgICByZXR1cm4gZGF0ZSAmJiB0aW1lem9uZSA/IGNvbnZlcnRUaW1lem9uZVRvTG9jYWwoZGF0ZSwgdGltZXpvbmUsIHRydWUpIDogZGF0ZTtcbiAgfVxuXG4gIC8vaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci5qcy9ibG9iLzYyMmM0MjE2OTY5OWVjMDdmYzZkYWFhMTlmZTZkMjI0ZTVkMmY3MGUvc3JjL0FuZ3VsYXIuanMjTDEyMDdcbiAgZnVuY3Rpb24gdGltZXpvbmVUb09mZnNldCh0aW1lem9uZSwgZmFsbGJhY2spIHtcbiAgICB0aW1lem9uZSA9IHRpbWV6b25lLnJlcGxhY2UoLzovZywgJycpO1xuICAgIHZhciByZXF1ZXN0ZWRUaW1lem9uZU9mZnNldCA9IERhdGUucGFyc2UoJ0phbiAwMSwgMTk3MCAwMDowMDowMCAnICsgdGltZXpvbmUpIC8gNjAwMDA7XG4gICAgcmV0dXJuIGlzTmFOKHJlcXVlc3RlZFRpbWV6b25lT2Zmc2V0KSA/IGZhbGxiYWNrIDogcmVxdWVzdGVkVGltZXpvbmVPZmZzZXQ7XG4gIH1cblxuICBmdW5jdGlvbiBhZGREYXRlTWludXRlcyhkYXRlLCBtaW51dGVzKSB7XG4gICAgZGF0ZSA9IG5ldyBEYXRlKGRhdGUuZ2V0VGltZSgpKTtcbiAgICBkYXRlLnNldE1pbnV0ZXMoZGF0ZS5nZXRNaW51dGVzKCkgKyBtaW51dGVzKTtcbiAgICByZXR1cm4gZGF0ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbnZlcnRUaW1lem9uZVRvTG9jYWwoZGF0ZSwgdGltZXpvbmUsIHJldmVyc2UpIHtcbiAgICByZXZlcnNlID0gcmV2ZXJzZSA/IC0xIDogMTtcbiAgICB2YXIgZGF0ZVRpbWV6b25lT2Zmc2V0ID0gZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpO1xuICAgIHZhciB0aW1lem9uZU9mZnNldCA9IHRpbWV6b25lVG9PZmZzZXQodGltZXpvbmUsIGRhdGVUaW1lem9uZU9mZnNldCk7XG4gICAgcmV0dXJuIGFkZERhdGVNaW51dGVzKGRhdGUsIHJldmVyc2UgKiAodGltZXpvbmVPZmZzZXQgLSBkYXRlVGltZXpvbmVPZmZzZXQpKTtcbiAgfVxufV0pO1xuXG4vLyBBdm9pZGluZyB1c2Ugb2YgbmctY2xhc3MgYXMgaXQgY3JlYXRlcyBhIGxvdCBvZiB3YXRjaGVycyB3aGVuIGEgY2xhc3MgaXMgdG8gYmUgYXBwbGllZCB0b1xuLy8gYXQgbW9zdCBvbmUgZWxlbWVudC5cbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAuaXNDbGFzcycsIFtdKVxuLmRpcmVjdGl2ZSgndWliSXNDbGFzcycsIFtcbiAgICAgICAgICckYW5pbWF0ZScsXG5mdW5jdGlvbiAoJGFuaW1hdGUpIHtcbiAgLy8gICAgICAgICAgICAgICAgICAgIDExMTExMTExICAgICAgICAgIDIyMjIyMjIyXG4gIHZhciBPTl9SRUdFWFAgPSAvXlxccyooW1xcc1xcU10rPylcXHMrb25cXHMrKFtcXHNcXFNdKz8pXFxzKiQvO1xuICAvLyAgICAgICAgICAgICAgICAgICAgMTExMTExMTEgICAgICAgICAgIDIyMjIyMjIyXG4gIHZhciBJU19SRUdFWFAgPSAvXlxccyooW1xcc1xcU10rPylcXHMrZm9yXFxzKyhbXFxzXFxTXSs/KVxccyokLztcblxuICB2YXIgZGF0YVBlclRyYWNrZWQgPSB7fTtcblxuICByZXR1cm4ge1xuICAgIHJlc3RyaWN0OiAnQScsXG4gICAgY29tcGlsZTogZnVuY3Rpb24odEVsZW1lbnQsIHRBdHRycykge1xuICAgICAgdmFyIGxpbmtlZFNjb3BlcyA9IFtdO1xuICAgICAgdmFyIGluc3RhbmNlcyA9IFtdO1xuICAgICAgdmFyIGV4cFRvRGF0YSA9IHt9O1xuICAgICAgdmFyIGxhc3RBY3RpdmF0ZWQgPSBudWxsO1xuICAgICAgdmFyIG9uRXhwTWF0Y2hlcyA9IHRBdHRycy51aWJJc0NsYXNzLm1hdGNoKE9OX1JFR0VYUCk7XG4gICAgICB2YXIgb25FeHAgPSBvbkV4cE1hdGNoZXNbMl07XG4gICAgICB2YXIgZXhwc1N0ciA9IG9uRXhwTWF0Y2hlc1sxXTtcbiAgICAgIHZhciBleHBzID0gZXhwc1N0ci5zcGxpdCgnLCcpO1xuXG4gICAgICByZXR1cm4gbGlua0ZuO1xuXG4gICAgICBmdW5jdGlvbiBsaW5rRm4oc2NvcGUsIGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgICAgIGxpbmtlZFNjb3Blcy5wdXNoKHNjb3BlKTtcbiAgICAgICAgaW5zdGFuY2VzLnB1c2goe1xuICAgICAgICAgIHNjb3BlOiBzY29wZSxcbiAgICAgICAgICBlbGVtZW50OiBlbGVtZW50XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGV4cHMuZm9yRWFjaChmdW5jdGlvbihleHAsIGspIHtcbiAgICAgICAgICBhZGRGb3JFeHAoZXhwLCBzY29wZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNjb3BlLiRvbignJGRlc3Ryb3knLCByZW1vdmVTY29wZSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGFkZEZvckV4cChleHAsIHNjb3BlKSB7XG4gICAgICAgIHZhciBtYXRjaGVzID0gZXhwLm1hdGNoKElTX1JFR0VYUCk7XG4gICAgICAgIHZhciBjbGF6eiA9IHNjb3BlLiRldmFsKG1hdGNoZXNbMV0pO1xuICAgICAgICB2YXIgY29tcGFyZVdpdGhFeHAgPSBtYXRjaGVzWzJdO1xuICAgICAgICB2YXIgZGF0YSA9IGV4cFRvRGF0YVtleHBdO1xuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICB2YXIgd2F0Y2hGbiA9IGZ1bmN0aW9uKGNvbXBhcmVXaXRoVmFsKSB7XG4gICAgICAgICAgICB2YXIgbmV3QWN0aXZhdGVkID0gbnVsbDtcbiAgICAgICAgICAgIGluc3RhbmNlcy5zb21lKGZ1bmN0aW9uKGluc3RhbmNlKSB7XG4gICAgICAgICAgICAgIHZhciB0aGlzVmFsID0gaW5zdGFuY2Uuc2NvcGUuJGV2YWwob25FeHApO1xuICAgICAgICAgICAgICBpZiAodGhpc1ZhbCA9PT0gY29tcGFyZVdpdGhWYWwpIHtcbiAgICAgICAgICAgICAgICBuZXdBY3RpdmF0ZWQgPSBpbnN0YW5jZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoZGF0YS5sYXN0QWN0aXZhdGVkICE9PSBuZXdBY3RpdmF0ZWQpIHtcbiAgICAgICAgICAgICAgaWYgKGRhdGEubGFzdEFjdGl2YXRlZCkge1xuICAgICAgICAgICAgICAgICRhbmltYXRlLnJlbW92ZUNsYXNzKGRhdGEubGFzdEFjdGl2YXRlZC5lbGVtZW50LCBjbGF6eik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKG5ld0FjdGl2YXRlZCkge1xuICAgICAgICAgICAgICAgICRhbmltYXRlLmFkZENsYXNzKG5ld0FjdGl2YXRlZC5lbGVtZW50LCBjbGF6eik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGF0YS5sYXN0QWN0aXZhdGVkID0gbmV3QWN0aXZhdGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgZXhwVG9EYXRhW2V4cF0gPSBkYXRhID0ge1xuICAgICAgICAgICAgbGFzdEFjdGl2YXRlZDogbnVsbCxcbiAgICAgICAgICAgIHNjb3BlOiBzY29wZSxcbiAgICAgICAgICAgIHdhdGNoRm46IHdhdGNoRm4sXG4gICAgICAgICAgICBjb21wYXJlV2l0aEV4cDogY29tcGFyZVdpdGhFeHAsXG4gICAgICAgICAgICB3YXRjaGVyOiBzY29wZS4kd2F0Y2goY29tcGFyZVdpdGhFeHAsIHdhdGNoRm4pXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBkYXRhLndhdGNoRm4oc2NvcGUuJGV2YWwoY29tcGFyZVdpdGhFeHApKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcmVtb3ZlU2NvcGUoZSkge1xuICAgICAgICB2YXIgcmVtb3ZlZFNjb3BlID0gZS50YXJnZXRTY29wZTtcbiAgICAgICAgdmFyIGluZGV4ID0gbGlua2VkU2NvcGVzLmluZGV4T2YocmVtb3ZlZFNjb3BlKTtcbiAgICAgICAgbGlua2VkU2NvcGVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIGluc3RhbmNlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICBpZiAobGlua2VkU2NvcGVzLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBuZXdXYXRjaFNjb3BlID0gbGlua2VkU2NvcGVzWzBdO1xuICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChleHBUb0RhdGEsIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIGlmIChkYXRhLnNjb3BlID09PSByZW1vdmVkU2NvcGUpIHtcbiAgICAgICAgICAgICAgZGF0YS53YXRjaGVyID0gbmV3V2F0Y2hTY29wZS4kd2F0Y2goZGF0YS5jb21wYXJlV2l0aEV4cCwgZGF0YS53YXRjaEZuKTtcbiAgICAgICAgICAgICAgZGF0YS5zY29wZSA9IG5ld1dhdGNoU2NvcGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXhwVG9EYXRhID0ge307XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG59XSk7XG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLmRhdGVwaWNrZXInLCBbJ3VpLmJvb3RzdHJhcC5kYXRlcGFyc2VyJywgJ3VpLmJvb3RzdHJhcC5pc0NsYXNzJ10pXG5cbi52YWx1ZSgnJGRhdGVwaWNrZXJTdXBwcmVzc0Vycm9yJywgZmFsc2UpXG5cbi52YWx1ZSgnJGRhdGVwaWNrZXJMaXRlcmFsV2FybmluZycsIHRydWUpXG5cbi5jb25zdGFudCgndWliRGF0ZXBpY2tlckNvbmZpZycsIHtcbiAgZGF0ZXBpY2tlck1vZGU6ICdkYXknLFxuICBmb3JtYXREYXk6ICdkZCcsXG4gIGZvcm1hdE1vbnRoOiAnTU1NTScsXG4gIGZvcm1hdFllYXI6ICd5eXl5JyxcbiAgZm9ybWF0RGF5SGVhZGVyOiAnRUVFJyxcbiAgZm9ybWF0RGF5VGl0bGU6ICdNTU1NIHl5eXknLFxuICBmb3JtYXRNb250aFRpdGxlOiAneXl5eScsXG4gIG1heERhdGU6IG51bGwsXG4gIG1heE1vZGU6ICd5ZWFyJyxcbiAgbWluRGF0ZTogbnVsbCxcbiAgbWluTW9kZTogJ2RheScsXG4gIG1vbnRoQ29sdW1uczogMyxcbiAgbmdNb2RlbE9wdGlvbnM6IHt9LFxuICBzaG9ydGN1dFByb3BhZ2F0aW9uOiBmYWxzZSxcbiAgc2hvd1dlZWtzOiB0cnVlLFxuICB5ZWFyQ29sdW1uczogNSxcbiAgeWVhclJvd3M6IDRcbn0pXG5cbi5jb250cm9sbGVyKCdVaWJEYXRlcGlja2VyQ29udHJvbGxlcicsIFsnJHNjb3BlJywgJyRlbGVtZW50JywgJyRhdHRycycsICckcGFyc2UnLCAnJGludGVycG9sYXRlJywgJyRsb2NhbGUnLCAnJGxvZycsICdkYXRlRmlsdGVyJywgJ3VpYkRhdGVwaWNrZXJDb25maWcnLCAnJGRhdGVwaWNrZXJMaXRlcmFsV2FybmluZycsICckZGF0ZXBpY2tlclN1cHByZXNzRXJyb3InLCAndWliRGF0ZVBhcnNlcicsXG4gIGZ1bmN0aW9uKCRzY29wZSwgJGVsZW1lbnQsICRhdHRycywgJHBhcnNlLCAkaW50ZXJwb2xhdGUsICRsb2NhbGUsICRsb2csIGRhdGVGaWx0ZXIsIGRhdGVwaWNrZXJDb25maWcsICRkYXRlcGlja2VyTGl0ZXJhbFdhcm5pbmcsICRkYXRlcGlja2VyU3VwcHJlc3NFcnJvciwgZGF0ZVBhcnNlcikge1xuICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICBuZ01vZGVsQ3RybCA9IHsgJHNldFZpZXdWYWx1ZTogYW5ndWxhci5ub29wIH0sIC8vIG51bGxNb2RlbEN0cmw7XG4gICAgICBuZ01vZGVsT3B0aW9ucyA9IHt9LFxuICAgICAgd2F0Y2hMaXN0ZW5lcnMgPSBbXTtcblxuICAkZWxlbWVudC5hZGRDbGFzcygndWliLWRhdGVwaWNrZXInKTtcbiAgJGF0dHJzLiRzZXQoJ3JvbGUnLCAnYXBwbGljYXRpb24nKTtcblxuICBpZiAoISRzY29wZS5kYXRlcGlja2VyT3B0aW9ucykge1xuICAgICRzY29wZS5kYXRlcGlja2VyT3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgLy8gTW9kZXMgY2hhaW5cbiAgdGhpcy5tb2RlcyA9IFsnZGF5JywgJ21vbnRoJywgJ3llYXInXTtcblxuICBbXG4gICAgJ2N1c3RvbUNsYXNzJyxcbiAgICAnZGF0ZURpc2FibGVkJyxcbiAgICAnZGF0ZXBpY2tlck1vZGUnLFxuICAgICdmb3JtYXREYXknLFxuICAgICdmb3JtYXREYXlIZWFkZXInLFxuICAgICdmb3JtYXREYXlUaXRsZScsXG4gICAgJ2Zvcm1hdE1vbnRoJyxcbiAgICAnZm9ybWF0TW9udGhUaXRsZScsXG4gICAgJ2Zvcm1hdFllYXInLFxuICAgICdtYXhEYXRlJyxcbiAgICAnbWF4TW9kZScsXG4gICAgJ21pbkRhdGUnLFxuICAgICdtaW5Nb2RlJyxcbiAgICAnbW9udGhDb2x1bW5zJyxcbiAgICAnc2hvd1dlZWtzJyxcbiAgICAnc2hvcnRjdXRQcm9wYWdhdGlvbicsXG4gICAgJ3N0YXJ0aW5nRGF5JyxcbiAgICAneWVhckNvbHVtbnMnLFxuICAgICd5ZWFyUm93cydcbiAgXS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICBjYXNlICdjdXN0b21DbGFzcyc6XG4gICAgICBjYXNlICdkYXRlRGlzYWJsZWQnOlxuICAgICAgICAkc2NvcGVba2V5XSA9ICRzY29wZS5kYXRlcGlja2VyT3B0aW9uc1trZXldIHx8IGFuZ3VsYXIubm9vcDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdkYXRlcGlja2VyTW9kZSc6XG4gICAgICAgICRzY29wZS5kYXRlcGlja2VyTW9kZSA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRzY29wZS5kYXRlcGlja2VyT3B0aW9ucy5kYXRlcGlja2VyTW9kZSkgP1xuICAgICAgICAgICRzY29wZS5kYXRlcGlja2VyT3B0aW9ucy5kYXRlcGlja2VyTW9kZSA6IGRhdGVwaWNrZXJDb25maWcuZGF0ZXBpY2tlck1vZGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZm9ybWF0RGF5JzpcbiAgICAgIGNhc2UgJ2Zvcm1hdERheUhlYWRlcic6XG4gICAgICBjYXNlICdmb3JtYXREYXlUaXRsZSc6XG4gICAgICBjYXNlICdmb3JtYXRNb250aCc6XG4gICAgICBjYXNlICdmb3JtYXRNb250aFRpdGxlJzpcbiAgICAgIGNhc2UgJ2Zvcm1hdFllYXInOlxuICAgICAgICBzZWxmW2tleV0gPSBhbmd1bGFyLmlzRGVmaW5lZCgkc2NvcGUuZGF0ZXBpY2tlck9wdGlvbnNba2V5XSkgP1xuICAgICAgICAgICRpbnRlcnBvbGF0ZSgkc2NvcGUuZGF0ZXBpY2tlck9wdGlvbnNba2V5XSkoJHNjb3BlLiRwYXJlbnQpIDpcbiAgICAgICAgICBkYXRlcGlja2VyQ29uZmlnW2tleV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbW9udGhDb2x1bW5zJzpcbiAgICAgIGNhc2UgJ3Nob3dXZWVrcyc6XG4gICAgICBjYXNlICdzaG9ydGN1dFByb3BhZ2F0aW9uJzpcbiAgICAgIGNhc2UgJ3llYXJDb2x1bW5zJzpcbiAgICAgIGNhc2UgJ3llYXJSb3dzJzpcbiAgICAgICAgc2VsZltrZXldID0gYW5ndWxhci5pc0RlZmluZWQoJHNjb3BlLmRhdGVwaWNrZXJPcHRpb25zW2tleV0pID9cbiAgICAgICAgICAkc2NvcGUuZGF0ZXBpY2tlck9wdGlvbnNba2V5XSA6IGRhdGVwaWNrZXJDb25maWdba2V5XTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzdGFydGluZ0RheSc6XG4gICAgICAgIGlmIChhbmd1bGFyLmlzRGVmaW5lZCgkc2NvcGUuZGF0ZXBpY2tlck9wdGlvbnMuc3RhcnRpbmdEYXkpKSB7XG4gICAgICAgICAgc2VsZi5zdGFydGluZ0RheSA9ICRzY29wZS5kYXRlcGlja2VyT3B0aW9ucy5zdGFydGluZ0RheTtcbiAgICAgICAgfSBlbHNlIGlmIChhbmd1bGFyLmlzTnVtYmVyKGRhdGVwaWNrZXJDb25maWcuc3RhcnRpbmdEYXkpKSB7XG4gICAgICAgICAgc2VsZi5zdGFydGluZ0RheSA9IGRhdGVwaWNrZXJDb25maWcuc3RhcnRpbmdEYXk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VsZi5zdGFydGluZ0RheSA9ICgkbG9jYWxlLkRBVEVUSU1FX0ZPUk1BVFMuRklSU1REQVlPRldFRUsgKyA4KSAlIDc7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21heERhdGUnOlxuICAgICAgY2FzZSAnbWluRGF0ZSc6XG4gICAgICAgICRzY29wZS4kd2F0Y2goJ2RhdGVwaWNrZXJPcHRpb25zLicgKyBrZXksIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoYW5ndWxhci5pc0RhdGUodmFsdWUpKSB7XG4gICAgICAgICAgICAgIHNlbGZba2V5XSA9IGRhdGVQYXJzZXIuZnJvbVRpbWV6b25lKG5ldyBEYXRlKHZhbHVlKSwgbmdNb2RlbE9wdGlvbnMuZ2V0T3B0aW9uKCd0aW1lem9uZScpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmICgkZGF0ZXBpY2tlckxpdGVyYWxXYXJuaW5nKSB7XG4gICAgICAgICAgICAgICAgJGxvZy53YXJuKCdMaXRlcmFsIGRhdGUgc3VwcG9ydCBoYXMgYmVlbiBkZXByZWNhdGVkLCBwbGVhc2Ugc3dpdGNoIHRvIGRhdGUgb2JqZWN0IHVzYWdlJyk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBzZWxmW2tleV0gPSBuZXcgRGF0ZShkYXRlRmlsdGVyKHZhbHVlLCAnbWVkaXVtJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmW2tleV0gPSBkYXRlcGlja2VyQ29uZmlnW2tleV0gP1xuICAgICAgICAgICAgICBkYXRlUGFyc2VyLmZyb21UaW1lem9uZShuZXcgRGF0ZShkYXRlcGlja2VyQ29uZmlnW2tleV0pLCBuZ01vZGVsT3B0aW9ucy5nZXRPcHRpb24oJ3RpbWV6b25lJykpIDpcbiAgICAgICAgICAgICAgbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZWxmLnJlZnJlc2hWaWV3KCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbWF4TW9kZSc6XG4gICAgICBjYXNlICdtaW5Nb2RlJzpcbiAgICAgICAgaWYgKCRzY29wZS5kYXRlcGlja2VyT3B0aW9uc1trZXldKSB7XG4gICAgICAgICAgJHNjb3BlLiR3YXRjaChmdW5jdGlvbigpIHsgcmV0dXJuICRzY29wZS5kYXRlcGlja2VyT3B0aW9uc1trZXldOyB9LCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgc2VsZltrZXldID0gJHNjb3BlW2tleV0gPSBhbmd1bGFyLmlzRGVmaW5lZCh2YWx1ZSkgPyB2YWx1ZSA6ICRzY29wZS5kYXRlcGlja2VyT3B0aW9uc1trZXldO1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ21pbk1vZGUnICYmIHNlbGYubW9kZXMuaW5kZXhPZigkc2NvcGUuZGF0ZXBpY2tlck9wdGlvbnMuZGF0ZXBpY2tlck1vZGUpIDwgc2VsZi5tb2Rlcy5pbmRleE9mKHNlbGZba2V5XSkgfHxcbiAgICAgICAgICAgICAga2V5ID09PSAnbWF4TW9kZScgJiYgc2VsZi5tb2Rlcy5pbmRleE9mKCRzY29wZS5kYXRlcGlja2VyT3B0aW9ucy5kYXRlcGlja2VyTW9kZSkgPiBzZWxmLm1vZGVzLmluZGV4T2Yoc2VsZltrZXldKSkge1xuICAgICAgICAgICAgICAkc2NvcGUuZGF0ZXBpY2tlck1vZGUgPSBzZWxmW2tleV07XG4gICAgICAgICAgICAgICRzY29wZS5kYXRlcGlja2VyT3B0aW9ucy5kYXRlcGlja2VyTW9kZSA9IHNlbGZba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWxmW2tleV0gPSAkc2NvcGVba2V5XSA9IGRhdGVwaWNrZXJDb25maWdba2V5XSB8fCBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9KTtcblxuICAkc2NvcGUudW5pcXVlSWQgPSAnZGF0ZXBpY2tlci0nICsgJHNjb3BlLiRpZCArICctJyArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwKTtcblxuICAkc2NvcGUuZGlzYWJsZWQgPSBhbmd1bGFyLmlzRGVmaW5lZCgkYXR0cnMuZGlzYWJsZWQpIHx8IGZhbHNlO1xuICBpZiAoYW5ndWxhci5pc0RlZmluZWQoJGF0dHJzLm5nRGlzYWJsZWQpKSB7XG4gICAgd2F0Y2hMaXN0ZW5lcnMucHVzaCgkc2NvcGUuJHBhcmVudC4kd2F0Y2goJGF0dHJzLm5nRGlzYWJsZWQsIGZ1bmN0aW9uKGRpc2FibGVkKSB7XG4gICAgICAkc2NvcGUuZGlzYWJsZWQgPSBkaXNhYmxlZDtcbiAgICAgIHNlbGYucmVmcmVzaFZpZXcoKTtcbiAgICB9KSk7XG4gIH1cblxuICAkc2NvcGUuaXNBY3RpdmUgPSBmdW5jdGlvbihkYXRlT2JqZWN0KSB7XG4gICAgaWYgKHNlbGYuY29tcGFyZShkYXRlT2JqZWN0LmRhdGUsIHNlbGYuYWN0aXZlRGF0ZSkgPT09IDApIHtcbiAgICAgICRzY29wZS5hY3RpdmVEYXRlSWQgPSBkYXRlT2JqZWN0LnVpZDtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgdGhpcy5pbml0ID0gZnVuY3Rpb24obmdNb2RlbEN0cmxfKSB7XG4gICAgbmdNb2RlbEN0cmwgPSBuZ01vZGVsQ3RybF87XG4gICAgbmdNb2RlbE9wdGlvbnMgPSBleHRyYWN0T3B0aW9ucyhuZ01vZGVsQ3RybCk7XG5cbiAgICBpZiAoJHNjb3BlLmRhdGVwaWNrZXJPcHRpb25zLmluaXREYXRlKSB7XG4gICAgICBzZWxmLmFjdGl2ZURhdGUgPSBkYXRlUGFyc2VyLmZyb21UaW1lem9uZSgkc2NvcGUuZGF0ZXBpY2tlck9wdGlvbnMuaW5pdERhdGUsIG5nTW9kZWxPcHRpb25zLmdldE9wdGlvbigndGltZXpvbmUnKSkgfHwgbmV3IERhdGUoKTtcbiAgICAgICRzY29wZS4kd2F0Y2goJ2RhdGVwaWNrZXJPcHRpb25zLmluaXREYXRlJywgZnVuY3Rpb24oaW5pdERhdGUpIHtcbiAgICAgICAgaWYgKGluaXREYXRlICYmIChuZ01vZGVsQ3RybC4kaXNFbXB0eShuZ01vZGVsQ3RybC4kbW9kZWxWYWx1ZSkgfHwgbmdNb2RlbEN0cmwuJGludmFsaWQpKSB7XG4gICAgICAgICAgc2VsZi5hY3RpdmVEYXRlID0gZGF0ZVBhcnNlci5mcm9tVGltZXpvbmUoaW5pdERhdGUsIG5nTW9kZWxPcHRpb25zLmdldE9wdGlvbigndGltZXpvbmUnKSk7XG4gICAgICAgICAgc2VsZi5yZWZyZXNoVmlldygpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5hY3RpdmVEYXRlID0gbmV3IERhdGUoKTtcbiAgICB9XG5cbiAgICB2YXIgZGF0ZSA9IG5nTW9kZWxDdHJsLiRtb2RlbFZhbHVlID8gbmV3IERhdGUobmdNb2RlbEN0cmwuJG1vZGVsVmFsdWUpIDogbmV3IERhdGUoKTtcbiAgICB0aGlzLmFjdGl2ZURhdGUgPSAhaXNOYU4oZGF0ZSkgP1xuICAgICAgZGF0ZVBhcnNlci5mcm9tVGltZXpvbmUoZGF0ZSwgbmdNb2RlbE9wdGlvbnMuZ2V0T3B0aW9uKCd0aW1lem9uZScpKSA6XG4gICAgICBkYXRlUGFyc2VyLmZyb21UaW1lem9uZShuZXcgRGF0ZSgpLCBuZ01vZGVsT3B0aW9ucy5nZXRPcHRpb24oJ3RpbWV6b25lJykpO1xuXG4gICAgbmdNb2RlbEN0cmwuJHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5yZW5kZXIoKTtcbiAgICB9O1xuICB9O1xuXG4gIHRoaXMucmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKG5nTW9kZWxDdHJsLiR2aWV3VmFsdWUpIHtcbiAgICAgIHZhciBkYXRlID0gbmV3IERhdGUobmdNb2RlbEN0cmwuJHZpZXdWYWx1ZSksXG4gICAgICAgICAgaXNWYWxpZCA9ICFpc05hTihkYXRlKTtcblxuICAgICAgaWYgKGlzVmFsaWQpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVEYXRlID0gZGF0ZVBhcnNlci5mcm9tVGltZXpvbmUoZGF0ZSwgbmdNb2RlbE9wdGlvbnMuZ2V0T3B0aW9uKCd0aW1lem9uZScpKTtcbiAgICAgIH0gZWxzZSBpZiAoISRkYXRlcGlja2VyU3VwcHJlc3NFcnJvcikge1xuICAgICAgICAkbG9nLmVycm9yKCdEYXRlcGlja2VyIGRpcmVjdGl2ZTogXCJuZy1tb2RlbFwiIHZhbHVlIG11c3QgYmUgYSBEYXRlIG9iamVjdCcpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnJlZnJlc2hWaWV3KCk7XG4gIH07XG5cbiAgdGhpcy5yZWZyZXNoVmlldyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmVsZW1lbnQpIHtcbiAgICAgICRzY29wZS5zZWxlY3RlZER0ID0gbnVsbDtcbiAgICAgIHRoaXMuX3JlZnJlc2hWaWV3KCk7XG4gICAgICBpZiAoJHNjb3BlLmFjdGl2ZUR0KSB7XG4gICAgICAgICRzY29wZS5hY3RpdmVEYXRlSWQgPSAkc2NvcGUuYWN0aXZlRHQudWlkO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGF0ZSA9IG5nTW9kZWxDdHJsLiR2aWV3VmFsdWUgPyBuZXcgRGF0ZShuZ01vZGVsQ3RybC4kdmlld1ZhbHVlKSA6IG51bGw7XG4gICAgICBkYXRlID0gZGF0ZVBhcnNlci5mcm9tVGltZXpvbmUoZGF0ZSwgbmdNb2RlbE9wdGlvbnMuZ2V0T3B0aW9uKCd0aW1lem9uZScpKTtcbiAgICAgIG5nTW9kZWxDdHJsLiRzZXRWYWxpZGl0eSgnZGF0ZURpc2FibGVkJywgIWRhdGUgfHxcbiAgICAgICAgdGhpcy5lbGVtZW50ICYmICF0aGlzLmlzRGlzYWJsZWQoZGF0ZSkpO1xuICAgIH1cbiAgfTtcblxuICB0aGlzLmNyZWF0ZURhdGVPYmplY3QgPSBmdW5jdGlvbihkYXRlLCBmb3JtYXQpIHtcbiAgICB2YXIgbW9kZWwgPSBuZ01vZGVsQ3RybC4kdmlld1ZhbHVlID8gbmV3IERhdGUobmdNb2RlbEN0cmwuJHZpZXdWYWx1ZSkgOiBudWxsO1xuICAgIG1vZGVsID0gZGF0ZVBhcnNlci5mcm9tVGltZXpvbmUobW9kZWwsIG5nTW9kZWxPcHRpb25zLmdldE9wdGlvbigndGltZXpvbmUnKSk7XG4gICAgdmFyIHRvZGF5ID0gbmV3IERhdGUoKTtcbiAgICB0b2RheSA9IGRhdGVQYXJzZXIuZnJvbVRpbWV6b25lKHRvZGF5LCBuZ01vZGVsT3B0aW9ucy5nZXRPcHRpb24oJ3RpbWV6b25lJykpO1xuICAgIHZhciB0aW1lID0gdGhpcy5jb21wYXJlKGRhdGUsIHRvZGF5KTtcbiAgICB2YXIgZHQgPSB7XG4gICAgICBkYXRlOiBkYXRlLFxuICAgICAgbGFiZWw6IGRhdGVQYXJzZXIuZmlsdGVyKGRhdGUsIGZvcm1hdCksXG4gICAgICBzZWxlY3RlZDogbW9kZWwgJiYgdGhpcy5jb21wYXJlKGRhdGUsIG1vZGVsKSA9PT0gMCxcbiAgICAgIGRpc2FibGVkOiB0aGlzLmlzRGlzYWJsZWQoZGF0ZSksXG4gICAgICBwYXN0OiB0aW1lIDwgMCxcbiAgICAgIGN1cnJlbnQ6IHRpbWUgPT09IDAsXG4gICAgICBmdXR1cmU6IHRpbWUgPiAwLFxuICAgICAgY3VzdG9tQ2xhc3M6IHRoaXMuY3VzdG9tQ2xhc3MoZGF0ZSkgfHwgbnVsbFxuICAgIH07XG5cbiAgICBpZiAobW9kZWwgJiYgdGhpcy5jb21wYXJlKGRhdGUsIG1vZGVsKSA9PT0gMCkge1xuICAgICAgJHNjb3BlLnNlbGVjdGVkRHQgPSBkdDtcbiAgICB9XG5cbiAgICBpZiAoc2VsZi5hY3RpdmVEYXRlICYmIHRoaXMuY29tcGFyZShkdC5kYXRlLCBzZWxmLmFjdGl2ZURhdGUpID09PSAwKSB7XG4gICAgICAkc2NvcGUuYWN0aXZlRHQgPSBkdDtcbiAgICB9XG5cbiAgICByZXR1cm4gZHQ7XG4gIH07XG5cbiAgdGhpcy5pc0Rpc2FibGVkID0gZnVuY3Rpb24oZGF0ZSkge1xuICAgIHJldHVybiAkc2NvcGUuZGlzYWJsZWQgfHxcbiAgICAgIHRoaXMubWluRGF0ZSAmJiB0aGlzLmNvbXBhcmUoZGF0ZSwgdGhpcy5taW5EYXRlKSA8IDAgfHxcbiAgICAgIHRoaXMubWF4RGF0ZSAmJiB0aGlzLmNvbXBhcmUoZGF0ZSwgdGhpcy5tYXhEYXRlKSA+IDAgfHxcbiAgICAgICRzY29wZS5kYXRlRGlzYWJsZWQgJiYgJHNjb3BlLmRhdGVEaXNhYmxlZCh7ZGF0ZTogZGF0ZSwgbW9kZTogJHNjb3BlLmRhdGVwaWNrZXJNb2RlfSk7XG4gIH07XG5cbiAgdGhpcy5jdXN0b21DbGFzcyA9IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICByZXR1cm4gJHNjb3BlLmN1c3RvbUNsYXNzKHtkYXRlOiBkYXRlLCBtb2RlOiAkc2NvcGUuZGF0ZXBpY2tlck1vZGV9KTtcbiAgfTtcblxuICAvLyBTcGxpdCBhcnJheSBpbnRvIHNtYWxsZXIgYXJyYXlzXG4gIHRoaXMuc3BsaXQgPSBmdW5jdGlvbihhcnIsIHNpemUpIHtcbiAgICB2YXIgYXJyYXlzID0gW107XG4gICAgd2hpbGUgKGFyci5sZW5ndGggPiAwKSB7XG4gICAgICBhcnJheXMucHVzaChhcnIuc3BsaWNlKDAsIHNpemUpKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5cztcbiAgfTtcblxuICAkc2NvcGUuc2VsZWN0ID0gZnVuY3Rpb24oZGF0ZSkge1xuICAgIGlmICgkc2NvcGUuZGF0ZXBpY2tlck1vZGUgPT09IHNlbGYubWluTW9kZSkge1xuICAgICAgdmFyIGR0ID0gbmdNb2RlbEN0cmwuJHZpZXdWYWx1ZSA/IGRhdGVQYXJzZXIuZnJvbVRpbWV6b25lKG5ldyBEYXRlKG5nTW9kZWxDdHJsLiR2aWV3VmFsdWUpLCBuZ01vZGVsT3B0aW9ucy5nZXRPcHRpb24oJ3RpbWV6b25lJykpIDogbmV3IERhdGUoMCwgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgICBkdC5zZXRGdWxsWWVhcihkYXRlLmdldEZ1bGxZZWFyKCksIGRhdGUuZ2V0TW9udGgoKSwgZGF0ZS5nZXREYXRlKCkpO1xuICAgICAgZHQgPSBkYXRlUGFyc2VyLnRvVGltZXpvbmUoZHQsIG5nTW9kZWxPcHRpb25zLmdldE9wdGlvbigndGltZXpvbmUnKSk7XG4gICAgICBuZ01vZGVsQ3RybC4kc2V0Vmlld1ZhbHVlKGR0KTtcbiAgICAgIG5nTW9kZWxDdHJsLiRyZW5kZXIoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5hY3RpdmVEYXRlID0gZGF0ZTtcbiAgICAgIHNldE1vZGUoc2VsZi5tb2Rlc1tzZWxmLm1vZGVzLmluZGV4T2YoJHNjb3BlLmRhdGVwaWNrZXJNb2RlKSAtIDFdKTtcblxuICAgICAgJHNjb3BlLiRlbWl0KCd1aWI6ZGF0ZXBpY2tlci5tb2RlJyk7XG4gICAgfVxuXG4gICAgJHNjb3BlLiRicm9hZGNhc3QoJ3VpYjpkYXRlcGlja2VyLmZvY3VzJyk7XG4gIH07XG5cbiAgJHNjb3BlLm1vdmUgPSBmdW5jdGlvbihkaXJlY3Rpb24pIHtcbiAgICB2YXIgeWVhciA9IHNlbGYuYWN0aXZlRGF0ZS5nZXRGdWxsWWVhcigpICsgZGlyZWN0aW9uICogKHNlbGYuc3RlcC55ZWFycyB8fCAwKSxcbiAgICAgICAgbW9udGggPSBzZWxmLmFjdGl2ZURhdGUuZ2V0TW9udGgoKSArIGRpcmVjdGlvbiAqIChzZWxmLnN0ZXAubW9udGhzIHx8IDApO1xuICAgIHNlbGYuYWN0aXZlRGF0ZS5zZXRGdWxsWWVhcih5ZWFyLCBtb250aCwgMSk7XG4gICAgc2VsZi5yZWZyZXNoVmlldygpO1xuICB9O1xuXG4gICRzY29wZS50b2dnbGVNb2RlID0gZnVuY3Rpb24oZGlyZWN0aW9uKSB7XG4gICAgZGlyZWN0aW9uID0gZGlyZWN0aW9uIHx8IDE7XG5cbiAgICBpZiAoJHNjb3BlLmRhdGVwaWNrZXJNb2RlID09PSBzZWxmLm1heE1vZGUgJiYgZGlyZWN0aW9uID09PSAxIHx8XG4gICAgICAkc2NvcGUuZGF0ZXBpY2tlck1vZGUgPT09IHNlbGYubWluTW9kZSAmJiBkaXJlY3Rpb24gPT09IC0xKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc2V0TW9kZShzZWxmLm1vZGVzW3NlbGYubW9kZXMuaW5kZXhPZigkc2NvcGUuZGF0ZXBpY2tlck1vZGUpICsgZGlyZWN0aW9uXSk7XG5cbiAgICAkc2NvcGUuJGVtaXQoJ3VpYjpkYXRlcGlja2VyLm1vZGUnKTtcbiAgfTtcblxuICAvLyBLZXkgZXZlbnQgbWFwcGVyXG4gICRzY29wZS5rZXlzID0geyAxMzogJ2VudGVyJywgMzI6ICdzcGFjZScsIDMzOiAncGFnZXVwJywgMzQ6ICdwYWdlZG93bicsIDM1OiAnZW5kJywgMzY6ICdob21lJywgMzc6ICdsZWZ0JywgMzg6ICd1cCcsIDM5OiAncmlnaHQnLCA0MDogJ2Rvd24nIH07XG5cbiAgdmFyIGZvY3VzRWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuZWxlbWVudFswXS5mb2N1cygpO1xuICB9O1xuXG4gIC8vIExpc3RlbiBmb3IgZm9jdXMgcmVxdWVzdHMgZnJvbSBwb3B1cCBkaXJlY3RpdmVcbiAgJHNjb3BlLiRvbigndWliOmRhdGVwaWNrZXIuZm9jdXMnLCBmb2N1c0VsZW1lbnQpO1xuXG4gICRzY29wZS5rZXlkb3duID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgdmFyIGtleSA9ICRzY29wZS5rZXlzW2V2dC53aGljaF07XG5cbiAgICBpZiAoIWtleSB8fCBldnQuc2hpZnRLZXkgfHwgZXZ0LmFsdEtleSB8fCAkc2NvcGUuZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICBpZiAoIXNlbGYuc2hvcnRjdXRQcm9wYWdhdGlvbikge1xuICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cblxuICAgIGlmIChrZXkgPT09ICdlbnRlcicgfHwga2V5ID09PSAnc3BhY2UnKSB7XG4gICAgICBpZiAoc2VsZi5pc0Rpc2FibGVkKHNlbGYuYWN0aXZlRGF0ZSkpIHtcbiAgICAgICAgcmV0dXJuOyAvLyBkbyBub3RoaW5nXG4gICAgICB9XG4gICAgICAkc2NvcGUuc2VsZWN0KHNlbGYuYWN0aXZlRGF0ZSk7XG4gICAgfSBlbHNlIGlmIChldnQuY3RybEtleSAmJiAoa2V5ID09PSAndXAnIHx8IGtleSA9PT0gJ2Rvd24nKSkge1xuICAgICAgJHNjb3BlLnRvZ2dsZU1vZGUoa2V5ID09PSAndXAnID8gMSA6IC0xKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5oYW5kbGVLZXlEb3duKGtleSwgZXZ0KTtcbiAgICAgIHNlbGYucmVmcmVzaFZpZXcoKTtcbiAgICB9XG4gIH07XG5cbiAgJGVsZW1lbnQub24oJ2tleWRvd24nLCBmdW5jdGlvbihldnQpIHtcbiAgICAkc2NvcGUuJGFwcGx5KGZ1bmN0aW9uKCkge1xuICAgICAgJHNjb3BlLmtleWRvd24oZXZ0KTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgJHNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICAvL0NsZWFyIGFsbCB3YXRjaCBsaXN0ZW5lcnMgb24gZGVzdHJveVxuICAgIHdoaWxlICh3YXRjaExpc3RlbmVycy5sZW5ndGgpIHtcbiAgICAgIHdhdGNoTGlzdGVuZXJzLnNoaWZ0KCkoKTtcbiAgICB9XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIHNldE1vZGUobW9kZSkge1xuICAgICRzY29wZS5kYXRlcGlja2VyTW9kZSA9IG1vZGU7XG4gICAgJHNjb3BlLmRhdGVwaWNrZXJPcHRpb25zLmRhdGVwaWNrZXJNb2RlID0gbW9kZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dHJhY3RPcHRpb25zKG5nTW9kZWxDdHJsKSB7XG4gICAgdmFyIG5nTW9kZWxPcHRpb25zO1xuXG4gICAgaWYgKGFuZ3VsYXIudmVyc2lvbi5taW5vciA8IDYpIHsgLy8gaW4gYW5ndWxhciA8IDEuNiAkb3B0aW9ucyBjb3VsZCBiZSBtaXNzaW5nXG4gICAgICAvLyBndWFyYW50ZWUgYSB2YWx1ZVxuICAgICAgbmdNb2RlbE9wdGlvbnMgPSBuZ01vZGVsQ3RybC4kb3B0aW9ucyB8fFxuICAgICAgICAkc2NvcGUuZGF0ZXBpY2tlck9wdGlvbnMubmdNb2RlbE9wdGlvbnMgfHxcbiAgICAgICAgZGF0ZXBpY2tlckNvbmZpZy5uZ01vZGVsT3B0aW9ucyB8fFxuICAgICAgICB7fTtcblxuICAgICAgLy8gbWltaWMgMS42KyBhcGlcbiAgICAgIG5nTW9kZWxPcHRpb25zLmdldE9wdGlvbiA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIG5nTW9kZWxPcHRpb25zW2tleV07XG4gICAgICB9O1xuICAgIH0gZWxzZSB7IC8vIGluIGFuZ3VsYXIgPj0xLjYgJG9wdGlvbnMgaXMgYWx3YXlzIHByZXNlbnRcbiAgICAgIC8vIG5nLW1vZGVsLW9wdGlvbnMgZGVmYXVsdHMgdGltZXpvbmUgdG8gbnVsbDsgZG9uJ3QgbGV0IGl0cyBwcmVjZWRlbmNlIHNxdWFzaCBhIG5vbi1udWxsIHZhbHVlXG4gICAgICB2YXIgdGltZXpvbmUgPSBuZ01vZGVsQ3RybC4kb3B0aW9ucy5nZXRPcHRpb24oJ3RpbWV6b25lJykgfHxcbiAgICAgICAgKCRzY29wZS5kYXRlcGlja2VyT3B0aW9ucy5uZ01vZGVsT3B0aW9ucyA/ICRzY29wZS5kYXRlcGlja2VyT3B0aW9ucy5uZ01vZGVsT3B0aW9ucy50aW1lem9uZSA6IG51bGwpIHx8XG4gICAgICAgIChkYXRlcGlja2VyQ29uZmlnLm5nTW9kZWxPcHRpb25zID8gZGF0ZXBpY2tlckNvbmZpZy5uZ01vZGVsT3B0aW9ucy50aW1lem9uZSA6IG51bGwpO1xuXG4gICAgICAvLyB2YWx1ZXMgcGFzc2VkIHRvIGNyZWF0ZUNoaWxkIG92ZXJyaWRlIGV4aXN0aW5nIHZhbHVlc1xuICAgICAgbmdNb2RlbE9wdGlvbnMgPSBuZ01vZGVsQ3RybC4kb3B0aW9ucyAvLyBzdGFydCB3aXRoIGEgTW9kZWxPcHRpb25zIGluc3RhbmNlXG4gICAgICAgIC5jcmVhdGVDaGlsZChkYXRlcGlja2VyQ29uZmlnLm5nTW9kZWxPcHRpb25zKSAvLyBsb3dlc3QgcHJlY2VkZW5jZVxuICAgICAgICAuY3JlYXRlQ2hpbGQoJHNjb3BlLmRhdGVwaWNrZXJPcHRpb25zLm5nTW9kZWxPcHRpb25zKVxuICAgICAgICAuY3JlYXRlQ2hpbGQobmdNb2RlbEN0cmwuJG9wdGlvbnMpIC8vIGhpZ2hlc3QgcHJlY2VkZW5jZVxuICAgICAgICAuY3JlYXRlQ2hpbGQoe3RpbWV6b25lOiB0aW1lem9uZX0pOyAvLyB0byBrZWVwIGZyb20gc3F1YXNoaW5nIGEgbm9uLW51bGwgdmFsdWVcbiAgICB9XG5cbiAgICByZXR1cm4gbmdNb2RlbE9wdGlvbnM7XG4gIH1cbn1dKVxuXG4uY29udHJvbGxlcignVWliRGF5cGlja2VyQ29udHJvbGxlcicsIFsnJHNjb3BlJywgJyRlbGVtZW50JywgJ2RhdGVGaWx0ZXInLCBmdW5jdGlvbihzY29wZSwgJGVsZW1lbnQsIGRhdGVGaWx0ZXIpIHtcbiAgdmFyIERBWVNfSU5fTU9OVEggPSBbMzEsIDI4LCAzMSwgMzAsIDMxLCAzMCwgMzEsIDMxLCAzMCwgMzEsIDMwLCAzMV07XG5cbiAgdGhpcy5zdGVwID0geyBtb250aHM6IDEgfTtcbiAgdGhpcy5lbGVtZW50ID0gJGVsZW1lbnQ7XG4gIGZ1bmN0aW9uIGdldERheXNJbk1vbnRoKHllYXIsIG1vbnRoKSB7XG4gICAgcmV0dXJuIG1vbnRoID09PSAxICYmIHllYXIgJSA0ID09PSAwICYmXG4gICAgICAoeWVhciAlIDEwMCAhPT0gMCB8fCB5ZWFyICUgNDAwID09PSAwKSA/IDI5IDogREFZU19JTl9NT05USFttb250aF07XG4gIH1cblxuICB0aGlzLmluaXQgPSBmdW5jdGlvbihjdHJsKSB7XG4gICAgYW5ndWxhci5leHRlbmQoY3RybCwgdGhpcyk7XG4gICAgc2NvcGUuc2hvd1dlZWtzID0gY3RybC5zaG93V2Vla3M7XG4gICAgY3RybC5yZWZyZXNoVmlldygpO1xuICB9O1xuXG4gIHRoaXMuZ2V0RGF0ZXMgPSBmdW5jdGlvbihzdGFydERhdGUsIG4pIHtcbiAgICB2YXIgZGF0ZXMgPSBuZXcgQXJyYXkobiksIGN1cnJlbnQgPSBuZXcgRGF0ZShzdGFydERhdGUpLCBpID0gMCwgZGF0ZTtcbiAgICB3aGlsZSAoaSA8IG4pIHtcbiAgICAgIGRhdGUgPSBuZXcgRGF0ZShjdXJyZW50KTtcbiAgICAgIGRhdGVzW2krK10gPSBkYXRlO1xuICAgICAgY3VycmVudC5zZXREYXRlKGN1cnJlbnQuZ2V0RGF0ZSgpICsgMSk7XG4gICAgfVxuICAgIHJldHVybiBkYXRlcztcbiAgfTtcblxuICB0aGlzLl9yZWZyZXNoVmlldyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB5ZWFyID0gdGhpcy5hY3RpdmVEYXRlLmdldEZ1bGxZZWFyKCksXG4gICAgICBtb250aCA9IHRoaXMuYWN0aXZlRGF0ZS5nZXRNb250aCgpLFxuICAgICAgZmlyc3REYXlPZk1vbnRoID0gbmV3IERhdGUodGhpcy5hY3RpdmVEYXRlKTtcblxuICAgIGZpcnN0RGF5T2ZNb250aC5zZXRGdWxsWWVhcih5ZWFyLCBtb250aCwgMSk7XG5cbiAgICB2YXIgZGlmZmVyZW5jZSA9IHRoaXMuc3RhcnRpbmdEYXkgLSBmaXJzdERheU9mTW9udGguZ2V0RGF5KCksXG4gICAgICBudW1EaXNwbGF5ZWRGcm9tUHJldmlvdXNNb250aCA9IGRpZmZlcmVuY2UgPiAwID9cbiAgICAgICAgNyAtIGRpZmZlcmVuY2UgOiAtIGRpZmZlcmVuY2UsXG4gICAgICBmaXJzdERhdGUgPSBuZXcgRGF0ZShmaXJzdERheU9mTW9udGgpO1xuXG4gICAgaWYgKG51bURpc3BsYXllZEZyb21QcmV2aW91c01vbnRoID4gMCkge1xuICAgICAgZmlyc3REYXRlLnNldERhdGUoLW51bURpc3BsYXllZEZyb21QcmV2aW91c01vbnRoICsgMSk7XG4gICAgfVxuXG4gICAgLy8gNDIgaXMgdGhlIG51bWJlciBvZiBkYXlzIG9uIGEgc2l4LXdlZWsgY2FsZW5kYXJcbiAgICB2YXIgZGF5cyA9IHRoaXMuZ2V0RGF0ZXMoZmlyc3REYXRlLCA0Mik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0MjsgaSArKykge1xuICAgICAgZGF5c1tpXSA9IGFuZ3VsYXIuZXh0ZW5kKHRoaXMuY3JlYXRlRGF0ZU9iamVjdChkYXlzW2ldLCB0aGlzLmZvcm1hdERheSksIHtcbiAgICAgICAgc2Vjb25kYXJ5OiBkYXlzW2ldLmdldE1vbnRoKCkgIT09IG1vbnRoLFxuICAgICAgICB1aWQ6IHNjb3BlLnVuaXF1ZUlkICsgJy0nICsgaVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgc2NvcGUubGFiZWxzID0gbmV3IEFycmF5KDcpO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgNzsgaisrKSB7XG4gICAgICBzY29wZS5sYWJlbHNbal0gPSB7XG4gICAgICAgIGFiYnI6IGRhdGVGaWx0ZXIoZGF5c1tqXS5kYXRlLCB0aGlzLmZvcm1hdERheUhlYWRlciksXG4gICAgICAgIGZ1bGw6IGRhdGVGaWx0ZXIoZGF5c1tqXS5kYXRlLCAnRUVFRScpXG4gICAgICB9O1xuICAgIH1cblxuICAgIHNjb3BlLnRpdGxlID0gZGF0ZUZpbHRlcih0aGlzLmFjdGl2ZURhdGUsIHRoaXMuZm9ybWF0RGF5VGl0bGUpO1xuICAgIHNjb3BlLnJvd3MgPSB0aGlzLnNwbGl0KGRheXMsIDcpO1xuXG4gICAgaWYgKHNjb3BlLnNob3dXZWVrcykge1xuICAgICAgc2NvcGUud2Vla051bWJlcnMgPSBbXTtcbiAgICAgIHZhciB0aHVyc2RheUluZGV4ID0gKDQgKyA3IC0gdGhpcy5zdGFydGluZ0RheSkgJSA3LFxuICAgICAgICAgIG51bVdlZWtzID0gc2NvcGUucm93cy5sZW5ndGg7XG4gICAgICBmb3IgKHZhciBjdXJXZWVrID0gMDsgY3VyV2VlayA8IG51bVdlZWtzOyBjdXJXZWVrKyspIHtcbiAgICAgICAgc2NvcGUud2Vla051bWJlcnMucHVzaChcbiAgICAgICAgICBnZXRJU084NjAxV2Vla051bWJlcihzY29wZS5yb3dzW2N1cldlZWtdW3RodXJzZGF5SW5kZXhdLmRhdGUpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdGhpcy5jb21wYXJlID0gZnVuY3Rpb24oZGF0ZTEsIGRhdGUyKSB7XG4gICAgdmFyIF9kYXRlMSA9IG5ldyBEYXRlKGRhdGUxLmdldEZ1bGxZZWFyKCksIGRhdGUxLmdldE1vbnRoKCksIGRhdGUxLmdldERhdGUoKSk7XG4gICAgdmFyIF9kYXRlMiA9IG5ldyBEYXRlKGRhdGUyLmdldEZ1bGxZZWFyKCksIGRhdGUyLmdldE1vbnRoKCksIGRhdGUyLmdldERhdGUoKSk7XG4gICAgX2RhdGUxLnNldEZ1bGxZZWFyKGRhdGUxLmdldEZ1bGxZZWFyKCkpO1xuICAgIF9kYXRlMi5zZXRGdWxsWWVhcihkYXRlMi5nZXRGdWxsWWVhcigpKTtcbiAgICByZXR1cm4gX2RhdGUxIC0gX2RhdGUyO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGdldElTTzg2MDFXZWVrTnVtYmVyKGRhdGUpIHtcbiAgICB2YXIgY2hlY2tEYXRlID0gbmV3IERhdGUoZGF0ZSk7XG4gICAgY2hlY2tEYXRlLnNldERhdGUoY2hlY2tEYXRlLmdldERhdGUoKSArIDQgLSAoY2hlY2tEYXRlLmdldERheSgpIHx8IDcpKTsgLy8gVGh1cnNkYXlcbiAgICB2YXIgdGltZSA9IGNoZWNrRGF0ZS5nZXRUaW1lKCk7XG4gICAgY2hlY2tEYXRlLnNldE1vbnRoKDApOyAvLyBDb21wYXJlIHdpdGggSmFuIDFcbiAgICBjaGVja0RhdGUuc2V0RGF0ZSgxKTtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJvdW5kKCh0aW1lIC0gY2hlY2tEYXRlKSAvIDg2NDAwMDAwKSAvIDcpICsgMTtcbiAgfVxuXG4gIHRoaXMuaGFuZGxlS2V5RG93biA9IGZ1bmN0aW9uKGtleSwgZXZ0KSB7XG4gICAgdmFyIGRhdGUgPSB0aGlzLmFjdGl2ZURhdGUuZ2V0RGF0ZSgpO1xuXG4gICAgaWYgKGtleSA9PT0gJ2xlZnQnKSB7XG4gICAgICBkYXRlID0gZGF0ZSAtIDE7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09ICd1cCcpIHtcbiAgICAgIGRhdGUgPSBkYXRlIC0gNztcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ3JpZ2h0Jykge1xuICAgICAgZGF0ZSA9IGRhdGUgKyAxO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnZG93bicpIHtcbiAgICAgIGRhdGUgPSBkYXRlICsgNztcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ3BhZ2V1cCcgfHwga2V5ID09PSAncGFnZWRvd24nKSB7XG4gICAgICB2YXIgbW9udGggPSB0aGlzLmFjdGl2ZURhdGUuZ2V0TW9udGgoKSArIChrZXkgPT09ICdwYWdldXAnID8gLSAxIDogMSk7XG4gICAgICB0aGlzLmFjdGl2ZURhdGUuc2V0TW9udGgobW9udGgsIDEpO1xuICAgICAgZGF0ZSA9IE1hdGgubWluKGdldERheXNJbk1vbnRoKHRoaXMuYWN0aXZlRGF0ZS5nZXRGdWxsWWVhcigpLCB0aGlzLmFjdGl2ZURhdGUuZ2V0TW9udGgoKSksIGRhdGUpO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnaG9tZScpIHtcbiAgICAgIGRhdGUgPSAxO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnZW5kJykge1xuICAgICAgZGF0ZSA9IGdldERheXNJbk1vbnRoKHRoaXMuYWN0aXZlRGF0ZS5nZXRGdWxsWWVhcigpLCB0aGlzLmFjdGl2ZURhdGUuZ2V0TW9udGgoKSk7XG4gICAgfVxuICAgIHRoaXMuYWN0aXZlRGF0ZS5zZXREYXRlKGRhdGUpO1xuICB9O1xufV0pXG5cbi5jb250cm9sbGVyKCdVaWJNb250aHBpY2tlckNvbnRyb2xsZXInLCBbJyRzY29wZScsICckZWxlbWVudCcsICdkYXRlRmlsdGVyJywgZnVuY3Rpb24oc2NvcGUsICRlbGVtZW50LCBkYXRlRmlsdGVyKSB7XG4gIHRoaXMuc3RlcCA9IHsgeWVhcnM6IDEgfTtcbiAgdGhpcy5lbGVtZW50ID0gJGVsZW1lbnQ7XG5cbiAgdGhpcy5pbml0ID0gZnVuY3Rpb24oY3RybCkge1xuICAgIGFuZ3VsYXIuZXh0ZW5kKGN0cmwsIHRoaXMpO1xuICAgIGN0cmwucmVmcmVzaFZpZXcoKTtcbiAgfTtcblxuICB0aGlzLl9yZWZyZXNoVmlldyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBtb250aHMgPSBuZXcgQXJyYXkoMTIpLFxuICAgICAgICB5ZWFyID0gdGhpcy5hY3RpdmVEYXRlLmdldEZ1bGxZZWFyKCksXG4gICAgICAgIGRhdGU7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgIGRhdGUgPSBuZXcgRGF0ZSh0aGlzLmFjdGl2ZURhdGUpO1xuICAgICAgZGF0ZS5zZXRGdWxsWWVhcih5ZWFyLCBpLCAxKTtcbiAgICAgIG1vbnRoc1tpXSA9IGFuZ3VsYXIuZXh0ZW5kKHRoaXMuY3JlYXRlRGF0ZU9iamVjdChkYXRlLCB0aGlzLmZvcm1hdE1vbnRoKSwge1xuICAgICAgICB1aWQ6IHNjb3BlLnVuaXF1ZUlkICsgJy0nICsgaVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgc2NvcGUudGl0bGUgPSBkYXRlRmlsdGVyKHRoaXMuYWN0aXZlRGF0ZSwgdGhpcy5mb3JtYXRNb250aFRpdGxlKTtcbiAgICBzY29wZS5yb3dzID0gdGhpcy5zcGxpdChtb250aHMsIHRoaXMubW9udGhDb2x1bW5zKTtcbiAgICBzY29wZS55ZWFySGVhZGVyQ29sc3BhbiA9IHRoaXMubW9udGhDb2x1bW5zID4gMyA/IHRoaXMubW9udGhDb2x1bW5zIC0gMiA6IDE7XG4gIH07XG5cbiAgdGhpcy5jb21wYXJlID0gZnVuY3Rpb24oZGF0ZTEsIGRhdGUyKSB7XG4gICAgdmFyIF9kYXRlMSA9IG5ldyBEYXRlKGRhdGUxLmdldEZ1bGxZZWFyKCksIGRhdGUxLmdldE1vbnRoKCkpO1xuICAgIHZhciBfZGF0ZTIgPSBuZXcgRGF0ZShkYXRlMi5nZXRGdWxsWWVhcigpLCBkYXRlMi5nZXRNb250aCgpKTtcbiAgICBfZGF0ZTEuc2V0RnVsbFllYXIoZGF0ZTEuZ2V0RnVsbFllYXIoKSk7XG4gICAgX2RhdGUyLnNldEZ1bGxZZWFyKGRhdGUyLmdldEZ1bGxZZWFyKCkpO1xuICAgIHJldHVybiBfZGF0ZTEgLSBfZGF0ZTI7XG4gIH07XG5cbiAgdGhpcy5oYW5kbGVLZXlEb3duID0gZnVuY3Rpb24oa2V5LCBldnQpIHtcbiAgICB2YXIgZGF0ZSA9IHRoaXMuYWN0aXZlRGF0ZS5nZXRNb250aCgpO1xuXG4gICAgaWYgKGtleSA9PT0gJ2xlZnQnKSB7XG4gICAgICBkYXRlID0gZGF0ZSAtIDE7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09ICd1cCcpIHtcbiAgICAgIGRhdGUgPSBkYXRlIC0gdGhpcy5tb250aENvbHVtbnM7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09ICdyaWdodCcpIHtcbiAgICAgIGRhdGUgPSBkYXRlICsgMTtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ2Rvd24nKSB7XG4gICAgICBkYXRlID0gZGF0ZSArIHRoaXMubW9udGhDb2x1bW5zO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSAncGFnZXVwJyB8fCBrZXkgPT09ICdwYWdlZG93bicpIHtcbiAgICAgIHZhciB5ZWFyID0gdGhpcy5hY3RpdmVEYXRlLmdldEZ1bGxZZWFyKCkgKyAoa2V5ID09PSAncGFnZXVwJyA/IC0gMSA6IDEpO1xuICAgICAgdGhpcy5hY3RpdmVEYXRlLnNldEZ1bGxZZWFyKHllYXIpO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnaG9tZScpIHtcbiAgICAgIGRhdGUgPSAwO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnZW5kJykge1xuICAgICAgZGF0ZSA9IDExO1xuICAgIH1cbiAgICB0aGlzLmFjdGl2ZURhdGUuc2V0TW9udGgoZGF0ZSk7XG4gIH07XG59XSlcblxuLmNvbnRyb2xsZXIoJ1VpYlllYXJwaWNrZXJDb250cm9sbGVyJywgWyckc2NvcGUnLCAnJGVsZW1lbnQnLCAnZGF0ZUZpbHRlcicsIGZ1bmN0aW9uKHNjb3BlLCAkZWxlbWVudCwgZGF0ZUZpbHRlcikge1xuICB2YXIgY29sdW1ucywgcmFuZ2U7XG4gIHRoaXMuZWxlbWVudCA9ICRlbGVtZW50O1xuXG4gIGZ1bmN0aW9uIGdldFN0YXJ0aW5nWWVhcih5ZWFyKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KCh5ZWFyIC0gMSkgLyByYW5nZSwgMTApICogcmFuZ2UgKyAxO1xuICB9XG5cbiAgdGhpcy55ZWFycGlja2VySW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgIGNvbHVtbnMgPSB0aGlzLnllYXJDb2x1bW5zO1xuICAgIHJhbmdlID0gdGhpcy55ZWFyUm93cyAqIGNvbHVtbnM7XG4gICAgdGhpcy5zdGVwID0geyB5ZWFyczogcmFuZ2UgfTtcbiAgfTtcblxuICB0aGlzLl9yZWZyZXNoVmlldyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB5ZWFycyA9IG5ldyBBcnJheShyYW5nZSksIGRhdGU7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgc3RhcnQgPSBnZXRTdGFydGluZ1llYXIodGhpcy5hY3RpdmVEYXRlLmdldEZ1bGxZZWFyKCkpOyBpIDwgcmFuZ2U7IGkrKykge1xuICAgICAgZGF0ZSA9IG5ldyBEYXRlKHRoaXMuYWN0aXZlRGF0ZSk7XG4gICAgICBkYXRlLnNldEZ1bGxZZWFyKHN0YXJ0ICsgaSwgMCwgMSk7XG4gICAgICB5ZWFyc1tpXSA9IGFuZ3VsYXIuZXh0ZW5kKHRoaXMuY3JlYXRlRGF0ZU9iamVjdChkYXRlLCB0aGlzLmZvcm1hdFllYXIpLCB7XG4gICAgICAgIHVpZDogc2NvcGUudW5pcXVlSWQgKyAnLScgKyBpXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBzY29wZS50aXRsZSA9IFt5ZWFyc1swXS5sYWJlbCwgeWVhcnNbcmFuZ2UgLSAxXS5sYWJlbF0uam9pbignIC0gJyk7XG4gICAgc2NvcGUucm93cyA9IHRoaXMuc3BsaXQoeWVhcnMsIGNvbHVtbnMpO1xuICAgIHNjb3BlLmNvbHVtbnMgPSBjb2x1bW5zO1xuICB9O1xuXG4gIHRoaXMuY29tcGFyZSA9IGZ1bmN0aW9uKGRhdGUxLCBkYXRlMikge1xuICAgIHJldHVybiBkYXRlMS5nZXRGdWxsWWVhcigpIC0gZGF0ZTIuZ2V0RnVsbFllYXIoKTtcbiAgfTtcblxuICB0aGlzLmhhbmRsZUtleURvd24gPSBmdW5jdGlvbihrZXksIGV2dCkge1xuICAgIHZhciBkYXRlID0gdGhpcy5hY3RpdmVEYXRlLmdldEZ1bGxZZWFyKCk7XG5cbiAgICBpZiAoa2V5ID09PSAnbGVmdCcpIHtcbiAgICAgIGRhdGUgPSBkYXRlIC0gMTtcbiAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ3VwJykge1xuICAgICAgZGF0ZSA9IGRhdGUgLSBjb2x1bW5zO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSAncmlnaHQnKSB7XG4gICAgICBkYXRlID0gZGF0ZSArIDE7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09ICdkb3duJykge1xuICAgICAgZGF0ZSA9IGRhdGUgKyBjb2x1bW5zO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSAncGFnZXVwJyB8fCBrZXkgPT09ICdwYWdlZG93bicpIHtcbiAgICAgIGRhdGUgKz0gKGtleSA9PT0gJ3BhZ2V1cCcgPyAtIDEgOiAxKSAqIHJhbmdlO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnaG9tZScpIHtcbiAgICAgIGRhdGUgPSBnZXRTdGFydGluZ1llYXIodGhpcy5hY3RpdmVEYXRlLmdldEZ1bGxZZWFyKCkpO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnZW5kJykge1xuICAgICAgZGF0ZSA9IGdldFN0YXJ0aW5nWWVhcih0aGlzLmFjdGl2ZURhdGUuZ2V0RnVsbFllYXIoKSkgKyByYW5nZSAtIDE7XG4gICAgfVxuICAgIHRoaXMuYWN0aXZlRGF0ZS5zZXRGdWxsWWVhcihkYXRlKTtcbiAgfTtcbn1dKVxuXG4uZGlyZWN0aXZlKCd1aWJEYXRlcGlja2VyJywgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgdGVtcGxhdGVVcmw6IGZ1bmN0aW9uKGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgICByZXR1cm4gYXR0cnMudGVtcGxhdGVVcmwgfHwgJ3VpYi90ZW1wbGF0ZS9kYXRlcGlja2VyL2RhdGVwaWNrZXIuaHRtbCc7XG4gICAgfSxcbiAgICBzY29wZToge1xuICAgICAgZGF0ZXBpY2tlck9wdGlvbnM6ICc9PydcbiAgICB9LFxuICAgIHJlcXVpcmU6IFsndWliRGF0ZXBpY2tlcicsICdebmdNb2RlbCddLFxuICAgIHJlc3RyaWN0OiAnQScsXG4gICAgY29udHJvbGxlcjogJ1VpYkRhdGVwaWNrZXJDb250cm9sbGVyJyxcbiAgICBjb250cm9sbGVyQXM6ICdkYXRlcGlja2VyJyxcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIGN0cmxzKSB7XG4gICAgICB2YXIgZGF0ZXBpY2tlckN0cmwgPSBjdHJsc1swXSwgbmdNb2RlbEN0cmwgPSBjdHJsc1sxXTtcblxuICAgICAgZGF0ZXBpY2tlckN0cmwuaW5pdChuZ01vZGVsQ3RybCk7XG4gICAgfVxuICB9O1xufSlcblxuLmRpcmVjdGl2ZSgndWliRGF5cGlja2VyJywgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgdGVtcGxhdGVVcmw6IGZ1bmN0aW9uKGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgICByZXR1cm4gYXR0cnMudGVtcGxhdGVVcmwgfHwgJ3VpYi90ZW1wbGF0ZS9kYXRlcGlja2VyL2RheS5odG1sJztcbiAgICB9LFxuICAgIHJlcXVpcmU6IFsnXnVpYkRhdGVwaWNrZXInLCAndWliRGF5cGlja2VyJ10sXG4gICAgcmVzdHJpY3Q6ICdBJyxcbiAgICBjb250cm9sbGVyOiAnVWliRGF5cGlja2VyQ29udHJvbGxlcicsXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBjdHJscykge1xuICAgICAgdmFyIGRhdGVwaWNrZXJDdHJsID0gY3RybHNbMF0sXG4gICAgICAgIGRheXBpY2tlckN0cmwgPSBjdHJsc1sxXTtcblxuICAgICAgZGF5cGlja2VyQ3RybC5pbml0KGRhdGVwaWNrZXJDdHJsKTtcbiAgICB9XG4gIH07XG59KVxuXG4uZGlyZWN0aXZlKCd1aWJNb250aHBpY2tlcicsIGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHRlbXBsYXRlVXJsOiBmdW5jdGlvbihlbGVtZW50LCBhdHRycykge1xuICAgICAgcmV0dXJuIGF0dHJzLnRlbXBsYXRlVXJsIHx8ICd1aWIvdGVtcGxhdGUvZGF0ZXBpY2tlci9tb250aC5odG1sJztcbiAgICB9LFxuICAgIHJlcXVpcmU6IFsnXnVpYkRhdGVwaWNrZXInLCAndWliTW9udGhwaWNrZXInXSxcbiAgICByZXN0cmljdDogJ0EnLFxuICAgIGNvbnRyb2xsZXI6ICdVaWJNb250aHBpY2tlckNvbnRyb2xsZXInLFxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgY3RybHMpIHtcbiAgICAgIHZhciBkYXRlcGlja2VyQ3RybCA9IGN0cmxzWzBdLFxuICAgICAgICBtb250aHBpY2tlckN0cmwgPSBjdHJsc1sxXTtcblxuICAgICAgbW9udGhwaWNrZXJDdHJsLmluaXQoZGF0ZXBpY2tlckN0cmwpO1xuICAgIH1cbiAgfTtcbn0pXG5cbi5kaXJlY3RpdmUoJ3VpYlllYXJwaWNrZXInLCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICB0ZW1wbGF0ZVVybDogZnVuY3Rpb24oZWxlbWVudCwgYXR0cnMpIHtcbiAgICAgIHJldHVybiBhdHRycy50ZW1wbGF0ZVVybCB8fCAndWliL3RlbXBsYXRlL2RhdGVwaWNrZXIveWVhci5odG1sJztcbiAgICB9LFxuICAgIHJlcXVpcmU6IFsnXnVpYkRhdGVwaWNrZXInLCAndWliWWVhcnBpY2tlciddLFxuICAgIHJlc3RyaWN0OiAnQScsXG4gICAgY29udHJvbGxlcjogJ1VpYlllYXJwaWNrZXJDb250cm9sbGVyJyxcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIGN0cmxzKSB7XG4gICAgICB2YXIgY3RybCA9IGN0cmxzWzBdO1xuICAgICAgYW5ndWxhci5leHRlbmQoY3RybCwgY3RybHNbMV0pO1xuICAgICAgY3RybC55ZWFycGlja2VySW5pdCgpO1xuXG4gICAgICBjdHJsLnJlZnJlc2hWaWV3KCk7XG4gICAgfVxuICB9O1xufSk7XG5cbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAucG9zaXRpb24nLCBbXSlcblxuLyoqXG4gKiBBIHNldCBvZiB1dGlsaXR5IG1ldGhvZHMgZm9yIHdvcmtpbmcgd2l0aCB0aGUgRE9NLlxuICogSXQgaXMgbWVhbnQgdG8gYmUgdXNlZCB3aGVyZSB3ZSBuZWVkIHRvIGFic29sdXRlLXBvc2l0aW9uIGVsZW1lbnRzIGluXG4gKiByZWxhdGlvbiB0byBhbm90aGVyIGVsZW1lbnQgKHRoaXMgaXMgdGhlIGNhc2UgZm9yIHRvb2x0aXBzLCBwb3BvdmVycyxcbiAqIHR5cGVhaGVhZCBzdWdnZXN0aW9ucyBldGMuKS5cbiAqL1xuICAuZmFjdG9yeSgnJHVpYlBvc2l0aW9uJywgWyckZG9jdW1lbnQnLCAnJHdpbmRvdycsIGZ1bmN0aW9uKCRkb2N1bWVudCwgJHdpbmRvdykge1xuICAgIC8qKlxuICAgICAqIFVzZWQgYnkgc2Nyb2xsYmFyV2lkdGgoKSBmdW5jdGlvbiB0byBjYWNoZSBzY3JvbGxiYXIncyB3aWR0aC5cbiAgICAgKiBEbyBub3QgYWNjZXNzIHRoaXMgdmFyaWFibGUgZGlyZWN0bHksIHVzZSBzY3JvbGxiYXJXaWR0aCgpIGluc3RlYWQuXG4gICAgICovXG4gICAgdmFyIFNDUk9MTEJBUl9XSURUSDtcbiAgICAvKipcbiAgICAgKiBzY3JvbGxiYXIgb24gYm9keSBhbmQgaHRtbCBlbGVtZW50IGluIElFIGFuZCBFZGdlIG92ZXJsYXlcbiAgICAgKiBjb250ZW50IGFuZCBzaG91bGQgYmUgY29uc2lkZXJlZCAwIHdpZHRoLlxuICAgICAqL1xuICAgIHZhciBCT0RZX1NDUk9MTEJBUl9XSURUSDtcbiAgICB2YXIgT1ZFUkZMT1dfUkVHRVggPSB7XG4gICAgICBub3JtYWw6IC8oYXV0b3xzY3JvbGwpLyxcbiAgICAgIGhpZGRlbjogLyhhdXRvfHNjcm9sbHxoaWRkZW4pL1xuICAgIH07XG4gICAgdmFyIFBMQUNFTUVOVF9SRUdFWCA9IHtcbiAgICAgIGF1dG86IC9cXHM/YXV0bz9cXHM/L2ksXG4gICAgICBwcmltYXJ5OiAvXih0b3B8Ym90dG9tfGxlZnR8cmlnaHQpJC8sXG4gICAgICBzZWNvbmRhcnk6IC9eKHRvcHxib3R0b218bGVmdHxyaWdodHxjZW50ZXIpJC8sXG4gICAgICB2ZXJ0aWNhbDogL14odG9wfGJvdHRvbSkkL1xuICAgIH07XG4gICAgdmFyIEJPRFlfUkVHRVggPSAvKEhUTUx8Qk9EWSkvO1xuXG4gICAgcmV0dXJuIHtcblxuICAgICAgLyoqXG4gICAgICAgKiBQcm92aWRlcyBhIHJhdyBET00gZWxlbWVudCBmcm9tIGEgalF1ZXJ5L2pRTGl0ZSBlbGVtZW50LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7ZWxlbWVudH0gZWxlbSAtIFRoZSBlbGVtZW50IHRvIGNvbnZlcnQuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybnMge2VsZW1lbnR9IEEgSFRNTCBlbGVtZW50LlxuICAgICAgICovXG4gICAgICBnZXRSYXdOb2RlOiBmdW5jdGlvbihlbGVtKSB7XG4gICAgICAgIHJldHVybiBlbGVtLm5vZGVOYW1lID8gZWxlbSA6IGVsZW1bMF0gfHwgZWxlbTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogUHJvdmlkZXMgYSBwYXJzZWQgbnVtYmVyIGZvciBhIHN0eWxlIHByb3BlcnR5LiAgU3RyaXBzXG4gICAgICAgKiB1bml0cyBhbmQgY2FzdHMgaW52YWxpZCBudW1iZXJzIHRvIDAuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIC0gVGhlIHN0eWxlIHZhbHVlIHRvIHBhcnNlLlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IEEgdmFsaWQgbnVtYmVyLlxuICAgICAgICovXG4gICAgICBwYXJzZVN0eWxlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB2YWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgICByZXR1cm4gaXNGaW5pdGUodmFsdWUpID8gdmFsdWUgOiAwO1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBQcm92aWRlcyB0aGUgY2xvc2VzdCBwb3NpdGlvbmVkIGFuY2VzdG9yLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7ZWxlbWVudH0gZWxlbWVudCAtIFRoZSBlbGVtZW50IHRvIGdldCB0aGUgb2ZmZXN0IHBhcmVudCBmb3IuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybnMge2VsZW1lbnR9IFRoZSBjbG9zZXN0IHBvc2l0aW9uZWQgYW5jZXN0b3IuXG4gICAgICAgKi9cbiAgICAgIG9mZnNldFBhcmVudDogZnVuY3Rpb24oZWxlbSkge1xuICAgICAgICBlbGVtID0gdGhpcy5nZXRSYXdOb2RlKGVsZW0pO1xuXG4gICAgICAgIHZhciBvZmZzZXRQYXJlbnQgPSBlbGVtLm9mZnNldFBhcmVudCB8fCAkZG9jdW1lbnRbMF0uZG9jdW1lbnRFbGVtZW50O1xuXG4gICAgICAgIGZ1bmN0aW9uIGlzU3RhdGljUG9zaXRpb25lZChlbCkge1xuICAgICAgICAgIHJldHVybiAoJHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKS5wb3NpdGlvbiB8fCAnc3RhdGljJykgPT09ICdzdGF0aWMnO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKG9mZnNldFBhcmVudCAmJiBvZmZzZXRQYXJlbnQgIT09ICRkb2N1bWVudFswXS5kb2N1bWVudEVsZW1lbnQgJiYgaXNTdGF0aWNQb3NpdGlvbmVkKG9mZnNldFBhcmVudCkpIHtcbiAgICAgICAgICBvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQub2Zmc2V0UGFyZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9mZnNldFBhcmVudCB8fCAkZG9jdW1lbnRbMF0uZG9jdW1lbnRFbGVtZW50O1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBQcm92aWRlcyB0aGUgc2Nyb2xsYmFyIHdpZHRoLCBjb25jZXB0IGZyb20gVFdCUyBtZWFzdXJlU2Nyb2xsYmFyKClcbiAgICAgICAqIGZ1bmN0aW9uIGluIGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21hc3Rlci9qcy9tb2RhbC5qc1xuICAgICAgICogSW4gSUUgYW5kIEVkZ2UsIHNjb2xsYmFyIG9uIGJvZHkgYW5kIGh0bWwgZWxlbWVudCBvdmVybGF5IGFuZCBzaG91bGRcbiAgICAgICAqIHJldHVybiBhIHdpZHRoIG9mIDAuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybnMge251bWJlcn0gVGhlIHdpZHRoIG9mIHRoZSBicm93c2VyIHNjb2xsYmFyLlxuICAgICAgICovXG4gICAgICBzY3JvbGxiYXJXaWR0aDogZnVuY3Rpb24oaXNCb2R5KSB7XG4gICAgICAgIGlmIChpc0JvZHkpIHtcbiAgICAgICAgICBpZiAoYW5ndWxhci5pc1VuZGVmaW5lZChCT0RZX1NDUk9MTEJBUl9XSURUSCkpIHtcbiAgICAgICAgICAgIHZhciBib2R5RWxlbSA9ICRkb2N1bWVudC5maW5kKCdib2R5Jyk7XG4gICAgICAgICAgICBib2R5RWxlbS5hZGRDbGFzcygndWliLXBvc2l0aW9uLWJvZHktc2Nyb2xsYmFyLW1lYXN1cmUnKTtcbiAgICAgICAgICAgIEJPRFlfU0NST0xMQkFSX1dJRFRIID0gJHdpbmRvdy5pbm5lcldpZHRoIC0gYm9keUVsZW1bMF0uY2xpZW50V2lkdGg7XG4gICAgICAgICAgICBCT0RZX1NDUk9MTEJBUl9XSURUSCA9IGlzRmluaXRlKEJPRFlfU0NST0xMQkFSX1dJRFRIKSA/IEJPRFlfU0NST0xMQkFSX1dJRFRIIDogMDtcbiAgICAgICAgICAgIGJvZHlFbGVtLnJlbW92ZUNsYXNzKCd1aWItcG9zaXRpb24tYm9keS1zY3JvbGxiYXItbWVhc3VyZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gQk9EWV9TQ1JPTExCQVJfV0lEVEg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYW5ndWxhci5pc1VuZGVmaW5lZChTQ1JPTExCQVJfV0lEVEgpKSB7XG4gICAgICAgICAgdmFyIHNjcm9sbEVsZW0gPSBhbmd1bGFyLmVsZW1lbnQoJzxkaXYgY2xhc3M9XCJ1aWItcG9zaXRpb24tc2Nyb2xsYmFyLW1lYXN1cmVcIj48L2Rpdj4nKTtcbiAgICAgICAgICAkZG9jdW1lbnQuZmluZCgnYm9keScpLmFwcGVuZChzY3JvbGxFbGVtKTtcbiAgICAgICAgICBTQ1JPTExCQVJfV0lEVEggPSBzY3JvbGxFbGVtWzBdLm9mZnNldFdpZHRoIC0gc2Nyb2xsRWxlbVswXS5jbGllbnRXaWR0aDtcbiAgICAgICAgICBTQ1JPTExCQVJfV0lEVEggPSBpc0Zpbml0ZShTQ1JPTExCQVJfV0lEVEgpID8gU0NST0xMQkFSX1dJRFRIIDogMDtcbiAgICAgICAgICBzY3JvbGxFbGVtLnJlbW92ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFNDUk9MTEJBUl9XSURUSDtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogUHJvdmlkZXMgdGhlIHBhZGRpbmcgcmVxdWlyZWQgb24gYW4gZWxlbWVudCB0byByZXBsYWNlIHRoZSBzY3JvbGxiYXIuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybnMge29iamVjdH0gQW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgICAgICogICA8dWw+XG4gICAgICAgKiAgICAgPGxpPioqc2Nyb2xsYmFyV2lkdGgqKjogdGhlIHdpZHRoIG9mIHRoZSBzY3JvbGxiYXI8L2xpPlxuICAgICAgICogICAgIDxsaT4qKndpZHRoT3ZlcmZsb3cqKjogd2hldGhlciB0aGUgdGhlIHdpZHRoIGlzIG92ZXJmbG93aW5nPC9saT5cbiAgICAgICAqICAgICA8bGk+KipyaWdodCoqOiB0aGUgYW1vdW50IG9mIHJpZ2h0IHBhZGRpbmcgb24gdGhlIGVsZW1lbnQgbmVlZGVkIHRvIHJlcGxhY2UgdGhlIHNjcm9sbGJhcjwvbGk+XG4gICAgICAgKiAgICAgPGxpPioqcmlnaHRPcmlnaW5hbCoqOiB0aGUgYW1vdW50IG9mIHJpZ2h0IHBhZGRpbmcgY3VycmVudGx5IG9uIHRoZSBlbGVtZW50PC9saT5cbiAgICAgICAqICAgICA8bGk+KipoZWlnaHRPdmVyZmxvdyoqOiB3aGV0aGVyIHRoZSB0aGUgaGVpZ2h0IGlzIG92ZXJmbG93aW5nPC9saT5cbiAgICAgICAqICAgICA8bGk+Kipib3R0b20qKjogdGhlIGFtb3VudCBvZiBib3R0b20gcGFkZGluZyBvbiB0aGUgZWxlbWVudCBuZWVkZWQgdG8gcmVwbGFjZSB0aGUgc2Nyb2xsYmFyPC9saT5cbiAgICAgICAqICAgICA8bGk+Kipib3R0b21PcmlnaW5hbCoqOiB0aGUgYW1vdW50IG9mIGJvdHRvbSBwYWRkaW5nIGN1cnJlbnRseSBvbiB0aGUgZWxlbWVudDwvbGk+XG4gICAgICAgKiAgIDwvdWw+XG4gICAgICAgKi9cbiAgICAgIHNjcm9sbGJhclBhZGRpbmc6IGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgICAgZWxlbSA9IHRoaXMuZ2V0UmF3Tm9kZShlbGVtKTtcblxuICAgICAgICB2YXIgZWxlbVN0eWxlID0gJHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW0pO1xuICAgICAgICB2YXIgcGFkZGluZ1JpZ2h0ID0gdGhpcy5wYXJzZVN0eWxlKGVsZW1TdHlsZS5wYWRkaW5nUmlnaHQpO1xuICAgICAgICB2YXIgcGFkZGluZ0JvdHRvbSA9IHRoaXMucGFyc2VTdHlsZShlbGVtU3R5bGUucGFkZGluZ0JvdHRvbSk7XG4gICAgICAgIHZhciBzY3JvbGxQYXJlbnQgPSB0aGlzLnNjcm9sbFBhcmVudChlbGVtLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIHZhciBzY3JvbGxiYXJXaWR0aCA9IHRoaXMuc2Nyb2xsYmFyV2lkdGgoQk9EWV9SRUdFWC50ZXN0KHNjcm9sbFBhcmVudC50YWdOYW1lKSk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzY3JvbGxiYXJXaWR0aDogc2Nyb2xsYmFyV2lkdGgsXG4gICAgICAgICAgd2lkdGhPdmVyZmxvdzogc2Nyb2xsUGFyZW50LnNjcm9sbFdpZHRoID4gc2Nyb2xsUGFyZW50LmNsaWVudFdpZHRoLFxuICAgICAgICAgIHJpZ2h0OiBwYWRkaW5nUmlnaHQgKyBzY3JvbGxiYXJXaWR0aCxcbiAgICAgICAgICBvcmlnaW5hbFJpZ2h0OiBwYWRkaW5nUmlnaHQsXG4gICAgICAgICAgaGVpZ2h0T3ZlcmZsb3c6IHNjcm9sbFBhcmVudC5zY3JvbGxIZWlnaHQgPiBzY3JvbGxQYXJlbnQuY2xpZW50SGVpZ2h0LFxuICAgICAgICAgIGJvdHRvbTogcGFkZGluZ0JvdHRvbSArIHNjcm9sbGJhcldpZHRoLFxuICAgICAgICAgIG9yaWdpbmFsQm90dG9tOiBwYWRkaW5nQm90dG9tXG4gICAgICAgICB9O1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBDaGVja3MgdG8gc2VlIGlmIHRoZSBlbGVtZW50IGlzIHNjcm9sbGFibGUuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtlbGVtZW50fSBlbGVtIC0gVGhlIGVsZW1lbnQgdG8gY2hlY2suXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBbaW5jbHVkZUhpZGRlbj1mYWxzZV0gLSBTaG91bGQgc2Nyb2xsIHN0eWxlIG9mICdoaWRkZW4nIGJlIGNvbnNpZGVyZWQsXG4gICAgICAgKiAgIGRlZmF1bHQgaXMgZmFsc2UuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgc2Nyb2xsYWJsZS5cbiAgICAgICAqL1xuICAgICAgaXNTY3JvbGxhYmxlOiBmdW5jdGlvbihlbGVtLCBpbmNsdWRlSGlkZGVuKSB7XG4gICAgICAgIGVsZW0gPSB0aGlzLmdldFJhd05vZGUoZWxlbSk7XG5cbiAgICAgICAgdmFyIG92ZXJmbG93UmVnZXggPSBpbmNsdWRlSGlkZGVuID8gT1ZFUkZMT1dfUkVHRVguaGlkZGVuIDogT1ZFUkZMT1dfUkVHRVgubm9ybWFsO1xuICAgICAgICB2YXIgZWxlbVN0eWxlID0gJHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW0pO1xuICAgICAgICByZXR1cm4gb3ZlcmZsb3dSZWdleC50ZXN0KGVsZW1TdHlsZS5vdmVyZmxvdyArIGVsZW1TdHlsZS5vdmVyZmxvd1kgKyBlbGVtU3R5bGUub3ZlcmZsb3dYKTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogUHJvdmlkZXMgdGhlIGNsb3Nlc3Qgc2Nyb2xsYWJsZSBhbmNlc3Rvci5cbiAgICAgICAqIEEgcG9ydCBvZiB0aGUgalF1ZXJ5IFVJIHNjcm9sbFBhcmVudCBtZXRob2Q6XG4gICAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS11aS9ibG9iL21hc3Rlci91aS9zY3JvbGwtcGFyZW50LmpzXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtlbGVtZW50fSBlbGVtIC0gVGhlIGVsZW1lbnQgdG8gZmluZCB0aGUgc2Nyb2xsIHBhcmVudCBvZi5cbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IFtpbmNsdWRlSGlkZGVuPWZhbHNlXSAtIFNob3VsZCBzY3JvbGwgc3R5bGUgb2YgJ2hpZGRlbicgYmUgY29uc2lkZXJlZCxcbiAgICAgICAqICAgZGVmYXVsdCBpcyBmYWxzZS5cbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IFtpbmNsdWRlU2VsZj1mYWxzZV0gLSBTaG91bGQgdGhlIGVsZW1lbnQgYmVpbmcgcGFzc2VkIGJlXG4gICAgICAgKiBpbmNsdWRlZCBpbiB0aGUgc2Nyb2xsYWJsZSBsbG9rdXAuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybnMge2VsZW1lbnR9IEEgSFRNTCBlbGVtZW50LlxuICAgICAgICovXG4gICAgICBzY3JvbGxQYXJlbnQ6IGZ1bmN0aW9uKGVsZW0sIGluY2x1ZGVIaWRkZW4sIGluY2x1ZGVTZWxmKSB7XG4gICAgICAgIGVsZW0gPSB0aGlzLmdldFJhd05vZGUoZWxlbSk7XG5cbiAgICAgICAgdmFyIG92ZXJmbG93UmVnZXggPSBpbmNsdWRlSGlkZGVuID8gT1ZFUkZMT1dfUkVHRVguaGlkZGVuIDogT1ZFUkZMT1dfUkVHRVgubm9ybWFsO1xuICAgICAgICB2YXIgZG9jdW1lbnRFbCA9ICRkb2N1bWVudFswXS5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHZhciBlbGVtU3R5bGUgPSAkd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbSk7XG4gICAgICAgIGlmIChpbmNsdWRlU2VsZiAmJiBvdmVyZmxvd1JlZ2V4LnRlc3QoZWxlbVN0eWxlLm92ZXJmbG93ICsgZWxlbVN0eWxlLm92ZXJmbG93WSArIGVsZW1TdHlsZS5vdmVyZmxvd1gpKSB7XG4gICAgICAgICAgcmV0dXJuIGVsZW07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGV4Y2x1ZGVTdGF0aWMgPSBlbGVtU3R5bGUucG9zaXRpb24gPT09ICdhYnNvbHV0ZSc7XG4gICAgICAgIHZhciBzY3JvbGxQYXJlbnQgPSBlbGVtLnBhcmVudEVsZW1lbnQgfHwgZG9jdW1lbnRFbDtcblxuICAgICAgICBpZiAoc2Nyb2xsUGFyZW50ID09PSBkb2N1bWVudEVsIHx8IGVsZW1TdHlsZS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJykge1xuICAgICAgICAgIHJldHVybiBkb2N1bWVudEVsO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKHNjcm9sbFBhcmVudC5wYXJlbnRFbGVtZW50ICYmIHNjcm9sbFBhcmVudCAhPT0gZG9jdW1lbnRFbCkge1xuICAgICAgICAgIHZhciBzcFN0eWxlID0gJHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHNjcm9sbFBhcmVudCk7XG4gICAgICAgICAgaWYgKGV4Y2x1ZGVTdGF0aWMgJiYgc3BTdHlsZS5wb3NpdGlvbiAhPT0gJ3N0YXRpYycpIHtcbiAgICAgICAgICAgIGV4Y2x1ZGVTdGF0aWMgPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWV4Y2x1ZGVTdGF0aWMgJiYgb3ZlcmZsb3dSZWdleC50ZXN0KHNwU3R5bGUub3ZlcmZsb3cgKyBzcFN0eWxlLm92ZXJmbG93WSArIHNwU3R5bGUub3ZlcmZsb3dYKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNjcm9sbFBhcmVudCA9IHNjcm9sbFBhcmVudC5wYXJlbnRFbGVtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNjcm9sbFBhcmVudDtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogUHJvdmlkZXMgcmVhZC1vbmx5IGVxdWl2YWxlbnQgb2YgalF1ZXJ5J3MgcG9zaXRpb24gZnVuY3Rpb246XG4gICAgICAgKiBodHRwOi8vYXBpLmpxdWVyeS5jb20vcG9zaXRpb24vIC0gZGlzdGFuY2UgdG8gY2xvc2VzdCBwb3NpdGlvbmVkXG4gICAgICAgKiBhbmNlc3Rvci4gIERvZXMgbm90IGFjY291bnQgZm9yIG1hcmdpbnMgYnkgZGVmYXVsdCBsaWtlIGpRdWVyeSBwb3NpdGlvbi5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge2VsZW1lbnR9IGVsZW0gLSBUaGUgZWxlbWVudCB0byBjYWNsdWxhdGUgdGhlIHBvc2l0aW9uIG9uLlxuICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gW2luY2x1ZGVNYXJnaW5zPWZhbHNlXSAtIFNob3VsZCBtYXJnaW5zIGJlIGFjY291bnRlZFxuICAgICAgICogZm9yLCBkZWZhdWx0IGlzIGZhbHNlLlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm5zIHtvYmplY3R9IEFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICAgICAqICAgPHVsPlxuICAgICAgICogICAgIDxsaT4qKndpZHRoKio6IHRoZSB3aWR0aCBvZiB0aGUgZWxlbWVudDwvbGk+XG4gICAgICAgKiAgICAgPGxpPioqaGVpZ2h0Kio6IHRoZSBoZWlnaHQgb2YgdGhlIGVsZW1lbnQ8L2xpPlxuICAgICAgICogICAgIDxsaT4qKnRvcCoqOiBkaXN0YW5jZSB0byB0b3AgZWRnZSBvZiBvZmZzZXQgcGFyZW50PC9saT5cbiAgICAgICAqICAgICA8bGk+KipsZWZ0Kio6IGRpc3RhbmNlIHRvIGxlZnQgZWRnZSBvZiBvZmZzZXQgcGFyZW50PC9saT5cbiAgICAgICAqICAgPC91bD5cbiAgICAgICAqL1xuICAgICAgcG9zaXRpb246IGZ1bmN0aW9uKGVsZW0sIGluY2x1ZGVNYWdpbnMpIHtcbiAgICAgICAgZWxlbSA9IHRoaXMuZ2V0UmF3Tm9kZShlbGVtKTtcblxuICAgICAgICB2YXIgZWxlbU9mZnNldCA9IHRoaXMub2Zmc2V0KGVsZW0pO1xuICAgICAgICBpZiAoaW5jbHVkZU1hZ2lucykge1xuICAgICAgICAgIHZhciBlbGVtU3R5bGUgPSAkd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbSk7XG4gICAgICAgICAgZWxlbU9mZnNldC50b3AgLT0gdGhpcy5wYXJzZVN0eWxlKGVsZW1TdHlsZS5tYXJnaW5Ub3ApO1xuICAgICAgICAgIGVsZW1PZmZzZXQubGVmdCAtPSB0aGlzLnBhcnNlU3R5bGUoZWxlbVN0eWxlLm1hcmdpbkxlZnQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudChlbGVtKTtcbiAgICAgICAgdmFyIHBhcmVudE9mZnNldCA9IHt0b3A6IDAsIGxlZnQ6IDB9O1xuXG4gICAgICAgIGlmIChwYXJlbnQgIT09ICRkb2N1bWVudFswXS5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgICAgICBwYXJlbnRPZmZzZXQgPSB0aGlzLm9mZnNldChwYXJlbnQpO1xuICAgICAgICAgIHBhcmVudE9mZnNldC50b3AgKz0gcGFyZW50LmNsaWVudFRvcCAtIHBhcmVudC5zY3JvbGxUb3A7XG4gICAgICAgICAgcGFyZW50T2Zmc2V0LmxlZnQgKz0gcGFyZW50LmNsaWVudExlZnQgLSBwYXJlbnQuc2Nyb2xsTGVmdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgd2lkdGg6IE1hdGgucm91bmQoYW5ndWxhci5pc051bWJlcihlbGVtT2Zmc2V0LndpZHRoKSA/IGVsZW1PZmZzZXQud2lkdGggOiBlbGVtLm9mZnNldFdpZHRoKSxcbiAgICAgICAgICBoZWlnaHQ6IE1hdGgucm91bmQoYW5ndWxhci5pc051bWJlcihlbGVtT2Zmc2V0LmhlaWdodCkgPyBlbGVtT2Zmc2V0LmhlaWdodCA6IGVsZW0ub2Zmc2V0SGVpZ2h0KSxcbiAgICAgICAgICB0b3A6IE1hdGgucm91bmQoZWxlbU9mZnNldC50b3AgLSBwYXJlbnRPZmZzZXQudG9wKSxcbiAgICAgICAgICBsZWZ0OiBNYXRoLnJvdW5kKGVsZW1PZmZzZXQubGVmdCAtIHBhcmVudE9mZnNldC5sZWZ0KVxuICAgICAgICB9O1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBQcm92aWRlcyByZWFkLW9ubHkgZXF1aXZhbGVudCBvZiBqUXVlcnkncyBvZmZzZXQgZnVuY3Rpb246XG4gICAgICAgKiBodHRwOi8vYXBpLmpxdWVyeS5jb20vb2Zmc2V0LyAtIGRpc3RhbmNlIHRvIHZpZXdwb3J0LiAgRG9lc1xuICAgICAgICogbm90IGFjY291bnQgZm9yIGJvcmRlcnMsIG1hcmdpbnMsIG9yIHBhZGRpbmcgb24gdGhlIGJvZHlcbiAgICAgICAqIGVsZW1lbnQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtlbGVtZW50fSBlbGVtIC0gVGhlIGVsZW1lbnQgdG8gY2FsY3VsYXRlIHRoZSBvZmZzZXQgb24uXG4gICAgICAgKlxuICAgICAgICogQHJldHVybnMge29iamVjdH0gQW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgICAgICogICA8dWw+XG4gICAgICAgKiAgICAgPGxpPioqd2lkdGgqKjogdGhlIHdpZHRoIG9mIHRoZSBlbGVtZW50PC9saT5cbiAgICAgICAqICAgICA8bGk+KipoZWlnaHQqKjogdGhlIGhlaWdodCBvZiB0aGUgZWxlbWVudDwvbGk+XG4gICAgICAgKiAgICAgPGxpPioqdG9wKio6IGRpc3RhbmNlIHRvIHRvcCBlZGdlIG9mIHZpZXdwb3J0PC9saT5cbiAgICAgICAqICAgICA8bGk+KipyaWdodCoqOiBkaXN0YW5jZSB0byBib3R0b20gZWRnZSBvZiB2aWV3cG9ydDwvbGk+XG4gICAgICAgKiAgIDwvdWw+XG4gICAgICAgKi9cbiAgICAgIG9mZnNldDogZnVuY3Rpb24oZWxlbSkge1xuICAgICAgICBlbGVtID0gdGhpcy5nZXRSYXdOb2RlKGVsZW0pO1xuXG4gICAgICAgIHZhciBlbGVtQkNSID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB3aWR0aDogTWF0aC5yb3VuZChhbmd1bGFyLmlzTnVtYmVyKGVsZW1CQ1Iud2lkdGgpID8gZWxlbUJDUi53aWR0aCA6IGVsZW0ub2Zmc2V0V2lkdGgpLFxuICAgICAgICAgIGhlaWdodDogTWF0aC5yb3VuZChhbmd1bGFyLmlzTnVtYmVyKGVsZW1CQ1IuaGVpZ2h0KSA/IGVsZW1CQ1IuaGVpZ2h0IDogZWxlbS5vZmZzZXRIZWlnaHQpLFxuICAgICAgICAgIHRvcDogTWF0aC5yb3VuZChlbGVtQkNSLnRvcCArICgkd2luZG93LnBhZ2VZT2Zmc2V0IHx8ICRkb2N1bWVudFswXS5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wKSksXG4gICAgICAgICAgbGVmdDogTWF0aC5yb3VuZChlbGVtQkNSLmxlZnQgKyAoJHdpbmRvdy5wYWdlWE9mZnNldCB8fCAkZG9jdW1lbnRbMF0uZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQpKVxuICAgICAgICB9O1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBQcm92aWRlcyBvZmZzZXQgZGlzdGFuY2UgdG8gdGhlIGNsb3Nlc3Qgc2Nyb2xsYWJsZSBhbmNlc3RvclxuICAgICAgICogb3Igdmlld3BvcnQuICBBY2NvdW50cyBmb3IgYm9yZGVyIGFuZCBzY3JvbGxiYXIgd2lkdGguXG4gICAgICAgKlxuICAgICAgICogUmlnaHQgYW5kIGJvdHRvbSBkaW1lbnNpb25zIHJlcHJlc2VudCB0aGUgZGlzdGFuY2UgdG8gdGhlXG4gICAgICAgKiByZXNwZWN0aXZlIGVkZ2Ugb2YgdGhlIHZpZXdwb3J0IGVsZW1lbnQuICBJZiB0aGUgZWxlbWVudFxuICAgICAgICogZWRnZSBleHRlbmRzIGJleW9uZCB0aGUgdmlld3BvcnQsIGEgbmVnYXRpdmUgdmFsdWUgd2lsbCBiZVxuICAgICAgICogcmVwb3J0ZWQuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtlbGVtZW50fSBlbGVtIC0gVGhlIGVsZW1lbnQgdG8gZ2V0IHRoZSB2aWV3cG9ydCBvZmZzZXQgZm9yLlxuICAgICAgICogQHBhcmFtIHtib29sZWFuPX0gW3VzZURvY3VtZW50PWZhbHNlXSAtIFNob3VsZCB0aGUgdmlld3BvcnQgYmUgdGhlIGRvY3VtZW50IGVsZW1lbnQgaW5zdGVhZFxuICAgICAgICogb2YgdGhlIGZpcnN0IHNjcm9sbGFibGUgZWxlbWVudCwgZGVmYXVsdCBpcyBmYWxzZS5cbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IFtpbmNsdWRlUGFkZGluZz10cnVlXSAtIFNob3VsZCB0aGUgcGFkZGluZyBvbiB0aGUgb2Zmc2V0IHBhcmVudCBlbGVtZW50XG4gICAgICAgKiBiZSBhY2NvdW50ZWQgZm9yLCBkZWZhdWx0IGlzIHRydWUuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybnMge29iamVjdH0gQW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgICAgICogICA8dWw+XG4gICAgICAgKiAgICAgPGxpPioqdG9wKio6IGRpc3RhbmNlIHRvIHRoZSB0b3AgY29udGVudCBlZGdlIG9mIHZpZXdwb3J0IGVsZW1lbnQ8L2xpPlxuICAgICAgICogICAgIDxsaT4qKmJvdHRvbSoqOiBkaXN0YW5jZSB0byB0aGUgYm90dG9tIGNvbnRlbnQgZWRnZSBvZiB2aWV3cG9ydCBlbGVtZW50PC9saT5cbiAgICAgICAqICAgICA8bGk+KipsZWZ0Kio6IGRpc3RhbmNlIHRvIHRoZSBsZWZ0IGNvbnRlbnQgZWRnZSBvZiB2aWV3cG9ydCBlbGVtZW50PC9saT5cbiAgICAgICAqICAgICA8bGk+KipyaWdodCoqOiBkaXN0YW5jZSB0byB0aGUgcmlnaHQgY29udGVudCBlZGdlIG9mIHZpZXdwb3J0IGVsZW1lbnQ8L2xpPlxuICAgICAgICogICA8L3VsPlxuICAgICAgICovXG4gICAgICB2aWV3cG9ydE9mZnNldDogZnVuY3Rpb24oZWxlbSwgdXNlRG9jdW1lbnQsIGluY2x1ZGVQYWRkaW5nKSB7XG4gICAgICAgIGVsZW0gPSB0aGlzLmdldFJhd05vZGUoZWxlbSk7XG4gICAgICAgIGluY2x1ZGVQYWRkaW5nID0gaW5jbHVkZVBhZGRpbmcgIT09IGZhbHNlID8gdHJ1ZSA6IGZhbHNlO1xuXG4gICAgICAgIHZhciBlbGVtQkNSID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdmFyIG9mZnNldEJDUiA9IHt0b3A6IDAsIGxlZnQ6IDAsIGJvdHRvbTogMCwgcmlnaHQ6IDB9O1xuXG4gICAgICAgIHZhciBvZmZzZXRQYXJlbnQgPSB1c2VEb2N1bWVudCA/ICRkb2N1bWVudFswXS5kb2N1bWVudEVsZW1lbnQgOiB0aGlzLnNjcm9sbFBhcmVudChlbGVtKTtcbiAgICAgICAgdmFyIG9mZnNldFBhcmVudEJDUiA9IG9mZnNldFBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICBvZmZzZXRCQ1IudG9wID0gb2Zmc2V0UGFyZW50QkNSLnRvcCArIG9mZnNldFBhcmVudC5jbGllbnRUb3A7XG4gICAgICAgIG9mZnNldEJDUi5sZWZ0ID0gb2Zmc2V0UGFyZW50QkNSLmxlZnQgKyBvZmZzZXRQYXJlbnQuY2xpZW50TGVmdDtcbiAgICAgICAgaWYgKG9mZnNldFBhcmVudCA9PT0gJGRvY3VtZW50WzBdLmRvY3VtZW50RWxlbWVudCkge1xuICAgICAgICAgIG9mZnNldEJDUi50b3AgKz0gJHdpbmRvdy5wYWdlWU9mZnNldDtcbiAgICAgICAgICBvZmZzZXRCQ1IubGVmdCArPSAkd2luZG93LnBhZ2VYT2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIG9mZnNldEJDUi5ib3R0b20gPSBvZmZzZXRCQ1IudG9wICsgb2Zmc2V0UGFyZW50LmNsaWVudEhlaWdodDtcbiAgICAgICAgb2Zmc2V0QkNSLnJpZ2h0ID0gb2Zmc2V0QkNSLmxlZnQgKyBvZmZzZXRQYXJlbnQuY2xpZW50V2lkdGg7XG5cbiAgICAgICAgaWYgKGluY2x1ZGVQYWRkaW5nKSB7XG4gICAgICAgICAgdmFyIG9mZnNldFBhcmVudFN0eWxlID0gJHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG9mZnNldFBhcmVudCk7XG4gICAgICAgICAgb2Zmc2V0QkNSLnRvcCArPSB0aGlzLnBhcnNlU3R5bGUob2Zmc2V0UGFyZW50U3R5bGUucGFkZGluZ1RvcCk7XG4gICAgICAgICAgb2Zmc2V0QkNSLmJvdHRvbSAtPSB0aGlzLnBhcnNlU3R5bGUob2Zmc2V0UGFyZW50U3R5bGUucGFkZGluZ0JvdHRvbSk7XG4gICAgICAgICAgb2Zmc2V0QkNSLmxlZnQgKz0gdGhpcy5wYXJzZVN0eWxlKG9mZnNldFBhcmVudFN0eWxlLnBhZGRpbmdMZWZ0KTtcbiAgICAgICAgICBvZmZzZXRCQ1IucmlnaHQgLT0gdGhpcy5wYXJzZVN0eWxlKG9mZnNldFBhcmVudFN0eWxlLnBhZGRpbmdSaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRvcDogTWF0aC5yb3VuZChlbGVtQkNSLnRvcCAtIG9mZnNldEJDUi50b3ApLFxuICAgICAgICAgIGJvdHRvbTogTWF0aC5yb3VuZChvZmZzZXRCQ1IuYm90dG9tIC0gZWxlbUJDUi5ib3R0b20pLFxuICAgICAgICAgIGxlZnQ6IE1hdGgucm91bmQoZWxlbUJDUi5sZWZ0IC0gb2Zmc2V0QkNSLmxlZnQpLFxuICAgICAgICAgIHJpZ2h0OiBNYXRoLnJvdW5kKG9mZnNldEJDUi5yaWdodCAtIGVsZW1CQ1IucmlnaHQpXG4gICAgICAgIH07XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFByb3ZpZGVzIGFuIGFycmF5IG9mIHBsYWNlbWVudCB2YWx1ZXMgcGFyc2VkIGZyb20gYSBwbGFjZW1lbnQgc3RyaW5nLlxuICAgICAgICogQWxvbmcgd2l0aCB0aGUgJ2F1dG8nIGluZGljYXRvciwgc3VwcG9ydGVkIHBsYWNlbWVudCBzdHJpbmdzIGFyZTpcbiAgICAgICAqICAgPHVsPlxuICAgICAgICogICAgIDxsaT50b3A6IGVsZW1lbnQgb24gdG9wLCBob3Jpem9udGFsbHkgY2VudGVyZWQgb24gaG9zdCBlbGVtZW50LjwvbGk+XG4gICAgICAgKiAgICAgPGxpPnRvcC1sZWZ0OiBlbGVtZW50IG9uIHRvcCwgbGVmdCBlZGdlIGFsaWduZWQgd2l0aCBob3N0IGVsZW1lbnQgbGVmdCBlZGdlLjwvbGk+XG4gICAgICAgKiAgICAgPGxpPnRvcC1yaWdodDogZWxlbWVudCBvbiB0b3AsIGxlcmlnaHRmdCBlZGdlIGFsaWduZWQgd2l0aCBob3N0IGVsZW1lbnQgcmlnaHQgZWRnZS48L2xpPlxuICAgICAgICogICAgIDxsaT5ib3R0b206IGVsZW1lbnQgb24gYm90dG9tLCBob3Jpem9udGFsbHkgY2VudGVyZWQgb24gaG9zdCBlbGVtZW50LjwvbGk+XG4gICAgICAgKiAgICAgPGxpPmJvdHRvbS1sZWZ0OiBlbGVtZW50IG9uIGJvdHRvbSwgbGVmdCBlZGdlIGFsaWduZWQgd2l0aCBob3N0IGVsZW1lbnQgbGVmdCBlZGdlLjwvbGk+XG4gICAgICAgKiAgICAgPGxpPmJvdHRvbS1yaWdodDogZWxlbWVudCBvbiBib3R0b20sIHJpZ2h0IGVkZ2UgYWxpZ25lZCB3aXRoIGhvc3QgZWxlbWVudCByaWdodCBlZGdlLjwvbGk+XG4gICAgICAgKiAgICAgPGxpPmxlZnQ6IGVsZW1lbnQgb24gbGVmdCwgdmVydGljYWxseSBjZW50ZXJlZCBvbiBob3N0IGVsZW1lbnQuPC9saT5cbiAgICAgICAqICAgICA8bGk+bGVmdC10b3A6IGVsZW1lbnQgb24gbGVmdCwgdG9wIGVkZ2UgYWxpZ25lZCB3aXRoIGhvc3QgZWxlbWVudCB0b3AgZWRnZS48L2xpPlxuICAgICAgICogICAgIDxsaT5sZWZ0LWJvdHRvbTogZWxlbWVudCBvbiBsZWZ0LCBib3R0b20gZWRnZSBhbGlnbmVkIHdpdGggaG9zdCBlbGVtZW50IGJvdHRvbSBlZGdlLjwvbGk+XG4gICAgICAgKiAgICAgPGxpPnJpZ2h0OiBlbGVtZW50IG9uIHJpZ2h0LCB2ZXJ0aWNhbGx5IGNlbnRlcmVkIG9uIGhvc3QgZWxlbWVudC48L2xpPlxuICAgICAgICogICAgIDxsaT5yaWdodC10b3A6IGVsZW1lbnQgb24gcmlnaHQsIHRvcCBlZGdlIGFsaWduZWQgd2l0aCBob3N0IGVsZW1lbnQgdG9wIGVkZ2UuPC9saT5cbiAgICAgICAqICAgICA8bGk+cmlnaHQtYm90dG9tOiBlbGVtZW50IG9uIHJpZ2h0LCBib3R0b20gZWRnZSBhbGlnbmVkIHdpdGggaG9zdCBlbGVtZW50IGJvdHRvbSBlZGdlLjwvbGk+XG4gICAgICAgKiAgIDwvdWw+XG4gICAgICAgKiBBIHBsYWNlbWVudCBzdHJpbmcgd2l0aCBhbiAnYXV0bycgaW5kaWNhdG9yIGlzIGV4cGVjdGVkIHRvIGJlXG4gICAgICAgKiBzcGFjZSBzZXBhcmF0ZWQgZnJvbSB0aGUgcGxhY2VtZW50LCBpLmU6ICdhdXRvIGJvdHRvbS1sZWZ0JyAgSWZcbiAgICAgICAqIHRoZSBwcmltYXJ5IGFuZCBzZWNvbmRhcnkgcGxhY2VtZW50IHZhbHVlcyBkbyBub3QgbWF0Y2ggJ3RvcCxcbiAgICAgICAqIGJvdHRvbSwgbGVmdCwgcmlnaHQnIHRoZW4gJ3RvcCcgd2lsbCBiZSB0aGUgcHJpbWFyeSBwbGFjZW1lbnQgYW5kXG4gICAgICAgKiAnY2VudGVyJyB3aWxsIGJlIHRoZSBzZWNvbmRhcnkgcGxhY2VtZW50LiAgSWYgJ2F1dG8nIGlzIHBhc3NlZCwgdHJ1ZVxuICAgICAgICogd2lsbCBiZSByZXR1cm5lZCBhcyB0aGUgM3JkIHZhbHVlIG9mIHRoZSBhcnJheS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGxhY2VtZW50IC0gVGhlIHBsYWNlbWVudCBzdHJpbmcgdG8gcGFyc2UuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybnMge2FycmF5fSBBbiBhcnJheSB3aXRoIHRoZSBmb2xsb3dpbmcgdmFsdWVzXG4gICAgICAgKiA8dWw+XG4gICAgICAgKiAgIDxsaT4qKlswXSoqOiBUaGUgcHJpbWFyeSBwbGFjZW1lbnQuPC9saT5cbiAgICAgICAqICAgPGxpPioqWzFdKio6IFRoZSBzZWNvbmRhcnkgcGxhY2VtZW50LjwvbGk+XG4gICAgICAgKiAgIDxsaT4qKlsyXSoqOiBJZiBhdXRvIGlzIHBhc3NlZDogdHJ1ZSwgZWxzZSB1bmRlZmluZWQuPC9saT5cbiAgICAgICAqIDwvdWw+XG4gICAgICAgKi9cbiAgICAgIHBhcnNlUGxhY2VtZW50OiBmdW5jdGlvbihwbGFjZW1lbnQpIHtcbiAgICAgICAgdmFyIGF1dG9QbGFjZSA9IFBMQUNFTUVOVF9SRUdFWC5hdXRvLnRlc3QocGxhY2VtZW50KTtcbiAgICAgICAgaWYgKGF1dG9QbGFjZSkge1xuICAgICAgICAgIHBsYWNlbWVudCA9IHBsYWNlbWVudC5yZXBsYWNlKFBMQUNFTUVOVF9SRUdFWC5hdXRvLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICBwbGFjZW1lbnQgPSBwbGFjZW1lbnQuc3BsaXQoJy0nKTtcblxuICAgICAgICBwbGFjZW1lbnRbMF0gPSBwbGFjZW1lbnRbMF0gfHwgJ3RvcCc7XG4gICAgICAgIGlmICghUExBQ0VNRU5UX1JFR0VYLnByaW1hcnkudGVzdChwbGFjZW1lbnRbMF0pKSB7XG4gICAgICAgICAgcGxhY2VtZW50WzBdID0gJ3RvcCc7XG4gICAgICAgIH1cblxuICAgICAgICBwbGFjZW1lbnRbMV0gPSBwbGFjZW1lbnRbMV0gfHwgJ2NlbnRlcic7XG4gICAgICAgIGlmICghUExBQ0VNRU5UX1JFR0VYLnNlY29uZGFyeS50ZXN0KHBsYWNlbWVudFsxXSkpIHtcbiAgICAgICAgICBwbGFjZW1lbnRbMV0gPSAnY2VudGVyJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhdXRvUGxhY2UpIHtcbiAgICAgICAgICBwbGFjZW1lbnRbMl0gPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBsYWNlbWVudFsyXSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBsYWNlbWVudDtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogUHJvdmlkZXMgY29vcmRpbmF0ZXMgZm9yIGFuIGVsZW1lbnQgdG8gYmUgcG9zaXRpb25lZCByZWxhdGl2ZSB0b1xuICAgICAgICogYW5vdGhlciBlbGVtZW50LiAgUGFzc2luZyAnYXV0bycgYXMgcGFydCBvZiB0aGUgcGxhY2VtZW50IHBhcmFtZXRlclxuICAgICAgICogd2lsbCBlbmFibGUgc21hcnQgcGxhY2VtZW50IC0gd2hlcmUgdGhlIGVsZW1lbnQgZml0cy4gaS5lOlxuICAgICAgICogJ2F1dG8gbGVmdC10b3AnIHdpbGwgY2hlY2sgdG8gc2VlIGlmIHRoZXJlIGlzIGVub3VnaCBzcGFjZSB0byB0aGUgbGVmdFxuICAgICAgICogb2YgdGhlIGhvc3RFbGVtIHRvIGZpdCB0aGUgdGFyZ2V0RWxlbSwgaWYgbm90IHBsYWNlIHJpZ2h0IChzYW1lIGZvciBzZWNvbmRhcnlcbiAgICAgICAqIHRvcCBwbGFjZW1lbnQpLiAgQXZhaWxhYmxlIHNwYWNlIGlzIGNhbGN1bGF0ZWQgdXNpbmcgdGhlIHZpZXdwb3J0T2Zmc2V0XG4gICAgICAgKiBmdW5jdGlvbi5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge2VsZW1lbnR9IGhvc3RFbGVtIC0gVGhlIGVsZW1lbnQgdG8gcG9zaXRpb24gYWdhaW5zdC5cbiAgICAgICAqIEBwYXJhbSB7ZWxlbWVudH0gdGFyZ2V0RWxlbSAtIFRoZSBlbGVtZW50IHRvIHBvc2l0aW9uLlxuICAgICAgICogQHBhcmFtIHtzdHJpbmc9fSBbcGxhY2VtZW50PXRvcF0gLSBUaGUgcGxhY2VtZW50IGZvciB0aGUgdGFyZ2V0RWxlbSxcbiAgICAgICAqICAgZGVmYXVsdCBpcyAndG9wJy4gJ2NlbnRlcicgaXMgYXNzdW1lZCBhcyBzZWNvbmRhcnkgcGxhY2VtZW50IGZvclxuICAgICAgICogICAndG9wJywgJ2xlZnQnLCAncmlnaHQnLCBhbmQgJ2JvdHRvbScgcGxhY2VtZW50cy4gIEF2YWlsYWJsZSBwbGFjZW1lbnRzIGFyZTpcbiAgICAgICAqICAgPHVsPlxuICAgICAgICogICAgIDxsaT50b3A8L2xpPlxuICAgICAgICogICAgIDxsaT50b3AtcmlnaHQ8L2xpPlxuICAgICAgICogICAgIDxsaT50b3AtbGVmdDwvbGk+XG4gICAgICAgKiAgICAgPGxpPmJvdHRvbTwvbGk+XG4gICAgICAgKiAgICAgPGxpPmJvdHRvbS1sZWZ0PC9saT5cbiAgICAgICAqICAgICA8bGk+Ym90dG9tLXJpZ2h0PC9saT5cbiAgICAgICAqICAgICA8bGk+bGVmdDwvbGk+XG4gICAgICAgKiAgICAgPGxpPmxlZnQtdG9wPC9saT5cbiAgICAgICAqICAgICA8bGk+bGVmdC1ib3R0b208L2xpPlxuICAgICAgICogICAgIDxsaT5yaWdodDwvbGk+XG4gICAgICAgKiAgICAgPGxpPnJpZ2h0LXRvcDwvbGk+XG4gICAgICAgKiAgICAgPGxpPnJpZ2h0LWJvdHRvbTwvbGk+XG4gICAgICAgKiAgIDwvdWw+XG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBbYXBwZW5kVG9Cb2R5PWZhbHNlXSAtIFNob3VsZCB0aGUgdG9wIGFuZCBsZWZ0IHZhbHVlcyByZXR1cm5lZFxuICAgICAgICogICBiZSBjYWxjdWxhdGVkIGZyb20gdGhlIGJvZHkgZWxlbWVudCwgZGVmYXVsdCBpcyBmYWxzZS5cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBBbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAgICAgKiAgIDx1bD5cbiAgICAgICAqICAgICA8bGk+Kip0b3AqKjogVmFsdWUgZm9yIHRhcmdldEVsZW0gdG9wLjwvbGk+XG4gICAgICAgKiAgICAgPGxpPioqbGVmdCoqOiBWYWx1ZSBmb3IgdGFyZ2V0RWxlbSBsZWZ0LjwvbGk+XG4gICAgICAgKiAgICAgPGxpPioqcGxhY2VtZW50Kio6IFRoZSByZXNvbHZlZCBwbGFjZW1lbnQuPC9saT5cbiAgICAgICAqICAgPC91bD5cbiAgICAgICAqL1xuICAgICAgcG9zaXRpb25FbGVtZW50czogZnVuY3Rpb24oaG9zdEVsZW0sIHRhcmdldEVsZW0sIHBsYWNlbWVudCwgYXBwZW5kVG9Cb2R5KSB7XG4gICAgICAgIGhvc3RFbGVtID0gdGhpcy5nZXRSYXdOb2RlKGhvc3RFbGVtKTtcbiAgICAgICAgdGFyZ2V0RWxlbSA9IHRoaXMuZ2V0UmF3Tm9kZSh0YXJnZXRFbGVtKTtcblxuICAgICAgICAvLyBuZWVkIHRvIHJlYWQgZnJvbSBwcm9wIHRvIHN1cHBvcnQgdGVzdHMuXG4gICAgICAgIHZhciB0YXJnZXRXaWR0aCA9IGFuZ3VsYXIuaXNEZWZpbmVkKHRhcmdldEVsZW0ub2Zmc2V0V2lkdGgpID8gdGFyZ2V0RWxlbS5vZmZzZXRXaWR0aCA6IHRhcmdldEVsZW0ucHJvcCgnb2Zmc2V0V2lkdGgnKTtcbiAgICAgICAgdmFyIHRhcmdldEhlaWdodCA9IGFuZ3VsYXIuaXNEZWZpbmVkKHRhcmdldEVsZW0ub2Zmc2V0SGVpZ2h0KSA/IHRhcmdldEVsZW0ub2Zmc2V0SGVpZ2h0IDogdGFyZ2V0RWxlbS5wcm9wKCdvZmZzZXRIZWlnaHQnKTtcblxuICAgICAgICBwbGFjZW1lbnQgPSB0aGlzLnBhcnNlUGxhY2VtZW50KHBsYWNlbWVudCk7XG5cbiAgICAgICAgdmFyIGhvc3RFbGVtUG9zID0gYXBwZW5kVG9Cb2R5ID8gdGhpcy5vZmZzZXQoaG9zdEVsZW0pIDogdGhpcy5wb3NpdGlvbihob3N0RWxlbSk7XG4gICAgICAgIHZhciB0YXJnZXRFbGVtUG9zID0ge3RvcDogMCwgbGVmdDogMCwgcGxhY2VtZW50OiAnJ307XG5cbiAgICAgICAgaWYgKHBsYWNlbWVudFsyXSkge1xuICAgICAgICAgIHZhciB2aWV3cG9ydE9mZnNldCA9IHRoaXMudmlld3BvcnRPZmZzZXQoaG9zdEVsZW0sIGFwcGVuZFRvQm9keSk7XG5cbiAgICAgICAgICB2YXIgdGFyZ2V0RWxlbVN0eWxlID0gJHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRhcmdldEVsZW0pO1xuICAgICAgICAgIHZhciBhZGp1c3RlZFNpemUgPSB7XG4gICAgICAgICAgICB3aWR0aDogdGFyZ2V0V2lkdGggKyBNYXRoLnJvdW5kKE1hdGguYWJzKHRoaXMucGFyc2VTdHlsZSh0YXJnZXRFbGVtU3R5bGUubWFyZ2luTGVmdCkgKyB0aGlzLnBhcnNlU3R5bGUodGFyZ2V0RWxlbVN0eWxlLm1hcmdpblJpZ2h0KSkpLFxuICAgICAgICAgICAgaGVpZ2h0OiB0YXJnZXRIZWlnaHQgKyBNYXRoLnJvdW5kKE1hdGguYWJzKHRoaXMucGFyc2VTdHlsZSh0YXJnZXRFbGVtU3R5bGUubWFyZ2luVG9wKSArIHRoaXMucGFyc2VTdHlsZSh0YXJnZXRFbGVtU3R5bGUubWFyZ2luQm90dG9tKSkpXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHBsYWNlbWVudFswXSA9IHBsYWNlbWVudFswXSA9PT0gJ3RvcCcgJiYgYWRqdXN0ZWRTaXplLmhlaWdodCA+IHZpZXdwb3J0T2Zmc2V0LnRvcCAmJiBhZGp1c3RlZFNpemUuaGVpZ2h0IDw9IHZpZXdwb3J0T2Zmc2V0LmJvdHRvbSA/ICdib3R0b20nIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnRbMF0gPT09ICdib3R0b20nICYmIGFkanVzdGVkU2l6ZS5oZWlnaHQgPiB2aWV3cG9ydE9mZnNldC5ib3R0b20gJiYgYWRqdXN0ZWRTaXplLmhlaWdodCA8PSB2aWV3cG9ydE9mZnNldC50b3AgPyAndG9wJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2VtZW50WzBdID09PSAnbGVmdCcgJiYgYWRqdXN0ZWRTaXplLndpZHRoID4gdmlld3BvcnRPZmZzZXQubGVmdCAmJiBhZGp1c3RlZFNpemUud2lkdGggPD0gdmlld3BvcnRPZmZzZXQucmlnaHQgPyAncmlnaHQnIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnRbMF0gPT09ICdyaWdodCcgJiYgYWRqdXN0ZWRTaXplLndpZHRoID4gdmlld3BvcnRPZmZzZXQucmlnaHQgJiYgYWRqdXN0ZWRTaXplLndpZHRoIDw9IHZpZXdwb3J0T2Zmc2V0LmxlZnQgPyAnbGVmdCcgOlxuICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlbWVudFswXTtcblxuICAgICAgICAgIHBsYWNlbWVudFsxXSA9IHBsYWNlbWVudFsxXSA9PT0gJ3RvcCcgJiYgYWRqdXN0ZWRTaXplLmhlaWdodCAtIGhvc3RFbGVtUG9zLmhlaWdodCA+IHZpZXdwb3J0T2Zmc2V0LmJvdHRvbSAmJiBhZGp1c3RlZFNpemUuaGVpZ2h0IC0gaG9zdEVsZW1Qb3MuaGVpZ2h0IDw9IHZpZXdwb3J0T2Zmc2V0LnRvcCA/ICdib3R0b20nIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZW1lbnRbMV0gPT09ICdib3R0b20nICYmIGFkanVzdGVkU2l6ZS5oZWlnaHQgLSBob3N0RWxlbVBvcy5oZWlnaHQgPiB2aWV3cG9ydE9mZnNldC50b3AgJiYgYWRqdXN0ZWRTaXplLmhlaWdodCAtIGhvc3RFbGVtUG9zLmhlaWdodCA8PSB2aWV3cG9ydE9mZnNldC5ib3R0b20gPyAndG9wJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2VtZW50WzFdID09PSAnbGVmdCcgJiYgYWRqdXN0ZWRTaXplLndpZHRoIC0gaG9zdEVsZW1Qb3Mud2lkdGggPiB2aWV3cG9ydE9mZnNldC5yaWdodCAmJiBhZGp1c3RlZFNpemUud2lkdGggLSBob3N0RWxlbVBvcy53aWR0aCA8PSB2aWV3cG9ydE9mZnNldC5sZWZ0ID8gJ3JpZ2h0JyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2VtZW50WzFdID09PSAncmlnaHQnICYmIGFkanVzdGVkU2l6ZS53aWR0aCAtIGhvc3RFbGVtUG9zLndpZHRoID4gdmlld3BvcnRPZmZzZXQubGVmdCAmJiBhZGp1c3RlZFNpemUud2lkdGggLSBob3N0RWxlbVBvcy53aWR0aCA8PSB2aWV3cG9ydE9mZnNldC5yaWdodCA/ICdsZWZ0JyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2VtZW50WzFdO1xuXG4gICAgICAgICAgaWYgKHBsYWNlbWVudFsxXSA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgIGlmIChQTEFDRU1FTlRfUkVHRVgudmVydGljYWwudGVzdChwbGFjZW1lbnRbMF0pKSB7XG4gICAgICAgICAgICAgIHZhciB4T3ZlcmZsb3cgPSBob3N0RWxlbVBvcy53aWR0aCAvIDIgLSB0YXJnZXRXaWR0aCAvIDI7XG4gICAgICAgICAgICAgIGlmICh2aWV3cG9ydE9mZnNldC5sZWZ0ICsgeE92ZXJmbG93IDwgMCAmJiBhZGp1c3RlZFNpemUud2lkdGggLSBob3N0RWxlbVBvcy53aWR0aCA8PSB2aWV3cG9ydE9mZnNldC5yaWdodCkge1xuICAgICAgICAgICAgICAgIHBsYWNlbWVudFsxXSA9ICdsZWZ0JztcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh2aWV3cG9ydE9mZnNldC5yaWdodCArIHhPdmVyZmxvdyA8IDAgJiYgYWRqdXN0ZWRTaXplLndpZHRoIC0gaG9zdEVsZW1Qb3Mud2lkdGggPD0gdmlld3BvcnRPZmZzZXQubGVmdCkge1xuICAgICAgICAgICAgICAgIHBsYWNlbWVudFsxXSA9ICdyaWdodCc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciB5T3ZlcmZsb3cgPSBob3N0RWxlbVBvcy5oZWlnaHQgLyAyIC0gYWRqdXN0ZWRTaXplLmhlaWdodCAvIDI7XG4gICAgICAgICAgICAgIGlmICh2aWV3cG9ydE9mZnNldC50b3AgKyB5T3ZlcmZsb3cgPCAwICYmIGFkanVzdGVkU2l6ZS5oZWlnaHQgLSBob3N0RWxlbVBvcy5oZWlnaHQgPD0gdmlld3BvcnRPZmZzZXQuYm90dG9tKSB7XG4gICAgICAgICAgICAgICAgcGxhY2VtZW50WzFdID0gJ3RvcCc7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodmlld3BvcnRPZmZzZXQuYm90dG9tICsgeU92ZXJmbG93IDwgMCAmJiBhZGp1c3RlZFNpemUuaGVpZ2h0IC0gaG9zdEVsZW1Qb3MuaGVpZ2h0IDw9IHZpZXdwb3J0T2Zmc2V0LnRvcCkge1xuICAgICAgICAgICAgICAgIHBsYWNlbWVudFsxXSA9ICdib3R0b20nO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChwbGFjZW1lbnRbMF0pIHtcbiAgICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAgdGFyZ2V0RWxlbVBvcy50b3AgPSBob3N0RWxlbVBvcy50b3AgLSB0YXJnZXRIZWlnaHQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgdGFyZ2V0RWxlbVBvcy50b3AgPSBob3N0RWxlbVBvcy50b3AgKyBob3N0RWxlbVBvcy5oZWlnaHQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgIHRhcmdldEVsZW1Qb3MubGVmdCA9IGhvc3RFbGVtUG9zLmxlZnQgLSB0YXJnZXRXaWR0aDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICAgIHRhcmdldEVsZW1Qb3MubGVmdCA9IGhvc3RFbGVtUG9zLmxlZnQgKyBob3N0RWxlbVBvcy53aWR0aDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoIChwbGFjZW1lbnRbMV0pIHtcbiAgICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAgdGFyZ2V0RWxlbVBvcy50b3AgPSBob3N0RWxlbVBvcy50b3A7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgdGFyZ2V0RWxlbVBvcy50b3AgPSBob3N0RWxlbVBvcy50b3AgKyBob3N0RWxlbVBvcy5oZWlnaHQgLSB0YXJnZXRIZWlnaHQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgIHRhcmdldEVsZW1Qb3MubGVmdCA9IGhvc3RFbGVtUG9zLmxlZnQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICB0YXJnZXRFbGVtUG9zLmxlZnQgPSBob3N0RWxlbVBvcy5sZWZ0ICsgaG9zdEVsZW1Qb3Mud2lkdGggLSB0YXJnZXRXaWR0aDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICAgICAgICBpZiAoUExBQ0VNRU5UX1JFR0VYLnZlcnRpY2FsLnRlc3QocGxhY2VtZW50WzBdKSkge1xuICAgICAgICAgICAgICB0YXJnZXRFbGVtUG9zLmxlZnQgPSBob3N0RWxlbVBvcy5sZWZ0ICsgaG9zdEVsZW1Qb3Mud2lkdGggLyAyIC0gdGFyZ2V0V2lkdGggLyAyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGFyZ2V0RWxlbVBvcy50b3AgPSBob3N0RWxlbVBvcy50b3AgKyBob3N0RWxlbVBvcy5oZWlnaHQgLyAyIC0gdGFyZ2V0SGVpZ2h0IC8gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFyZ2V0RWxlbVBvcy50b3AgPSBNYXRoLnJvdW5kKHRhcmdldEVsZW1Qb3MudG9wKTtcbiAgICAgICAgdGFyZ2V0RWxlbVBvcy5sZWZ0ID0gTWF0aC5yb3VuZCh0YXJnZXRFbGVtUG9zLmxlZnQpO1xuICAgICAgICB0YXJnZXRFbGVtUG9zLnBsYWNlbWVudCA9IHBsYWNlbWVudFsxXSA9PT0gJ2NlbnRlcicgPyBwbGFjZW1lbnRbMF0gOiBwbGFjZW1lbnRbMF0gKyAnLScgKyBwbGFjZW1lbnRbMV07XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldEVsZW1Qb3M7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFByb3ZpZGVzIGEgd2F5IHRvIGFkanVzdCB0aGUgdG9wIHBvc2l0aW9uaW5nIGFmdGVyIGZpcnN0XG4gICAgICAgKiByZW5kZXIgdG8gY29ycmVjdGx5IGFsaWduIGVsZW1lbnQgdG8gdG9wIGFmdGVyIGNvbnRlbnRcbiAgICAgICAqIHJlbmRlcmluZyBjYXVzZXMgcmVzaXplZCBlbGVtZW50IGhlaWdodFxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7YXJyYXl9IHBsYWNlbWVudENsYXNzZXMgLSBUaGUgYXJyYXkgb2Ygc3RyaW5ncyBvZiBjbGFzc2VzXG4gICAgICAgKiBlbGVtZW50IHNob3VsZCBoYXZlLlxuICAgICAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRhaW5lclBvc2l0aW9uIC0gVGhlIG9iamVjdCB3aXRoIGNvbnRhaW5lclxuICAgICAgICogcG9zaXRpb24gaW5mb3JtYXRpb25cbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbml0aWFsSGVpZ2h0IC0gVGhlIGluaXRpYWwgaGVpZ2h0IGZvciB0aGUgZWxlbS5cbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjdXJyZW50SGVpZ2h0IC0gVGhlIGN1cnJlbnQgaGVpZ2h0IGZvciB0aGUgZWxlbS5cbiAgICAgICAqL1xuICAgICAgYWRqdXN0VG9wOiBmdW5jdGlvbihwbGFjZW1lbnRDbGFzc2VzLCBjb250YWluZXJQb3NpdGlvbiwgaW5pdGlhbEhlaWdodCwgY3VycmVudEhlaWdodCkge1xuICAgICAgICBpZiAocGxhY2VtZW50Q2xhc3Nlcy5pbmRleE9mKCd0b3AnKSAhPT0gLTEgJiYgaW5pdGlhbEhlaWdodCAhPT0gY3VycmVudEhlaWdodCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b3A6IGNvbnRhaW5lclBvc2l0aW9uLnRvcCAtIGN1cnJlbnRIZWlnaHQgKyAncHgnXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBQcm92aWRlcyBhIHdheSBmb3IgcG9zaXRpb25pbmcgdG9vbHRpcCAmIGRyb3Bkb3duXG4gICAgICAgKiBhcnJvd3Mgd2hlbiB1c2luZyBwbGFjZW1lbnQgb3B0aW9ucyBiZXlvbmQgdGhlIHN0YW5kYXJkXG4gICAgICAgKiBsZWZ0LCByaWdodCwgdG9wLCBvciBib3R0b20uXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtlbGVtZW50fSBlbGVtIC0gVGhlIHRvb2x0aXAvZHJvcGRvd24gZWxlbWVudC5cbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwbGFjZW1lbnQgLSBUaGUgcGxhY2VtZW50IGZvciB0aGUgZWxlbS5cbiAgICAgICAqL1xuICAgICAgcG9zaXRpb25BcnJvdzogZnVuY3Rpb24oZWxlbSwgcGxhY2VtZW50KSB7XG4gICAgICAgIGVsZW0gPSB0aGlzLmdldFJhd05vZGUoZWxlbSk7XG5cbiAgICAgICAgdmFyIGlubmVyRWxlbSA9IGVsZW0ucXVlcnlTZWxlY3RvcignLnRvb2x0aXAtaW5uZXIsIC5wb3BvdmVyLWlubmVyJyk7XG4gICAgICAgIGlmICghaW5uZXJFbGVtKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGlzVG9vbHRpcCA9IGFuZ3VsYXIuZWxlbWVudChpbm5lckVsZW0pLmhhc0NsYXNzKCd0b29sdGlwLWlubmVyJyk7XG5cbiAgICAgICAgdmFyIGFycm93RWxlbSA9IGlzVG9vbHRpcCA/IGVsZW0ucXVlcnlTZWxlY3RvcignLnRvb2x0aXAtYXJyb3cnKSA6IGVsZW0ucXVlcnlTZWxlY3RvcignLmFycm93Jyk7XG4gICAgICAgIGlmICghYXJyb3dFbGVtKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFycm93Q3NzID0ge1xuICAgICAgICAgIHRvcDogJycsXG4gICAgICAgICAgYm90dG9tOiAnJyxcbiAgICAgICAgICBsZWZ0OiAnJyxcbiAgICAgICAgICByaWdodDogJydcbiAgICAgICAgfTtcblxuICAgICAgICBwbGFjZW1lbnQgPSB0aGlzLnBhcnNlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gICAgICAgIGlmIChwbGFjZW1lbnRbMV0gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgLy8gbm8gYWRqdXN0bWVudCBuZWNlc3NhcnkgLSBqdXN0IHJlc2V0IHN0eWxlc1xuICAgICAgICAgIGFuZ3VsYXIuZWxlbWVudChhcnJvd0VsZW0pLmNzcyhhcnJvd0Nzcyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGJvcmRlclByb3AgPSAnYm9yZGVyLScgKyBwbGFjZW1lbnRbMF0gKyAnLXdpZHRoJztcbiAgICAgICAgdmFyIGJvcmRlcldpZHRoID0gJHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGFycm93RWxlbSlbYm9yZGVyUHJvcF07XG5cbiAgICAgICAgdmFyIGJvcmRlclJhZGl1c1Byb3AgPSAnYm9yZGVyLSc7XG4gICAgICAgIGlmIChQTEFDRU1FTlRfUkVHRVgudmVydGljYWwudGVzdChwbGFjZW1lbnRbMF0pKSB7XG4gICAgICAgICAgYm9yZGVyUmFkaXVzUHJvcCArPSBwbGFjZW1lbnRbMF0gKyAnLScgKyBwbGFjZW1lbnRbMV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYm9yZGVyUmFkaXVzUHJvcCArPSBwbGFjZW1lbnRbMV0gKyAnLScgKyBwbGFjZW1lbnRbMF07XG4gICAgICAgIH1cbiAgICAgICAgYm9yZGVyUmFkaXVzUHJvcCArPSAnLXJhZGl1cyc7XG4gICAgICAgIHZhciBib3JkZXJSYWRpdXMgPSAkd2luZG93LmdldENvbXB1dGVkU3R5bGUoaXNUb29sdGlwID8gaW5uZXJFbGVtIDogZWxlbSlbYm9yZGVyUmFkaXVzUHJvcF07XG5cbiAgICAgICAgc3dpdGNoIChwbGFjZW1lbnRbMF0pIHtcbiAgICAgICAgICBjYXNlICd0b3AnOlxuICAgICAgICAgICAgYXJyb3dDc3MuYm90dG9tID0gaXNUb29sdGlwID8gJzAnIDogJy0nICsgYm9yZGVyV2lkdGg7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdib3R0b20nOlxuICAgICAgICAgICAgYXJyb3dDc3MudG9wID0gaXNUb29sdGlwID8gJzAnIDogJy0nICsgYm9yZGVyV2lkdGg7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgIGFycm93Q3NzLnJpZ2h0ID0gaXNUb29sdGlwID8gJzAnIDogJy0nICsgYm9yZGVyV2lkdGg7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICBhcnJvd0Nzcy5sZWZ0ID0gaXNUb29sdGlwID8gJzAnIDogJy0nICsgYm9yZGVyV2lkdGg7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGFycm93Q3NzW3BsYWNlbWVudFsxXV0gPSBib3JkZXJSYWRpdXM7XG5cbiAgICAgICAgYW5ndWxhci5lbGVtZW50KGFycm93RWxlbSkuY3NzKGFycm93Q3NzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XSk7XG5cbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAuZGF0ZXBpY2tlclBvcHVwJywgWyd1aS5ib290c3RyYXAuZGF0ZXBpY2tlcicsICd1aS5ib290c3RyYXAucG9zaXRpb24nXSlcblxuLnZhbHVlKCckZGF0ZXBpY2tlclBvcHVwTGl0ZXJhbFdhcm5pbmcnLCB0cnVlKVxuXG4uY29uc3RhbnQoJ3VpYkRhdGVwaWNrZXJQb3B1cENvbmZpZycsIHtcbiAgYWx0SW5wdXRGb3JtYXRzOiBbXSxcbiAgYXBwZW5kVG9Cb2R5OiBmYWxzZSxcbiAgY2xlYXJUZXh0OiAnQ2xlYXInLFxuICBjbG9zZU9uRGF0ZVNlbGVjdGlvbjogdHJ1ZSxcbiAgY2xvc2VUZXh0OiAnRG9uZScsXG4gIGN1cnJlbnRUZXh0OiAnVG9kYXknLFxuICBkYXRlcGlja2VyUG9wdXA6ICd5eXl5LU1NLWRkJyxcbiAgZGF0ZXBpY2tlclBvcHVwVGVtcGxhdGVVcmw6ICd1aWIvdGVtcGxhdGUvZGF0ZXBpY2tlclBvcHVwL3BvcHVwLmh0bWwnLFxuICBkYXRlcGlja2VyVGVtcGxhdGVVcmw6ICd1aWIvdGVtcGxhdGUvZGF0ZXBpY2tlci9kYXRlcGlja2VyLmh0bWwnLFxuICBodG1sNVR5cGVzOiB7XG4gICAgZGF0ZTogJ3l5eXktTU0tZGQnLFxuICAgICdkYXRldGltZS1sb2NhbCc6ICd5eXl5LU1NLWRkVEhIOm1tOnNzLnNzcycsXG4gICAgJ21vbnRoJzogJ3l5eXktTU0nXG4gIH0sXG4gIG9uT3BlbkZvY3VzOiB0cnVlLFxuICBzaG93QnV0dG9uQmFyOiB0cnVlLFxuICBwbGFjZW1lbnQ6ICdhdXRvIGJvdHRvbS1sZWZ0J1xufSlcblxuLmNvbnRyb2xsZXIoJ1VpYkRhdGVwaWNrZXJQb3B1cENvbnRyb2xsZXInLCBbJyRzY29wZScsICckZWxlbWVudCcsICckYXR0cnMnLCAnJGNvbXBpbGUnLCAnJGxvZycsICckcGFyc2UnLCAnJHdpbmRvdycsICckZG9jdW1lbnQnLCAnJHJvb3RTY29wZScsICckdWliUG9zaXRpb24nLCAnZGF0ZUZpbHRlcicsICd1aWJEYXRlUGFyc2VyJywgJ3VpYkRhdGVwaWNrZXJQb3B1cENvbmZpZycsICckdGltZW91dCcsICd1aWJEYXRlcGlja2VyQ29uZmlnJywgJyRkYXRlcGlja2VyUG9wdXBMaXRlcmFsV2FybmluZycsXG5mdW5jdGlvbigkc2NvcGUsICRlbGVtZW50LCAkYXR0cnMsICRjb21waWxlLCAkbG9nLCAkcGFyc2UsICR3aW5kb3csICRkb2N1bWVudCwgJHJvb3RTY29wZSwgJHBvc2l0aW9uLCBkYXRlRmlsdGVyLCBkYXRlUGFyc2VyLCBkYXRlcGlja2VyUG9wdXBDb25maWcsICR0aW1lb3V0LCBkYXRlcGlja2VyQ29uZmlnLCAkZGF0ZXBpY2tlclBvcHVwTGl0ZXJhbFdhcm5pbmcpIHtcbiAgdmFyIGNhY2hlID0ge30sXG4gICAgaXNIdG1sNURhdGVJbnB1dCA9IGZhbHNlO1xuICB2YXIgZGF0ZUZvcm1hdCwgY2xvc2VPbkRhdGVTZWxlY3Rpb24sIGFwcGVuZFRvQm9keSwgb25PcGVuRm9jdXMsXG4gICAgZGF0ZXBpY2tlclBvcHVwVGVtcGxhdGVVcmwsIGRhdGVwaWNrZXJUZW1wbGF0ZVVybCwgcG9wdXBFbCwgZGF0ZXBpY2tlckVsLCBzY3JvbGxQYXJlbnRFbCxcbiAgICBuZ01vZGVsLCBuZ01vZGVsT3B0aW9ucywgJHBvcHVwLCBhbHRJbnB1dEZvcm1hdHMsIHdhdGNoTGlzdGVuZXJzID0gW107XG5cbiAgdGhpcy5pbml0ID0gZnVuY3Rpb24oX25nTW9kZWxfKSB7XG4gICAgbmdNb2RlbCA9IF9uZ01vZGVsXztcbiAgICBuZ01vZGVsT3B0aW9ucyA9IGV4dHJhY3RPcHRpb25zKG5nTW9kZWwpO1xuICAgIGNsb3NlT25EYXRlU2VsZWN0aW9uID0gYW5ndWxhci5pc0RlZmluZWQoJGF0dHJzLmNsb3NlT25EYXRlU2VsZWN0aW9uKSA/XG4gICAgICAkc2NvcGUuJHBhcmVudC4kZXZhbCgkYXR0cnMuY2xvc2VPbkRhdGVTZWxlY3Rpb24pIDpcbiAgICAgIGRhdGVwaWNrZXJQb3B1cENvbmZpZy5jbG9zZU9uRGF0ZVNlbGVjdGlvbjtcbiAgICBhcHBlbmRUb0JvZHkgPSBhbmd1bGFyLmlzRGVmaW5lZCgkYXR0cnMuZGF0ZXBpY2tlckFwcGVuZFRvQm9keSkgP1xuICAgICAgJHNjb3BlLiRwYXJlbnQuJGV2YWwoJGF0dHJzLmRhdGVwaWNrZXJBcHBlbmRUb0JvZHkpIDpcbiAgICAgIGRhdGVwaWNrZXJQb3B1cENvbmZpZy5hcHBlbmRUb0JvZHk7XG4gICAgb25PcGVuRm9jdXMgPSBhbmd1bGFyLmlzRGVmaW5lZCgkYXR0cnMub25PcGVuRm9jdXMpID9cbiAgICAgICRzY29wZS4kcGFyZW50LiRldmFsKCRhdHRycy5vbk9wZW5Gb2N1cykgOiBkYXRlcGlja2VyUG9wdXBDb25maWcub25PcGVuRm9jdXM7XG4gICAgZGF0ZXBpY2tlclBvcHVwVGVtcGxhdGVVcmwgPSBhbmd1bGFyLmlzRGVmaW5lZCgkYXR0cnMuZGF0ZXBpY2tlclBvcHVwVGVtcGxhdGVVcmwpID9cbiAgICAgICRhdHRycy5kYXRlcGlja2VyUG9wdXBUZW1wbGF0ZVVybCA6XG4gICAgICBkYXRlcGlja2VyUG9wdXBDb25maWcuZGF0ZXBpY2tlclBvcHVwVGVtcGxhdGVVcmw7XG4gICAgZGF0ZXBpY2tlclRlbXBsYXRlVXJsID0gYW5ndWxhci5pc0RlZmluZWQoJGF0dHJzLmRhdGVwaWNrZXJUZW1wbGF0ZVVybCkgP1xuICAgICAgJGF0dHJzLmRhdGVwaWNrZXJUZW1wbGF0ZVVybCA6IGRhdGVwaWNrZXJQb3B1cENvbmZpZy5kYXRlcGlja2VyVGVtcGxhdGVVcmw7XG4gICAgYWx0SW5wdXRGb3JtYXRzID0gYW5ndWxhci5pc0RlZmluZWQoJGF0dHJzLmFsdElucHV0Rm9ybWF0cykgP1xuICAgICAgJHNjb3BlLiRwYXJlbnQuJGV2YWwoJGF0dHJzLmFsdElucHV0Rm9ybWF0cykgOlxuICAgICAgZGF0ZXBpY2tlclBvcHVwQ29uZmlnLmFsdElucHV0Rm9ybWF0cztcblxuICAgICRzY29wZS5zaG93QnV0dG9uQmFyID0gYW5ndWxhci5pc0RlZmluZWQoJGF0dHJzLnNob3dCdXR0b25CYXIpID9cbiAgICAgICRzY29wZS4kcGFyZW50LiRldmFsKCRhdHRycy5zaG93QnV0dG9uQmFyKSA6XG4gICAgICBkYXRlcGlja2VyUG9wdXBDb25maWcuc2hvd0J1dHRvbkJhcjtcblxuICAgIGlmIChkYXRlcGlja2VyUG9wdXBDb25maWcuaHRtbDVUeXBlc1skYXR0cnMudHlwZV0pIHtcbiAgICAgIGRhdGVGb3JtYXQgPSBkYXRlcGlja2VyUG9wdXBDb25maWcuaHRtbDVUeXBlc1skYXR0cnMudHlwZV07XG4gICAgICBpc0h0bWw1RGF0ZUlucHV0ID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0ZUZvcm1hdCA9ICRhdHRycy51aWJEYXRlcGlja2VyUG9wdXAgfHwgZGF0ZXBpY2tlclBvcHVwQ29uZmlnLmRhdGVwaWNrZXJQb3B1cDtcbiAgICAgICRhdHRycy4kb2JzZXJ2ZSgndWliRGF0ZXBpY2tlclBvcHVwJywgZnVuY3Rpb24odmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHZhciBuZXdEYXRlRm9ybWF0ID0gdmFsdWUgfHwgZGF0ZXBpY2tlclBvcHVwQ29uZmlnLmRhdGVwaWNrZXJQb3B1cDtcbiAgICAgICAgLy8gSW52YWxpZGF0ZSB0aGUgJG1vZGVsVmFsdWUgdG8gZW5zdXJlIHRoYXQgZm9ybWF0dGVycyByZS1ydW5cbiAgICAgICAgLy8gRklYTUU6IFJlZmFjdG9yIHdoZW4gUFIgaXMgbWVyZ2VkOiBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyLmpzL3B1bGwvMTA3NjRcbiAgICAgICAgaWYgKG5ld0RhdGVGb3JtYXQgIT09IGRhdGVGb3JtYXQpIHtcbiAgICAgICAgICBkYXRlRm9ybWF0ID0gbmV3RGF0ZUZvcm1hdDtcbiAgICAgICAgICBuZ01vZGVsLiRtb2RlbFZhbHVlID0gbnVsbDtcblxuICAgICAgICAgIGlmICghZGF0ZUZvcm1hdCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1aWJEYXRlcGlja2VyUG9wdXAgbXVzdCBoYXZlIGEgZGF0ZSBmb3JtYXQgc3BlY2lmaWVkLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKCFkYXRlRm9ybWF0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VpYkRhdGVwaWNrZXJQb3B1cCBtdXN0IGhhdmUgYSBkYXRlIGZvcm1hdCBzcGVjaWZpZWQuJyk7XG4gICAgfVxuXG4gICAgaWYgKGlzSHRtbDVEYXRlSW5wdXQgJiYgJGF0dHJzLnVpYkRhdGVwaWNrZXJQb3B1cCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdIVE1MNSBkYXRlIGlucHV0IHR5cGVzIGRvIG5vdCBzdXBwb3J0IGN1c3RvbSBmb3JtYXRzLicpO1xuICAgIH1cblxuICAgIC8vIHBvcHVwIGVsZW1lbnQgdXNlZCB0byBkaXNwbGF5IGNhbGVuZGFyXG4gICAgcG9wdXBFbCA9IGFuZ3VsYXIuZWxlbWVudCgnPGRpdiB1aWItZGF0ZXBpY2tlci1wb3B1cC13cmFwPjxkaXYgdWliLWRhdGVwaWNrZXI+PC9kaXY+PC9kaXY+Jyk7XG5cbiAgICBwb3B1cEVsLmF0dHIoe1xuICAgICAgJ25nLW1vZGVsJzogJ2RhdGUnLFxuICAgICAgJ25nLWNoYW5nZSc6ICdkYXRlU2VsZWN0aW9uKGRhdGUpJyxcbiAgICAgICd0ZW1wbGF0ZS11cmwnOiBkYXRlcGlja2VyUG9wdXBUZW1wbGF0ZVVybFxuICAgIH0pO1xuXG4gICAgLy8gZGF0ZXBpY2tlciBlbGVtZW50XG4gICAgZGF0ZXBpY2tlckVsID0gYW5ndWxhci5lbGVtZW50KHBvcHVwRWwuY2hpbGRyZW4oKVswXSk7XG4gICAgZGF0ZXBpY2tlckVsLmF0dHIoJ3RlbXBsYXRlLXVybCcsIGRhdGVwaWNrZXJUZW1wbGF0ZVVybCk7XG5cbiAgICBpZiAoISRzY29wZS5kYXRlcGlja2VyT3B0aW9ucykge1xuICAgICAgJHNjb3BlLmRhdGVwaWNrZXJPcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgaWYgKGlzSHRtbDVEYXRlSW5wdXQpIHtcbiAgICAgIGlmICgkYXR0cnMudHlwZSA9PT0gJ21vbnRoJykge1xuICAgICAgICAkc2NvcGUuZGF0ZXBpY2tlck9wdGlvbnMuZGF0ZXBpY2tlck1vZGUgPSAnbW9udGgnO1xuICAgICAgICAkc2NvcGUuZGF0ZXBpY2tlck9wdGlvbnMubWluTW9kZSA9ICdtb250aCc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZGF0ZXBpY2tlckVsLmF0dHIoJ2RhdGVwaWNrZXItb3B0aW9ucycsICdkYXRlcGlja2VyT3B0aW9ucycpO1xuXG4gICAgaWYgKCFpc0h0bWw1RGF0ZUlucHV0KSB7XG4gICAgICAvLyBJbnRlcm5hbCBBUEkgdG8gbWFpbnRhaW4gdGhlIGNvcnJlY3QgbmctaW52YWxpZC1ba2V5XSBjbGFzc1xuICAgICAgbmdNb2RlbC4kJHBhcnNlck5hbWUgPSAnZGF0ZSc7XG4gICAgICBuZ01vZGVsLiR2YWxpZGF0b3JzLmRhdGUgPSB2YWxpZGF0b3I7XG4gICAgICBuZ01vZGVsLiRwYXJzZXJzLnVuc2hpZnQocGFyc2VEYXRlKTtcbiAgICAgIG5nTW9kZWwuJGZvcm1hdHRlcnMucHVzaChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAobmdNb2RlbC4kaXNFbXB0eSh2YWx1ZSkpIHtcbiAgICAgICAgICAkc2NvcGUuZGF0ZSA9IHZhbHVlO1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhbmd1bGFyLmlzTnVtYmVyKHZhbHVlKSkge1xuICAgICAgICAgIHZhbHVlID0gbmV3IERhdGUodmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgJHNjb3BlLmRhdGUgPSBkYXRlUGFyc2VyLmZyb21UaW1lem9uZSh2YWx1ZSwgbmdNb2RlbE9wdGlvbnMuZ2V0T3B0aW9uKCd0aW1lem9uZScpKTtcblxuICAgICAgICByZXR1cm4gZGF0ZVBhcnNlci5maWx0ZXIoJHNjb3BlLmRhdGUsIGRhdGVGb3JtYXQpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5nTW9kZWwuJGZvcm1hdHRlcnMucHVzaChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAkc2NvcGUuZGF0ZSA9IGRhdGVQYXJzZXIuZnJvbVRpbWV6b25lKHZhbHVlLCBuZ01vZGVsT3B0aW9ucy5nZXRPcHRpb24oJ3RpbWV6b25lJykpO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBEZXRlY3QgY2hhbmdlcyBpbiB0aGUgdmlldyBmcm9tIHRoZSB0ZXh0IGJveFxuICAgIG5nTW9kZWwuJHZpZXdDaGFuZ2VMaXN0ZW5lcnMucHVzaChmdW5jdGlvbigpIHtcbiAgICAgICRzY29wZS5kYXRlID0gcGFyc2VEYXRlU3RyaW5nKG5nTW9kZWwuJHZpZXdWYWx1ZSk7XG4gICAgfSk7XG5cbiAgICAkZWxlbWVudC5vbigna2V5ZG93bicsIGlucHV0S2V5ZG93bkJpbmQpO1xuXG4gICAgJHBvcHVwID0gJGNvbXBpbGUocG9wdXBFbCkoJHNjb3BlKTtcbiAgICAvLyBQcmV2ZW50IGpRdWVyeSBjYWNoZSBtZW1vcnkgbGVhayAodGVtcGxhdGUgaXMgbm93IHJlZHVuZGFudCBhZnRlciBsaW5raW5nKVxuICAgIHBvcHVwRWwucmVtb3ZlKCk7XG5cbiAgICBpZiAoYXBwZW5kVG9Cb2R5KSB7XG4gICAgICAkZG9jdW1lbnQuZmluZCgnYm9keScpLmFwcGVuZCgkcG9wdXApO1xuICAgIH0gZWxzZSB7XG4gICAgICAkZWxlbWVudC5hZnRlcigkcG9wdXApO1xuICAgIH1cblxuICAgICRzY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoJHNjb3BlLmlzT3BlbiA9PT0gdHJ1ZSkge1xuICAgICAgICBpZiAoISRyb290U2NvcGUuJCRwaGFzZSkge1xuICAgICAgICAgICRzY29wZS4kYXBwbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkc2NvcGUuaXNPcGVuID0gZmFsc2U7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgJHBvcHVwLnJlbW92ZSgpO1xuICAgICAgJGVsZW1lbnQub2ZmKCdrZXlkb3duJywgaW5wdXRLZXlkb3duQmluZCk7XG4gICAgICAkZG9jdW1lbnQub2ZmKCdjbGljaycsIGRvY3VtZW50Q2xpY2tCaW5kKTtcbiAgICAgIGlmIChzY3JvbGxQYXJlbnRFbCkge1xuICAgICAgICBzY3JvbGxQYXJlbnRFbC5vZmYoJ3Njcm9sbCcsIHBvc2l0aW9uUG9wdXApO1xuICAgICAgfVxuICAgICAgYW5ndWxhci5lbGVtZW50KCR3aW5kb3cpLm9mZigncmVzaXplJywgcG9zaXRpb25Qb3B1cCk7XG5cbiAgICAgIC8vQ2xlYXIgYWxsIHdhdGNoIGxpc3RlbmVycyBvbiBkZXN0cm95XG4gICAgICB3aGlsZSAod2F0Y2hMaXN0ZW5lcnMubGVuZ3RoKSB7XG4gICAgICAgIHdhdGNoTGlzdGVuZXJzLnNoaWZ0KCkoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICAkc2NvcGUuZ2V0VGV4dCA9IGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiAkc2NvcGVba2V5ICsgJ1RleHQnXSB8fCBkYXRlcGlja2VyUG9wdXBDb25maWdba2V5ICsgJ1RleHQnXTtcbiAgfTtcblxuICAkc2NvcGUuaXNEaXNhYmxlZCA9IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICBpZiAoZGF0ZSA9PT0gJ3RvZGF5Jykge1xuICAgICAgZGF0ZSA9IGRhdGVQYXJzZXIuZnJvbVRpbWV6b25lKG5ldyBEYXRlKCksIG5nTW9kZWxPcHRpb25zLmdldE9wdGlvbigndGltZXpvbmUnKSk7XG4gICAgfVxuXG4gICAgdmFyIGRhdGVzID0ge307XG4gICAgYW5ndWxhci5mb3JFYWNoKFsnbWluRGF0ZScsICdtYXhEYXRlJ10sIGZ1bmN0aW9uKGtleSkge1xuICAgICAgaWYgKCEkc2NvcGUuZGF0ZXBpY2tlck9wdGlvbnNba2V5XSkge1xuICAgICAgICBkYXRlc1trZXldID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAoYW5ndWxhci5pc0RhdGUoJHNjb3BlLmRhdGVwaWNrZXJPcHRpb25zW2tleV0pKSB7XG4gICAgICAgIGRhdGVzW2tleV0gPSBuZXcgRGF0ZSgkc2NvcGUuZGF0ZXBpY2tlck9wdGlvbnNba2V5XSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoJGRhdGVwaWNrZXJQb3B1cExpdGVyYWxXYXJuaW5nKSB7XG4gICAgICAgICAgJGxvZy53YXJuKCdMaXRlcmFsIGRhdGUgc3VwcG9ydCBoYXMgYmVlbiBkZXByZWNhdGVkLCBwbGVhc2Ugc3dpdGNoIHRvIGRhdGUgb2JqZWN0IHVzYWdlJyk7XG4gICAgICAgIH1cblxuICAgICAgICBkYXRlc1trZXldID0gbmV3IERhdGUoZGF0ZUZpbHRlcigkc2NvcGUuZGF0ZXBpY2tlck9wdGlvbnNba2V5XSwgJ21lZGl1bScpKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiAkc2NvcGUuZGF0ZXBpY2tlck9wdGlvbnMgJiZcbiAgICAgIGRhdGVzLm1pbkRhdGUgJiYgJHNjb3BlLmNvbXBhcmUoZGF0ZSwgZGF0ZXMubWluRGF0ZSkgPCAwIHx8XG4gICAgICBkYXRlcy5tYXhEYXRlICYmICRzY29wZS5jb21wYXJlKGRhdGUsIGRhdGVzLm1heERhdGUpID4gMDtcbiAgfTtcblxuICAkc2NvcGUuY29tcGFyZSA9IGZ1bmN0aW9uKGRhdGUxLCBkYXRlMikge1xuICAgIHJldHVybiBuZXcgRGF0ZShkYXRlMS5nZXRGdWxsWWVhcigpLCBkYXRlMS5nZXRNb250aCgpLCBkYXRlMS5nZXREYXRlKCkpIC0gbmV3IERhdGUoZGF0ZTIuZ2V0RnVsbFllYXIoKSwgZGF0ZTIuZ2V0TW9udGgoKSwgZGF0ZTIuZ2V0RGF0ZSgpKTtcbiAgfTtcblxuICAvLyBJbm5lciBjaGFuZ2VcbiAgJHNjb3BlLmRhdGVTZWxlY3Rpb24gPSBmdW5jdGlvbihkdCkge1xuICAgICRzY29wZS5kYXRlID0gZHQ7XG4gICAgdmFyIGRhdGUgPSAkc2NvcGUuZGF0ZSA/IGRhdGVQYXJzZXIuZmlsdGVyKCRzY29wZS5kYXRlLCBkYXRlRm9ybWF0KSA6IG51bGw7IC8vIFNldHRpbmcgdG8gTlVMTCBpcyBuZWNlc3NhcnkgZm9yIGZvcm0gdmFsaWRhdG9ycyB0byBmdW5jdGlvblxuICAgICRlbGVtZW50LnZhbChkYXRlKTtcbiAgICBuZ01vZGVsLiRzZXRWaWV3VmFsdWUoZGF0ZSk7XG5cbiAgICBpZiAoY2xvc2VPbkRhdGVTZWxlY3Rpb24pIHtcbiAgICAgICRzY29wZS5pc09wZW4gPSBmYWxzZTtcbiAgICAgICRlbGVtZW50WzBdLmZvY3VzKCk7XG4gICAgfVxuICB9O1xuXG4gICRzY29wZS5rZXlkb3duID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgaWYgKGV2dC53aGljaCA9PT0gMjcpIHtcbiAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICRzY29wZS5pc09wZW4gPSBmYWxzZTtcbiAgICAgICRlbGVtZW50WzBdLmZvY3VzKCk7XG4gICAgfVxuICB9O1xuXG4gICRzY29wZS5zZWxlY3QgPSBmdW5jdGlvbihkYXRlLCBldnQpIHtcbiAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICBpZiAoZGF0ZSA9PT0gJ3RvZGF5Jykge1xuICAgICAgdmFyIHRvZGF5ID0gbmV3IERhdGUoKTtcbiAgICAgIGlmIChhbmd1bGFyLmlzRGF0ZSgkc2NvcGUuZGF0ZSkpIHtcbiAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKCRzY29wZS5kYXRlKTtcbiAgICAgICAgZGF0ZS5zZXRGdWxsWWVhcih0b2RheS5nZXRGdWxsWWVhcigpLCB0b2RheS5nZXRNb250aCgpLCB0b2RheS5nZXREYXRlKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0ZSA9IGRhdGVQYXJzZXIuZnJvbVRpbWV6b25lKHRvZGF5LCBuZ01vZGVsT3B0aW9ucy5nZXRPcHRpb24oJ3RpbWV6b25lJykpO1xuICAgICAgICBkYXRlLnNldEhvdXJzKDAsIDAsIDAsIDApO1xuICAgICAgfVxuICAgIH1cbiAgICAkc2NvcGUuZGF0ZVNlbGVjdGlvbihkYXRlKTtcbiAgfTtcblxuICAkc2NvcGUuY2xvc2UgPSBmdW5jdGlvbihldnQpIHtcbiAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAkc2NvcGUuaXNPcGVuID0gZmFsc2U7XG4gICAgJGVsZW1lbnRbMF0uZm9jdXMoKTtcbiAgfTtcblxuICAkc2NvcGUuZGlzYWJsZWQgPSBhbmd1bGFyLmlzRGVmaW5lZCgkYXR0cnMuZGlzYWJsZWQpIHx8IGZhbHNlO1xuICBpZiAoJGF0dHJzLm5nRGlzYWJsZWQpIHtcbiAgICB3YXRjaExpc3RlbmVycy5wdXNoKCRzY29wZS4kcGFyZW50LiR3YXRjaCgkcGFyc2UoJGF0dHJzLm5nRGlzYWJsZWQpLCBmdW5jdGlvbihkaXNhYmxlZCkge1xuICAgICAgJHNjb3BlLmRpc2FibGVkID0gZGlzYWJsZWQ7XG4gICAgfSkpO1xuICB9XG5cbiAgJHNjb3BlLiR3YXRjaCgnaXNPcGVuJywgZnVuY3Rpb24odmFsdWUpIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGlmICghJHNjb3BlLmRpc2FibGVkKSB7XG4gICAgICAgICR0aW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHBvc2l0aW9uUG9wdXAoKTtcblxuICAgICAgICAgIGlmIChvbk9wZW5Gb2N1cykge1xuICAgICAgICAgICAgJHNjb3BlLiRicm9hZGNhc3QoJ3VpYjpkYXRlcGlja2VyLmZvY3VzJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgJGRvY3VtZW50Lm9uKCdjbGljaycsIGRvY3VtZW50Q2xpY2tCaW5kKTtcblxuICAgICAgICAgIHZhciBwbGFjZW1lbnQgPSAkYXR0cnMucG9wdXBQbGFjZW1lbnQgPyAkYXR0cnMucG9wdXBQbGFjZW1lbnQgOiBkYXRlcGlja2VyUG9wdXBDb25maWcucGxhY2VtZW50O1xuICAgICAgICAgIGlmIChhcHBlbmRUb0JvZHkgfHwgJHBvc2l0aW9uLnBhcnNlUGxhY2VtZW50KHBsYWNlbWVudClbMl0pIHtcbiAgICAgICAgICAgIHNjcm9sbFBhcmVudEVsID0gc2Nyb2xsUGFyZW50RWwgfHwgYW5ndWxhci5lbGVtZW50KCRwb3NpdGlvbi5zY3JvbGxQYXJlbnQoJGVsZW1lbnQpKTtcbiAgICAgICAgICAgIGlmIChzY3JvbGxQYXJlbnRFbCkge1xuICAgICAgICAgICAgICBzY3JvbGxQYXJlbnRFbC5vbignc2Nyb2xsJywgcG9zaXRpb25Qb3B1cCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNjcm9sbFBhcmVudEVsID0gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhbmd1bGFyLmVsZW1lbnQoJHdpbmRvdykub24oJ3Jlc2l6ZScsIHBvc2l0aW9uUG9wdXApO1xuICAgICAgICB9LCAwLCBmYWxzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkc2NvcGUuaXNPcGVuID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICRkb2N1bWVudC5vZmYoJ2NsaWNrJywgZG9jdW1lbnRDbGlja0JpbmQpO1xuICAgICAgaWYgKHNjcm9sbFBhcmVudEVsKSB7XG4gICAgICAgIHNjcm9sbFBhcmVudEVsLm9mZignc2Nyb2xsJywgcG9zaXRpb25Qb3B1cCk7XG4gICAgICB9XG4gICAgICBhbmd1bGFyLmVsZW1lbnQoJHdpbmRvdykub2ZmKCdyZXNpemUnLCBwb3NpdGlvblBvcHVwKTtcbiAgICB9XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGNhbWVsdG9EYXNoKHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvKFtBLVpdKS9nLCBmdW5jdGlvbigkMSkgeyByZXR1cm4gJy0nICsgJDEudG9Mb3dlckNhc2UoKTsgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZURhdGVTdHJpbmcodmlld1ZhbHVlKSB7XG4gICAgdmFyIGRhdGUgPSBkYXRlUGFyc2VyLnBhcnNlKHZpZXdWYWx1ZSwgZGF0ZUZvcm1hdCwgJHNjb3BlLmRhdGUpO1xuICAgIGlmIChpc05hTihkYXRlKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbHRJbnB1dEZvcm1hdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGF0ZSA9IGRhdGVQYXJzZXIucGFyc2Uodmlld1ZhbHVlLCBhbHRJbnB1dEZvcm1hdHNbaV0sICRzY29wZS5kYXRlKTtcbiAgICAgICAgaWYgKCFpc05hTihkYXRlKSkge1xuICAgICAgICAgIHJldHVybiBkYXRlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkYXRlO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VEYXRlKHZpZXdWYWx1ZSkge1xuICAgIGlmIChhbmd1bGFyLmlzTnVtYmVyKHZpZXdWYWx1ZSkpIHtcbiAgICAgIC8vIHByZXN1bWFibHkgdGltZXN0YW1wIHRvIGRhdGUgb2JqZWN0XG4gICAgICB2aWV3VmFsdWUgPSBuZXcgRGF0ZSh2aWV3VmFsdWUpO1xuICAgIH1cblxuICAgIGlmICghdmlld1ZhbHVlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoYW5ndWxhci5pc0RhdGUodmlld1ZhbHVlKSAmJiAhaXNOYU4odmlld1ZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZpZXdWYWx1ZTtcbiAgICB9XG5cbiAgICBpZiAoYW5ndWxhci5pc1N0cmluZyh2aWV3VmFsdWUpKSB7XG4gICAgICB2YXIgZGF0ZSA9IHBhcnNlRGF0ZVN0cmluZyh2aWV3VmFsdWUpO1xuICAgICAgaWYgKCFpc05hTihkYXRlKSkge1xuICAgICAgICByZXR1cm4gZGF0ZVBhcnNlci50b1RpbWV6b25lKGRhdGUsIG5nTW9kZWxPcHRpb25zLmdldE9wdGlvbigndGltZXpvbmUnKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5nTW9kZWxPcHRpb25zLmdldE9wdGlvbignYWxsb3dJbnZhbGlkJykgPyB2aWV3VmFsdWUgOiB1bmRlZmluZWQ7XG4gIH1cblxuICBmdW5jdGlvbiB2YWxpZGF0b3IobW9kZWxWYWx1ZSwgdmlld1ZhbHVlKSB7XG4gICAgdmFyIHZhbHVlID0gbW9kZWxWYWx1ZSB8fCB2aWV3VmFsdWU7XG5cbiAgICBpZiAoISRhdHRycy5uZ1JlcXVpcmVkICYmICF2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGFuZ3VsYXIuaXNOdW1iZXIodmFsdWUpKSB7XG4gICAgICB2YWx1ZSA9IG5ldyBEYXRlKHZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAoIXZhbHVlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoYW5ndWxhci5pc0RhdGUodmFsdWUpICYmICFpc05hTih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChhbmd1bGFyLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgcmV0dXJuICFpc05hTihwYXJzZURhdGVTdHJpbmcodmFsdWUpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBkb2N1bWVudENsaWNrQmluZChldmVudCkge1xuICAgIGlmICghJHNjb3BlLmlzT3BlbiAmJiAkc2NvcGUuZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcG9wdXAgPSAkcG9wdXBbMF07XG4gICAgdmFyIGRwQ29udGFpbnNUYXJnZXQgPSAkZWxlbWVudFswXS5jb250YWlucyhldmVudC50YXJnZXQpO1xuICAgIC8vIFRoZSBwb3B1cCBub2RlIG1heSBub3QgYmUgYW4gZWxlbWVudCBub2RlXG4gICAgLy8gSW4gc29tZSBicm93c2VycyAoSUUpIG9ubHkgZWxlbWVudCBub2RlcyBoYXZlIHRoZSAnY29udGFpbnMnIGZ1bmN0aW9uXG4gICAgdmFyIHBvcHVwQ29udGFpbnNUYXJnZXQgPSBwb3B1cC5jb250YWlucyAhPT0gdW5kZWZpbmVkICYmIHBvcHVwLmNvbnRhaW5zKGV2ZW50LnRhcmdldCk7XG4gICAgaWYgKCRzY29wZS5pc09wZW4gJiYgIShkcENvbnRhaW5zVGFyZ2V0IHx8IHBvcHVwQ29udGFpbnNUYXJnZXQpKSB7XG4gICAgICAkc2NvcGUuJGFwcGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAkc2NvcGUuaXNPcGVuID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnB1dEtleWRvd25CaW5kKGV2dCkge1xuICAgIGlmIChldnQud2hpY2ggPT09IDI3ICYmICRzY29wZS5pc09wZW4pIHtcbiAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgJHNjb3BlLiRhcHBseShmdW5jdGlvbigpIHtcbiAgICAgICAgJHNjb3BlLmlzT3BlbiA9IGZhbHNlO1xuICAgICAgfSk7XG4gICAgICAkZWxlbWVudFswXS5mb2N1cygpO1xuICAgIH0gZWxzZSBpZiAoZXZ0LndoaWNoID09PSA0MCAmJiAhJHNjb3BlLmlzT3Blbikge1xuICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAkc2NvcGUuJGFwcGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAkc2NvcGUuaXNPcGVuID0gdHJ1ZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBvc2l0aW9uUG9wdXAoKSB7XG4gICAgaWYgKCRzY29wZS5pc09wZW4pIHtcbiAgICAgIHZhciBkcEVsZW1lbnQgPSBhbmd1bGFyLmVsZW1lbnQoJHBvcHVwWzBdLnF1ZXJ5U2VsZWN0b3IoJy51aWItZGF0ZXBpY2tlci1wb3B1cCcpKTtcbiAgICAgIHZhciBwbGFjZW1lbnQgPSAkYXR0cnMucG9wdXBQbGFjZW1lbnQgPyAkYXR0cnMucG9wdXBQbGFjZW1lbnQgOiBkYXRlcGlja2VyUG9wdXBDb25maWcucGxhY2VtZW50O1xuICAgICAgdmFyIHBvc2l0aW9uID0gJHBvc2l0aW9uLnBvc2l0aW9uRWxlbWVudHMoJGVsZW1lbnQsIGRwRWxlbWVudCwgcGxhY2VtZW50LCBhcHBlbmRUb0JvZHkpO1xuICAgICAgZHBFbGVtZW50LmNzcyh7dG9wOiBwb3NpdGlvbi50b3AgKyAncHgnLCBsZWZ0OiBwb3NpdGlvbi5sZWZ0ICsgJ3B4J30pO1xuICAgICAgaWYgKGRwRWxlbWVudC5oYXNDbGFzcygndWliLXBvc2l0aW9uLW1lYXN1cmUnKSkge1xuICAgICAgICBkcEVsZW1lbnQucmVtb3ZlQ2xhc3MoJ3VpYi1wb3NpdGlvbi1tZWFzdXJlJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZXh0cmFjdE9wdGlvbnMobmdNb2RlbEN0cmwpIHtcbiAgICB2YXIgbmdNb2RlbE9wdGlvbnM7XG5cbiAgICBpZiAoYW5ndWxhci52ZXJzaW9uLm1pbm9yIDwgNikgeyAvLyBpbiBhbmd1bGFyIDwgMS42ICRvcHRpb25zIGNvdWxkIGJlIG1pc3NpbmdcbiAgICAgIC8vIGd1YXJhbnRlZSBhIHZhbHVlXG4gICAgICBuZ01vZGVsT3B0aW9ucyA9IGFuZ3VsYXIuaXNPYmplY3QobmdNb2RlbEN0cmwuJG9wdGlvbnMpID9cbiAgICAgICAgbmdNb2RlbEN0cmwuJG9wdGlvbnMgOlxuICAgICAgICB7XG4gICAgICAgICAgdGltZXpvbmU6IG51bGxcbiAgICAgICAgfTtcblxuICAgICAgLy8gbWltaWMgMS42KyBhcGlcbiAgICAgIG5nTW9kZWxPcHRpb25zLmdldE9wdGlvbiA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIG5nTW9kZWxPcHRpb25zW2tleV07XG4gICAgICB9O1xuICAgIH0gZWxzZSB7IC8vIGluIGFuZ3VsYXIgPj0xLjYgJG9wdGlvbnMgaXMgYWx3YXlzIHByZXNlbnRcbiAgICAgIG5nTW9kZWxPcHRpb25zID0gbmdNb2RlbEN0cmwuJG9wdGlvbnM7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5nTW9kZWxPcHRpb25zO1xuICB9XG5cbiAgJHNjb3BlLiRvbigndWliOmRhdGVwaWNrZXIubW9kZScsIGZ1bmN0aW9uKCkge1xuICAgICR0aW1lb3V0KHBvc2l0aW9uUG9wdXAsIDAsIGZhbHNlKTtcbiAgfSk7XG59XSlcblxuLmRpcmVjdGl2ZSgndWliRGF0ZXBpY2tlclBvcHVwJywgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgcmVxdWlyZTogWyduZ01vZGVsJywgJ3VpYkRhdGVwaWNrZXJQb3B1cCddLFxuICAgIGNvbnRyb2xsZXI6ICdVaWJEYXRlcGlja2VyUG9wdXBDb250cm9sbGVyJyxcbiAgICBzY29wZToge1xuICAgICAgZGF0ZXBpY2tlck9wdGlvbnM6ICc9PycsXG4gICAgICBpc09wZW46ICc9PycsXG4gICAgICBjdXJyZW50VGV4dDogJ0AnLFxuICAgICAgY2xlYXJUZXh0OiAnQCcsXG4gICAgICBjbG9zZVRleHQ6ICdAJ1xuICAgIH0sXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBjdHJscykge1xuICAgICAgdmFyIG5nTW9kZWwgPSBjdHJsc1swXSxcbiAgICAgICAgY3RybCA9IGN0cmxzWzFdO1xuXG4gICAgICBjdHJsLmluaXQobmdNb2RlbCk7XG4gICAgfVxuICB9O1xufSlcblxuLmRpcmVjdGl2ZSgndWliRGF0ZXBpY2tlclBvcHVwV3JhcCcsIGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHJlc3RyaWN0OiAnQScsXG4gICAgdHJhbnNjbHVkZTogdHJ1ZSxcbiAgICB0ZW1wbGF0ZVVybDogZnVuY3Rpb24oZWxlbWVudCwgYXR0cnMpIHtcbiAgICAgIHJldHVybiBhdHRycy50ZW1wbGF0ZVVybCB8fCAndWliL3RlbXBsYXRlL2RhdGVwaWNrZXJQb3B1cC9wb3B1cC5odG1sJztcbiAgICB9XG4gIH07XG59KTtcblxuYW5ndWxhci5tb2R1bGUoJ3VpLmJvb3RzdHJhcC5kZWJvdW5jZScsIFtdKVxuLyoqXG4gKiBBIGhlbHBlciwgaW50ZXJuYWwgc2VydmljZSB0aGF0IGRlYm91bmNlcyBhIGZ1bmN0aW9uXG4gKi9cbiAgLmZhY3RvcnkoJyQkZGVib3VuY2UnLCBbJyR0aW1lb3V0JywgZnVuY3Rpb24oJHRpbWVvdXQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oY2FsbGJhY2ssIGRlYm91bmNlVGltZSkge1xuICAgICAgdmFyIHRpbWVvdXRQcm9taXNlO1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICBpZiAodGltZW91dFByb21pc2UpIHtcbiAgICAgICAgICAkdGltZW91dC5jYW5jZWwodGltZW91dFByb21pc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGltZW91dFByb21pc2UgPSAkdGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBjYWxsYmFjay5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgICAgfSwgZGVib3VuY2VUaW1lKTtcbiAgICAgIH07XG4gICAgfTtcbiAgfV0pO1xuXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLm11bHRpTWFwJywgW10pXG4vKipcbiAqIEEgaGVscGVyLCBpbnRlcm5hbCBkYXRhIHN0cnVjdHVyZSB0aGF0IHN0b3JlcyBhbGwgcmVmZXJlbmNlcyBhdHRhY2hlZCB0byBrZXlcbiAqL1xuICAuZmFjdG9yeSgnJCRtdWx0aU1hcCcsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjcmVhdGVOZXc6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbWFwID0ge307XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBlbnRyaWVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhtYXApLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbWFwW2tleV1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBtYXBba2V5XTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGhhc0tleTogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gISFtYXBba2V5XTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGtleXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKG1hcCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBwdXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICghbWFwW2tleV0pIHtcbiAgICAgICAgICAgICAgbWFwW2tleV0gPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWFwW2tleV0ucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICByZW1vdmU6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBtYXBba2V5XTtcblxuICAgICAgICAgICAgaWYgKCF2YWx1ZXMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaWR4ID0gdmFsdWVzLmluZGV4T2YodmFsdWUpO1xuXG4gICAgICAgICAgICBpZiAoaWR4ICE9PSAtMSkge1xuICAgICAgICAgICAgICB2YWx1ZXMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICBkZWxldGUgbWFwW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xuXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLmRyb3Bkb3duJywgWyd1aS5ib290c3RyYXAubXVsdGlNYXAnLCAndWkuYm9vdHN0cmFwLnBvc2l0aW9uJ10pXG5cbi5jb25zdGFudCgndWliRHJvcGRvd25Db25maWcnLCB7XG4gIGFwcGVuZFRvT3BlbkNsYXNzOiAndWliLWRyb3Bkb3duLW9wZW4nLFxuICBvcGVuQ2xhc3M6ICdvcGVuJ1xufSlcblxuLnNlcnZpY2UoJ3VpYkRyb3Bkb3duU2VydmljZScsIFsnJGRvY3VtZW50JywgJyRyb290U2NvcGUnLCAnJCRtdWx0aU1hcCcsIGZ1bmN0aW9uKCRkb2N1bWVudCwgJHJvb3RTY29wZSwgJCRtdWx0aU1hcCkge1xuICB2YXIgb3BlblNjb3BlID0gbnVsbDtcbiAgdmFyIG9wZW5lZENvbnRhaW5lcnMgPSAkJG11bHRpTWFwLmNyZWF0ZU5ldygpO1xuXG4gIHRoaXMuaXNPbmx5T3BlbiA9IGZ1bmN0aW9uKGRyb3Bkb3duU2NvcGUsIGFwcGVuZFRvKSB7XG4gICAgdmFyIG9wZW5lZERyb3Bkb3ducyA9IG9wZW5lZENvbnRhaW5lcnMuZ2V0KGFwcGVuZFRvKTtcbiAgICBpZiAob3BlbmVkRHJvcGRvd25zKSB7XG4gICAgICB2YXIgb3BlbkRyb3Bkb3duID0gb3BlbmVkRHJvcGRvd25zLnJlZHVjZShmdW5jdGlvbih0b0Nsb3NlLCBkcm9wZG93bikge1xuICAgICAgICBpZiAoZHJvcGRvd24uc2NvcGUgPT09IGRyb3Bkb3duU2NvcGUpIHtcbiAgICAgICAgICByZXR1cm4gZHJvcGRvd247XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG9DbG9zZTtcbiAgICAgIH0sIHt9KTtcbiAgICAgIGlmIChvcGVuRHJvcGRvd24pIHtcbiAgICAgICAgcmV0dXJuIG9wZW5lZERyb3Bkb3ducy5sZW5ndGggPT09IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIHRoaXMub3BlbiA9IGZ1bmN0aW9uKGRyb3Bkb3duU2NvcGUsIGVsZW1lbnQsIGFwcGVuZFRvKSB7XG4gICAgaWYgKCFvcGVuU2NvcGUpIHtcbiAgICAgICRkb2N1bWVudC5vbignY2xpY2snLCBjbG9zZURyb3Bkb3duKTtcbiAgICB9XG5cbiAgICBpZiAob3BlblNjb3BlICYmIG9wZW5TY29wZSAhPT0gZHJvcGRvd25TY29wZSkge1xuICAgICAgb3BlblNjb3BlLmlzT3BlbiA9IGZhbHNlO1xuICAgIH1cblxuICAgIG9wZW5TY29wZSA9IGRyb3Bkb3duU2NvcGU7XG5cbiAgICBpZiAoIWFwcGVuZFRvKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG9wZW5lZERyb3Bkb3ducyA9IG9wZW5lZENvbnRhaW5lcnMuZ2V0KGFwcGVuZFRvKTtcbiAgICBpZiAob3BlbmVkRHJvcGRvd25zKSB7XG4gICAgICB2YXIgb3BlbmVkU2NvcGVzID0gb3BlbmVkRHJvcGRvd25zLm1hcChmdW5jdGlvbihkcm9wZG93bikge1xuICAgICAgICByZXR1cm4gZHJvcGRvd24uc2NvcGU7XG4gICAgICB9KTtcbiAgICAgIGlmIChvcGVuZWRTY29wZXMuaW5kZXhPZihkcm9wZG93blNjb3BlKSA9PT0gLTEpIHtcbiAgICAgICAgb3BlbmVkQ29udGFpbmVycy5wdXQoYXBwZW5kVG8sIHtcbiAgICAgICAgICBzY29wZTogZHJvcGRvd25TY29wZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb3BlbmVkQ29udGFpbmVycy5wdXQoYXBwZW5kVG8sIHtcbiAgICAgICAgc2NvcGU6IGRyb3Bkb3duU2NvcGVcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICB0aGlzLmNsb3NlID0gZnVuY3Rpb24oZHJvcGRvd25TY29wZSwgZWxlbWVudCwgYXBwZW5kVG8pIHtcbiAgICBpZiAob3BlblNjb3BlID09PSBkcm9wZG93blNjb3BlKSB7XG4gICAgICAkZG9jdW1lbnQub2ZmKCdjbGljaycsIGNsb3NlRHJvcGRvd24pO1xuICAgICAgJGRvY3VtZW50Lm9mZigna2V5ZG93bicsIHRoaXMua2V5YmluZEZpbHRlcik7XG4gICAgICBvcGVuU2NvcGUgPSBudWxsO1xuICAgIH1cblxuICAgIGlmICghYXBwZW5kVG8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgb3BlbmVkRHJvcGRvd25zID0gb3BlbmVkQ29udGFpbmVycy5nZXQoYXBwZW5kVG8pO1xuICAgIGlmIChvcGVuZWREcm9wZG93bnMpIHtcbiAgICAgIHZhciBkcm9wZG93blRvQ2xvc2UgPSBvcGVuZWREcm9wZG93bnMucmVkdWNlKGZ1bmN0aW9uKHRvQ2xvc2UsIGRyb3Bkb3duKSB7XG4gICAgICAgIGlmIChkcm9wZG93bi5zY29wZSA9PT0gZHJvcGRvd25TY29wZSkge1xuICAgICAgICAgIHJldHVybiBkcm9wZG93bjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0b0Nsb3NlO1xuICAgICAgfSwge30pO1xuICAgICAgaWYgKGRyb3Bkb3duVG9DbG9zZSkge1xuICAgICAgICBvcGVuZWRDb250YWluZXJzLnJlbW92ZShhcHBlbmRUbywgZHJvcGRvd25Ub0Nsb3NlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdmFyIGNsb3NlRHJvcGRvd24gPSBmdW5jdGlvbihldnQpIHtcbiAgICAvLyBUaGlzIG1ldGhvZCBtYXkgc3RpbGwgYmUgY2FsbGVkIGR1cmluZyB0aGUgc2FtZSBtb3VzZSBldmVudCB0aGF0XG4gICAgLy8gdW5ib3VuZCB0aGlzIGV2ZW50IGhhbmRsZXIuIFNvIGNoZWNrIG9wZW5TY29wZSBiZWZvcmUgcHJvY2VlZGluZy5cbiAgICBpZiAoIW9wZW5TY29wZSB8fCAhb3BlblNjb3BlLmlzT3BlbikgeyByZXR1cm47IH1cblxuICAgIGlmIChldnQgJiYgb3BlblNjb3BlLmdldEF1dG9DbG9zZSgpID09PSAnZGlzYWJsZWQnKSB7IHJldHVybjsgfVxuXG4gICAgaWYgKGV2dCAmJiBldnQud2hpY2ggPT09IDMpIHsgcmV0dXJuOyB9XG5cbiAgICB2YXIgdG9nZ2xlRWxlbWVudCA9IG9wZW5TY29wZS5nZXRUb2dnbGVFbGVtZW50KCk7XG4gICAgaWYgKGV2dCAmJiB0b2dnbGVFbGVtZW50ICYmIHRvZ2dsZUVsZW1lbnRbMF0uY29udGFpbnMoZXZ0LnRhcmdldCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZHJvcGRvd25FbGVtZW50ID0gb3BlblNjb3BlLmdldERyb3Bkb3duRWxlbWVudCgpO1xuICAgIGlmIChldnQgJiYgb3BlblNjb3BlLmdldEF1dG9DbG9zZSgpID09PSAnb3V0c2lkZUNsaWNrJyAmJlxuICAgICAgZHJvcGRvd25FbGVtZW50ICYmIGRyb3Bkb3duRWxlbWVudFswXS5jb250YWlucyhldnQudGFyZ2V0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG9wZW5TY29wZS5mb2N1c1RvZ2dsZUVsZW1lbnQoKTtcbiAgICBvcGVuU2NvcGUuaXNPcGVuID0gZmFsc2U7XG5cbiAgICBpZiAoISRyb290U2NvcGUuJCRwaGFzZSkge1xuICAgICAgb3BlblNjb3BlLiRhcHBseSgpO1xuICAgIH1cbiAgfTtcblxuICB0aGlzLmtleWJpbmRGaWx0ZXIgPSBmdW5jdGlvbihldnQpIHtcbiAgICBpZiAoIW9wZW5TY29wZSkge1xuICAgICAgLy8gc2VlIHRoaXMuY2xvc2UgYXMgRVNDIGNvdWxkIGhhdmUgYmVlbiBwcmVzc2VkIHdoaWNoIGtpbGxzIHRoZSBzY29wZSBzbyB3ZSBjYW4gbm90IHByb2NlZWRcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZHJvcGRvd25FbGVtZW50ID0gb3BlblNjb3BlLmdldERyb3Bkb3duRWxlbWVudCgpO1xuICAgIHZhciB0b2dnbGVFbGVtZW50ID0gb3BlblNjb3BlLmdldFRvZ2dsZUVsZW1lbnQoKTtcbiAgICB2YXIgZHJvcGRvd25FbGVtZW50VGFyZ2V0ZWQgPSBkcm9wZG93bkVsZW1lbnQgJiYgZHJvcGRvd25FbGVtZW50WzBdLmNvbnRhaW5zKGV2dC50YXJnZXQpO1xuICAgIHZhciB0b2dnbGVFbGVtZW50VGFyZ2V0ZWQgPSB0b2dnbGVFbGVtZW50ICYmIHRvZ2dsZUVsZW1lbnRbMF0uY29udGFpbnMoZXZ0LnRhcmdldCk7XG4gICAgaWYgKGV2dC53aGljaCA9PT0gMjcpIHtcbiAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIG9wZW5TY29wZS5mb2N1c1RvZ2dsZUVsZW1lbnQoKTtcbiAgICAgIGNsb3NlRHJvcGRvd24oKTtcbiAgICB9IGVsc2UgaWYgKG9wZW5TY29wZS5pc0tleW5hdkVuYWJsZWQoKSAmJiBbMzgsIDQwXS5pbmRleE9mKGV2dC53aGljaCkgIT09IC0xICYmIG9wZW5TY29wZS5pc09wZW4gJiYgKGRyb3Bkb3duRWxlbWVudFRhcmdldGVkIHx8IHRvZ2dsZUVsZW1lbnRUYXJnZXRlZCkpIHtcbiAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgb3BlblNjb3BlLmZvY3VzRHJvcGRvd25FbnRyeShldnQud2hpY2gpO1xuICAgIH1cbiAgfTtcbn1dKVxuXG4uY29udHJvbGxlcignVWliRHJvcGRvd25Db250cm9sbGVyJywgWyckc2NvcGUnLCAnJGVsZW1lbnQnLCAnJGF0dHJzJywgJyRwYXJzZScsICd1aWJEcm9wZG93bkNvbmZpZycsICd1aWJEcm9wZG93blNlcnZpY2UnLCAnJGFuaW1hdGUnLCAnJHVpYlBvc2l0aW9uJywgJyRkb2N1bWVudCcsICckY29tcGlsZScsICckdGVtcGxhdGVSZXF1ZXN0JywgZnVuY3Rpb24oJHNjb3BlLCAkZWxlbWVudCwgJGF0dHJzLCAkcGFyc2UsIGRyb3Bkb3duQ29uZmlnLCB1aWJEcm9wZG93blNlcnZpY2UsICRhbmltYXRlLCAkcG9zaXRpb24sICRkb2N1bWVudCwgJGNvbXBpbGUsICR0ZW1wbGF0ZVJlcXVlc3QpIHtcbiAgdmFyIHNlbGYgPSB0aGlzLFxuICAgIHNjb3BlID0gJHNjb3BlLiRuZXcoKSwgLy8gY3JlYXRlIGEgY2hpbGQgc2NvcGUgc28gd2UgYXJlIG5vdCBwb2xsdXRpbmcgb3JpZ2luYWwgb25lXG4gICAgdGVtcGxhdGVTY29wZSxcbiAgICBhcHBlbmRUb09wZW5DbGFzcyA9IGRyb3Bkb3duQ29uZmlnLmFwcGVuZFRvT3BlbkNsYXNzLFxuICAgIG9wZW5DbGFzcyA9IGRyb3Bkb3duQ29uZmlnLm9wZW5DbGFzcyxcbiAgICBnZXRJc09wZW4sXG4gICAgc2V0SXNPcGVuID0gYW5ndWxhci5ub29wLFxuICAgIHRvZ2dsZUludm9rZXIgPSAkYXR0cnMub25Ub2dnbGUgPyAkcGFyc2UoJGF0dHJzLm9uVG9nZ2xlKSA6IGFuZ3VsYXIubm9vcCxcbiAgICBrZXluYXZFbmFibGVkID0gZmFsc2UsXG4gICAgc2VsZWN0ZWRPcHRpb24gPSBudWxsLFxuICAgIGJvZHkgPSAkZG9jdW1lbnQuZmluZCgnYm9keScpO1xuXG4gICRlbGVtZW50LmFkZENsYXNzKCdkcm9wZG93bicpO1xuXG4gIHRoaXMuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICgkYXR0cnMuaXNPcGVuKSB7XG4gICAgICBnZXRJc09wZW4gPSAkcGFyc2UoJGF0dHJzLmlzT3Blbik7XG4gICAgICBzZXRJc09wZW4gPSBnZXRJc09wZW4uYXNzaWduO1xuXG4gICAgICAkc2NvcGUuJHdhdGNoKGdldElzT3BlbiwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgc2NvcGUuaXNPcGVuID0gISF2YWx1ZTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGtleW5hdkVuYWJsZWQgPSBhbmd1bGFyLmlzRGVmaW5lZCgkYXR0cnMua2V5Ym9hcmROYXYpO1xuICB9O1xuXG4gIHRoaXMudG9nZ2xlID0gZnVuY3Rpb24ob3Blbikge1xuICAgIHNjb3BlLmlzT3BlbiA9IGFyZ3VtZW50cy5sZW5ndGggPyAhIW9wZW4gOiAhc2NvcGUuaXNPcGVuO1xuICAgIGlmIChhbmd1bGFyLmlzRnVuY3Rpb24oc2V0SXNPcGVuKSkge1xuICAgICAgc2V0SXNPcGVuKHNjb3BlLCBzY29wZS5pc09wZW4pO1xuICAgIH1cblxuICAgIHJldHVybiBzY29wZS5pc09wZW47XG4gIH07XG5cbiAgLy8gQWxsb3cgb3RoZXIgZGlyZWN0aXZlcyB0byB3YXRjaCBzdGF0dXNcbiAgdGhpcy5pc09wZW4gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc2NvcGUuaXNPcGVuO1xuICB9O1xuXG4gIHNjb3BlLmdldFRvZ2dsZUVsZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc2VsZi50b2dnbGVFbGVtZW50O1xuICB9O1xuXG4gIHNjb3BlLmdldEF1dG9DbG9zZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAkYXR0cnMuYXV0b0Nsb3NlIHx8ICdhbHdheXMnOyAvL29yICdvdXRzaWRlQ2xpY2snIG9yICdkaXNhYmxlZCdcbiAgfTtcblxuICBzY29wZS5nZXRFbGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICRlbGVtZW50O1xuICB9O1xuXG4gIHNjb3BlLmlzS2V5bmF2RW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBrZXluYXZFbmFibGVkO1xuICB9O1xuXG4gIHNjb3BlLmZvY3VzRHJvcGRvd25FbnRyeSA9IGZ1bmN0aW9uKGtleUNvZGUpIHtcbiAgICB2YXIgZWxlbXMgPSBzZWxmLmRyb3Bkb3duTWVudSA/IC8vSWYgYXBwZW5kIHRvIGJvZHkgaXMgdXNlZC5cbiAgICAgIGFuZ3VsYXIuZWxlbWVudChzZWxmLmRyb3Bkb3duTWVudSkuZmluZCgnYScpIDpcbiAgICAgICRlbGVtZW50LmZpbmQoJ3VsJykuZXEoMCkuZmluZCgnYScpO1xuXG4gICAgc3dpdGNoIChrZXlDb2RlKSB7XG4gICAgICBjYXNlIDQwOiB7XG4gICAgICAgIGlmICghYW5ndWxhci5pc051bWJlcihzZWxmLnNlbGVjdGVkT3B0aW9uKSkge1xuICAgICAgICAgIHNlbGYuc2VsZWN0ZWRPcHRpb24gPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbGYuc2VsZWN0ZWRPcHRpb24gPSBzZWxmLnNlbGVjdGVkT3B0aW9uID09PSBlbGVtcy5sZW5ndGggLSAxID9cbiAgICAgICAgICAgIHNlbGYuc2VsZWN0ZWRPcHRpb24gOlxuICAgICAgICAgICAgc2VsZi5zZWxlY3RlZE9wdGlvbiArIDE7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIDM4OiB7XG4gICAgICAgIGlmICghYW5ndWxhci5pc051bWJlcihzZWxmLnNlbGVjdGVkT3B0aW9uKSkge1xuICAgICAgICAgIHNlbGYuc2VsZWN0ZWRPcHRpb24gPSBlbGVtcy5sZW5ndGggLSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbGYuc2VsZWN0ZWRPcHRpb24gPSBzZWxmLnNlbGVjdGVkT3B0aW9uID09PSAwID9cbiAgICAgICAgICAgIDAgOiBzZWxmLnNlbGVjdGVkT3B0aW9uIC0gMTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgZWxlbXNbc2VsZi5zZWxlY3RlZE9wdGlvbl0uZm9jdXMoKTtcbiAgfTtcblxuICBzY29wZS5nZXREcm9wZG93bkVsZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc2VsZi5kcm9wZG93bk1lbnU7XG4gIH07XG5cbiAgc2NvcGUuZm9jdXNUb2dnbGVFbGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHNlbGYudG9nZ2xlRWxlbWVudCkge1xuICAgICAgc2VsZi50b2dnbGVFbGVtZW50WzBdLmZvY3VzKCk7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIHJlbW92ZURyb3Bkb3duTWVudSgpIHtcbiAgICAkZWxlbWVudC5hcHBlbmQoc2VsZi5kcm9wZG93bk1lbnUpO1xuICB9XG5cbiAgc2NvcGUuJHdhdGNoKCdpc09wZW4nLCBmdW5jdGlvbihpc09wZW4sIHdhc09wZW4pIHtcbiAgICB2YXIgYXBwZW5kVG8gPSBudWxsLFxuICAgICAgYXBwZW5kVG9Cb2R5ID0gZmFsc2U7XG5cbiAgICBpZiAoYW5ndWxhci5pc0RlZmluZWQoJGF0dHJzLmRyb3Bkb3duQXBwZW5kVG8pKSB7XG4gICAgICB2YXIgYXBwZW5kVG9FbCA9ICRwYXJzZSgkYXR0cnMuZHJvcGRvd25BcHBlbmRUbykoc2NvcGUpO1xuICAgICAgaWYgKGFwcGVuZFRvRWwpIHtcbiAgICAgICAgYXBwZW5kVG8gPSBhbmd1bGFyLmVsZW1lbnQoYXBwZW5kVG9FbCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGFuZ3VsYXIuaXNEZWZpbmVkKCRhdHRycy5kcm9wZG93bkFwcGVuZFRvQm9keSkpIHtcbiAgICAgIHZhciBhcHBlbmRUb0JvZHlWYWx1ZSA9ICRwYXJzZSgkYXR0cnMuZHJvcGRvd25BcHBlbmRUb0JvZHkpKHNjb3BlKTtcbiAgICAgIGlmIChhcHBlbmRUb0JvZHlWYWx1ZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgYXBwZW5kVG9Cb2R5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYXBwZW5kVG9Cb2R5ICYmICFhcHBlbmRUbykge1xuICAgICAgYXBwZW5kVG8gPSBib2R5O1xuICAgIH1cblxuICAgIGlmIChhcHBlbmRUbyAmJiBzZWxmLmRyb3Bkb3duTWVudSkge1xuICAgICAgaWYgKGlzT3Blbikge1xuICAgICAgICBhcHBlbmRUby5hcHBlbmQoc2VsZi5kcm9wZG93bk1lbnUpO1xuICAgICAgICAkZWxlbWVudC5vbignJGRlc3Ryb3knLCByZW1vdmVEcm9wZG93bk1lbnUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgJGVsZW1lbnQub2ZmKCckZGVzdHJveScsIHJlbW92ZURyb3Bkb3duTWVudSk7XG4gICAgICAgIHJlbW92ZURyb3Bkb3duTWVudSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChhcHBlbmRUbyAmJiBzZWxmLmRyb3Bkb3duTWVudSkge1xuICAgICAgdmFyIHBvcyA9ICRwb3NpdGlvbi5wb3NpdGlvbkVsZW1lbnRzKCRlbGVtZW50LCBzZWxmLmRyb3Bkb3duTWVudSwgJ2JvdHRvbS1sZWZ0JywgdHJ1ZSksXG4gICAgICAgIGNzcyxcbiAgICAgICAgcmlnaHRhbGlnbixcbiAgICAgICAgc2Nyb2xsYmFyUGFkZGluZyxcbiAgICAgICAgc2Nyb2xsYmFyV2lkdGggPSAwO1xuXG4gICAgICBjc3MgPSB7XG4gICAgICAgIHRvcDogcG9zLnRvcCArICdweCcsXG4gICAgICAgIGRpc3BsYXk6IGlzT3BlbiA/ICdibG9jaycgOiAnbm9uZSdcbiAgICAgIH07XG5cbiAgICAgIHJpZ2h0YWxpZ24gPSBzZWxmLmRyb3Bkb3duTWVudS5oYXNDbGFzcygnZHJvcGRvd24tbWVudS1yaWdodCcpO1xuICAgICAgaWYgKCFyaWdodGFsaWduKSB7XG4gICAgICAgIGNzcy5sZWZ0ID0gcG9zLmxlZnQgKyAncHgnO1xuICAgICAgICBjc3MucmlnaHQgPSAnYXV0byc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjc3MubGVmdCA9ICdhdXRvJztcbiAgICAgICAgc2Nyb2xsYmFyUGFkZGluZyA9ICRwb3NpdGlvbi5zY3JvbGxiYXJQYWRkaW5nKGFwcGVuZFRvKTtcblxuICAgICAgICBpZiAoc2Nyb2xsYmFyUGFkZGluZy5oZWlnaHRPdmVyZmxvdyAmJiBzY3JvbGxiYXJQYWRkaW5nLnNjcm9sbGJhcldpZHRoKSB7XG4gICAgICAgICAgc2Nyb2xsYmFyV2lkdGggPSBzY3JvbGxiYXJQYWRkaW5nLnNjcm9sbGJhcldpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgY3NzLnJpZ2h0ID0gd2luZG93LmlubmVyV2lkdGggLSBzY3JvbGxiYXJXaWR0aCAtXG4gICAgICAgICAgKHBvcy5sZWZ0ICsgJGVsZW1lbnQucHJvcCgnb2Zmc2V0V2lkdGgnKSkgKyAncHgnO1xuICAgICAgfVxuXG4gICAgICAvLyBOZWVkIHRvIGFkanVzdCBvdXIgcG9zaXRpb25pbmcgdG8gYmUgcmVsYXRpdmUgdG8gdGhlIGFwcGVuZFRvIGNvbnRhaW5lclxuICAgICAgLy8gaWYgaXQncyBub3QgdGhlIGJvZHkgZWxlbWVudFxuICAgICAgaWYgKCFhcHBlbmRUb0JvZHkpIHtcbiAgICAgICAgdmFyIGFwcGVuZE9mZnNldCA9ICRwb3NpdGlvbi5vZmZzZXQoYXBwZW5kVG8pO1xuXG4gICAgICAgIGNzcy50b3AgPSBwb3MudG9wIC0gYXBwZW5kT2Zmc2V0LnRvcCArICdweCc7XG5cbiAgICAgICAgaWYgKCFyaWdodGFsaWduKSB7XG4gICAgICAgICAgY3NzLmxlZnQgPSBwb3MubGVmdCAtIGFwcGVuZE9mZnNldC5sZWZ0ICsgJ3B4JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjc3MucmlnaHQgPSB3aW5kb3cuaW5uZXJXaWR0aCAtXG4gICAgICAgICAgICAocG9zLmxlZnQgLSBhcHBlbmRPZmZzZXQubGVmdCArICRlbGVtZW50LnByb3AoJ29mZnNldFdpZHRoJykpICsgJ3B4JztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzZWxmLmRyb3Bkb3duTWVudS5jc3MoY3NzKTtcbiAgICB9XG5cbiAgICB2YXIgb3BlbkNvbnRhaW5lciA9IGFwcGVuZFRvID8gYXBwZW5kVG8gOiAkZWxlbWVudDtcbiAgICB2YXIgZHJvcGRvd25PcGVuQ2xhc3MgPSBhcHBlbmRUbyA/IGFwcGVuZFRvT3BlbkNsYXNzIDogb3BlbkNsYXNzO1xuICAgIHZhciBoYXNPcGVuQ2xhc3MgPSBvcGVuQ29udGFpbmVyLmhhc0NsYXNzKGRyb3Bkb3duT3BlbkNsYXNzKTtcbiAgICB2YXIgaXNPbmx5T3BlbiA9IHVpYkRyb3Bkb3duU2VydmljZS5pc09ubHlPcGVuKCRzY29wZSwgYXBwZW5kVG8pO1xuXG4gICAgaWYgKGhhc09wZW5DbGFzcyA9PT0gIWlzT3Blbikge1xuICAgICAgdmFyIHRvZ2dsZUNsYXNzO1xuICAgICAgaWYgKGFwcGVuZFRvKSB7XG4gICAgICAgIHRvZ2dsZUNsYXNzID0gIWlzT25seU9wZW4gPyAnYWRkQ2xhc3MnIDogJ3JlbW92ZUNsYXNzJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRvZ2dsZUNsYXNzID0gaXNPcGVuID8gJ2FkZENsYXNzJyA6ICdyZW1vdmVDbGFzcyc7XG4gICAgICB9XG4gICAgICAkYW5pbWF0ZVt0b2dnbGVDbGFzc10ob3BlbkNvbnRhaW5lciwgZHJvcGRvd25PcGVuQ2xhc3MpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChhbmd1bGFyLmlzRGVmaW5lZChpc09wZW4pICYmIGlzT3BlbiAhPT0gd2FzT3Blbikge1xuICAgICAgICAgIHRvZ2dsZUludm9rZXIoJHNjb3BlLCB7IG9wZW46ICEhaXNPcGVuIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoaXNPcGVuKSB7XG4gICAgICBpZiAoc2VsZi5kcm9wZG93bk1lbnVUZW1wbGF0ZVVybCkge1xuICAgICAgICAkdGVtcGxhdGVSZXF1ZXN0KHNlbGYuZHJvcGRvd25NZW51VGVtcGxhdGVVcmwpLnRoZW4oZnVuY3Rpb24odHBsQ29udGVudCkge1xuICAgICAgICAgIHRlbXBsYXRlU2NvcGUgPSBzY29wZS4kbmV3KCk7XG4gICAgICAgICAgJGNvbXBpbGUodHBsQ29udGVudC50cmltKCkpKHRlbXBsYXRlU2NvcGUsIGZ1bmN0aW9uKGRyb3Bkb3duRWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIG5ld0VsID0gZHJvcGRvd25FbGVtZW50O1xuICAgICAgICAgICAgc2VsZi5kcm9wZG93bk1lbnUucmVwbGFjZVdpdGgobmV3RWwpO1xuICAgICAgICAgICAgc2VsZi5kcm9wZG93bk1lbnUgPSBuZXdFbDtcbiAgICAgICAgICAgICRkb2N1bWVudC5vbigna2V5ZG93bicsIHVpYkRyb3Bkb3duU2VydmljZS5rZXliaW5kRmlsdGVyKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkZG9jdW1lbnQub24oJ2tleWRvd24nLCB1aWJEcm9wZG93blNlcnZpY2Uua2V5YmluZEZpbHRlcik7XG4gICAgICB9XG5cbiAgICAgIHNjb3BlLmZvY3VzVG9nZ2xlRWxlbWVudCgpO1xuICAgICAgdWliRHJvcGRvd25TZXJ2aWNlLm9wZW4oc2NvcGUsICRlbGVtZW50LCBhcHBlbmRUbyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVpYkRyb3Bkb3duU2VydmljZS5jbG9zZShzY29wZSwgJGVsZW1lbnQsIGFwcGVuZFRvKTtcbiAgICAgIGlmIChzZWxmLmRyb3Bkb3duTWVudVRlbXBsYXRlVXJsKSB7XG4gICAgICAgIGlmICh0ZW1wbGF0ZVNjb3BlKSB7XG4gICAgICAgICAgdGVtcGxhdGVTY29wZS4kZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZXdFbCA9IGFuZ3VsYXIuZWxlbWVudCgnPHVsIGNsYXNzPVwiZHJvcGRvd24tbWVudVwiPjwvdWw+Jyk7XG4gICAgICAgIHNlbGYuZHJvcGRvd25NZW51LnJlcGxhY2VXaXRoKG5ld0VsKTtcbiAgICAgICAgc2VsZi5kcm9wZG93bk1lbnUgPSBuZXdFbDtcbiAgICAgIH1cblxuICAgICAgc2VsZi5zZWxlY3RlZE9wdGlvbiA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGFuZ3VsYXIuaXNGdW5jdGlvbihzZXRJc09wZW4pKSB7XG4gICAgICBzZXRJc09wZW4oJHNjb3BlLCBpc09wZW4pO1xuICAgIH1cbiAgfSk7XG59XSlcblxuLmRpcmVjdGl2ZSgndWliRHJvcGRvd24nLCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICBjb250cm9sbGVyOiAnVWliRHJvcGRvd25Db250cm9sbGVyJyxcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIGRyb3Bkb3duQ3RybCkge1xuICAgICAgZHJvcGRvd25DdHJsLmluaXQoKTtcbiAgICB9XG4gIH07XG59KVxuXG4uZGlyZWN0aXZlKCd1aWJEcm9wZG93bk1lbnUnLCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICByZXN0cmljdDogJ0EnLFxuICAgIHJlcXVpcmU6ICc/XnVpYkRyb3Bkb3duJyxcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIGRyb3Bkb3duQ3RybCkge1xuICAgICAgaWYgKCFkcm9wZG93bkN0cmwgfHwgYW5ndWxhci5pc0RlZmluZWQoYXR0cnMuZHJvcGRvd25OZXN0ZWQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZWxlbWVudC5hZGRDbGFzcygnZHJvcGRvd24tbWVudScpO1xuXG4gICAgICB2YXIgdHBsVXJsID0gYXR0cnMudGVtcGxhdGVVcmw7XG4gICAgICBpZiAodHBsVXJsKSB7XG4gICAgICAgIGRyb3Bkb3duQ3RybC5kcm9wZG93bk1lbnVUZW1wbGF0ZVVybCA9IHRwbFVybDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFkcm9wZG93bkN0cmwuZHJvcGRvd25NZW51KSB7XG4gICAgICAgIGRyb3Bkb3duQ3RybC5kcm9wZG93bk1lbnUgPSBlbGVtZW50O1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn0pXG5cbi5kaXJlY3RpdmUoJ3VpYkRyb3Bkb3duVG9nZ2xlJywgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgcmVxdWlyZTogJz9edWliRHJvcGRvd24nLFxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgZHJvcGRvd25DdHJsKSB7XG4gICAgICBpZiAoIWRyb3Bkb3duQ3RybCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGVsZW1lbnQuYWRkQ2xhc3MoJ2Ryb3Bkb3duLXRvZ2dsZScpO1xuXG4gICAgICBkcm9wZG93bkN0cmwudG9nZ2xlRWxlbWVudCA9IGVsZW1lbnQ7XG5cbiAgICAgIHZhciB0b2dnbGVEcm9wZG93biA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgaWYgKCFlbGVtZW50Lmhhc0NsYXNzKCdkaXNhYmxlZCcpICYmICFhdHRycy5kaXNhYmxlZCkge1xuICAgICAgICAgIHNjb3BlLiRhcHBseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGRyb3Bkb3duQ3RybC50b2dnbGUoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZWxlbWVudC5vbignY2xpY2snLCB0b2dnbGVEcm9wZG93bik7XG5cbiAgICAgIC8vIFdBSS1BUklBXG4gICAgICBlbGVtZW50LmF0dHIoeyAnYXJpYS1oYXNwb3B1cCc6IHRydWUsICdhcmlhLWV4cGFuZGVkJzogZmFsc2UgfSk7XG4gICAgICBzY29wZS4kd2F0Y2goZHJvcGRvd25DdHJsLmlzT3BlbiwgZnVuY3Rpb24oaXNPcGVuKSB7XG4gICAgICAgIGVsZW1lbnQuYXR0cignYXJpYS1leHBhbmRlZCcsICEhaXNPcGVuKTtcbiAgICAgIH0pO1xuXG4gICAgICBzY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGVsZW1lbnQub2ZmKCdjbGljaycsIHRvZ2dsZURyb3Bkb3duKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn0pO1xuXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLnN0YWNrZWRNYXAnLCBbXSlcbi8qKlxuICogQSBoZWxwZXIsIGludGVybmFsIGRhdGEgc3RydWN0dXJlIHRoYXQgYWN0cyBhcyBhIG1hcCBidXQgYWxzbyBhbGxvd3MgZ2V0dGluZyAvIHJlbW92aW5nXG4gKiBlbGVtZW50cyBpbiB0aGUgTElGTyBvcmRlclxuICovXG4gIC5mYWN0b3J5KCckJHN0YWNrZWRNYXAnLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY3JlYXRlTmV3OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0YWNrID0gW107XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBhZGQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goe1xuICAgICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGlmIChrZXkgPT09IHN0YWNrW2ldLmtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGFja1tpXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAga2V5czogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIga2V5cyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBrZXlzLnB1c2goc3RhY2tbaV0ua2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBrZXlzO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlbW92ZTogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICB2YXIgaWR4ID0gLTE7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGlmIChrZXkgPT09IHN0YWNrW2ldLmtleSkge1xuICAgICAgICAgICAgICAgIGlkeCA9IGk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdGFjay5zcGxpY2UoaWR4LCAxKVswXTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlbW92ZVRvcDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RhY2sucG9wKCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBsZW5ndGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YWNrLmxlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLm1vZGFsJywgWyd1aS5ib290c3RyYXAubXVsdGlNYXAnLCAndWkuYm9vdHN0cmFwLnN0YWNrZWRNYXAnLCAndWkuYm9vdHN0cmFwLnBvc2l0aW9uJ10pXG4vKipcbiAqIFBsdWdnYWJsZSByZXNvbHZlIG1lY2hhbmlzbSBmb3IgdGhlIG1vZGFsIHJlc29sdmUgcmVzb2x1dGlvblxuICogU3VwcG9ydHMgVUkgUm91dGVyJ3MgJHJlc29sdmUgc2VydmljZVxuICovXG4gIC5wcm92aWRlcignJHVpYlJlc29sdmUnLCBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVzb2x2ZSA9IHRoaXM7XG4gICAgdGhpcy5yZXNvbHZlciA9IG51bGw7XG5cbiAgICB0aGlzLnNldFJlc29sdmVyID0gZnVuY3Rpb24ocmVzb2x2ZXIpIHtcbiAgICAgIHRoaXMucmVzb2x2ZXIgPSByZXNvbHZlcjtcbiAgICB9O1xuXG4gICAgdGhpcy4kZ2V0ID0gWyckaW5qZWN0b3InLCAnJHEnLCBmdW5jdGlvbigkaW5qZWN0b3IsICRxKSB7XG4gICAgICB2YXIgcmVzb2x2ZXIgPSByZXNvbHZlLnJlc29sdmVyID8gJGluamVjdG9yLmdldChyZXNvbHZlLnJlc29sdmVyKSA6IG51bGw7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXNvbHZlOiBmdW5jdGlvbihpbnZvY2FibGVzLCBsb2NhbHMsIHBhcmVudCwgc2VsZikge1xuICAgICAgICAgIGlmIChyZXNvbHZlcikge1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVyLnJlc29sdmUoaW52b2NhYmxlcywgbG9jYWxzLCBwYXJlbnQsIHNlbGYpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBwcm9taXNlcyA9IFtdO1xuXG4gICAgICAgICAgYW5ndWxhci5mb3JFYWNoKGludm9jYWJsZXMsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoYW5ndWxhci5pc0Z1bmN0aW9uKHZhbHVlKSB8fCBhbmd1bGFyLmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgIHByb21pc2VzLnB1c2goJHEucmVzb2x2ZSgkaW5qZWN0b3IuaW52b2tlKHZhbHVlKSkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhbmd1bGFyLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKCRxLnJlc29sdmUoJGluamVjdG9yLmdldCh2YWx1ZSkpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHByb21pc2VzLnB1c2goJHEucmVzb2x2ZSh2YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcmV0dXJuICRxLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbihyZXNvbHZlcykge1xuICAgICAgICAgICAgdmFyIHJlc29sdmVPYmogPSB7fTtcbiAgICAgICAgICAgIHZhciByZXNvbHZlSXRlciA9IDA7XG4gICAgICAgICAgICBhbmd1bGFyLmZvckVhY2goaW52b2NhYmxlcywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICAgICAgICByZXNvbHZlT2JqW2tleV0gPSByZXNvbHZlc1tyZXNvbHZlSXRlcisrXTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZU9iajtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XTtcbiAgfSlcblxuLyoqXG4gKiBBIGhlbHBlciBkaXJlY3RpdmUgZm9yIHRoZSAkbW9kYWwgc2VydmljZS4gSXQgY3JlYXRlcyBhIGJhY2tkcm9wIGVsZW1lbnQuXG4gKi9cbiAgLmRpcmVjdGl2ZSgndWliTW9kYWxCYWNrZHJvcCcsIFsnJGFuaW1hdGUnLCAnJGluamVjdG9yJywgJyR1aWJNb2RhbFN0YWNrJyxcbiAgZnVuY3Rpb24oJGFuaW1hdGUsICRpbmplY3RvciwgJG1vZGFsU3RhY2spIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVzdHJpY3Q6ICdBJyxcbiAgICAgIGNvbXBpbGU6IGZ1bmN0aW9uKHRFbGVtZW50LCB0QXR0cnMpIHtcbiAgICAgICAgdEVsZW1lbnQuYWRkQ2xhc3ModEF0dHJzLmJhY2tkcm9wQ2xhc3MpO1xuICAgICAgICByZXR1cm4gbGlua0ZuO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBsaW5rRm4oc2NvcGUsIGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgICBpZiAoYXR0cnMubW9kYWxJbkNsYXNzKSB7XG4gICAgICAgICRhbmltYXRlLmFkZENsYXNzKGVsZW1lbnQsIGF0dHJzLm1vZGFsSW5DbGFzcyk7XG5cbiAgICAgICAgc2NvcGUuJG9uKCRtb2RhbFN0YWNrLk5PV19DTE9TSU5HX0VWRU5ULCBmdW5jdGlvbihlLCBzZXRJc0FzeW5jKSB7XG4gICAgICAgICAgdmFyIGRvbmUgPSBzZXRJc0FzeW5jKCk7XG4gICAgICAgICAgaWYgKHNjb3BlLm1vZGFsT3B0aW9ucy5hbmltYXRpb24pIHtcbiAgICAgICAgICAgICRhbmltYXRlLnJlbW92ZUNsYXNzKGVsZW1lbnQsIGF0dHJzLm1vZGFsSW5DbGFzcykudGhlbihkb25lKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XSlcblxuICAuZGlyZWN0aXZlKCd1aWJNb2RhbFdpbmRvdycsIFsnJHVpYk1vZGFsU3RhY2snLCAnJHEnLCAnJGFuaW1hdGVDc3MnLCAnJGRvY3VtZW50JyxcbiAgZnVuY3Rpb24oJG1vZGFsU3RhY2ssICRxLCAkYW5pbWF0ZUNzcywgJGRvY3VtZW50KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNjb3BlOiB7XG4gICAgICAgIGluZGV4OiAnQCdcbiAgICAgIH0sXG4gICAgICByZXN0cmljdDogJ0EnLFxuICAgICAgdHJhbnNjbHVkZTogdHJ1ZSxcbiAgICAgIHRlbXBsYXRlVXJsOiBmdW5jdGlvbih0RWxlbWVudCwgdEF0dHJzKSB7XG4gICAgICAgIHJldHVybiB0QXR0cnMudGVtcGxhdGVVcmwgfHwgJ3VpYi90ZW1wbGF0ZS9tb2RhbC93aW5kb3cuaHRtbCc7XG4gICAgICB9LFxuICAgICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgICAgIGVsZW1lbnQuYWRkQ2xhc3MoYXR0cnMud2luZG93VG9wQ2xhc3MgfHwgJycpO1xuICAgICAgICBzY29wZS5zaXplID0gYXR0cnMuc2l6ZTtcblxuICAgICAgICBzY29wZS5jbG9zZSA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgIHZhciBtb2RhbCA9ICRtb2RhbFN0YWNrLmdldFRvcCgpO1xuICAgICAgICAgIGlmIChtb2RhbCAmJiBtb2RhbC52YWx1ZS5iYWNrZHJvcCAmJlxuICAgICAgICAgICAgbW9kYWwudmFsdWUuYmFja2Ryb3AgIT09ICdzdGF0aWMnICYmXG4gICAgICAgICAgICBldnQudGFyZ2V0ID09PSBldnQuY3VycmVudFRhcmdldCkge1xuICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAkbW9kYWxTdGFjay5kaXNtaXNzKG1vZGFsLmtleSwgJ2JhY2tkcm9wIGNsaWNrJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIG1vdmVkIGZyb20gdGVtcGxhdGUgdG8gZml4IGlzc3VlICMyMjgwXG4gICAgICAgIGVsZW1lbnQub24oJ2NsaWNrJywgc2NvcGUuY2xvc2UpO1xuXG4gICAgICAgIC8vIFRoaXMgcHJvcGVydHkgaXMgb25seSBhZGRlZCB0byB0aGUgc2NvcGUgZm9yIHRoZSBwdXJwb3NlIG9mIGRldGVjdGluZyB3aGVuIHRoaXMgZGlyZWN0aXZlIGlzIHJlbmRlcmVkLlxuICAgICAgICAvLyBXZSBjYW4gZGV0ZWN0IHRoYXQgYnkgdXNpbmcgdGhpcyBwcm9wZXJ0eSBpbiB0aGUgdGVtcGxhdGUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgZGlyZWN0aXZlIGFuZCB0aGVuIHVzZVxuICAgICAgICAvLyB7QGxpbmsgQXR0cmlidXRlIyRvYnNlcnZlfSBvbiBpdC4gRm9yIG1vcmUgZGV0YWlscyBwbGVhc2Ugc2VlIHtAbGluayBUYWJsZUNvbHVtblJlc2l6ZX0uXG4gICAgICAgIHNjb3BlLiRpc1JlbmRlcmVkID0gdHJ1ZTtcblxuICAgICAgICAvLyBEZWZlcnJlZCBvYmplY3QgdGhhdCB3aWxsIGJlIHJlc29sdmVkIHdoZW4gdGhpcyBtb2RhbCBpcyByZW5kZXJlZC5cbiAgICAgICAgdmFyIG1vZGFsUmVuZGVyRGVmZXJPYmogPSAkcS5kZWZlcigpO1xuICAgICAgICAvLyBSZXNvbHZlIHJlbmRlciBwcm9taXNlIHBvc3QtZGlnZXN0XG4gICAgICAgIHNjb3BlLiQkcG9zdERpZ2VzdChmdW5jdGlvbigpIHtcbiAgICAgICAgICBtb2RhbFJlbmRlckRlZmVyT2JqLnJlc29sdmUoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbW9kYWxSZW5kZXJEZWZlck9iai5wcm9taXNlLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGFuaW1hdGlvblByb21pc2UgPSBudWxsO1xuXG4gICAgICAgICAgaWYgKGF0dHJzLm1vZGFsSW5DbGFzcykge1xuICAgICAgICAgICAgYW5pbWF0aW9uUHJvbWlzZSA9ICRhbmltYXRlQ3NzKGVsZW1lbnQsIHtcbiAgICAgICAgICAgICAgYWRkQ2xhc3M6IGF0dHJzLm1vZGFsSW5DbGFzc1xuICAgICAgICAgICAgfSkuc3RhcnQoKTtcblxuICAgICAgICAgICAgc2NvcGUuJG9uKCRtb2RhbFN0YWNrLk5PV19DTE9TSU5HX0VWRU5ULCBmdW5jdGlvbihlLCBzZXRJc0FzeW5jKSB7XG4gICAgICAgICAgICAgIHZhciBkb25lID0gc2V0SXNBc3luYygpO1xuICAgICAgICAgICAgICAkYW5pbWF0ZUNzcyhlbGVtZW50LCB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3M6IGF0dHJzLm1vZGFsSW5DbGFzc1xuICAgICAgICAgICAgICB9KS5zdGFydCgpLnRoZW4oZG9uZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cblxuICAgICAgICAgICRxLndoZW4oYW5pbWF0aW9uUHJvbWlzZSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIE5vdGlmeSB7QGxpbmsgJG1vZGFsU3RhY2t9IHRoYXQgbW9kYWwgaXMgcmVuZGVyZWQuXG4gICAgICAgICAgICB2YXIgbW9kYWwgPSAkbW9kYWxTdGFjay5nZXRUb3AoKTtcbiAgICAgICAgICAgIGlmIChtb2RhbCkge1xuICAgICAgICAgICAgICAkbW9kYWxTdGFjay5tb2RhbFJlbmRlcmVkKG1vZGFsLmtleSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgc29tZXRoaW5nIHdpdGhpbiB0aGUgZnJlc2hseS1vcGVuZWQgbW9kYWwgYWxyZWFkeSBoYXMgZm9jdXMgKHBlcmhhcHMgdmlhIGFcbiAgICAgICAgICAgICAqIGRpcmVjdGl2ZSB0aGF0IGNhdXNlcyBmb2N1cykgdGhlbiB0aGVyZSdzIG5vIG5lZWQgdG8gdHJ5IHRvIGZvY3VzIGFueXRoaW5nLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoISgkZG9jdW1lbnRbMF0uYWN0aXZlRWxlbWVudCAmJiBlbGVtZW50WzBdLmNvbnRhaW5zKCRkb2N1bWVudFswXS5hY3RpdmVFbGVtZW50KSkpIHtcbiAgICAgICAgICAgICAgdmFyIGlucHV0V2l0aEF1dG9mb2N1cyA9IGVsZW1lbnRbMF0ucXVlcnlTZWxlY3RvcignW2F1dG9mb2N1c10nKTtcbiAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAqIEF1dG8tZm9jdXNpbmcgb2YgYSBmcmVzaGx5LW9wZW5lZCBtb2RhbCBlbGVtZW50IGNhdXNlcyBhbnkgY2hpbGQgZWxlbWVudHNcbiAgICAgICAgICAgICAgICogd2l0aCB0aGUgYXV0b2ZvY3VzIGF0dHJpYnV0ZSB0byBsb3NlIGZvY3VzLiBUaGlzIGlzIGFuIGlzc3VlIG9uIHRvdWNoXG4gICAgICAgICAgICAgICAqIGJhc2VkIGRldmljZXMgd2hpY2ggd2lsbCBzaG93IGFuZCB0aGVuIGhpZGUgdGhlIG9uc2NyZWVuIGtleWJvYXJkLlxuICAgICAgICAgICAgICAgKiBBdHRlbXB0cyB0byByZWZvY3VzIHRoZSBhdXRvZm9jdXMgZWxlbWVudCB2aWEgSmF2YVNjcmlwdCB3aWxsIG5vdCByZW9wZW5cbiAgICAgICAgICAgICAgICogdGhlIG9uc2NyZWVuIGtleWJvYXJkLiBGaXhlZCBieSB1cGRhdGVkIHRoZSBmb2N1c2luZyBsb2dpYyB0byBvbmx5IGF1dG9mb2N1c1xuICAgICAgICAgICAgICAgKiB0aGUgbW9kYWwgZWxlbWVudCBpZiB0aGUgbW9kYWwgZG9lcyBub3QgY29udGFpbiBhbiBhdXRvZm9jdXMgZWxlbWVudC5cbiAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgIGlmIChpbnB1dFdpdGhBdXRvZm9jdXMpIHtcbiAgICAgICAgICAgICAgICBpbnB1dFdpdGhBdXRvZm9jdXMuZm9jdXMoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50WzBdLmZvY3VzKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfV0pXG5cbiAgLmRpcmVjdGl2ZSgndWliTW9kYWxBbmltYXRpb25DbGFzcycsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb21waWxlOiBmdW5jdGlvbih0RWxlbWVudCwgdEF0dHJzKSB7XG4gICAgICAgIGlmICh0QXR0cnMubW9kYWxBbmltYXRpb24pIHtcbiAgICAgICAgICB0RWxlbWVudC5hZGRDbGFzcyh0QXR0cnMudWliTW9kYWxBbmltYXRpb25DbGFzcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9KVxuXG4gIC5kaXJlY3RpdmUoJ3VpYk1vZGFsVHJhbnNjbHVkZScsIFsnJGFuaW1hdGUnLCBmdW5jdGlvbigkYW5pbWF0ZSkge1xuICAgIHJldHVybiB7XG4gICAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIGNvbnRyb2xsZXIsIHRyYW5zY2x1ZGUpIHtcbiAgICAgICAgdHJhbnNjbHVkZShzY29wZS4kcGFyZW50LCBmdW5jdGlvbihjbG9uZSkge1xuICAgICAgICAgIGVsZW1lbnQuZW1wdHkoKTtcbiAgICAgICAgICAkYW5pbWF0ZS5lbnRlcihjbG9uZSwgZWxlbWVudCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH1dKVxuXG4gIC5mYWN0b3J5KCckdWliTW9kYWxTdGFjaycsIFsnJGFuaW1hdGUnLCAnJGFuaW1hdGVDc3MnLCAnJGRvY3VtZW50JyxcbiAgICAnJGNvbXBpbGUnLCAnJHJvb3RTY29wZScsICckcScsICckJG11bHRpTWFwJywgJyQkc3RhY2tlZE1hcCcsICckdWliUG9zaXRpb24nLFxuICAgIGZ1bmN0aW9uKCRhbmltYXRlLCAkYW5pbWF0ZUNzcywgJGRvY3VtZW50LCAkY29tcGlsZSwgJHJvb3RTY29wZSwgJHEsICQkbXVsdGlNYXAsICQkc3RhY2tlZE1hcCwgJHVpYlBvc2l0aW9uKSB7XG4gICAgICB2YXIgT1BFTkVEX01PREFMX0NMQVNTID0gJ21vZGFsLW9wZW4nO1xuXG4gICAgICB2YXIgYmFja2Ryb3BEb21FbCwgYmFja2Ryb3BTY29wZTtcbiAgICAgIHZhciBvcGVuZWRXaW5kb3dzID0gJCRzdGFja2VkTWFwLmNyZWF0ZU5ldygpO1xuICAgICAgdmFyIG9wZW5lZENsYXNzZXMgPSAkJG11bHRpTWFwLmNyZWF0ZU5ldygpO1xuICAgICAgdmFyICRtb2RhbFN0YWNrID0ge1xuICAgICAgICBOT1dfQ0xPU0lOR19FVkVOVDogJ21vZGFsLnN0YWNrLm5vdy1jbG9zaW5nJ1xuICAgICAgfTtcbiAgICAgIHZhciB0b3BNb2RhbEluZGV4ID0gMDtcbiAgICAgIHZhciBwcmV2aW91c1RvcE9wZW5lZE1vZGFsID0gbnVsbDtcbiAgICAgIHZhciBBUklBX0hJRERFTl9BVFRSSUJVVEVfTkFNRSA9ICdkYXRhLWJvb3RzdHJhcC1tb2RhbC1hcmlhLWhpZGRlbi1jb3VudCc7XG5cbiAgICAgIC8vTW9kYWwgZm9jdXMgYmVoYXZpb3JcbiAgICAgIHZhciB0YWJiYWJsZVNlbGVjdG9yID0gJ2FbaHJlZl0sIGFyZWFbaHJlZl0sIGlucHV0Om5vdChbZGlzYWJsZWRdKTpub3QoW3RhYmluZGV4PVxcJy0xXFwnXSksICcgK1xuICAgICAgICAnYnV0dG9uOm5vdChbZGlzYWJsZWRdKTpub3QoW3RhYmluZGV4PVxcJy0xXFwnXSksc2VsZWN0Om5vdChbZGlzYWJsZWRdKTpub3QoW3RhYmluZGV4PVxcJy0xXFwnXSksIHRleHRhcmVhOm5vdChbZGlzYWJsZWRdKTpub3QoW3RhYmluZGV4PVxcJy0xXFwnXSksICcgK1xuICAgICAgICAnaWZyYW1lLCBvYmplY3QsIGVtYmVkLCAqW3RhYmluZGV4XTpub3QoW3RhYmluZGV4PVxcJy0xXFwnXSksICpbY29udGVudGVkaXRhYmxlPXRydWVdJztcbiAgICAgIHZhciBzY3JvbGxiYXJQYWRkaW5nO1xuICAgICAgdmFyIFNOQUtFX0NBU0VfUkVHRVhQID0gL1tBLVpdL2c7XG5cbiAgICAgIC8vIFRPRE86IGV4dHJhY3QgaW50byBjb21tb24gZGVwZW5kZW5jeSB3aXRoIHRvb2x0aXBcbiAgICAgIGZ1bmN0aW9uIHNuYWtlX2Nhc2UobmFtZSkge1xuICAgICAgICB2YXIgc2VwYXJhdG9yID0gJy0nO1xuICAgICAgICByZXR1cm4gbmFtZS5yZXBsYWNlKFNOQUtFX0NBU0VfUkVHRVhQLCBmdW5jdGlvbihsZXR0ZXIsIHBvcykge1xuICAgICAgICAgIHJldHVybiAocG9zID8gc2VwYXJhdG9yIDogJycpICsgbGV0dGVyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpc1Zpc2libGUoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gISEoZWxlbWVudC5vZmZzZXRXaWR0aCB8fFxuICAgICAgICAgIGVsZW1lbnQub2Zmc2V0SGVpZ2h0IHx8XG4gICAgICAgICAgZWxlbWVudC5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGJhY2tkcm9wSW5kZXgoKSB7XG4gICAgICAgIHZhciB0b3BCYWNrZHJvcEluZGV4ID0gLTE7XG4gICAgICAgIHZhciBvcGVuZWQgPSBvcGVuZWRXaW5kb3dzLmtleXMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcGVuZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAob3BlbmVkV2luZG93cy5nZXQob3BlbmVkW2ldKS52YWx1ZS5iYWNrZHJvcCkge1xuICAgICAgICAgICAgdG9wQmFja2Ryb3BJbmRleCA9IGk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgYW55IGJhY2tkcm9wIGV4aXN0LCBlbnN1cmUgdGhhdCBpdCdzIGluZGV4IGlzIGFsd2F5c1xuICAgICAgICAvLyByaWdodCBiZWxvdyB0aGUgdG9wIG1vZGFsXG4gICAgICAgIGlmICh0b3BCYWNrZHJvcEluZGV4ID4gLTEgJiYgdG9wQmFja2Ryb3BJbmRleCA8IHRvcE1vZGFsSW5kZXgpIHtcbiAgICAgICAgICB0b3BCYWNrZHJvcEluZGV4ID0gdG9wTW9kYWxJbmRleDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9wQmFja2Ryb3BJbmRleDtcbiAgICAgIH1cblxuICAgICAgJHJvb3RTY29wZS4kd2F0Y2goYmFja2Ryb3BJbmRleCwgZnVuY3Rpb24obmV3QmFja2Ryb3BJbmRleCkge1xuICAgICAgICBpZiAoYmFja2Ryb3BTY29wZSkge1xuICAgICAgICAgIGJhY2tkcm9wU2NvcGUuaW5kZXggPSBuZXdCYWNrZHJvcEluZGV4O1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgZnVuY3Rpb24gcmVtb3ZlTW9kYWxXaW5kb3cobW9kYWxJbnN0YW5jZSwgZWxlbWVudFRvUmVjZWl2ZUZvY3VzKSB7XG4gICAgICAgIHZhciBtb2RhbFdpbmRvdyA9IG9wZW5lZFdpbmRvd3MuZ2V0KG1vZGFsSW5zdGFuY2UpLnZhbHVlO1xuICAgICAgICB2YXIgYXBwZW5kVG9FbGVtZW50ID0gbW9kYWxXaW5kb3cuYXBwZW5kVG87XG5cbiAgICAgICAgLy9jbGVhbiB1cCB0aGUgc3RhY2tcbiAgICAgICAgb3BlbmVkV2luZG93cy5yZW1vdmUobW9kYWxJbnN0YW5jZSk7XG4gICAgICAgIHByZXZpb3VzVG9wT3BlbmVkTW9kYWwgPSBvcGVuZWRXaW5kb3dzLnRvcCgpO1xuICAgICAgICBpZiAocHJldmlvdXNUb3BPcGVuZWRNb2RhbCkge1xuICAgICAgICAgIHRvcE1vZGFsSW5kZXggPSBwYXJzZUludChwcmV2aW91c1RvcE9wZW5lZE1vZGFsLnZhbHVlLm1vZGFsRG9tRWwuYXR0cignaW5kZXgnKSwgMTApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVtb3ZlQWZ0ZXJBbmltYXRlKG1vZGFsV2luZG93Lm1vZGFsRG9tRWwsIG1vZGFsV2luZG93Lm1vZGFsU2NvcGUsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBtb2RhbEJvZHlDbGFzcyA9IG1vZGFsV2luZG93Lm9wZW5lZENsYXNzIHx8IE9QRU5FRF9NT0RBTF9DTEFTUztcbiAgICAgICAgICBvcGVuZWRDbGFzc2VzLnJlbW92ZShtb2RhbEJvZHlDbGFzcywgbW9kYWxJbnN0YW5jZSk7XG4gICAgICAgICAgdmFyIGFyZUFueU9wZW4gPSBvcGVuZWRDbGFzc2VzLmhhc0tleShtb2RhbEJvZHlDbGFzcyk7XG4gICAgICAgICAgYXBwZW5kVG9FbGVtZW50LnRvZ2dsZUNsYXNzKG1vZGFsQm9keUNsYXNzLCBhcmVBbnlPcGVuKTtcbiAgICAgICAgICBpZiAoIWFyZUFueU9wZW4gJiYgc2Nyb2xsYmFyUGFkZGluZyAmJiBzY3JvbGxiYXJQYWRkaW5nLmhlaWdodE92ZXJmbG93ICYmIHNjcm9sbGJhclBhZGRpbmcuc2Nyb2xsYmFyV2lkdGgpIHtcbiAgICAgICAgICAgIGlmIChzY3JvbGxiYXJQYWRkaW5nLm9yaWdpbmFsUmlnaHQpIHtcbiAgICAgICAgICAgICAgYXBwZW5kVG9FbGVtZW50LmNzcyh7cGFkZGluZ1JpZ2h0OiBzY3JvbGxiYXJQYWRkaW5nLm9yaWdpbmFsUmlnaHQgKyAncHgnfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhcHBlbmRUb0VsZW1lbnQuY3NzKHtwYWRkaW5nUmlnaHQ6ICcnfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzY3JvbGxiYXJQYWRkaW5nID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdG9nZ2xlVG9wV2luZG93Q2xhc3ModHJ1ZSk7XG4gICAgICAgIH0sIG1vZGFsV2luZG93LmNsb3NlZERlZmVycmVkKTtcbiAgICAgICAgY2hlY2tSZW1vdmVCYWNrZHJvcCgpO1xuXG4gICAgICAgIC8vbW92ZSBmb2N1cyB0byBzcGVjaWZpZWQgZWxlbWVudCBpZiBhdmFpbGFibGUsIG9yIGVsc2UgdG8gYm9keVxuICAgICAgICBpZiAoZWxlbWVudFRvUmVjZWl2ZUZvY3VzICYmIGVsZW1lbnRUb1JlY2VpdmVGb2N1cy5mb2N1cykge1xuICAgICAgICAgIGVsZW1lbnRUb1JlY2VpdmVGb2N1cy5mb2N1cygpO1xuICAgICAgICB9IGVsc2UgaWYgKGFwcGVuZFRvRWxlbWVudC5mb2N1cykge1xuICAgICAgICAgIGFwcGVuZFRvRWxlbWVudC5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCBvciByZW1vdmUgXCJ3aW5kb3dUb3BDbGFzc1wiIGZyb20gdGhlIHRvcCB3aW5kb3cgaW4gdGhlIHN0YWNrXG4gICAgICBmdW5jdGlvbiB0b2dnbGVUb3BXaW5kb3dDbGFzcyh0b2dnbGVTd2l0Y2gpIHtcbiAgICAgICAgdmFyIG1vZGFsV2luZG93O1xuXG4gICAgICAgIGlmIChvcGVuZWRXaW5kb3dzLmxlbmd0aCgpID4gMCkge1xuICAgICAgICAgIG1vZGFsV2luZG93ID0gb3BlbmVkV2luZG93cy50b3AoKS52YWx1ZTtcbiAgICAgICAgICBtb2RhbFdpbmRvdy5tb2RhbERvbUVsLnRvZ2dsZUNsYXNzKG1vZGFsV2luZG93LndpbmRvd1RvcENsYXNzIHx8ICcnLCB0b2dnbGVTd2l0Y2gpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNoZWNrUmVtb3ZlQmFja2Ryb3AoKSB7XG4gICAgICAgIC8vcmVtb3ZlIGJhY2tkcm9wIGlmIG5vIGxvbmdlciBuZWVkZWRcbiAgICAgICAgaWYgKGJhY2tkcm9wRG9tRWwgJiYgYmFja2Ryb3BJbmRleCgpID09PSAtMSkge1xuICAgICAgICAgIHZhciBiYWNrZHJvcFNjb3BlUmVmID0gYmFja2Ryb3BTY29wZTtcbiAgICAgICAgICByZW1vdmVBZnRlckFuaW1hdGUoYmFja2Ryb3BEb21FbCwgYmFja2Ryb3BTY29wZSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBiYWNrZHJvcFNjb3BlUmVmID0gbnVsbDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBiYWNrZHJvcERvbUVsID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGJhY2tkcm9wU2NvcGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcmVtb3ZlQWZ0ZXJBbmltYXRlKGRvbUVsLCBzY29wZSwgZG9uZSwgY2xvc2VkRGVmZXJyZWQpIHtcbiAgICAgICAgdmFyIGFzeW5jRGVmZXJyZWQ7XG4gICAgICAgIHZhciBhc3luY1Byb21pc2UgPSBudWxsO1xuICAgICAgICB2YXIgc2V0SXNBc3luYyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICghYXN5bmNEZWZlcnJlZCkge1xuICAgICAgICAgICAgYXN5bmNEZWZlcnJlZCA9ICRxLmRlZmVyKCk7XG4gICAgICAgICAgICBhc3luY1Byb21pc2UgPSBhc3luY0RlZmVycmVkLnByb21pc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGFzeW5jRG9uZSgpIHtcbiAgICAgICAgICAgIGFzeW5jRGVmZXJyZWQucmVzb2x2ZSgpO1xuICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIHNjb3BlLiRicm9hZGNhc3QoJG1vZGFsU3RhY2suTk9XX0NMT1NJTkdfRVZFTlQsIHNldElzQXN5bmMpO1xuXG4gICAgICAgIC8vIE5vdGUgdGhhdCBpdCdzIGludGVudGlvbmFsIHRoYXQgYXN5bmNQcm9taXNlIG1pZ2h0IGJlIG51bGwuXG4gICAgICAgIC8vIFRoYXQncyB3aGVuIHNldElzQXN5bmMgaGFzIG5vdCBiZWVuIGNhbGxlZCBkdXJpbmcgdGhlXG4gICAgICAgIC8vIE5PV19DTE9TSU5HX0VWRU5UIGJyb2FkY2FzdC5cbiAgICAgICAgcmV0dXJuICRxLndoZW4oYXN5bmNQcm9taXNlKS50aGVuKGFmdGVyQW5pbWF0aW5nKTtcblxuICAgICAgICBmdW5jdGlvbiBhZnRlckFuaW1hdGluZygpIHtcbiAgICAgICAgICBpZiAoYWZ0ZXJBbmltYXRpbmcuZG9uZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhZnRlckFuaW1hdGluZy5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgICRhbmltYXRlLmxlYXZlKGRvbUVsKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkb21FbC5yZW1vdmUoKTtcbiAgICAgICAgICAgIGlmIChjbG9zZWREZWZlcnJlZCkge1xuICAgICAgICAgICAgICBjbG9zZWREZWZlcnJlZC5yZXNvbHZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBzY29wZS4kZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgICRkb2N1bWVudC5vbigna2V5ZG93bicsIGtleWRvd25MaXN0ZW5lcik7XG5cbiAgICAgICRyb290U2NvcGUuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAkZG9jdW1lbnQub2ZmKCdrZXlkb3duJywga2V5ZG93bkxpc3RlbmVyKTtcbiAgICAgIH0pO1xuXG4gICAgICBmdW5jdGlvbiBrZXlkb3duTGlzdGVuZXIoZXZ0KSB7XG4gICAgICAgIGlmIChldnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgICAgICByZXR1cm4gZXZ0O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1vZGFsID0gb3BlbmVkV2luZG93cy50b3AoKTtcbiAgICAgICAgaWYgKG1vZGFsKSB7XG4gICAgICAgICAgc3dpdGNoIChldnQud2hpY2gpIHtcbiAgICAgICAgICAgIGNhc2UgMjc6IHtcbiAgICAgICAgICAgICAgaWYgKG1vZGFsLnZhbHVlLmtleWJvYXJkKSB7XG4gICAgICAgICAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYXBwbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAkbW9kYWxTdGFjay5kaXNtaXNzKG1vZGFsLmtleSwgJ2VzY2FwZSBrZXkgcHJlc3MnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgOToge1xuICAgICAgICAgICAgICB2YXIgbGlzdCA9ICRtb2RhbFN0YWNrLmxvYWRGb2N1c0VsZW1lbnRMaXN0KG1vZGFsKTtcbiAgICAgICAgICAgICAgdmFyIGZvY3VzQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICBpZiAoZXZ0LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKCRtb2RhbFN0YWNrLmlzRm9jdXNJbkZpcnN0SXRlbShldnQsIGxpc3QpIHx8ICRtb2RhbFN0YWNrLmlzTW9kYWxGb2N1c2VkKGV2dCwgbW9kYWwpKSB7XG4gICAgICAgICAgICAgICAgICBmb2N1c0NoYW5nZWQgPSAkbW9kYWxTdGFjay5mb2N1c0xhc3RGb2N1c2FibGVFbGVtZW50KGxpc3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoJG1vZGFsU3RhY2suaXNGb2N1c0luTGFzdEl0ZW0oZXZ0LCBsaXN0KSkge1xuICAgICAgICAgICAgICAgICAgZm9jdXNDaGFuZ2VkID0gJG1vZGFsU3RhY2suZm9jdXNGaXJzdEZvY3VzYWJsZUVsZW1lbnQobGlzdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGZvY3VzQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAkbW9kYWxTdGFjay5vcGVuID0gZnVuY3Rpb24obW9kYWxJbnN0YW5jZSwgbW9kYWwpIHtcbiAgICAgICAgdmFyIG1vZGFsT3BlbmVyID0gJGRvY3VtZW50WzBdLmFjdGl2ZUVsZW1lbnQsXG4gICAgICAgICAgbW9kYWxCb2R5Q2xhc3MgPSBtb2RhbC5vcGVuZWRDbGFzcyB8fCBPUEVORURfTU9EQUxfQ0xBU1M7XG5cbiAgICAgICAgdG9nZ2xlVG9wV2luZG93Q2xhc3MoZmFsc2UpO1xuXG4gICAgICAgIC8vIFN0b3JlIHRoZSBjdXJyZW50IHRvcCBmaXJzdCwgdG8gZGV0ZXJtaW5lIHdoYXQgaW5kZXggd2Ugb3VnaHQgdG8gdXNlXG4gICAgICAgIC8vIGZvciB0aGUgY3VycmVudCB0b3AgbW9kYWxcbiAgICAgICAgcHJldmlvdXNUb3BPcGVuZWRNb2RhbCA9IG9wZW5lZFdpbmRvd3MudG9wKCk7XG5cbiAgICAgICAgb3BlbmVkV2luZG93cy5hZGQobW9kYWxJbnN0YW5jZSwge1xuICAgICAgICAgIGRlZmVycmVkOiBtb2RhbC5kZWZlcnJlZCxcbiAgICAgICAgICByZW5kZXJEZWZlcnJlZDogbW9kYWwucmVuZGVyRGVmZXJyZWQsXG4gICAgICAgICAgY2xvc2VkRGVmZXJyZWQ6IG1vZGFsLmNsb3NlZERlZmVycmVkLFxuICAgICAgICAgIG1vZGFsU2NvcGU6IG1vZGFsLnNjb3BlLFxuICAgICAgICAgIGJhY2tkcm9wOiBtb2RhbC5iYWNrZHJvcCxcbiAgICAgICAgICBrZXlib2FyZDogbW9kYWwua2V5Ym9hcmQsXG4gICAgICAgICAgb3BlbmVkQ2xhc3M6IG1vZGFsLm9wZW5lZENsYXNzLFxuICAgICAgICAgIHdpbmRvd1RvcENsYXNzOiBtb2RhbC53aW5kb3dUb3BDbGFzcyxcbiAgICAgICAgICBhbmltYXRpb246IG1vZGFsLmFuaW1hdGlvbixcbiAgICAgICAgICBhcHBlbmRUbzogbW9kYWwuYXBwZW5kVG9cbiAgICAgICAgfSk7XG5cbiAgICAgICAgb3BlbmVkQ2xhc3Nlcy5wdXQobW9kYWxCb2R5Q2xhc3MsIG1vZGFsSW5zdGFuY2UpO1xuXG4gICAgICAgIHZhciBhcHBlbmRUb0VsZW1lbnQgPSBtb2RhbC5hcHBlbmRUbyxcbiAgICAgICAgICAgIGN1cnJCYWNrZHJvcEluZGV4ID0gYmFja2Ryb3BJbmRleCgpO1xuXG4gICAgICAgIGlmIChjdXJyQmFja2Ryb3BJbmRleCA+PSAwICYmICFiYWNrZHJvcERvbUVsKSB7XG4gICAgICAgICAgYmFja2Ryb3BTY29wZSA9ICRyb290U2NvcGUuJG5ldyh0cnVlKTtcbiAgICAgICAgICBiYWNrZHJvcFNjb3BlLm1vZGFsT3B0aW9ucyA9IG1vZGFsO1xuICAgICAgICAgIGJhY2tkcm9wU2NvcGUuaW5kZXggPSBjdXJyQmFja2Ryb3BJbmRleDtcbiAgICAgICAgICBiYWNrZHJvcERvbUVsID0gYW5ndWxhci5lbGVtZW50KCc8ZGl2IHVpYi1tb2RhbC1iYWNrZHJvcD1cIm1vZGFsLWJhY2tkcm9wXCI+PC9kaXY+Jyk7XG4gICAgICAgICAgYmFja2Ryb3BEb21FbC5hdHRyKHtcbiAgICAgICAgICAgICdjbGFzcyc6ICdtb2RhbC1iYWNrZHJvcCcsXG4gICAgICAgICAgICAnbmctc3R5bGUnOiAne1xcJ3otaW5kZXhcXCc6IDEwNDAgKyAoaW5kZXggJiYgMSB8fCAwKSArIGluZGV4KjEwfScsXG4gICAgICAgICAgICAndWliLW1vZGFsLWFuaW1hdGlvbi1jbGFzcyc6ICdmYWRlJyxcbiAgICAgICAgICAgICdtb2RhbC1pbi1jbGFzcyc6ICdpbidcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAobW9kYWwuYmFja2Ryb3BDbGFzcykge1xuICAgICAgICAgICAgYmFja2Ryb3BEb21FbC5hZGRDbGFzcyhtb2RhbC5iYWNrZHJvcENsYXNzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobW9kYWwuYW5pbWF0aW9uKSB7XG4gICAgICAgICAgICBiYWNrZHJvcERvbUVsLmF0dHIoJ21vZGFsLWFuaW1hdGlvbicsICd0cnVlJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgICRjb21waWxlKGJhY2tkcm9wRG9tRWwpKGJhY2tkcm9wU2NvcGUpO1xuICAgICAgICAgICRhbmltYXRlLmVudGVyKGJhY2tkcm9wRG9tRWwsIGFwcGVuZFRvRWxlbWVudCk7XG4gICAgICAgICAgaWYgKCR1aWJQb3NpdGlvbi5pc1Njcm9sbGFibGUoYXBwZW5kVG9FbGVtZW50KSkge1xuICAgICAgICAgICAgc2Nyb2xsYmFyUGFkZGluZyA9ICR1aWJQb3NpdGlvbi5zY3JvbGxiYXJQYWRkaW5nKGFwcGVuZFRvRWxlbWVudCk7XG4gICAgICAgICAgICBpZiAoc2Nyb2xsYmFyUGFkZGluZy5oZWlnaHRPdmVyZmxvdyAmJiBzY3JvbGxiYXJQYWRkaW5nLnNjcm9sbGJhcldpZHRoKSB7XG4gICAgICAgICAgICAgIGFwcGVuZFRvRWxlbWVudC5jc3Moe3BhZGRpbmdSaWdodDogc2Nyb2xsYmFyUGFkZGluZy5yaWdodCArICdweCd9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29udGVudDtcbiAgICAgICAgaWYgKG1vZGFsLmNvbXBvbmVudCkge1xuICAgICAgICAgIGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHNuYWtlX2Nhc2UobW9kYWwuY29tcG9uZW50Lm5hbWUpKTtcbiAgICAgICAgICBjb250ZW50ID0gYW5ndWxhci5lbGVtZW50KGNvbnRlbnQpO1xuICAgICAgICAgIGNvbnRlbnQuYXR0cih7XG4gICAgICAgICAgICByZXNvbHZlOiAnJHJlc29sdmUnLFxuICAgICAgICAgICAgJ21vZGFsLWluc3RhbmNlJzogJyR1aWJNb2RhbEluc3RhbmNlJyxcbiAgICAgICAgICAgIGNsb3NlOiAnJGNsb3NlKCR2YWx1ZSknLFxuICAgICAgICAgICAgZGlzbWlzczogJyRkaXNtaXNzKCR2YWx1ZSknXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udGVudCA9IG1vZGFsLmNvbnRlbnQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZXQgdGhlIHRvcCBtb2RhbCBpbmRleCBiYXNlZCBvbiB0aGUgaW5kZXggb2YgdGhlIHByZXZpb3VzIHRvcCBtb2RhbFxuICAgICAgICB0b3BNb2RhbEluZGV4ID0gcHJldmlvdXNUb3BPcGVuZWRNb2RhbCA/IHBhcnNlSW50KHByZXZpb3VzVG9wT3BlbmVkTW9kYWwudmFsdWUubW9kYWxEb21FbC5hdHRyKCdpbmRleCcpLCAxMCkgKyAxIDogMDtcbiAgICAgICAgdmFyIGFuZ3VsYXJEb21FbCA9IGFuZ3VsYXIuZWxlbWVudCgnPGRpdiB1aWItbW9kYWwtd2luZG93PVwibW9kYWwtd2luZG93XCI+PC9kaXY+Jyk7XG4gICAgICAgIGFuZ3VsYXJEb21FbC5hdHRyKHtcbiAgICAgICAgICAnY2xhc3MnOiAnbW9kYWwnLFxuICAgICAgICAgICd0ZW1wbGF0ZS11cmwnOiBtb2RhbC53aW5kb3dUZW1wbGF0ZVVybCxcbiAgICAgICAgICAnd2luZG93LXRvcC1jbGFzcyc6IG1vZGFsLndpbmRvd1RvcENsYXNzLFxuICAgICAgICAgICdyb2xlJzogJ2RpYWxvZycsXG4gICAgICAgICAgJ2FyaWEtbGFiZWxsZWRieSc6IG1vZGFsLmFyaWFMYWJlbGxlZEJ5LFxuICAgICAgICAgICdhcmlhLWRlc2NyaWJlZGJ5JzogbW9kYWwuYXJpYURlc2NyaWJlZEJ5LFxuICAgICAgICAgICdzaXplJzogbW9kYWwuc2l6ZSxcbiAgICAgICAgICAnaW5kZXgnOiB0b3BNb2RhbEluZGV4LFxuICAgICAgICAgICdhbmltYXRlJzogJ2FuaW1hdGUnLFxuICAgICAgICAgICduZy1zdHlsZSc6ICd7XFwnei1pbmRleFxcJzogMTA1MCArICQkdG9wTW9kYWxJbmRleCoxMCwgZGlzcGxheTogXFwnYmxvY2tcXCd9JyxcbiAgICAgICAgICAndGFiaW5kZXgnOiAtMSxcbiAgICAgICAgICAndWliLW1vZGFsLWFuaW1hdGlvbi1jbGFzcyc6ICdmYWRlJyxcbiAgICAgICAgICAnbW9kYWwtaW4tY2xhc3MnOiAnaW4nXG4gICAgICAgIH0pLmFwcGVuZChjb250ZW50KTtcbiAgICAgICAgaWYgKG1vZGFsLndpbmRvd0NsYXNzKSB7XG4gICAgICAgICAgYW5ndWxhckRvbUVsLmFkZENsYXNzKG1vZGFsLndpbmRvd0NsYXNzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtb2RhbC5hbmltYXRpb24pIHtcbiAgICAgICAgICBhbmd1bGFyRG9tRWwuYXR0cignbW9kYWwtYW5pbWF0aW9uJywgJ3RydWUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFwcGVuZFRvRWxlbWVudC5hZGRDbGFzcyhtb2RhbEJvZHlDbGFzcyk7XG4gICAgICAgIGlmIChtb2RhbC5zY29wZSkge1xuICAgICAgICAgIC8vIHdlIG5lZWQgdG8gZXhwbGljaXRseSBhZGQgdGhlIG1vZGFsIGluZGV4IHRvIHRoZSBtb2RhbCBzY29wZVxuICAgICAgICAgIC8vIGJlY2F1c2UgaXQgaXMgbmVlZGVkIGJ5IG5nU3R5bGUgdG8gY29tcHV0ZSB0aGUgekluZGV4IHByb3BlcnR5LlxuICAgICAgICAgIG1vZGFsLnNjb3BlLiQkdG9wTW9kYWxJbmRleCA9IHRvcE1vZGFsSW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgJGFuaW1hdGUuZW50ZXIoJGNvbXBpbGUoYW5ndWxhckRvbUVsKShtb2RhbC5zY29wZSksIGFwcGVuZFRvRWxlbWVudCk7XG5cbiAgICAgICAgb3BlbmVkV2luZG93cy50b3AoKS52YWx1ZS5tb2RhbERvbUVsID0gYW5ndWxhckRvbUVsO1xuICAgICAgICBvcGVuZWRXaW5kb3dzLnRvcCgpLnZhbHVlLm1vZGFsT3BlbmVyID0gbW9kYWxPcGVuZXI7XG5cbiAgICAgICAgYXBwbHlBcmlhSGlkZGVuKGFuZ3VsYXJEb21FbCk7XG5cbiAgICAgICAgZnVuY3Rpb24gYXBwbHlBcmlhSGlkZGVuKGVsKSB7XG4gICAgICAgICAgaWYgKCFlbCB8fCBlbFswXS50YWdOYW1lID09PSAnQk9EWScpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBnZXRTaWJsaW5ncyhlbCkuZm9yRWFjaChmdW5jdGlvbihzaWJsaW5nKSB7XG4gICAgICAgICAgICB2YXIgZWxlbUlzQWxyZWFkeUhpZGRlbiA9IHNpYmxpbmcuZ2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicpID09PSAndHJ1ZScsXG4gICAgICAgICAgICAgIGFyaWFIaWRkZW5Db3VudCA9IHBhcnNlSW50KHNpYmxpbmcuZ2V0QXR0cmlidXRlKEFSSUFfSElEREVOX0FUVFJJQlVURV9OQU1FKSwgMTApO1xuXG4gICAgICAgICAgICBpZiAoIWFyaWFIaWRkZW5Db3VudCkge1xuICAgICAgICAgICAgICBhcmlhSGlkZGVuQ291bnQgPSBlbGVtSXNBbHJlYWR5SGlkZGVuID8gMSA6IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNpYmxpbmcuc2V0QXR0cmlidXRlKEFSSUFfSElEREVOX0FUVFJJQlVURV9OQU1FLCBhcmlhSGlkZGVuQ291bnQgKyAxKTtcbiAgICAgICAgICAgIHNpYmxpbmcuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICByZXR1cm4gYXBwbHlBcmlhSGlkZGVuKGVsLnBhcmVudCgpKTtcblxuICAgICAgICAgIGZ1bmN0aW9uIGdldFNpYmxpbmdzKGVsKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBlbC5wYXJlbnQoKSA/IGVsLnBhcmVudCgpLmNoaWxkcmVuKCkgOiBbXTtcblxuICAgICAgICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5maWx0ZXIuY2FsbChjaGlsZHJlbiwgZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkICE9PSBlbFswXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZnVuY3Rpb24gYnJvYWRjYXN0Q2xvc2luZyhtb2RhbFdpbmRvdywgcmVzdWx0T3JSZWFzb24sIGNsb3NpbmcpIHtcbiAgICAgICAgcmV0dXJuICFtb2RhbFdpbmRvdy52YWx1ZS5tb2RhbFNjb3BlLiRicm9hZGNhc3QoJ21vZGFsLmNsb3NpbmcnLCByZXN1bHRPclJlYXNvbiwgY2xvc2luZykuZGVmYXVsdFByZXZlbnRlZDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdW5oaWRlQmFja2dyb3VuZEVsZW1lbnRzKCkge1xuICAgICAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKFxuICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1snICsgQVJJQV9ISURERU5fQVRUUklCVVRFX05BTUUgKyAnXScpLFxuICAgICAgICAgIGZ1bmN0aW9uKGhpZGRlbkVsKSB7XG4gICAgICAgICAgICB2YXIgYXJpYUhpZGRlbkNvdW50ID0gcGFyc2VJbnQoaGlkZGVuRWwuZ2V0QXR0cmlidXRlKEFSSUFfSElEREVOX0FUVFJJQlVURV9OQU1FKSwgMTApLFxuICAgICAgICAgICAgICBuZXdIaWRkZW5Db3VudCA9IGFyaWFIaWRkZW5Db3VudCAtIDE7XG4gICAgICAgICAgICBoaWRkZW5FbC5zZXRBdHRyaWJ1dGUoQVJJQV9ISURERU5fQVRUUklCVVRFX05BTUUsIG5ld0hpZGRlbkNvdW50KTtcblxuICAgICAgICAgICAgaWYgKCFuZXdIaWRkZW5Db3VudCkge1xuICAgICAgICAgICAgICBoaWRkZW5FbC5yZW1vdmVBdHRyaWJ1dGUoQVJJQV9ISURERU5fQVRUUklCVVRFX05BTUUpO1xuICAgICAgICAgICAgICBoaWRkZW5FbC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICAkbW9kYWxTdGFjay5jbG9zZSA9IGZ1bmN0aW9uKG1vZGFsSW5zdGFuY2UsIHJlc3VsdCkge1xuICAgICAgICB2YXIgbW9kYWxXaW5kb3cgPSBvcGVuZWRXaW5kb3dzLmdldChtb2RhbEluc3RhbmNlKTtcbiAgICAgICAgdW5oaWRlQmFja2dyb3VuZEVsZW1lbnRzKCk7XG4gICAgICAgIGlmIChtb2RhbFdpbmRvdyAmJiBicm9hZGNhc3RDbG9zaW5nKG1vZGFsV2luZG93LCByZXN1bHQsIHRydWUpKSB7XG4gICAgICAgICAgbW9kYWxXaW5kb3cudmFsdWUubW9kYWxTY29wZS4kJHVpYkRlc3RydWN0aW9uU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgICAgICBtb2RhbFdpbmRvdy52YWx1ZS5kZWZlcnJlZC5yZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgcmVtb3ZlTW9kYWxXaW5kb3cobW9kYWxJbnN0YW5jZSwgbW9kYWxXaW5kb3cudmFsdWUubW9kYWxPcGVuZXIpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICFtb2RhbFdpbmRvdztcbiAgICAgIH07XG5cbiAgICAgICRtb2RhbFN0YWNrLmRpc21pc3MgPSBmdW5jdGlvbihtb2RhbEluc3RhbmNlLCByZWFzb24pIHtcbiAgICAgICAgdmFyIG1vZGFsV2luZG93ID0gb3BlbmVkV2luZG93cy5nZXQobW9kYWxJbnN0YW5jZSk7XG4gICAgICAgIHVuaGlkZUJhY2tncm91bmRFbGVtZW50cygpO1xuICAgICAgICBpZiAobW9kYWxXaW5kb3cgJiYgYnJvYWRjYXN0Q2xvc2luZyhtb2RhbFdpbmRvdywgcmVhc29uLCBmYWxzZSkpIHtcbiAgICAgICAgICBtb2RhbFdpbmRvdy52YWx1ZS5tb2RhbFNjb3BlLiQkdWliRGVzdHJ1Y3Rpb25TY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgICAgIG1vZGFsV2luZG93LnZhbHVlLmRlZmVycmVkLnJlamVjdChyZWFzb24pO1xuICAgICAgICAgIHJlbW92ZU1vZGFsV2luZG93KG1vZGFsSW5zdGFuY2UsIG1vZGFsV2luZG93LnZhbHVlLm1vZGFsT3BlbmVyKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIW1vZGFsV2luZG93O1xuICAgICAgfTtcblxuICAgICAgJG1vZGFsU3RhY2suZGlzbWlzc0FsbCA9IGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgICB2YXIgdG9wTW9kYWwgPSB0aGlzLmdldFRvcCgpO1xuICAgICAgICB3aGlsZSAodG9wTW9kYWwgJiYgdGhpcy5kaXNtaXNzKHRvcE1vZGFsLmtleSwgcmVhc29uKSkge1xuICAgICAgICAgIHRvcE1vZGFsID0gdGhpcy5nZXRUb3AoKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgJG1vZGFsU3RhY2suZ2V0VG9wID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBvcGVuZWRXaW5kb3dzLnRvcCgpO1xuICAgICAgfTtcblxuICAgICAgJG1vZGFsU3RhY2subW9kYWxSZW5kZXJlZCA9IGZ1bmN0aW9uKG1vZGFsSW5zdGFuY2UpIHtcbiAgICAgICAgdmFyIG1vZGFsV2luZG93ID0gb3BlbmVkV2luZG93cy5nZXQobW9kYWxJbnN0YW5jZSk7XG4gICAgICAgIGlmIChtb2RhbFdpbmRvdykge1xuICAgICAgICAgIG1vZGFsV2luZG93LnZhbHVlLnJlbmRlckRlZmVycmVkLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgJG1vZGFsU3RhY2suZm9jdXNGaXJzdEZvY3VzYWJsZUVsZW1lbnQgPSBmdW5jdGlvbihsaXN0KSB7XG4gICAgICAgIGlmIChsaXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBsaXN0WzBdLmZvY3VzKCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcblxuICAgICAgJG1vZGFsU3RhY2suZm9jdXNMYXN0Rm9jdXNhYmxlRWxlbWVudCA9IGZ1bmN0aW9uKGxpc3QpIHtcbiAgICAgICAgaWYgKGxpc3QubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGxpc3RbbGlzdC5sZW5ndGggLSAxXS5mb2N1cygpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG5cbiAgICAgICRtb2RhbFN0YWNrLmlzTW9kYWxGb2N1c2VkID0gZnVuY3Rpb24oZXZ0LCBtb2RhbFdpbmRvdykge1xuICAgICAgICBpZiAoZXZ0ICYmIG1vZGFsV2luZG93KSB7XG4gICAgICAgICAgdmFyIG1vZGFsRG9tRWwgPSBtb2RhbFdpbmRvdy52YWx1ZS5tb2RhbERvbUVsO1xuICAgICAgICAgIGlmIChtb2RhbERvbUVsICYmIG1vZGFsRG9tRWwubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gKGV2dC50YXJnZXQgfHwgZXZ0LnNyY0VsZW1lbnQpID09PSBtb2RhbERvbUVsWzBdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuXG4gICAgICAkbW9kYWxTdGFjay5pc0ZvY3VzSW5GaXJzdEl0ZW0gPSBmdW5jdGlvbihldnQsIGxpc3QpIHtcbiAgICAgICAgaWYgKGxpc3QubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHJldHVybiAoZXZ0LnRhcmdldCB8fCBldnQuc3JjRWxlbWVudCkgPT09IGxpc3RbMF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcblxuICAgICAgJG1vZGFsU3RhY2suaXNGb2N1c0luTGFzdEl0ZW0gPSBmdW5jdGlvbihldnQsIGxpc3QpIHtcbiAgICAgICAgaWYgKGxpc3QubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHJldHVybiAoZXZ0LnRhcmdldCB8fCBldnQuc3JjRWxlbWVudCkgPT09IGxpc3RbbGlzdC5sZW5ndGggLSAxXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuXG4gICAgICAkbW9kYWxTdGFjay5sb2FkRm9jdXNFbGVtZW50TGlzdCA9IGZ1bmN0aW9uKG1vZGFsV2luZG93KSB7XG4gICAgICAgIGlmIChtb2RhbFdpbmRvdykge1xuICAgICAgICAgIHZhciBtb2RhbERvbUUxID0gbW9kYWxXaW5kb3cudmFsdWUubW9kYWxEb21FbDtcbiAgICAgICAgICBpZiAobW9kYWxEb21FMSAmJiBtb2RhbERvbUUxLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGVsZW1lbnRzID0gbW9kYWxEb21FMVswXS5xdWVyeVNlbGVjdG9yQWxsKHRhYmJhYmxlU2VsZWN0b3IpO1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRzID9cbiAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLmZpbHRlci5jYWxsKGVsZW1lbnRzLCBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzVmlzaWJsZShlbGVtZW50KTtcbiAgICAgICAgICAgICAgfSkgOiBlbGVtZW50cztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHJldHVybiAkbW9kYWxTdGFjaztcbiAgICB9XSlcblxuICAucHJvdmlkZXIoJyR1aWJNb2RhbCcsIGZ1bmN0aW9uKCkge1xuICAgIHZhciAkbW9kYWxQcm92aWRlciA9IHtcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgYW5pbWF0aW9uOiB0cnVlLFxuICAgICAgICBiYWNrZHJvcDogdHJ1ZSwgLy9jYW4gYWxzbyBiZSBmYWxzZSBvciAnc3RhdGljJ1xuICAgICAgICBrZXlib2FyZDogdHJ1ZVxuICAgICAgfSxcbiAgICAgICRnZXQ6IFsnJHJvb3RTY29wZScsICckcScsICckZG9jdW1lbnQnLCAnJHRlbXBsYXRlUmVxdWVzdCcsICckY29udHJvbGxlcicsICckdWliUmVzb2x2ZScsICckdWliTW9kYWxTdGFjaycsXG4gICAgICAgIGZ1bmN0aW9uICgkcm9vdFNjb3BlLCAkcSwgJGRvY3VtZW50LCAkdGVtcGxhdGVSZXF1ZXN0LCAkY29udHJvbGxlciwgJHVpYlJlc29sdmUsICRtb2RhbFN0YWNrKSB7XG4gICAgICAgICAgdmFyICRtb2RhbCA9IHt9O1xuXG4gICAgICAgICAgZnVuY3Rpb24gZ2V0VGVtcGxhdGVQcm9taXNlKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zLnRlbXBsYXRlID8gJHEud2hlbihvcHRpb25zLnRlbXBsYXRlKSA6XG4gICAgICAgICAgICAgICR0ZW1wbGF0ZVJlcXVlc3QoYW5ndWxhci5pc0Z1bmN0aW9uKG9wdGlvbnMudGVtcGxhdGVVcmwpID9cbiAgICAgICAgICAgICAgICBvcHRpb25zLnRlbXBsYXRlVXJsKCkgOiBvcHRpb25zLnRlbXBsYXRlVXJsKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcHJvbWlzZUNoYWluID0gbnVsbDtcbiAgICAgICAgICAkbW9kYWwuZ2V0UHJvbWlzZUNoYWluID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZUNoYWluO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICAkbW9kYWwub3BlbiA9IGZ1bmN0aW9uKG1vZGFsT3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIG1vZGFsUmVzdWx0RGVmZXJyZWQgPSAkcS5kZWZlcigpO1xuICAgICAgICAgICAgdmFyIG1vZGFsT3BlbmVkRGVmZXJyZWQgPSAkcS5kZWZlcigpO1xuICAgICAgICAgICAgdmFyIG1vZGFsQ2xvc2VkRGVmZXJyZWQgPSAkcS5kZWZlcigpO1xuICAgICAgICAgICAgdmFyIG1vZGFsUmVuZGVyRGVmZXJyZWQgPSAkcS5kZWZlcigpO1xuXG4gICAgICAgICAgICAvL3ByZXBhcmUgYW4gaW5zdGFuY2Ugb2YgYSBtb2RhbCB0byBiZSBpbmplY3RlZCBpbnRvIGNvbnRyb2xsZXJzIGFuZCByZXR1cm5lZCB0byBhIGNhbGxlclxuICAgICAgICAgICAgdmFyIG1vZGFsSW5zdGFuY2UgPSB7XG4gICAgICAgICAgICAgIHJlc3VsdDogbW9kYWxSZXN1bHREZWZlcnJlZC5wcm9taXNlLFxuICAgICAgICAgICAgICBvcGVuZWQ6IG1vZGFsT3BlbmVkRGVmZXJyZWQucHJvbWlzZSxcbiAgICAgICAgICAgICAgY2xvc2VkOiBtb2RhbENsb3NlZERlZmVycmVkLnByb21pc2UsXG4gICAgICAgICAgICAgIHJlbmRlcmVkOiBtb2RhbFJlbmRlckRlZmVycmVkLnByb21pc2UsXG4gICAgICAgICAgICAgIGNsb3NlOiBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICRtb2RhbFN0YWNrLmNsb3NlKG1vZGFsSW5zdGFuY2UsIHJlc3VsdCk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGRpc21pc3M6IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJG1vZGFsU3RhY2suZGlzbWlzcyhtb2RhbEluc3RhbmNlLCByZWFzb24pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvL21lcmdlIGFuZCBjbGVhbiB1cCBvcHRpb25zXG4gICAgICAgICAgICBtb2RhbE9wdGlvbnMgPSBhbmd1bGFyLmV4dGVuZCh7fSwgJG1vZGFsUHJvdmlkZXIub3B0aW9ucywgbW9kYWxPcHRpb25zKTtcbiAgICAgICAgICAgIG1vZGFsT3B0aW9ucy5yZXNvbHZlID0gbW9kYWxPcHRpb25zLnJlc29sdmUgfHwge307XG4gICAgICAgICAgICBtb2RhbE9wdGlvbnMuYXBwZW5kVG8gPSBtb2RhbE9wdGlvbnMuYXBwZW5kVG8gfHwgJGRvY3VtZW50LmZpbmQoJ2JvZHknKS5lcSgwKTtcblxuICAgICAgICAgICAgaWYgKCFtb2RhbE9wdGlvbnMuYXBwZW5kVG8ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXBwZW5kVG8gZWxlbWVudCBub3QgZm91bmQuIE1ha2Ugc3VyZSB0aGF0IHRoZSBlbGVtZW50IHBhc3NlZCBpcyBpbiBET00uJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vdmVyaWZ5IG9wdGlvbnNcbiAgICAgICAgICAgIGlmICghbW9kYWxPcHRpb25zLmNvbXBvbmVudCAmJiAhbW9kYWxPcHRpb25zLnRlbXBsYXRlICYmICFtb2RhbE9wdGlvbnMudGVtcGxhdGVVcmwpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPbmUgb2YgY29tcG9uZW50IG9yIHRlbXBsYXRlIG9yIHRlbXBsYXRlVXJsIG9wdGlvbnMgaXMgcmVxdWlyZWQuJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0ZW1wbGF0ZUFuZFJlc29sdmVQcm9taXNlO1xuICAgICAgICAgICAgaWYgKG1vZGFsT3B0aW9ucy5jb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgdGVtcGxhdGVBbmRSZXNvbHZlUHJvbWlzZSA9ICRxLndoZW4oJHVpYlJlc29sdmUucmVzb2x2ZShtb2RhbE9wdGlvbnMucmVzb2x2ZSwge30sIG51bGwsIG51bGwpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRlbXBsYXRlQW5kUmVzb2x2ZVByb21pc2UgPVxuICAgICAgICAgICAgICAgICRxLmFsbChbZ2V0VGVtcGxhdGVQcm9taXNlKG1vZGFsT3B0aW9ucyksICR1aWJSZXNvbHZlLnJlc29sdmUobW9kYWxPcHRpb25zLnJlc29sdmUsIHt9LCBudWxsLCBudWxsKV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiByZXNvbHZlV2l0aFRlbXBsYXRlKCkge1xuICAgICAgICAgICAgICByZXR1cm4gdGVtcGxhdGVBbmRSZXNvbHZlUHJvbWlzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gV2FpdCBmb3IgdGhlIHJlc29sdXRpb24gb2YgdGhlIGV4aXN0aW5nIHByb21pc2UgY2hhaW4uXG4gICAgICAgICAgICAvLyBUaGVuIHN3aXRjaCB0byBvdXIgb3duIGNvbWJpbmVkIHByb21pc2UgZGVwZW5kZW5jeSAocmVnYXJkbGVzcyBvZiBob3cgdGhlIHByZXZpb3VzIG1vZGFsIGZhcmVkKS5cbiAgICAgICAgICAgIC8vIFRoZW4gYWRkIHRvICRtb2RhbFN0YWNrIGFuZCByZXNvbHZlIG9wZW5lZC5cbiAgICAgICAgICAgIC8vIEZpbmFsbHkgY2xlYW4gdXAgdGhlIGNoYWluIHZhcmlhYmxlIGlmIG5vIHN1YnNlcXVlbnQgbW9kYWwgaGFzIG92ZXJ3cml0dGVuIGl0LlxuICAgICAgICAgICAgdmFyIHNhbWVQcm9taXNlO1xuICAgICAgICAgICAgc2FtZVByb21pc2UgPSBwcm9taXNlQ2hhaW4gPSAkcS5hbGwoW3Byb21pc2VDaGFpbl0pXG4gICAgICAgICAgICAgIC50aGVuKHJlc29sdmVXaXRoVGVtcGxhdGUsIHJlc29sdmVXaXRoVGVtcGxhdGUpXG4gICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIHJlc29sdmVTdWNjZXNzKHRwbEFuZFZhcnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJvdmlkZWRTY29wZSA9IG1vZGFsT3B0aW9ucy5zY29wZSB8fCAkcm9vdFNjb3BlO1xuXG4gICAgICAgICAgICAgICAgdmFyIG1vZGFsU2NvcGUgPSBwcm92aWRlZFNjb3BlLiRuZXcoKTtcbiAgICAgICAgICAgICAgICBtb2RhbFNjb3BlLiRjbG9zZSA9IG1vZGFsSW5zdGFuY2UuY2xvc2U7XG4gICAgICAgICAgICAgICAgbW9kYWxTY29wZS4kZGlzbWlzcyA9IG1vZGFsSW5zdGFuY2UuZGlzbWlzcztcblxuICAgICAgICAgICAgICAgIG1vZGFsU2NvcGUuJG9uKCckZGVzdHJveScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgaWYgKCFtb2RhbFNjb3BlLiQkdWliRGVzdHJ1Y3Rpb25TY2hlZHVsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kYWxTY29wZS4kZGlzbWlzcygnJHVpYlVuc2NoZWR1bGVkRGVzdHJ1Y3Rpb24nKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHZhciBtb2RhbCA9IHtcbiAgICAgICAgICAgICAgICAgIHNjb3BlOiBtb2RhbFNjb3BlLFxuICAgICAgICAgICAgICAgICAgZGVmZXJyZWQ6IG1vZGFsUmVzdWx0RGVmZXJyZWQsXG4gICAgICAgICAgICAgICAgICByZW5kZXJEZWZlcnJlZDogbW9kYWxSZW5kZXJEZWZlcnJlZCxcbiAgICAgICAgICAgICAgICAgIGNsb3NlZERlZmVycmVkOiBtb2RhbENsb3NlZERlZmVycmVkLFxuICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uOiBtb2RhbE9wdGlvbnMuYW5pbWF0aW9uLFxuICAgICAgICAgICAgICAgICAgYmFja2Ryb3A6IG1vZGFsT3B0aW9ucy5iYWNrZHJvcCxcbiAgICAgICAgICAgICAgICAgIGtleWJvYXJkOiBtb2RhbE9wdGlvbnMua2V5Ym9hcmQsXG4gICAgICAgICAgICAgICAgICBiYWNrZHJvcENsYXNzOiBtb2RhbE9wdGlvbnMuYmFja2Ryb3BDbGFzcyxcbiAgICAgICAgICAgICAgICAgIHdpbmRvd1RvcENsYXNzOiBtb2RhbE9wdGlvbnMud2luZG93VG9wQ2xhc3MsXG4gICAgICAgICAgICAgICAgICB3aW5kb3dDbGFzczogbW9kYWxPcHRpb25zLndpbmRvd0NsYXNzLFxuICAgICAgICAgICAgICAgICAgd2luZG93VGVtcGxhdGVVcmw6IG1vZGFsT3B0aW9ucy53aW5kb3dUZW1wbGF0ZVVybCxcbiAgICAgICAgICAgICAgICAgIGFyaWFMYWJlbGxlZEJ5OiBtb2RhbE9wdGlvbnMuYXJpYUxhYmVsbGVkQnksXG4gICAgICAgICAgICAgICAgICBhcmlhRGVzY3JpYmVkQnk6IG1vZGFsT3B0aW9ucy5hcmlhRGVzY3JpYmVkQnksXG4gICAgICAgICAgICAgICAgICBzaXplOiBtb2RhbE9wdGlvbnMuc2l6ZSxcbiAgICAgICAgICAgICAgICAgIG9wZW5lZENsYXNzOiBtb2RhbE9wdGlvbnMub3BlbmVkQ2xhc3MsXG4gICAgICAgICAgICAgICAgICBhcHBlbmRUbzogbW9kYWxPcHRpb25zLmFwcGVuZFRvXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHZhciBjb21wb25lbnQgPSB7fTtcbiAgICAgICAgICAgICAgICB2YXIgY3RybEluc3RhbmNlLCBjdHJsSW5zdGFudGlhdGUsIGN0cmxMb2NhbHMgPSB7fTtcblxuICAgICAgICAgICAgICAgIGlmIChtb2RhbE9wdGlvbnMuY29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgICBjb25zdHJ1Y3RMb2NhbHMoY29tcG9uZW50LCBmYWxzZSwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgY29tcG9uZW50Lm5hbWUgPSBtb2RhbE9wdGlvbnMuY29tcG9uZW50O1xuICAgICAgICAgICAgICAgICAgbW9kYWwuY29tcG9uZW50ID0gY29tcG9uZW50O1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobW9kYWxPcHRpb25zLmNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0cnVjdExvY2FscyhjdHJsTG9jYWxzLCB0cnVlLCBmYWxzZSwgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICAgIC8vIHRoZSB0aGlyZCBwYXJhbSB3aWxsIG1ha2UgdGhlIGNvbnRyb2xsZXIgaW5zdGFudGlhdGUgbGF0ZXIscHJpdmF0ZSBhcGlcbiAgICAgICAgICAgICAgICAgIC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci5qcy9ibG9iL21hc3Rlci9zcmMvbmcvY29udHJvbGxlci5qcyNMMTI2XG4gICAgICAgICAgICAgICAgICBjdHJsSW5zdGFudGlhdGUgPSAkY29udHJvbGxlcihtb2RhbE9wdGlvbnMuY29udHJvbGxlciwgY3RybExvY2FscywgdHJ1ZSwgbW9kYWxPcHRpb25zLmNvbnRyb2xsZXJBcyk7XG4gICAgICAgICAgICAgICAgICBpZiAobW9kYWxPcHRpb25zLmNvbnRyb2xsZXJBcyAmJiBtb2RhbE9wdGlvbnMuYmluZFRvQ29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgICAgICBjdHJsSW5zdGFuY2UgPSBjdHJsSW5zdGFudGlhdGUuaW5zdGFuY2U7XG4gICAgICAgICAgICAgICAgICAgIGN0cmxJbnN0YW5jZS4kY2xvc2UgPSBtb2RhbFNjb3BlLiRjbG9zZTtcbiAgICAgICAgICAgICAgICAgICAgY3RybEluc3RhbmNlLiRkaXNtaXNzID0gbW9kYWxTY29wZS4kZGlzbWlzcztcbiAgICAgICAgICAgICAgICAgICAgYW5ndWxhci5leHRlbmQoY3RybEluc3RhbmNlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgJHJlc29sdmU6IGN0cmxMb2NhbHMuJHNjb3BlLiRyZXNvbHZlXG4gICAgICAgICAgICAgICAgICAgIH0sIHByb3ZpZGVkU2NvcGUpO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBjdHJsSW5zdGFuY2UgPSBjdHJsSW5zdGFudGlhdGUoKTtcblxuICAgICAgICAgICAgICAgICAgaWYgKGFuZ3VsYXIuaXNGdW5jdGlvbihjdHJsSW5zdGFuY2UuJG9uSW5pdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3RybEluc3RhbmNlLiRvbkluaXQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIW1vZGFsT3B0aW9ucy5jb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgIG1vZGFsLmNvbnRlbnQgPSB0cGxBbmRWYXJzWzBdO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICRtb2RhbFN0YWNrLm9wZW4obW9kYWxJbnN0YW5jZSwgbW9kYWwpO1xuICAgICAgICAgICAgICAgIG1vZGFsT3BlbmVkRGVmZXJyZWQucmVzb2x2ZSh0cnVlKTtcblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGNvbnN0cnVjdExvY2FscyhvYmosIHRlbXBsYXRlLCBpbnN0YW5jZU9uU2NvcGUsIGluamVjdGFibGUpIHtcbiAgICAgICAgICAgICAgICAgIG9iai4kc2NvcGUgPSBtb2RhbFNjb3BlO1xuICAgICAgICAgICAgICAgICAgb2JqLiRzY29wZS4kcmVzb2x2ZSA9IHt9O1xuICAgICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlT25TY29wZSkge1xuICAgICAgICAgICAgICAgICAgICBvYmouJHNjb3BlLiR1aWJNb2RhbEluc3RhbmNlID0gbW9kYWxJbnN0YW5jZTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9iai4kdWliTW9kYWxJbnN0YW5jZSA9IG1vZGFsSW5zdGFuY2U7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHZhciByZXNvbHZlcyA9IHRlbXBsYXRlID8gdHBsQW5kVmFyc1sxXSA6IHRwbEFuZFZhcnM7XG4gICAgICAgICAgICAgICAgICBhbmd1bGFyLmZvckVhY2gocmVzb2x2ZXMsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluamVjdGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgb2JqLiRzY29wZS4kcmVzb2x2ZVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiByZXNvbHZlRXJyb3IocmVhc29uKSB7XG4gICAgICAgICAgICAgIG1vZGFsT3BlbmVkRGVmZXJyZWQucmVqZWN0KHJlYXNvbik7XG4gICAgICAgICAgICAgIG1vZGFsUmVzdWx0RGVmZXJyZWQucmVqZWN0KHJlYXNvbik7XG4gICAgICAgICAgICB9KVsnZmluYWxseSddKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBpZiAocHJvbWlzZUNoYWluID09PSBzYW1lUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHByb21pc2VDaGFpbiA9IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gbW9kYWxJbnN0YW5jZTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgcmV0dXJuICRtb2RhbDtcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH07XG5cbiAgICByZXR1cm4gJG1vZGFsUHJvdmlkZXI7XG4gIH0pO1xuXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLnBhZ2luZycsIFtdKVxuLyoqXG4gKiBIZWxwZXIgaW50ZXJuYWwgc2VydmljZSBmb3IgZ2VuZXJhdGluZyBjb21tb24gY29udHJvbGxlciBjb2RlIGJldHdlZW4gdGhlXG4gKiBwYWdlciBhbmQgcGFnaW5hdGlvbiBjb21wb25lbnRzXG4gKi9cbi5mYWN0b3J5KCd1aWJQYWdpbmcnLCBbJyRwYXJzZScsIGZ1bmN0aW9uKCRwYXJzZSkge1xuICByZXR1cm4ge1xuICAgIGNyZWF0ZTogZnVuY3Rpb24oY3RybCwgJHNjb3BlLCAkYXR0cnMpIHtcbiAgICAgIGN0cmwuc2V0TnVtUGFnZXMgPSAkYXR0cnMubnVtUGFnZXMgPyAkcGFyc2UoJGF0dHJzLm51bVBhZ2VzKS5hc3NpZ24gOiBhbmd1bGFyLm5vb3A7XG4gICAgICBjdHJsLm5nTW9kZWxDdHJsID0geyAkc2V0Vmlld1ZhbHVlOiBhbmd1bGFyLm5vb3AgfTsgLy8gbnVsbE1vZGVsQ3RybFxuICAgICAgY3RybC5fd2F0Y2hlcnMgPSBbXTtcblxuICAgICAgY3RybC5pbml0ID0gZnVuY3Rpb24obmdNb2RlbEN0cmwsIGNvbmZpZykge1xuICAgICAgICBjdHJsLm5nTW9kZWxDdHJsID0gbmdNb2RlbEN0cmw7XG4gICAgICAgIGN0cmwuY29uZmlnID0gY29uZmlnO1xuXG4gICAgICAgIG5nTW9kZWxDdHJsLiRyZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBjdHJsLnJlbmRlcigpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmICgkYXR0cnMuaXRlbXNQZXJQYWdlKSB7XG4gICAgICAgICAgY3RybC5fd2F0Y2hlcnMucHVzaCgkc2NvcGUuJHBhcmVudC4kd2F0Y2goJGF0dHJzLml0ZW1zUGVyUGFnZSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGN0cmwuaXRlbXNQZXJQYWdlID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgICAgICAgICAgICRzY29wZS50b3RhbFBhZ2VzID0gY3RybC5jYWxjdWxhdGVUb3RhbFBhZ2VzKCk7XG4gICAgICAgICAgICBjdHJsLnVwZGF0ZVBhZ2UoKTtcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3RybC5pdGVtc1BlclBhZ2UgPSBjb25maWcuaXRlbXNQZXJQYWdlO1xuICAgICAgICB9XG5cbiAgICAgICAgJHNjb3BlLiR3YXRjaCgndG90YWxJdGVtcycsIGZ1bmN0aW9uKG5ld1RvdGFsLCBvbGRUb3RhbCkge1xuICAgICAgICAgIGlmIChhbmd1bGFyLmlzRGVmaW5lZChuZXdUb3RhbCkgfHwgbmV3VG90YWwgIT09IG9sZFRvdGFsKSB7XG4gICAgICAgICAgICAkc2NvcGUudG90YWxQYWdlcyA9IGN0cmwuY2FsY3VsYXRlVG90YWxQYWdlcygpO1xuICAgICAgICAgICAgY3RybC51cGRhdGVQYWdlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGN0cmwuY2FsY3VsYXRlVG90YWxQYWdlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdG90YWxQYWdlcyA9IGN0cmwuaXRlbXNQZXJQYWdlIDwgMSA/IDEgOiBNYXRoLmNlaWwoJHNjb3BlLnRvdGFsSXRlbXMgLyBjdHJsLml0ZW1zUGVyUGFnZSk7XG4gICAgICAgIHJldHVybiBNYXRoLm1heCh0b3RhbFBhZ2VzIHx8IDAsIDEpO1xuICAgICAgfTtcblxuICAgICAgY3RybC5yZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgJHNjb3BlLnBhZ2UgPSBwYXJzZUludChjdHJsLm5nTW9kZWxDdHJsLiR2aWV3VmFsdWUsIDEwKSB8fCAxO1xuICAgICAgfTtcblxuICAgICAgJHNjb3BlLnNlbGVjdFBhZ2UgPSBmdW5jdGlvbihwYWdlLCBldnQpIHtcbiAgICAgICAgaWYgKGV2dCkge1xuICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNsaWNrQWxsb3dlZCA9ICEkc2NvcGUubmdEaXNhYmxlZCB8fCAhZXZ0O1xuICAgICAgICBpZiAoY2xpY2tBbGxvd2VkICYmICRzY29wZS5wYWdlICE9PSBwYWdlICYmIHBhZ2UgPiAwICYmIHBhZ2UgPD0gJHNjb3BlLnRvdGFsUGFnZXMpIHtcbiAgICAgICAgICBpZiAoZXZ0ICYmIGV2dC50YXJnZXQpIHtcbiAgICAgICAgICAgIGV2dC50YXJnZXQuYmx1cigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdHJsLm5nTW9kZWxDdHJsLiRzZXRWaWV3VmFsdWUocGFnZSk7XG4gICAgICAgICAgY3RybC5uZ01vZGVsQ3RybC4kcmVuZGVyKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgICRzY29wZS5nZXRUZXh0ID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiAkc2NvcGVba2V5ICsgJ1RleHQnXSB8fCBjdHJsLmNvbmZpZ1trZXkgKyAnVGV4dCddO1xuICAgICAgfTtcblxuICAgICAgJHNjb3BlLm5vUHJldmlvdXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICRzY29wZS5wYWdlID09PSAxO1xuICAgICAgfTtcblxuICAgICAgJHNjb3BlLm5vTmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gJHNjb3BlLnBhZ2UgPT09ICRzY29wZS50b3RhbFBhZ2VzO1xuICAgICAgfTtcblxuICAgICAgY3RybC51cGRhdGVQYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGN0cmwuc2V0TnVtUGFnZXMoJHNjb3BlLiRwYXJlbnQsICRzY29wZS50b3RhbFBhZ2VzKTsgLy8gUmVhZG9ubHkgdmFyaWFibGVcblxuICAgICAgICBpZiAoJHNjb3BlLnBhZ2UgPiAkc2NvcGUudG90YWxQYWdlcykge1xuICAgICAgICAgICRzY29wZS5zZWxlY3RQYWdlKCRzY29wZS50b3RhbFBhZ2VzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdHJsLm5nTW9kZWxDdHJsLiRyZW5kZXIoKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgJHNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICAgICAgd2hpbGUgKGN0cmwuX3dhdGNoZXJzLmxlbmd0aCkge1xuICAgICAgICAgIGN0cmwuX3dhdGNoZXJzLnNoaWZ0KCkoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9O1xufV0pO1xuXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLnBhZ2VyJywgWyd1aS5ib290c3RyYXAucGFnaW5nJywgJ3VpLmJvb3RzdHJhcC50YWJpbmRleCddKVxuXG4uY29udHJvbGxlcignVWliUGFnZXJDb250cm9sbGVyJywgWyckc2NvcGUnLCAnJGF0dHJzJywgJ3VpYlBhZ2luZycsICd1aWJQYWdlckNvbmZpZycsIGZ1bmN0aW9uKCRzY29wZSwgJGF0dHJzLCB1aWJQYWdpbmcsIHVpYlBhZ2VyQ29uZmlnKSB7XG4gICRzY29wZS5hbGlnbiA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRhdHRycy5hbGlnbikgPyAkc2NvcGUuJHBhcmVudC4kZXZhbCgkYXR0cnMuYWxpZ24pIDogdWliUGFnZXJDb25maWcuYWxpZ247XG5cbiAgdWliUGFnaW5nLmNyZWF0ZSh0aGlzLCAkc2NvcGUsICRhdHRycyk7XG59XSlcblxuLmNvbnN0YW50KCd1aWJQYWdlckNvbmZpZycsIHtcbiAgaXRlbXNQZXJQYWdlOiAxMCxcbiAgcHJldmlvdXNUZXh0OiAnwqsgUHJldmlvdXMnLFxuICBuZXh0VGV4dDogJ05leHQgwrsnLFxuICBhbGlnbjogdHJ1ZVxufSlcblxuLmRpcmVjdGl2ZSgndWliUGFnZXInLCBbJ3VpYlBhZ2VyQ29uZmlnJywgZnVuY3Rpb24odWliUGFnZXJDb25maWcpIHtcbiAgcmV0dXJuIHtcbiAgICBzY29wZToge1xuICAgICAgdG90YWxJdGVtczogJz0nLFxuICAgICAgcHJldmlvdXNUZXh0OiAnQCcsXG4gICAgICBuZXh0VGV4dDogJ0AnLFxuICAgICAgbmdEaXNhYmxlZDogJz0nXG4gICAgfSxcbiAgICByZXF1aXJlOiBbJ3VpYlBhZ2VyJywgJz9uZ01vZGVsJ10sXG4gICAgcmVzdHJpY3Q6ICdBJyxcbiAgICBjb250cm9sbGVyOiAnVWliUGFnZXJDb250cm9sbGVyJyxcbiAgICBjb250cm9sbGVyQXM6ICdwYWdlcicsXG4gICAgdGVtcGxhdGVVcmw6IGZ1bmN0aW9uKGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgICByZXR1cm4gYXR0cnMudGVtcGxhdGVVcmwgfHwgJ3VpYi90ZW1wbGF0ZS9wYWdlci9wYWdlci5odG1sJztcbiAgICB9LFxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgY3RybHMpIHtcbiAgICAgIGVsZW1lbnQuYWRkQ2xhc3MoJ3BhZ2VyJyk7XG4gICAgICB2YXIgcGFnaW5hdGlvbkN0cmwgPSBjdHJsc1swXSwgbmdNb2RlbEN0cmwgPSBjdHJsc1sxXTtcblxuICAgICAgaWYgKCFuZ01vZGVsQ3RybCkge1xuICAgICAgICByZXR1cm47IC8vIGRvIG5vdGhpbmcgaWYgbm8gbmctbW9kZWxcbiAgICAgIH1cblxuICAgICAgcGFnaW5hdGlvbkN0cmwuaW5pdChuZ01vZGVsQ3RybCwgdWliUGFnZXJDb25maWcpO1xuICAgIH1cbiAgfTtcbn1dKTtcblxuYW5ndWxhci5tb2R1bGUoJ3VpLmJvb3RzdHJhcC5wYWdpbmF0aW9uJywgWyd1aS5ib290c3RyYXAucGFnaW5nJywgJ3VpLmJvb3RzdHJhcC50YWJpbmRleCddKVxuLmNvbnRyb2xsZXIoJ1VpYlBhZ2luYXRpb25Db250cm9sbGVyJywgWyckc2NvcGUnLCAnJGF0dHJzJywgJyRwYXJzZScsICd1aWJQYWdpbmcnLCAndWliUGFnaW5hdGlvbkNvbmZpZycsIGZ1bmN0aW9uKCRzY29wZSwgJGF0dHJzLCAkcGFyc2UsIHVpYlBhZ2luZywgdWliUGFnaW5hdGlvbkNvbmZpZykge1xuICB2YXIgY3RybCA9IHRoaXM7XG4gIC8vIFNldHVwIGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVyc1xuICB2YXIgbWF4U2l6ZSA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRhdHRycy5tYXhTaXplKSA/ICRzY29wZS4kcGFyZW50LiRldmFsKCRhdHRycy5tYXhTaXplKSA6IHVpYlBhZ2luYXRpb25Db25maWcubWF4U2l6ZSxcbiAgICByb3RhdGUgPSBhbmd1bGFyLmlzRGVmaW5lZCgkYXR0cnMucm90YXRlKSA/ICRzY29wZS4kcGFyZW50LiRldmFsKCRhdHRycy5yb3RhdGUpIDogdWliUGFnaW5hdGlvbkNvbmZpZy5yb3RhdGUsXG4gICAgZm9yY2VFbGxpcHNlcyA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRhdHRycy5mb3JjZUVsbGlwc2VzKSA/ICRzY29wZS4kcGFyZW50LiRldmFsKCRhdHRycy5mb3JjZUVsbGlwc2VzKSA6IHVpYlBhZ2luYXRpb25Db25maWcuZm9yY2VFbGxpcHNlcyxcbiAgICBib3VuZGFyeUxpbmtOdW1iZXJzID0gYW5ndWxhci5pc0RlZmluZWQoJGF0dHJzLmJvdW5kYXJ5TGlua051bWJlcnMpID8gJHNjb3BlLiRwYXJlbnQuJGV2YWwoJGF0dHJzLmJvdW5kYXJ5TGlua051bWJlcnMpIDogdWliUGFnaW5hdGlvbkNvbmZpZy5ib3VuZGFyeUxpbmtOdW1iZXJzLFxuICAgIHBhZ2VMYWJlbCA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRhdHRycy5wYWdlTGFiZWwpID8gZnVuY3Rpb24oaWR4KSB7IHJldHVybiAkc2NvcGUuJHBhcmVudC4kZXZhbCgkYXR0cnMucGFnZUxhYmVsLCB7JHBhZ2U6IGlkeH0pOyB9IDogYW5ndWxhci5pZGVudGl0eTtcbiAgJHNjb3BlLmJvdW5kYXJ5TGlua3MgPSBhbmd1bGFyLmlzRGVmaW5lZCgkYXR0cnMuYm91bmRhcnlMaW5rcykgPyAkc2NvcGUuJHBhcmVudC4kZXZhbCgkYXR0cnMuYm91bmRhcnlMaW5rcykgOiB1aWJQYWdpbmF0aW9uQ29uZmlnLmJvdW5kYXJ5TGlua3M7XG4gICRzY29wZS5kaXJlY3Rpb25MaW5rcyA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRhdHRycy5kaXJlY3Rpb25MaW5rcykgPyAkc2NvcGUuJHBhcmVudC4kZXZhbCgkYXR0cnMuZGlyZWN0aW9uTGlua3MpIDogdWliUGFnaW5hdGlvbkNvbmZpZy5kaXJlY3Rpb25MaW5rcztcbiAgJGF0dHJzLiRzZXQoJ3JvbGUnLCAnbWVudScpO1xuXG4gIHVpYlBhZ2luZy5jcmVhdGUodGhpcywgJHNjb3BlLCAkYXR0cnMpO1xuXG4gIGlmICgkYXR0cnMubWF4U2l6ZSkge1xuICAgIGN0cmwuX3dhdGNoZXJzLnB1c2goJHNjb3BlLiRwYXJlbnQuJHdhdGNoKCRwYXJzZSgkYXR0cnMubWF4U2l6ZSksIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBtYXhTaXplID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgICAgIGN0cmwucmVuZGVyKCk7XG4gICAgfSkpO1xuICB9XG5cbiAgLy8gQ3JlYXRlIHBhZ2Ugb2JqZWN0IHVzZWQgaW4gdGVtcGxhdGVcbiAgZnVuY3Rpb24gbWFrZVBhZ2UobnVtYmVyLCB0ZXh0LCBpc0FjdGl2ZSkge1xuICAgIHJldHVybiB7XG4gICAgICBudW1iZXI6IG51bWJlcixcbiAgICAgIHRleHQ6IHRleHQsXG4gICAgICBhY3RpdmU6IGlzQWN0aXZlXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFBhZ2VzKGN1cnJlbnRQYWdlLCB0b3RhbFBhZ2VzKSB7XG4gICAgdmFyIHBhZ2VzID0gW107XG5cbiAgICAvLyBEZWZhdWx0IHBhZ2UgbGltaXRzXG4gICAgdmFyIHN0YXJ0UGFnZSA9IDEsIGVuZFBhZ2UgPSB0b3RhbFBhZ2VzO1xuICAgIHZhciBpc01heFNpemVkID0gYW5ndWxhci5pc0RlZmluZWQobWF4U2l6ZSkgJiYgbWF4U2l6ZSA8IHRvdGFsUGFnZXM7XG5cbiAgICAvLyByZWNvbXB1dGUgaWYgbWF4U2l6ZVxuICAgIGlmIChpc01heFNpemVkKSB7XG4gICAgICBpZiAocm90YXRlKSB7XG4gICAgICAgIC8vIEN1cnJlbnQgcGFnZSBpcyBkaXNwbGF5ZWQgaW4gdGhlIG1pZGRsZSBvZiB0aGUgdmlzaWJsZSBvbmVzXG4gICAgICAgIHN0YXJ0UGFnZSA9IE1hdGgubWF4KGN1cnJlbnRQYWdlIC0gTWF0aC5mbG9vcihtYXhTaXplIC8gMiksIDEpO1xuICAgICAgICBlbmRQYWdlID0gc3RhcnRQYWdlICsgbWF4U2l6ZSAtIDE7XG5cbiAgICAgICAgLy8gQWRqdXN0IGlmIGxpbWl0IGlzIGV4Y2VlZGVkXG4gICAgICAgIGlmIChlbmRQYWdlID4gdG90YWxQYWdlcykge1xuICAgICAgICAgIGVuZFBhZ2UgPSB0b3RhbFBhZ2VzO1xuICAgICAgICAgIHN0YXJ0UGFnZSA9IGVuZFBhZ2UgLSBtYXhTaXplICsgMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVmlzaWJsZSBwYWdlcyBhcmUgcGFnaW5hdGVkIHdpdGggbWF4U2l6ZVxuICAgICAgICBzdGFydFBhZ2UgPSAoTWF0aC5jZWlsKGN1cnJlbnRQYWdlIC8gbWF4U2l6ZSkgLSAxKSAqIG1heFNpemUgKyAxO1xuXG4gICAgICAgIC8vIEFkanVzdCBsYXN0IHBhZ2UgaWYgbGltaXQgaXMgZXhjZWVkZWRcbiAgICAgICAgZW5kUGFnZSA9IE1hdGgubWluKHN0YXJ0UGFnZSArIG1heFNpemUgLSAxLCB0b3RhbFBhZ2VzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBZGQgcGFnZSBudW1iZXIgbGlua3NcbiAgICBmb3IgKHZhciBudW1iZXIgPSBzdGFydFBhZ2U7IG51bWJlciA8PSBlbmRQYWdlOyBudW1iZXIrKykge1xuICAgICAgdmFyIHBhZ2UgPSBtYWtlUGFnZShudW1iZXIsIHBhZ2VMYWJlbChudW1iZXIpLCBudW1iZXIgPT09IGN1cnJlbnRQYWdlKTtcbiAgICAgIHBhZ2VzLnB1c2gocGFnZSk7XG4gICAgfVxuXG4gICAgLy8gQWRkIGxpbmtzIHRvIG1vdmUgYmV0d2VlbiBwYWdlIHNldHNcbiAgICBpZiAoaXNNYXhTaXplZCAmJiBtYXhTaXplID4gMCAmJiAoIXJvdGF0ZSB8fCBmb3JjZUVsbGlwc2VzIHx8IGJvdW5kYXJ5TGlua051bWJlcnMpKSB7XG4gICAgICBpZiAoc3RhcnRQYWdlID4gMSkge1xuICAgICAgICBpZiAoIWJvdW5kYXJ5TGlua051bWJlcnMgfHwgc3RhcnRQYWdlID4gMykgeyAvL25lZWQgZWxsaXBzaXMgZm9yIGFsbCBvcHRpb25zIHVubGVzcyByYW5nZSBpcyB0b28gY2xvc2UgdG8gYmVnaW5uaW5nXG4gICAgICAgIHZhciBwcmV2aW91c1BhZ2VTZXQgPSBtYWtlUGFnZShzdGFydFBhZ2UgLSAxLCAnLi4uJywgZmFsc2UpO1xuICAgICAgICBwYWdlcy51bnNoaWZ0KHByZXZpb3VzUGFnZVNldCk7XG4gICAgICB9XG4gICAgICAgIGlmIChib3VuZGFyeUxpbmtOdW1iZXJzKSB7XG4gICAgICAgICAgaWYgKHN0YXJ0UGFnZSA9PT0gMykgeyAvL25lZWQgdG8gcmVwbGFjZSBlbGxpcHNpcyB3aGVuIHRoZSBidXR0b25zIHdvdWxkIGJlIHNlcXVlbnRpYWxcbiAgICAgICAgICAgIHZhciBzZWNvbmRQYWdlTGluayA9IG1ha2VQYWdlKDIsICcyJywgZmFsc2UpO1xuICAgICAgICAgICAgcGFnZXMudW5zaGlmdChzZWNvbmRQYWdlTGluayk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vYWRkIHRoZSBmaXJzdCBwYWdlXG4gICAgICAgICAgdmFyIGZpcnN0UGFnZUxpbmsgPSBtYWtlUGFnZSgxLCAnMScsIGZhbHNlKTtcbiAgICAgICAgICBwYWdlcy51bnNoaWZ0KGZpcnN0UGFnZUxpbmspO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChlbmRQYWdlIDwgdG90YWxQYWdlcykge1xuICAgICAgICBpZiAoIWJvdW5kYXJ5TGlua051bWJlcnMgfHwgZW5kUGFnZSA8IHRvdGFsUGFnZXMgLSAyKSB7IC8vbmVlZCBlbGxpcHNpcyBmb3IgYWxsIG9wdGlvbnMgdW5sZXNzIHJhbmdlIGlzIHRvbyBjbG9zZSB0byBlbmRcbiAgICAgICAgdmFyIG5leHRQYWdlU2V0ID0gbWFrZVBhZ2UoZW5kUGFnZSArIDEsICcuLi4nLCBmYWxzZSk7XG4gICAgICAgIHBhZ2VzLnB1c2gobmV4dFBhZ2VTZXQpO1xuICAgICAgfVxuICAgICAgICBpZiAoYm91bmRhcnlMaW5rTnVtYmVycykge1xuICAgICAgICAgIGlmIChlbmRQYWdlID09PSB0b3RhbFBhZ2VzIC0gMikgeyAvL25lZWQgdG8gcmVwbGFjZSBlbGxpcHNpcyB3aGVuIHRoZSBidXR0b25zIHdvdWxkIGJlIHNlcXVlbnRpYWxcbiAgICAgICAgICAgIHZhciBzZWNvbmRUb0xhc3RQYWdlTGluayA9IG1ha2VQYWdlKHRvdGFsUGFnZXMgLSAxLCB0b3RhbFBhZ2VzIC0gMSwgZmFsc2UpO1xuICAgICAgICAgICAgcGFnZXMucHVzaChzZWNvbmRUb0xhc3RQYWdlTGluayk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vYWRkIHRoZSBsYXN0IHBhZ2VcbiAgICAgICAgICB2YXIgbGFzdFBhZ2VMaW5rID0gbWFrZVBhZ2UodG90YWxQYWdlcywgdG90YWxQYWdlcywgZmFsc2UpO1xuICAgICAgICAgIHBhZ2VzLnB1c2gobGFzdFBhZ2VMaW5rKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFnZXM7XG4gIH1cblxuICB2YXIgb3JpZ2luYWxSZW5kZXIgPSB0aGlzLnJlbmRlcjtcbiAgdGhpcy5yZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgICBvcmlnaW5hbFJlbmRlcigpO1xuICAgIGlmICgkc2NvcGUucGFnZSA+IDAgJiYgJHNjb3BlLnBhZ2UgPD0gJHNjb3BlLnRvdGFsUGFnZXMpIHtcbiAgICAgICRzY29wZS5wYWdlcyA9IGdldFBhZ2VzKCRzY29wZS5wYWdlLCAkc2NvcGUudG90YWxQYWdlcyk7XG4gICAgfVxuICB9O1xufV0pXG5cbi5jb25zdGFudCgndWliUGFnaW5hdGlvbkNvbmZpZycsIHtcbiAgaXRlbXNQZXJQYWdlOiAxMCxcbiAgYm91bmRhcnlMaW5rczogZmFsc2UsXG4gIGJvdW5kYXJ5TGlua051bWJlcnM6IGZhbHNlLFxuICBkaXJlY3Rpb25MaW5rczogdHJ1ZSxcbiAgZmlyc3RUZXh0OiAnRmlyc3QnLFxuICBwcmV2aW91c1RleHQ6ICdQcmV2aW91cycsXG4gIG5leHRUZXh0OiAnTmV4dCcsXG4gIGxhc3RUZXh0OiAnTGFzdCcsXG4gIHJvdGF0ZTogdHJ1ZSxcbiAgZm9yY2VFbGxpcHNlczogZmFsc2Vcbn0pXG5cbi5kaXJlY3RpdmUoJ3VpYlBhZ2luYXRpb24nLCBbJyRwYXJzZScsICd1aWJQYWdpbmF0aW9uQ29uZmlnJywgZnVuY3Rpb24oJHBhcnNlLCB1aWJQYWdpbmF0aW9uQ29uZmlnKSB7XG4gIHJldHVybiB7XG4gICAgc2NvcGU6IHtcbiAgICAgIHRvdGFsSXRlbXM6ICc9JyxcbiAgICAgIGZpcnN0VGV4dDogJ0AnLFxuICAgICAgcHJldmlvdXNUZXh0OiAnQCcsXG4gICAgICBuZXh0VGV4dDogJ0AnLFxuICAgICAgbGFzdFRleHQ6ICdAJyxcbiAgICAgIG5nRGlzYWJsZWQ6Jz0nXG4gICAgfSxcbiAgICByZXF1aXJlOiBbJ3VpYlBhZ2luYXRpb24nLCAnP25nTW9kZWwnXSxcbiAgICByZXN0cmljdDogJ0EnLFxuICAgIGNvbnRyb2xsZXI6ICdVaWJQYWdpbmF0aW9uQ29udHJvbGxlcicsXG4gICAgY29udHJvbGxlckFzOiAncGFnaW5hdGlvbicsXG4gICAgdGVtcGxhdGVVcmw6IGZ1bmN0aW9uKGVsZW1lbnQsIGF0dHJzKSB7XG4gICAgICByZXR1cm4gYXR0cnMudGVtcGxhdGVVcmwgfHwgJ3VpYi90ZW1wbGF0ZS9wYWdpbmF0aW9uL3BhZ2luYXRpb24uaHRtbCc7XG4gICAgfSxcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIGN0cmxzKSB7XG4gICAgICBlbGVtZW50LmFkZENsYXNzKCdwYWdpbmF0aW9uJyk7XG4gICAgICB2YXIgcGFnaW5hdGlvbkN0cmwgPSBjdHJsc1swXSwgbmdNb2RlbEN0cmwgPSBjdHJsc1sxXTtcblxuICAgICAgaWYgKCFuZ01vZGVsQ3RybCkge1xuICAgICAgICAgcmV0dXJuOyAvLyBkbyBub3RoaW5nIGlmIG5vIG5nLW1vZGVsXG4gICAgICB9XG5cbiAgICAgIHBhZ2luYXRpb25DdHJsLmluaXQobmdNb2RlbEN0cmwsIHVpYlBhZ2luYXRpb25Db25maWcpO1xuICAgIH1cbiAgfTtcbn1dKTtcblxuLyoqXG4gKiBUaGUgZm9sbG93aW5nIGZlYXR1cmVzIGFyZSBzdGlsbCBvdXRzdGFuZGluZzogYW5pbWF0aW9uIGFzIGFcbiAqIGZ1bmN0aW9uLCBwbGFjZW1lbnQgYXMgYSBmdW5jdGlvbiwgaW5zaWRlLCBzdXBwb3J0IGZvciBtb3JlIHRyaWdnZXJzIHRoYW5cbiAqIGp1c3QgbW91c2UgZW50ZXIvbGVhdmUsIGh0bWwgdG9vbHRpcHMsIGFuZCBzZWxlY3RvciBkZWxlZ2F0aW9uLlxuICovXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLnRvb2x0aXAnLCBbJ3VpLmJvb3RzdHJhcC5wb3NpdGlvbicsICd1aS5ib290c3RyYXAuc3RhY2tlZE1hcCddKVxuXG4vKipcbiAqIFRoZSAkdG9vbHRpcCBzZXJ2aWNlIGNyZWF0ZXMgdG9vbHRpcC0gYW5kIHBvcG92ZXItbGlrZSBkaXJlY3RpdmVzIGFzIHdlbGwgYXNcbiAqIGhvdXNlcyBnbG9iYWwgb3B0aW9ucyBmb3IgdGhlbS5cbiAqL1xuLnByb3ZpZGVyKCckdWliVG9vbHRpcCcsIGZ1bmN0aW9uKCkge1xuICAvLyBUaGUgZGVmYXVsdCBvcHRpb25zIHRvb2x0aXAgYW5kIHBvcG92ZXIuXG4gIHZhciBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBwbGFjZW1lbnQ6ICd0b3AnLFxuICAgIHBsYWNlbWVudENsYXNzUHJlZml4OiAnJyxcbiAgICBhbmltYXRpb246IHRydWUsXG4gICAgcG9wdXBEZWxheTogMCxcbiAgICBwb3B1cENsb3NlRGVsYXk6IDAsXG4gICAgdXNlQ29udGVudEV4cDogZmFsc2VcbiAgfTtcblxuICAvLyBEZWZhdWx0IGhpZGUgdHJpZ2dlcnMgZm9yIGVhY2ggc2hvdyB0cmlnZ2VyXG4gIHZhciB0cmlnZ2VyTWFwID0ge1xuICAgICdtb3VzZWVudGVyJzogJ21vdXNlbGVhdmUnLFxuICAgICdjbGljayc6ICdjbGljaycsXG4gICAgJ291dHNpZGVDbGljayc6ICdvdXRzaWRlQ2xpY2snLFxuICAgICdmb2N1cyc6ICdibHVyJyxcbiAgICAnbm9uZSc6ICcnXG4gIH07XG5cbiAgLy8gVGhlIG9wdGlvbnMgc3BlY2lmaWVkIHRvIHRoZSBwcm92aWRlciBnbG9iYWxseS5cbiAgdmFyIGdsb2JhbE9wdGlvbnMgPSB7fTtcblxuICAvKipcbiAgICogYG9wdGlvbnMoe30pYCBhbGxvd3MgZ2xvYmFsIGNvbmZpZ3VyYXRpb24gb2YgYWxsIHRvb2x0aXBzIGluIHRoZVxuICAgKiBhcHBsaWNhdGlvbi5cbiAgICpcbiAgICogICB2YXIgYXBwID0gYW5ndWxhci5tb2R1bGUoICdBcHAnLCBbJ3VpLmJvb3RzdHJhcC50b29sdGlwJ10sIGZ1bmN0aW9uKCAkdG9vbHRpcFByb3ZpZGVyICkge1xuICAgKiAgICAgLy8gcGxhY2UgdG9vbHRpcHMgbGVmdCBpbnN0ZWFkIG9mIHRvcCBieSBkZWZhdWx0XG4gICAqICAgICAkdG9vbHRpcFByb3ZpZGVyLm9wdGlvbnMoIHsgcGxhY2VtZW50OiAnbGVmdCcgfSApO1xuICAgKiAgIH0pO1xuICAgKi9cblx0dGhpcy5vcHRpb25zID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRhbmd1bGFyLmV4dGVuZChnbG9iYWxPcHRpb25zLCB2YWx1ZSk7XG5cdH07XG5cbiAgLyoqXG4gICAqIFRoaXMgYWxsb3dzIHlvdSB0byBleHRlbmQgdGhlIHNldCBvZiB0cmlnZ2VyIG1hcHBpbmdzIGF2YWlsYWJsZS4gRS5nLjpcbiAgICpcbiAgICogICAkdG9vbHRpcFByb3ZpZGVyLnNldFRyaWdnZXJzKCB7ICdvcGVuVHJpZ2dlcic6ICdjbG9zZVRyaWdnZXInIH0gKTtcbiAgICovXG4gIHRoaXMuc2V0VHJpZ2dlcnMgPSBmdW5jdGlvbiBzZXRUcmlnZ2Vycyh0cmlnZ2Vycykge1xuICAgIGFuZ3VsYXIuZXh0ZW5kKHRyaWdnZXJNYXAsIHRyaWdnZXJzKTtcbiAgfTtcblxuICAvKipcbiAgICogVGhpcyBpcyBhIGhlbHBlciBmdW5jdGlvbiBmb3IgdHJhbnNsYXRpbmcgY2FtZWwtY2FzZSB0byBzbmFrZV9jYXNlLlxuICAgKi9cbiAgZnVuY3Rpb24gc25ha2VfY2FzZShuYW1lKSB7XG4gICAgdmFyIHJlZ2V4cCA9IC9bQS1aXS9nO1xuICAgIHZhciBzZXBhcmF0b3IgPSAnLSc7XG4gICAgcmV0dXJuIG5hbWUucmVwbGFjZShyZWdleHAsIGZ1bmN0aW9uKGxldHRlciwgcG9zKSB7XG4gICAgICByZXR1cm4gKHBvcyA/IHNlcGFyYXRvciA6ICcnKSArIGxldHRlci50b0xvd2VyQ2FzZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFjdHVhbCBpbnN0YW5jZSBvZiB0aGUgJHRvb2x0aXAgc2VydmljZS5cbiAgICogVE9ETyBzdXBwb3J0IG11bHRpcGxlIHRyaWdnZXJzXG4gICAqL1xuICB0aGlzLiRnZXQgPSBbJyR3aW5kb3cnLCAnJGNvbXBpbGUnLCAnJHRpbWVvdXQnLCAnJGRvY3VtZW50JywgJyR1aWJQb3NpdGlvbicsICckaW50ZXJwb2xhdGUnLCAnJHJvb3RTY29wZScsICckcGFyc2UnLCAnJCRzdGFja2VkTWFwJywgZnVuY3Rpb24oJHdpbmRvdywgJGNvbXBpbGUsICR0aW1lb3V0LCAkZG9jdW1lbnQsICRwb3NpdGlvbiwgJGludGVycG9sYXRlLCAkcm9vdFNjb3BlLCAkcGFyc2UsICQkc3RhY2tlZE1hcCkge1xuICAgIHZhciBvcGVuZWRUb29sdGlwcyA9ICQkc3RhY2tlZE1hcC5jcmVhdGVOZXcoKTtcbiAgICAkZG9jdW1lbnQub24oJ2tleXVwJywga2V5cHJlc3NMaXN0ZW5lcik7XG5cbiAgICAkcm9vdFNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICAgICRkb2N1bWVudC5vZmYoJ2tleXVwJywga2V5cHJlc3NMaXN0ZW5lcik7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBrZXlwcmVzc0xpc3RlbmVyKGUpIHtcbiAgICAgIGlmIChlLndoaWNoID09PSAyNykge1xuICAgICAgICB2YXIgbGFzdCA9IG9wZW5lZFRvb2x0aXBzLnRvcCgpO1xuICAgICAgICBpZiAobGFzdCkge1xuICAgICAgICAgIGxhc3QudmFsdWUuY2xvc2UoKTtcbiAgICAgICAgICBsYXN0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAkdG9vbHRpcCh0dFR5cGUsIHByZWZpeCwgZGVmYXVsdFRyaWdnZXJTaG93LCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gYW5ndWxhci5leHRlbmQoe30sIGRlZmF1bHRPcHRpb25zLCBnbG9iYWxPcHRpb25zLCBvcHRpb25zKTtcblxuICAgICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIGFuIG9iamVjdCBvZiBzaG93IGFuZCBoaWRlIHRyaWdnZXJzLlxuICAgICAgICpcbiAgICAgICAqIElmIGEgdHJpZ2dlciBpcyBzdXBwbGllZCxcbiAgICAgICAqIGl0IGlzIHVzZWQgdG8gc2hvdyB0aGUgdG9vbHRpcDsgb3RoZXJ3aXNlLCBpdCB3aWxsIHVzZSB0aGUgYHRyaWdnZXJgXG4gICAgICAgKiBvcHRpb24gcGFzc2VkIHRvIHRoZSBgJHRvb2x0aXBQcm92aWRlci5vcHRpb25zYCBtZXRob2Q7IGVsc2UgaXQgd2lsbFxuICAgICAgICogZGVmYXVsdCB0byB0aGUgdHJpZ2dlciBzdXBwbGllZCB0byB0aGlzIGRpcmVjdGl2ZSBmYWN0b3J5LlxuICAgICAgICpcbiAgICAgICAqIFRoZSBoaWRlIHRyaWdnZXIgaXMgYmFzZWQgb24gdGhlIHNob3cgdHJpZ2dlci4gSWYgdGhlIGB0cmlnZ2VyYCBvcHRpb25cbiAgICAgICAqIHdhcyBwYXNzZWQgdG8gdGhlIGAkdG9vbHRpcFByb3ZpZGVyLm9wdGlvbnNgIG1ldGhvZCwgaXQgd2lsbCB1c2UgdGhlXG4gICAgICAgKiBtYXBwZWQgdHJpZ2dlciBmcm9tIGB0cmlnZ2VyTWFwYCBvciB0aGUgcGFzc2VkIHRyaWdnZXIgaWYgdGhlIG1hcCBpc1xuICAgICAgICogdW5kZWZpbmVkOyBvdGhlcndpc2UsIGl0IHVzZXMgdGhlIGB0cmlnZ2VyTWFwYCB2YWx1ZSBvZiB0aGUgc2hvd1xuICAgICAgICogdHJpZ2dlcjsgZWxzZSBpdCB3aWxsIGp1c3QgdXNlIHRoZSBzaG93IHRyaWdnZXIuXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIGdldFRyaWdnZXJzKHRyaWdnZXIpIHtcbiAgICAgICAgdmFyIHNob3cgPSAodHJpZ2dlciB8fCBvcHRpb25zLnRyaWdnZXIgfHwgZGVmYXVsdFRyaWdnZXJTaG93KS5zcGxpdCgnICcpO1xuICAgICAgICB2YXIgaGlkZSA9IHNob3cubWFwKGZ1bmN0aW9uKHRyaWdnZXIpIHtcbiAgICAgICAgICByZXR1cm4gdHJpZ2dlck1hcFt0cmlnZ2VyXSB8fCB0cmlnZ2VyO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzaG93OiBzaG93LFxuICAgICAgICAgIGhpZGU6IGhpZGVcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRpcmVjdGl2ZU5hbWUgPSBzbmFrZV9jYXNlKHR0VHlwZSk7XG5cbiAgICAgIHZhciBzdGFydFN5bSA9ICRpbnRlcnBvbGF0ZS5zdGFydFN5bWJvbCgpO1xuICAgICAgdmFyIGVuZFN5bSA9ICRpbnRlcnBvbGF0ZS5lbmRTeW1ib2woKTtcbiAgICAgIHZhciB0ZW1wbGF0ZSA9XG4gICAgICAgICc8ZGl2ICcrIGRpcmVjdGl2ZU5hbWUgKyAnLXBvcHVwICcgK1xuICAgICAgICAgICd1aWItdGl0bGU9XCInICsgc3RhcnRTeW0gKyAndGl0bGUnICsgZW5kU3ltICsgJ1wiICcgK1xuICAgICAgICAgIChvcHRpb25zLnVzZUNvbnRlbnRFeHAgP1xuICAgICAgICAgICAgJ2NvbnRlbnQtZXhwPVwiY29udGVudEV4cCgpXCIgJyA6XG4gICAgICAgICAgICAnY29udGVudD1cIicgKyBzdGFydFN5bSArICdjb250ZW50JyArIGVuZFN5bSArICdcIiAnKSArXG4gICAgICAgICAgJ29yaWdpbi1zY29wZT1cIm9yaWdTY29wZVwiICcgK1xuICAgICAgICAgICdjbGFzcz1cInVpYi1wb3NpdGlvbi1tZWFzdXJlICcgKyBwcmVmaXggKyAnXCIgJyArXG4gICAgICAgICAgJ3Rvb2x0aXAtYW5pbWF0aW9uLWNsYXNzPVwiZmFkZVwiJyArXG4gICAgICAgICAgJ3VpYi10b29sdGlwLWNsYXNzZXMgJyArXG4gICAgICAgICAgJ25nLWNsYXNzPVwieyBpbjogaXNPcGVuIH1cIiAnICtcbiAgICAgICAgICAnPicgK1xuICAgICAgICAnPC9kaXY+JztcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29tcGlsZTogZnVuY3Rpb24odEVsZW0sIHRBdHRycykge1xuICAgICAgICAgIHZhciB0b29sdGlwTGlua2VyID0gJGNvbXBpbGUodGVtcGxhdGUpO1xuXG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGxpbmsoc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCB0b29sdGlwQ3RybCkge1xuICAgICAgICAgICAgdmFyIHRvb2x0aXA7XG4gICAgICAgICAgICB2YXIgdG9vbHRpcExpbmtlZFNjb3BlO1xuICAgICAgICAgICAgdmFyIHRyYW5zaXRpb25UaW1lb3V0O1xuICAgICAgICAgICAgdmFyIHNob3dUaW1lb3V0O1xuICAgICAgICAgICAgdmFyIGhpZGVUaW1lb3V0O1xuICAgICAgICAgICAgdmFyIHBvc2l0aW9uVGltZW91dDtcbiAgICAgICAgICAgIHZhciBhZGp1c3RtZW50VGltZW91dDtcbiAgICAgICAgICAgIHZhciBhcHBlbmRUb0JvZHkgPSBhbmd1bGFyLmlzRGVmaW5lZChvcHRpb25zLmFwcGVuZFRvQm9keSkgPyBvcHRpb25zLmFwcGVuZFRvQm9keSA6IGZhbHNlO1xuICAgICAgICAgICAgdmFyIHRyaWdnZXJzID0gZ2V0VHJpZ2dlcnModW5kZWZpbmVkKTtcbiAgICAgICAgICAgIHZhciBoYXNFbmFibGVFeHAgPSBhbmd1bGFyLmlzRGVmaW5lZChhdHRyc1twcmVmaXggKyAnRW5hYmxlJ10pO1xuICAgICAgICAgICAgdmFyIHR0U2NvcGUgPSBzY29wZS4kbmV3KHRydWUpO1xuICAgICAgICAgICAgdmFyIHJlcG9zaXRpb25TY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBpc09wZW5QYXJzZSA9IGFuZ3VsYXIuaXNEZWZpbmVkKGF0dHJzW3ByZWZpeCArICdJc09wZW4nXSkgPyAkcGFyc2UoYXR0cnNbcHJlZml4ICsgJ0lzT3BlbiddKSA6IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGNvbnRlbnRQYXJzZSA9IG9wdGlvbnMudXNlQ29udGVudEV4cCA/ICRwYXJzZShhdHRyc1t0dFR5cGVdKSA6IGZhbHNlO1xuICAgICAgICAgICAgdmFyIG9ic2VydmVycyA9IFtdO1xuICAgICAgICAgICAgdmFyIGxhc3RQbGFjZW1lbnQ7XG5cbiAgICAgICAgICAgIHZhciBwb3NpdGlvblRvb2x0aXAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgdG9vbHRpcCBleGlzdHMgYW5kIGlzIG5vdCBlbXB0eVxuICAgICAgICAgICAgICBpZiAoIXRvb2x0aXAgfHwgIXRvb2x0aXAuaHRtbCgpKSB7IHJldHVybjsgfVxuXG4gICAgICAgICAgICAgIGlmICghcG9zaXRpb25UaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb25UaW1lb3V0ID0gJHRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgdHRQb3NpdGlvbiA9ICRwb3NpdGlvbi5wb3NpdGlvbkVsZW1lbnRzKGVsZW1lbnQsIHRvb2x0aXAsIHR0U2NvcGUucGxhY2VtZW50LCBhcHBlbmRUb0JvZHkpO1xuICAgICAgICAgICAgICAgICAgdmFyIGluaXRpYWxIZWlnaHQgPSBhbmd1bGFyLmlzRGVmaW5lZCh0b29sdGlwLm9mZnNldEhlaWdodCkgPyB0b29sdGlwLm9mZnNldEhlaWdodCA6IHRvb2x0aXAucHJvcCgnb2Zmc2V0SGVpZ2h0Jyk7XG4gICAgICAgICAgICAgICAgICB2YXIgZWxlbWVudFBvcyA9IGFwcGVuZFRvQm9keSA/ICRwb3NpdGlvbi5vZmZzZXQoZWxlbWVudCkgOiAkcG9zaXRpb24ucG9zaXRpb24oZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICB0b29sdGlwLmNzcyh7IHRvcDogdHRQb3NpdGlvbi50b3AgKyAncHgnLCBsZWZ0OiB0dFBvc2l0aW9uLmxlZnQgKyAncHgnIH0pO1xuICAgICAgICAgICAgICAgICAgdmFyIHBsYWNlbWVudENsYXNzZXMgPSB0dFBvc2l0aW9uLnBsYWNlbWVudC5zcGxpdCgnLScpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoIXRvb2x0aXAuaGFzQ2xhc3MocGxhY2VtZW50Q2xhc3Nlc1swXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9vbHRpcC5yZW1vdmVDbGFzcyhsYXN0UGxhY2VtZW50LnNwbGl0KCctJylbMF0pO1xuICAgICAgICAgICAgICAgICAgICB0b29sdGlwLmFkZENsYXNzKHBsYWNlbWVudENsYXNzZXNbMF0pO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBpZiAoIXRvb2x0aXAuaGFzQ2xhc3Mob3B0aW9ucy5wbGFjZW1lbnRDbGFzc1ByZWZpeCArIHR0UG9zaXRpb24ucGxhY2VtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICB0b29sdGlwLnJlbW92ZUNsYXNzKG9wdGlvbnMucGxhY2VtZW50Q2xhc3NQcmVmaXggKyBsYXN0UGxhY2VtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgdG9vbHRpcC5hZGRDbGFzcyhvcHRpb25zLnBsYWNlbWVudENsYXNzUHJlZml4ICsgdHRQb3NpdGlvbi5wbGFjZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBhZGp1c3RtZW50VGltZW91dCA9ICR0aW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudEhlaWdodCA9IGFuZ3VsYXIuaXNEZWZpbmVkKHRvb2x0aXAub2Zmc2V0SGVpZ2h0KSA/IHRvb2x0aXAub2Zmc2V0SGVpZ2h0IDogdG9vbHRpcC5wcm9wKCdvZmZzZXRIZWlnaHQnKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFkanVzdG1lbnQgPSAkcG9zaXRpb24uYWRqdXN0VG9wKHBsYWNlbWVudENsYXNzZXMsIGVsZW1lbnRQb3MsIGluaXRpYWxIZWlnaHQsIGN1cnJlbnRIZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWRqdXN0bWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgIHRvb2x0aXAuY3NzKGFkanVzdG1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFkanVzdG1lbnRUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgIH0sIDAsIGZhbHNlKTtcblxuICAgICAgICAgICAgICAgICAgLy8gZmlyc3QgdGltZSB0aHJvdWdoIHR0IGVsZW1lbnQgd2lsbCBoYXZlIHRoZVxuICAgICAgICAgICAgICAgICAgLy8gdWliLXBvc2l0aW9uLW1lYXN1cmUgY2xhc3Mgb3IgaWYgdGhlIHBsYWNlbWVudFxuICAgICAgICAgICAgICAgICAgLy8gaGFzIGNoYW5nZWQgd2UgbmVlZCB0byBwb3NpdGlvbiB0aGUgYXJyb3cuXG4gICAgICAgICAgICAgICAgICBpZiAodG9vbHRpcC5oYXNDbGFzcygndWliLXBvc2l0aW9uLW1lYXN1cmUnKSkge1xuICAgICAgICAgICAgICAgICAgICAkcG9zaXRpb24ucG9zaXRpb25BcnJvdyh0b29sdGlwLCB0dFBvc2l0aW9uLnBsYWNlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIHRvb2x0aXAucmVtb3ZlQ2xhc3MoJ3VpYi1wb3NpdGlvbi1tZWFzdXJlJyk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxhc3RQbGFjZW1lbnQgIT09IHR0UG9zaXRpb24ucGxhY2VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICRwb3NpdGlvbi5wb3NpdGlvbkFycm93KHRvb2x0aXAsIHR0UG9zaXRpb24ucGxhY2VtZW50KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGxhc3RQbGFjZW1lbnQgPSB0dFBvc2l0aW9uLnBsYWNlbWVudDtcblxuICAgICAgICAgICAgICAgICAgcG9zaXRpb25UaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9LCAwLCBmYWxzZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIFNldCB1cCB0aGUgY29ycmVjdCBzY29wZSB0byBhbGxvdyB0cmFuc2NsdXNpb24gbGF0ZXJcbiAgICAgICAgICAgIHR0U2NvcGUub3JpZ1Njb3BlID0gc2NvcGU7XG5cbiAgICAgICAgICAgIC8vIEJ5IGRlZmF1bHQsIHRoZSB0b29sdGlwIGlzIG5vdCBvcGVuLlxuICAgICAgICAgICAgLy8gVE9ETyBhZGQgYWJpbGl0eSB0byBzdGFydCB0b29sdGlwIG9wZW5lZFxuICAgICAgICAgICAgdHRTY29wZS5pc09wZW4gPSBmYWxzZTtcblxuICAgICAgICAgICAgZnVuY3Rpb24gdG9nZ2xlVG9vbHRpcEJpbmQoKSB7XG4gICAgICAgICAgICAgIGlmICghdHRTY29wZS5pc09wZW4pIHtcbiAgICAgICAgICAgICAgICBzaG93VG9vbHRpcEJpbmQoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBoaWRlVG9vbHRpcEJpbmQoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTaG93IHRoZSB0b29sdGlwIHdpdGggZGVsYXkgaWYgc3BlY2lmaWVkLCBvdGhlcndpc2Ugc2hvdyBpdCBpbW1lZGlhdGVseVxuICAgICAgICAgICAgZnVuY3Rpb24gc2hvd1Rvb2x0aXBCaW5kKCkge1xuICAgICAgICAgICAgICBpZiAoaGFzRW5hYmxlRXhwICYmICFzY29wZS4kZXZhbChhdHRyc1twcmVmaXggKyAnRW5hYmxlJ10pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY2FuY2VsSGlkZSgpO1xuICAgICAgICAgICAgICBwcmVwYXJlVG9vbHRpcCgpO1xuXG4gICAgICAgICAgICAgIGlmICh0dFNjb3BlLnBvcHVwRGVsYXkpIHtcbiAgICAgICAgICAgICAgICAvLyBEbyBub3RoaW5nIGlmIHRoZSB0b29sdGlwIHdhcyBhbHJlYWR5IHNjaGVkdWxlZCB0byBwb3AtdXAuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBoYXBwZW5zIGlmIHNob3cgaXMgdHJpZ2dlcmVkIG11bHRpcGxlIHRpbWVzIGJlZm9yZSBhbnkgaGlkZSBpcyB0cmlnZ2VyZWQuXG4gICAgICAgICAgICAgICAgaWYgKCFzaG93VGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgc2hvd1RpbWVvdXQgPSAkdGltZW91dChzaG93LCB0dFNjb3BlLnBvcHVwRGVsYXksIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2hvdygpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGhpZGVUb29sdGlwQmluZCgpIHtcbiAgICAgICAgICAgICAgY2FuY2VsU2hvdygpO1xuXG4gICAgICAgICAgICAgIGlmICh0dFNjb3BlLnBvcHVwQ2xvc2VEZWxheSkge1xuICAgICAgICAgICAgICAgIGlmICghaGlkZVRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgIGhpZGVUaW1lb3V0ID0gJHRpbWVvdXQoaGlkZSwgdHRTY29wZS5wb3B1cENsb3NlRGVsYXksIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaGlkZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNob3cgdGhlIHRvb2x0aXAgcG9wdXAgZWxlbWVudC5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHNob3coKSB7XG4gICAgICAgICAgICAgIGNhbmNlbFNob3coKTtcbiAgICAgICAgICAgICAgY2FuY2VsSGlkZSgpO1xuXG4gICAgICAgICAgICAgIC8vIERvbid0IHNob3cgZW1wdHkgdG9vbHRpcHMuXG4gICAgICAgICAgICAgIGlmICghdHRTY29wZS5jb250ZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFuZ3VsYXIubm9vcDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNyZWF0ZVRvb2x0aXAoKTtcblxuICAgICAgICAgICAgICAvLyBBbmQgc2hvdyB0aGUgdG9vbHRpcC5cbiAgICAgICAgICAgICAgdHRTY29wZS4kZXZhbEFzeW5jKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHR0U2NvcGUuaXNPcGVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBhc3NpZ25Jc09wZW4odHJ1ZSk7XG4gICAgICAgICAgICAgICAgcG9zaXRpb25Ub29sdGlwKCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBjYW5jZWxTaG93KCkge1xuICAgICAgICAgICAgICBpZiAoc2hvd1RpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAkdGltZW91dC5jYW5jZWwoc2hvd1RpbWVvdXQpO1xuICAgICAgICAgICAgICAgIHNob3dUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChwb3NpdGlvblRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAkdGltZW91dC5jYW5jZWwocG9zaXRpb25UaW1lb3V0KTtcbiAgICAgICAgICAgICAgICBwb3NpdGlvblRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEhpZGUgdGhlIHRvb2x0aXAgcG9wdXAgZWxlbWVudC5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGhpZGUoKSB7XG4gICAgICAgICAgICAgIGlmICghdHRTY29wZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIEZpcnN0IHRoaW5ncyBmaXJzdDogd2UgZG9uJ3Qgc2hvdyBpdCBhbnltb3JlLlxuICAgICAgICAgICAgICB0dFNjb3BlLiRldmFsQXN5bmMoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR0U2NvcGUpIHtcbiAgICAgICAgICAgICAgICAgIHR0U2NvcGUuaXNPcGVuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICBhc3NpZ25Jc09wZW4oZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgLy8gQW5kIG5vdyB3ZSByZW1vdmUgaXQgZnJvbSB0aGUgRE9NLiBIb3dldmVyLCBpZiB3ZSBoYXZlIGFuaW1hdGlvbiwgd2VcbiAgICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gd2FpdCBmb3IgaXQgdG8gZXhwaXJlIGJlZm9yZWhhbmQuXG4gICAgICAgICAgICAgICAgICAvLyBGSVhNRTogdGhpcyBpcyBhIHBsYWNlaG9sZGVyIGZvciBhIHBvcnQgb2YgdGhlIHRyYW5zaXRpb25zIGxpYnJhcnkuXG4gICAgICAgICAgICAgICAgICAvLyBUaGUgZmFkZSB0cmFuc2l0aW9uIGluIFRXQlMgaXMgMTUwbXMuXG4gICAgICAgICAgICAgICAgICBpZiAodHRTY29wZS5hbmltYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0cmFuc2l0aW9uVGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb25UaW1lb3V0ID0gJHRpbWVvdXQocmVtb3ZlVG9vbHRpcCwgMTUwLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZVRvb2x0aXAoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBjYW5jZWxIaWRlKCkge1xuICAgICAgICAgICAgICBpZiAoaGlkZVRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAkdGltZW91dC5jYW5jZWwoaGlkZVRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIGhpZGVUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICh0cmFuc2l0aW9uVGltZW91dCkge1xuICAgICAgICAgICAgICAgICR0aW1lb3V0LmNhbmNlbCh0cmFuc2l0aW9uVGltZW91dCk7XG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvblRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNyZWF0ZVRvb2x0aXAoKSB7XG4gICAgICAgICAgICAgIC8vIFRoZXJlIGNhbiBvbmx5IGJlIG9uZSB0b29sdGlwIGVsZW1lbnQgcGVyIGRpcmVjdGl2ZSBzaG93biBhdCBvbmNlLlxuICAgICAgICAgICAgICBpZiAodG9vbHRpcCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRvb2x0aXBMaW5rZWRTY29wZSA9IHR0U2NvcGUuJG5ldygpO1xuICAgICAgICAgICAgICB0b29sdGlwID0gdG9vbHRpcExpbmtlcih0b29sdGlwTGlua2VkU2NvcGUsIGZ1bmN0aW9uKHRvb2x0aXApIHtcbiAgICAgICAgICAgICAgICBpZiAoYXBwZW5kVG9Cb2R5KSB7XG4gICAgICAgICAgICAgICAgICAkZG9jdW1lbnQuZmluZCgnYm9keScpLmFwcGVuZCh0b29sdGlwKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgZWxlbWVudC5hZnRlcih0b29sdGlwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIG9wZW5lZFRvb2x0aXBzLmFkZCh0dFNjb3BlLCB7XG4gICAgICAgICAgICAgICAgY2xvc2U6IGhpZGVcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgcHJlcE9ic2VydmVycygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiByZW1vdmVUb29sdGlwKCkge1xuICAgICAgICAgICAgICBjYW5jZWxTaG93KCk7XG4gICAgICAgICAgICAgIGNhbmNlbEhpZGUoKTtcbiAgICAgICAgICAgICAgdW5yZWdpc3Rlck9ic2VydmVycygpO1xuXG4gICAgICAgICAgICAgIGlmICh0b29sdGlwKSB7XG4gICAgICAgICAgICAgICAgdG9vbHRpcC5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB0b29sdGlwID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoYWRqdXN0bWVudFRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICR0aW1lb3V0LmNhbmNlbChhZGp1c3RtZW50VGltZW91dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgb3BlbmVkVG9vbHRpcHMucmVtb3ZlKHR0U2NvcGUpO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgaWYgKHRvb2x0aXBMaW5rZWRTY29wZSkge1xuICAgICAgICAgICAgICAgIHRvb2x0aXBMaW5rZWRTY29wZS4kZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIHRvb2x0aXBMaW5rZWRTY29wZSA9IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTZXQgdGhlIGluaXRpYWwgc2NvcGUgdmFsdWVzLiBPbmNlXG4gICAgICAgICAgICAgKiB0aGUgdG9vbHRpcCBpcyBjcmVhdGVkLCB0aGUgb2JzZXJ2ZXJzXG4gICAgICAgICAgICAgKiB3aWxsIGJlIGFkZGVkIHRvIGtlZXAgdGhpbmdzIGluIHN5bmMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIHByZXBhcmVUb29sdGlwKCkge1xuICAgICAgICAgICAgICB0dFNjb3BlLnRpdGxlID0gYXR0cnNbcHJlZml4ICsgJ1RpdGxlJ107XG4gICAgICAgICAgICAgIGlmIChjb250ZW50UGFyc2UpIHtcbiAgICAgICAgICAgICAgICB0dFNjb3BlLmNvbnRlbnQgPSBjb250ZW50UGFyc2Uoc2NvcGUpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHR0U2NvcGUuY29udGVudCA9IGF0dHJzW3R0VHlwZV07XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0dFNjb3BlLnBvcHVwQ2xhc3MgPSBhdHRyc1twcmVmaXggKyAnQ2xhc3MnXTtcbiAgICAgICAgICAgICAgdHRTY29wZS5wbGFjZW1lbnQgPSBhbmd1bGFyLmlzRGVmaW5lZChhdHRyc1twcmVmaXggKyAnUGxhY2VtZW50J10pID8gYXR0cnNbcHJlZml4ICsgJ1BsYWNlbWVudCddIDogb3B0aW9ucy5wbGFjZW1lbnQ7XG4gICAgICAgICAgICAgIHZhciBwbGFjZW1lbnQgPSAkcG9zaXRpb24ucGFyc2VQbGFjZW1lbnQodHRTY29wZS5wbGFjZW1lbnQpO1xuICAgICAgICAgICAgICBsYXN0UGxhY2VtZW50ID0gcGxhY2VtZW50WzFdID8gcGxhY2VtZW50WzBdICsgJy0nICsgcGxhY2VtZW50WzFdIDogcGxhY2VtZW50WzBdO1xuXG4gICAgICAgICAgICAgIHZhciBkZWxheSA9IHBhcnNlSW50KGF0dHJzW3ByZWZpeCArICdQb3B1cERlbGF5J10sIDEwKTtcbiAgICAgICAgICAgICAgdmFyIGNsb3NlRGVsYXkgPSBwYXJzZUludChhdHRyc1twcmVmaXggKyAnUG9wdXBDbG9zZURlbGF5J10sIDEwKTtcbiAgICAgICAgICAgICAgdHRTY29wZS5wb3B1cERlbGF5ID0gIWlzTmFOKGRlbGF5KSA/IGRlbGF5IDogb3B0aW9ucy5wb3B1cERlbGF5O1xuICAgICAgICAgICAgICB0dFNjb3BlLnBvcHVwQ2xvc2VEZWxheSA9ICFpc05hTihjbG9zZURlbGF5KSA/IGNsb3NlRGVsYXkgOiBvcHRpb25zLnBvcHVwQ2xvc2VEZWxheTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gYXNzaWduSXNPcGVuKGlzT3Blbikge1xuICAgICAgICAgICAgICBpZiAoaXNPcGVuUGFyc2UgJiYgYW5ndWxhci5pc0Z1bmN0aW9uKGlzT3BlblBhcnNlLmFzc2lnbikpIHtcbiAgICAgICAgICAgICAgICBpc09wZW5QYXJzZS5hc3NpZ24oc2NvcGUsIGlzT3Blbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHRTY29wZS5jb250ZW50RXhwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0dFNjb3BlLmNvbnRlbnQ7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE9ic2VydmUgdGhlIHJlbGV2YW50IGF0dHJpYnV0ZXMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGF0dHJzLiRvYnNlcnZlKCdkaXNhYmxlZCcsIGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgICBpZiAodmFsKSB7XG4gICAgICAgICAgICAgICAgY2FuY2VsU2hvdygpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKHZhbCAmJiB0dFNjb3BlLmlzT3Blbikge1xuICAgICAgICAgICAgICAgIGhpZGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChpc09wZW5QYXJzZSkge1xuICAgICAgICAgICAgICBzY29wZS4kd2F0Y2goaXNPcGVuUGFyc2UsIGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgICAgIGlmICh0dFNjb3BlICYmICF2YWwgPT09IHR0U2NvcGUuaXNPcGVuKSB7XG4gICAgICAgICAgICAgICAgICB0b2dnbGVUb29sdGlwQmluZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHByZXBPYnNlcnZlcnMoKSB7XG4gICAgICAgICAgICAgIG9ic2VydmVycy5sZW5ndGggPSAwO1xuXG4gICAgICAgICAgICAgIGlmIChjb250ZW50UGFyc2UpIHtcbiAgICAgICAgICAgICAgICBvYnNlcnZlcnMucHVzaChcbiAgICAgICAgICAgICAgICAgIHNjb3BlLiR3YXRjaChjb250ZW50UGFyc2UsIGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgICAgICAgICB0dFNjb3BlLmNvbnRlbnQgPSB2YWw7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdmFsICYmIHR0U2NvcGUuaXNPcGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaGlkZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICBvYnNlcnZlcnMucHVzaChcbiAgICAgICAgICAgICAgICAgIHRvb2x0aXBMaW5rZWRTY29wZS4kd2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVwb3NpdGlvblNjaGVkdWxlZCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJlcG9zaXRpb25TY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgIHRvb2x0aXBMaW5rZWRTY29wZS4kJHBvc3REaWdlc3QoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXBvc2l0aW9uU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHRTY29wZSAmJiB0dFNjb3BlLmlzT3Blbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvblRvb2x0aXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG9ic2VydmVycy5wdXNoKFxuICAgICAgICAgICAgICAgICAgYXR0cnMuJG9ic2VydmUodHRUeXBlLCBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdHRTY29wZS5jb250ZW50ID0gdmFsO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbCAmJiB0dFNjb3BlLmlzT3Blbikge1xuICAgICAgICAgICAgICAgICAgICAgIGhpZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvblRvb2x0aXAoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgb2JzZXJ2ZXJzLnB1c2goXG4gICAgICAgICAgICAgICAgYXR0cnMuJG9ic2VydmUocHJlZml4ICsgJ1RpdGxlJywgZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAgICAgICB0dFNjb3BlLnRpdGxlID0gdmFsO1xuICAgICAgICAgICAgICAgICAgaWYgKHR0U2NvcGUuaXNPcGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uVG9vbHRpcCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgb2JzZXJ2ZXJzLnB1c2goXG4gICAgICAgICAgICAgICAgYXR0cnMuJG9ic2VydmUocHJlZml4ICsgJ1BsYWNlbWVudCcsIGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgICAgICAgdHRTY29wZS5wbGFjZW1lbnQgPSB2YWwgPyB2YWwgOiBvcHRpb25zLnBsYWNlbWVudDtcbiAgICAgICAgICAgICAgICAgIGlmICh0dFNjb3BlLmlzT3Blbikge1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvblRvb2x0aXAoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiB1bnJlZ2lzdGVyT2JzZXJ2ZXJzKCkge1xuICAgICAgICAgICAgICBpZiAob2JzZXJ2ZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGFuZ3VsYXIuZm9yRWFjaChvYnNlcnZlcnMsIGZ1bmN0aW9uKG9ic2VydmVyKSB7XG4gICAgICAgICAgICAgICAgICBvYnNlcnZlcigpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG9ic2VydmVycy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGhpZGUgdG9vbHRpcHMvcG9wb3ZlcnMgZm9yIG91dHNpZGVDbGljayB0cmlnZ2VyXG4gICAgICAgICAgICBmdW5jdGlvbiBib2R5SGlkZVRvb2x0aXBCaW5kKGUpIHtcbiAgICAgICAgICAgICAgaWYgKCF0dFNjb3BlIHx8ICF0dFNjb3BlLmlzT3BlbiB8fCAhdG9vbHRpcCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgdGhlIHRvb2x0aXAvcG9wb3ZlciBsaW5rIG9yIHRvb2wgdG9vbHRpcC9wb3BvdmVyIGl0c2VsZiB3ZXJlIG5vdCBjbGlja2VkXG4gICAgICAgICAgICAgIGlmICghZWxlbWVudFswXS5jb250YWlucyhlLnRhcmdldCkgJiYgIXRvb2x0aXBbMF0uY29udGFpbnMoZS50YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgaGlkZVRvb2x0aXBCaW5kKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gS2V5Ym9hcmRFdmVudCBoYW5kbGVyIHRvIGhpZGUgdGhlIHRvb2x0aXAgb24gRXNjYXBlIGtleSBwcmVzc1xuICAgICAgICAgICAgZnVuY3Rpb24gaGlkZU9uRXNjYXBlS2V5KGUpIHtcbiAgICAgICAgICAgICAgaWYgKGUud2hpY2ggPT09IDI3KSB7XG4gICAgICAgICAgICAgICAgaGlkZVRvb2x0aXBCaW5kKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHVucmVnaXN0ZXJUcmlnZ2VycyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB0cmlnZ2Vycy5zaG93LmZvckVhY2goZnVuY3Rpb24odHJpZ2dlcikge1xuICAgICAgICAgICAgICAgIGlmICh0cmlnZ2VyID09PSAnb3V0c2lkZUNsaWNrJykge1xuICAgICAgICAgICAgICAgICAgZWxlbWVudC5vZmYoJ2NsaWNrJywgdG9nZ2xlVG9vbHRpcEJpbmQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBlbGVtZW50Lm9mZih0cmlnZ2VyLCBzaG93VG9vbHRpcEJpbmQpO1xuICAgICAgICAgICAgICAgICAgZWxlbWVudC5vZmYodHJpZ2dlciwgdG9nZ2xlVG9vbHRpcEJpbmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbGVtZW50Lm9mZigna2V5cHJlc3MnLCBoaWRlT25Fc2NhcGVLZXkpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgdHJpZ2dlcnMuaGlkZS5mb3JFYWNoKGZ1bmN0aW9uKHRyaWdnZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAodHJpZ2dlciA9PT0gJ291dHNpZGVDbGljaycpIHtcbiAgICAgICAgICAgICAgICAgICRkb2N1bWVudC5vZmYoJ2NsaWNrJywgYm9keUhpZGVUb29sdGlwQmluZCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGVsZW1lbnQub2ZmKHRyaWdnZXIsIGhpZGVUb29sdGlwQmluZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHByZXBUcmlnZ2VycygpIHtcbiAgICAgICAgICAgICAgdmFyIHNob3dUcmlnZ2VycyA9IFtdLCBoaWRlVHJpZ2dlcnMgPSBbXTtcbiAgICAgICAgICAgICAgdmFyIHZhbCA9IHNjb3BlLiRldmFsKGF0dHJzW3ByZWZpeCArICdUcmlnZ2VyJ10pO1xuICAgICAgICAgICAgICB1bnJlZ2lzdGVyVHJpZ2dlcnMoKTtcblxuICAgICAgICAgICAgICBpZiAoYW5ndWxhci5pc09iamVjdCh2YWwpKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXModmFsKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgICAgc2hvd1RyaWdnZXJzLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICAgIGhpZGVUcmlnZ2Vycy5wdXNoKHZhbFtrZXldKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0cmlnZ2VycyA9IHtcbiAgICAgICAgICAgICAgICAgIHNob3c6IHNob3dUcmlnZ2VycyxcbiAgICAgICAgICAgICAgICAgIGhpZGU6IGhpZGVUcmlnZ2Vyc1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJpZ2dlcnMgPSBnZXRUcmlnZ2Vycyh2YWwpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKHRyaWdnZXJzLnNob3cgIT09ICdub25lJykge1xuICAgICAgICAgICAgICAgIHRyaWdnZXJzLnNob3cuZm9yRWFjaChmdW5jdGlvbih0cmlnZ2VyLCBpZHgpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0cmlnZ2VyID09PSAnb3V0c2lkZUNsaWNrJykge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50Lm9uKCdjbGljaycsIHRvZ2dsZVRvb2x0aXBCaW5kKTtcbiAgICAgICAgICAgICAgICAgICAgJGRvY3VtZW50Lm9uKCdjbGljaycsIGJvZHlIaWRlVG9vbHRpcEJpbmQpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0cmlnZ2VyID09PSB0cmlnZ2Vycy5oaWRlW2lkeF0pIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5vbih0cmlnZ2VyLCB0b2dnbGVUb29sdGlwQmluZCk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRyaWdnZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5vbih0cmlnZ2VyLCBzaG93VG9vbHRpcEJpbmQpO1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50Lm9uKHRyaWdnZXJzLmhpZGVbaWR4XSwgaGlkZVRvb2x0aXBCaW5kKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsZW1lbnQub24oJ2tleXByZXNzJywgaGlkZU9uRXNjYXBlS2V5KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwcmVwVHJpZ2dlcnMoKTtcblxuICAgICAgICAgICAgdmFyIGFuaW1hdGlvbiA9IHNjb3BlLiRldmFsKGF0dHJzW3ByZWZpeCArICdBbmltYXRpb24nXSk7XG4gICAgICAgICAgICB0dFNjb3BlLmFuaW1hdGlvbiA9IGFuZ3VsYXIuaXNEZWZpbmVkKGFuaW1hdGlvbikgPyAhIWFuaW1hdGlvbiA6IG9wdGlvbnMuYW5pbWF0aW9uO1xuXG4gICAgICAgICAgICB2YXIgYXBwZW5kVG9Cb2R5VmFsO1xuICAgICAgICAgICAgdmFyIGFwcGVuZEtleSA9IHByZWZpeCArICdBcHBlbmRUb0JvZHknO1xuICAgICAgICAgICAgaWYgKGFwcGVuZEtleSBpbiBhdHRycyAmJiBhdHRyc1thcHBlbmRLZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgYXBwZW5kVG9Cb2R5VmFsID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGFwcGVuZFRvQm9keVZhbCA9IHNjb3BlLiRldmFsKGF0dHJzW2FwcGVuZEtleV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhcHBlbmRUb0JvZHkgPSBhbmd1bGFyLmlzRGVmaW5lZChhcHBlbmRUb0JvZHlWYWwpID8gYXBwZW5kVG9Cb2R5VmFsIDogYXBwZW5kVG9Cb2R5O1xuXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdG9vbHRpcCBpcyBkZXN0cm95ZWQgYW5kIHJlbW92ZWQuXG4gICAgICAgICAgICBzY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24gb25EZXN0cm95VG9vbHRpcCgpIHtcbiAgICAgICAgICAgICAgdW5yZWdpc3RlclRyaWdnZXJzKCk7XG4gICAgICAgICAgICAgIHJlbW92ZVRvb2x0aXAoKTtcbiAgICAgICAgICAgICAgdHRTY29wZSA9IG51bGw7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG4gIH1dO1xufSlcblxuLy8gVGhpcyBpcyBtb3N0bHkgbmdJbmNsdWRlIGNvZGUgYnV0IHdpdGggYSBjdXN0b20gc2NvcGVcbi5kaXJlY3RpdmUoJ3VpYlRvb2x0aXBUZW1wbGF0ZVRyYW5zY2x1ZGUnLCBbXG4gICAgICAgICAnJGFuaW1hdGUnLCAnJHNjZScsICckY29tcGlsZScsICckdGVtcGxhdGVSZXF1ZXN0JyxcbmZ1bmN0aW9uICgkYW5pbWF0ZSwgJHNjZSwgJGNvbXBpbGUsICR0ZW1wbGF0ZVJlcXVlc3QpIHtcbiAgcmV0dXJuIHtcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbSwgYXR0cnMpIHtcbiAgICAgIHZhciBvcmlnU2NvcGUgPSBzY29wZS4kZXZhbChhdHRycy50b29sdGlwVGVtcGxhdGVUcmFuc2NsdWRlU2NvcGUpO1xuXG4gICAgICB2YXIgY2hhbmdlQ291bnRlciA9IDAsXG4gICAgICAgIGN1cnJlbnRTY29wZSxcbiAgICAgICAgcHJldmlvdXNFbGVtZW50LFxuICAgICAgICBjdXJyZW50RWxlbWVudDtcblxuICAgICAgdmFyIGNsZWFudXBMYXN0SW5jbHVkZUNvbnRlbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHByZXZpb3VzRWxlbWVudCkge1xuICAgICAgICAgIHByZXZpb3VzRWxlbWVudC5yZW1vdmUoKTtcbiAgICAgICAgICBwcmV2aW91c0VsZW1lbnQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGN1cnJlbnRTY29wZSkge1xuICAgICAgICAgIGN1cnJlbnRTY29wZS4kZGVzdHJveSgpO1xuICAgICAgICAgIGN1cnJlbnRTY29wZSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3VycmVudEVsZW1lbnQpIHtcbiAgICAgICAgICAkYW5pbWF0ZS5sZWF2ZShjdXJyZW50RWxlbWVudCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHByZXZpb3VzRWxlbWVudCA9IG51bGw7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcHJldmlvdXNFbGVtZW50ID0gY3VycmVudEVsZW1lbnQ7XG4gICAgICAgICAgY3VycmVudEVsZW1lbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBzY29wZS4kd2F0Y2goJHNjZS5wYXJzZUFzUmVzb3VyY2VVcmwoYXR0cnMudWliVG9vbHRpcFRlbXBsYXRlVHJhbnNjbHVkZSksIGZ1bmN0aW9uKHNyYykge1xuICAgICAgICB2YXIgdGhpc0NoYW5nZUlkID0gKytjaGFuZ2VDb3VudGVyO1xuXG4gICAgICAgIGlmIChzcmMpIHtcbiAgICAgICAgICAvL3NldCB0aGUgMm5kIHBhcmFtIHRvIHRydWUgdG8gaWdub3JlIHRoZSB0ZW1wbGF0ZSByZXF1ZXN0IGVycm9yIHNvIHRoYXQgdGhlIGlubmVyXG4gICAgICAgICAgLy9jb250ZW50cyBhbmQgc2NvcGUgY2FuIGJlIGNsZWFuZWQgdXAuXG4gICAgICAgICAgJHRlbXBsYXRlUmVxdWVzdChzcmMsIHRydWUpLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGlmICh0aGlzQ2hhbmdlSWQgIT09IGNoYW5nZUNvdW50ZXIpIHsgcmV0dXJuOyB9XG4gICAgICAgICAgICB2YXIgbmV3U2NvcGUgPSBvcmlnU2NvcGUuJG5ldygpO1xuICAgICAgICAgICAgdmFyIHRlbXBsYXRlID0gcmVzcG9uc2U7XG5cbiAgICAgICAgICAgIHZhciBjbG9uZSA9ICRjb21waWxlKHRlbXBsYXRlKShuZXdTY29wZSwgZnVuY3Rpb24oY2xvbmUpIHtcbiAgICAgICAgICAgICAgY2xlYW51cExhc3RJbmNsdWRlQ29udGVudCgpO1xuICAgICAgICAgICAgICAkYW5pbWF0ZS5lbnRlcihjbG9uZSwgZWxlbSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY3VycmVudFNjb3BlID0gbmV3U2NvcGU7XG4gICAgICAgICAgICBjdXJyZW50RWxlbWVudCA9IGNsb25lO1xuXG4gICAgICAgICAgICBjdXJyZW50U2NvcGUuJGVtaXQoJyRpbmNsdWRlQ29udGVudExvYWRlZCcsIHNyYyk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodGhpc0NoYW5nZUlkID09PSBjaGFuZ2VDb3VudGVyKSB7XG4gICAgICAgICAgICAgIGNsZWFudXBMYXN0SW5jbHVkZUNvbnRlbnQoKTtcbiAgICAgICAgICAgICAgc2NvcGUuJGVtaXQoJyRpbmNsdWRlQ29udGVudEVycm9yJywgc3JjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzY29wZS4kZW1pdCgnJGluY2x1ZGVDb250ZW50UmVxdWVzdGVkJywgc3JjKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjbGVhbnVwTGFzdEluY2x1ZGVDb250ZW50KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBzY29wZS4kb24oJyRkZXN0cm95JywgY2xlYW51cExhc3RJbmNsdWRlQ29udGVudCk7XG4gICAgfVxuICB9O1xufV0pXG5cbi8qKlxuICogTm90ZSB0aGF0IGl0J3MgaW50ZW50aW9uYWwgdGhhdCB0aGVzZSBjbGFzc2VzIGFyZSAqbm90KiBhcHBsaWVkIHRocm91Z2ggJGFuaW1hdGUuXG4gKiBUaGV5IG11c3Qgbm90IGJlIGFuaW1hdGVkIGFzIHRoZXkncmUgZXhwZWN0ZWQgdG8gYmUgcHJlc2VudCBvbiB0aGUgdG9vbHRpcCBvblxuICogaW5pdGlhbGl6YXRpb24uXG4gKi9cbi5kaXJlY3RpdmUoJ3VpYlRvb2x0aXBDbGFzc2VzJywgWyckdWliUG9zaXRpb24nLCBmdW5jdGlvbigkdWliUG9zaXRpb24pIHtcbiAgcmV0dXJuIHtcbiAgICByZXN0cmljdDogJ0EnLFxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycykge1xuICAgICAgLy8gbmVlZCB0byBzZXQgdGhlIHByaW1hcnkgcG9zaXRpb24gc28gdGhlXG4gICAgICAvLyBhcnJvdyBoYXMgc3BhY2UgZHVyaW5nIHBvc2l0aW9uIG1lYXN1cmUuXG4gICAgICAvLyB0b29sdGlwLnBvc2l0aW9uVG9vbHRpcCgpXG4gICAgICBpZiAoc2NvcGUucGxhY2VtZW50KSB7XG4gICAgICAgIC8vIC8vIFRoZXJlIGFyZSBubyB0b3AtbGVmdCBldGMuLi4gY2xhc3Nlc1xuICAgICAgICAvLyAvLyBpbiBUV0JTLCBzbyB3ZSBuZWVkIHRoZSBwcmltYXJ5IHBvc2l0aW9uLlxuICAgICAgICB2YXIgcG9zaXRpb24gPSAkdWliUG9zaXRpb24ucGFyc2VQbGFjZW1lbnQoc2NvcGUucGxhY2VtZW50KTtcbiAgICAgICAgZWxlbWVudC5hZGRDbGFzcyhwb3NpdGlvblswXSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzY29wZS5wb3B1cENsYXNzKSB7XG4gICAgICAgIGVsZW1lbnQuYWRkQ2xhc3Moc2NvcGUucG9wdXBDbGFzcyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzY29wZS5hbmltYXRpb24pIHtcbiAgICAgICAgZWxlbWVudC5hZGRDbGFzcyhhdHRycy50b29sdGlwQW5pbWF0aW9uQ2xhc3MpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1dKVxuXG4uZGlyZWN0aXZlKCd1aWJUb29sdGlwUG9wdXAnLCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICByZXN0cmljdDogJ0EnLFxuICAgIHNjb3BlOiB7IGNvbnRlbnQ6ICdAJyB9LFxuICAgIHRlbXBsYXRlVXJsOiAndWliL3RlbXBsYXRlL3Rvb2x0aXAvdG9vbHRpcC1wb3B1cC5odG1sJ1xuICB9O1xufSlcblxuLmRpcmVjdGl2ZSgndWliVG9vbHRpcCcsIFsgJyR1aWJUb29sdGlwJywgZnVuY3Rpb24oJHVpYlRvb2x0aXApIHtcbiAgcmV0dXJuICR1aWJUb29sdGlwKCd1aWJUb29sdGlwJywgJ3Rvb2x0aXAnLCAnbW91c2VlbnRlcicpO1xufV0pXG5cbi5kaXJlY3RpdmUoJ3VpYlRvb2x0aXBUZW1wbGF0ZVBvcHVwJywgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgcmVzdHJpY3Q6ICdBJyxcbiAgICBzY29wZTogeyBjb250ZW50RXhwOiAnJicsIG9yaWdpblNjb3BlOiAnJicgfSxcbiAgICB0ZW1wbGF0ZVVybDogJ3VpYi90ZW1wbGF0ZS90b29sdGlwL3Rvb2x0aXAtdGVtcGxhdGUtcG9wdXAuaHRtbCdcbiAgfTtcbn0pXG5cbi5kaXJlY3RpdmUoJ3VpYlRvb2x0aXBUZW1wbGF0ZScsIFsnJHVpYlRvb2x0aXAnLCBmdW5jdGlvbigkdWliVG9vbHRpcCkge1xuICByZXR1cm4gJHVpYlRvb2x0aXAoJ3VpYlRvb2x0aXBUZW1wbGF0ZScsICd0b29sdGlwJywgJ21vdXNlZW50ZXInLCB7XG4gICAgdXNlQ29udGVudEV4cDogdHJ1ZVxuICB9KTtcbn1dKVxuXG4uZGlyZWN0aXZlKCd1aWJUb29sdGlwSHRtbFBvcHVwJywgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgcmVzdHJpY3Q6ICdBJyxcbiAgICBzY29wZTogeyBjb250ZW50RXhwOiAnJicgfSxcbiAgICB0ZW1wbGF0ZVVybDogJ3VpYi90ZW1wbGF0ZS90b29sdGlwL3Rvb2x0aXAtaHRtbC1wb3B1cC5odG1sJ1xuICB9O1xufSlcblxuLmRpcmVjdGl2ZSgndWliVG9vbHRpcEh0bWwnLCBbJyR1aWJUb29sdGlwJywgZnVuY3Rpb24oJHVpYlRvb2x0aXApIHtcbiAgcmV0dXJuICR1aWJUb29sdGlwKCd1aWJUb29sdGlwSHRtbCcsICd0b29sdGlwJywgJ21vdXNlZW50ZXInLCB7XG4gICAgdXNlQ29udGVudEV4cDogdHJ1ZVxuICB9KTtcbn1dKTtcblxuLyoqXG4gKiBUaGUgZm9sbG93aW5nIGZlYXR1cmVzIGFyZSBzdGlsbCBvdXRzdGFuZGluZzogcG9wdXAgZGVsYXksIGFuaW1hdGlvbiBhcyBhXG4gKiBmdW5jdGlvbiwgcGxhY2VtZW50IGFzIGEgZnVuY3Rpb24sIGluc2lkZSwgc3VwcG9ydCBmb3IgbW9yZSB0cmlnZ2VycyB0aGFuXG4gKiBqdXN0IG1vdXNlIGVudGVyL2xlYXZlLCBhbmQgc2VsZWN0b3IgZGVsZWdhdGF0aW9uLlxuICovXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLnBvcG92ZXInLCBbJ3VpLmJvb3RzdHJhcC50b29sdGlwJ10pXG5cbi5kaXJlY3RpdmUoJ3VpYlBvcG92ZXJUZW1wbGF0ZVBvcHVwJywgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgcmVzdHJpY3Q6ICdBJyxcbiAgICBzY29wZTogeyB1aWJUaXRsZTogJ0AnLCBjb250ZW50RXhwOiAnJicsIG9yaWdpblNjb3BlOiAnJicgfSxcbiAgICB0ZW1wbGF0ZVVybDogJ3VpYi90ZW1wbGF0ZS9wb3BvdmVyL3BvcG92ZXItdGVtcGxhdGUuaHRtbCdcbiAgfTtcbn0pXG5cbi5kaXJlY3RpdmUoJ3VpYlBvcG92ZXJUZW1wbGF0ZScsIFsnJHVpYlRvb2x0aXAnLCBmdW5jdGlvbigkdWliVG9vbHRpcCkge1xuICByZXR1cm4gJHVpYlRvb2x0aXAoJ3VpYlBvcG92ZXJUZW1wbGF0ZScsICdwb3BvdmVyJywgJ2NsaWNrJywge1xuICAgIHVzZUNvbnRlbnRFeHA6IHRydWVcbiAgfSk7XG59XSlcblxuLmRpcmVjdGl2ZSgndWliUG9wb3Zlckh0bWxQb3B1cCcsIGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHJlc3RyaWN0OiAnQScsXG4gICAgc2NvcGU6IHsgY29udGVudEV4cDogJyYnLCB1aWJUaXRsZTogJ0AnIH0sXG4gICAgdGVtcGxhdGVVcmw6ICd1aWIvdGVtcGxhdGUvcG9wb3Zlci9wb3BvdmVyLWh0bWwuaHRtbCdcbiAgfTtcbn0pXG5cbi5kaXJlY3RpdmUoJ3VpYlBvcG92ZXJIdG1sJywgWyckdWliVG9vbHRpcCcsIGZ1bmN0aW9uKCR1aWJUb29sdGlwKSB7XG4gIHJldHVybiAkdWliVG9vbHRpcCgndWliUG9wb3Zlckh0bWwnLCAncG9wb3ZlcicsICdjbGljaycsIHtcbiAgICB1c2VDb250ZW50RXhwOiB0cnVlXG4gIH0pO1xufV0pXG5cbi5kaXJlY3RpdmUoJ3VpYlBvcG92ZXJQb3B1cCcsIGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHJlc3RyaWN0OiAnQScsXG4gICAgc2NvcGU6IHsgdWliVGl0bGU6ICdAJywgY29udGVudDogJ0AnIH0sXG4gICAgdGVtcGxhdGVVcmw6ICd1aWIvdGVtcGxhdGUvcG9wb3Zlci9wb3BvdmVyLmh0bWwnXG4gIH07XG59KVxuXG4uZGlyZWN0aXZlKCd1aWJQb3BvdmVyJywgWyckdWliVG9vbHRpcCcsIGZ1bmN0aW9uKCR1aWJUb29sdGlwKSB7XG4gIHJldHVybiAkdWliVG9vbHRpcCgndWliUG9wb3ZlcicsICdwb3BvdmVyJywgJ2NsaWNrJyk7XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAucHJvZ3Jlc3NiYXInLCBbXSlcblxuLmNvbnN0YW50KCd1aWJQcm9ncmVzc0NvbmZpZycsIHtcbiAgYW5pbWF0ZTogdHJ1ZSxcbiAgbWF4OiAxMDBcbn0pXG5cbi5jb250cm9sbGVyKCdVaWJQcm9ncmVzc0NvbnRyb2xsZXInLCBbJyRzY29wZScsICckYXR0cnMnLCAndWliUHJvZ3Jlc3NDb25maWcnLCBmdW5jdGlvbigkc2NvcGUsICRhdHRycywgcHJvZ3Jlc3NDb25maWcpIHtcbiAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgYW5pbWF0ZSA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRhdHRycy5hbmltYXRlKSA/ICRzY29wZS4kcGFyZW50LiRldmFsKCRhdHRycy5hbmltYXRlKSA6IHByb2dyZXNzQ29uZmlnLmFuaW1hdGU7XG5cbiAgdGhpcy5iYXJzID0gW107XG4gICRzY29wZS5tYXggPSBnZXRNYXhPckRlZmF1bHQoKTtcblxuICB0aGlzLmFkZEJhciA9IGZ1bmN0aW9uKGJhciwgZWxlbWVudCwgYXR0cnMpIHtcbiAgICBpZiAoIWFuaW1hdGUpIHtcbiAgICAgIGVsZW1lbnQuY3NzKHsndHJhbnNpdGlvbic6ICdub25lJ30pO1xuICAgIH1cblxuICAgIHRoaXMuYmFycy5wdXNoKGJhcik7XG5cbiAgICBiYXIubWF4ID0gZ2V0TWF4T3JEZWZhdWx0KCk7XG4gICAgYmFyLnRpdGxlID0gYXR0cnMgJiYgYW5ndWxhci5pc0RlZmluZWQoYXR0cnMudGl0bGUpID8gYXR0cnMudGl0bGUgOiAncHJvZ3Jlc3NiYXInO1xuXG4gICAgYmFyLiR3YXRjaCgndmFsdWUnLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgYmFyLnJlY2FsY3VsYXRlUGVyY2VudGFnZSgpO1xuICAgIH0pO1xuXG4gICAgYmFyLnJlY2FsY3VsYXRlUGVyY2VudGFnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHRvdGFsUGVyY2VudGFnZSA9IHNlbGYuYmFycy5yZWR1Y2UoZnVuY3Rpb24odG90YWwsIGJhcikge1xuICAgICAgICBiYXIucGVyY2VudCA9ICsoMTAwICogYmFyLnZhbHVlIC8gYmFyLm1heCkudG9GaXhlZCgyKTtcbiAgICAgICAgcmV0dXJuIHRvdGFsICsgYmFyLnBlcmNlbnQ7XG4gICAgICB9LCAwKTtcblxuICAgICAgaWYgKHRvdGFsUGVyY2VudGFnZSA+IDEwMCkge1xuICAgICAgICBiYXIucGVyY2VudCAtPSB0b3RhbFBlcmNlbnRhZ2UgLSAxMDA7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGJhci4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgICBlbGVtZW50ID0gbnVsbDtcbiAgICAgIHNlbGYucmVtb3ZlQmFyKGJhcik7XG4gICAgfSk7XG4gIH07XG5cbiAgdGhpcy5yZW1vdmVCYXIgPSBmdW5jdGlvbihiYXIpIHtcbiAgICB0aGlzLmJhcnMuc3BsaWNlKHRoaXMuYmFycy5pbmRleE9mKGJhciksIDEpO1xuICAgIHRoaXMuYmFycy5mb3JFYWNoKGZ1bmN0aW9uIChiYXIpIHtcbiAgICAgIGJhci5yZWNhbGN1bGF0ZVBlcmNlbnRhZ2UoKTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyRhdHRycy4kb2JzZXJ2ZSgnbWF4UGFyYW0nLCBmdW5jdGlvbihtYXhQYXJhbSkge1xuICAkc2NvcGUuJHdhdGNoKCdtYXhQYXJhbScsIGZ1bmN0aW9uKG1heFBhcmFtKSB7XG4gICAgc2VsZi5iYXJzLmZvckVhY2goZnVuY3Rpb24oYmFyKSB7XG4gICAgICBiYXIubWF4ID0gZ2V0TWF4T3JEZWZhdWx0KCk7XG4gICAgICBiYXIucmVjYWxjdWxhdGVQZXJjZW50YWdlKCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGdldE1heE9yRGVmYXVsdCAoKSB7XG4gICAgcmV0dXJuIGFuZ3VsYXIuaXNEZWZpbmVkKCRzY29wZS5tYXhQYXJhbSkgPyAkc2NvcGUubWF4UGFyYW0gOiBwcm9ncmVzc0NvbmZpZy5tYXg7XG4gIH1cbn1dKVxuXG4uZGlyZWN0aXZlKCd1aWJQcm9ncmVzcycsIGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHJlcGxhY2U6IHRydWUsXG4gICAgdHJhbnNjbHVkZTogdHJ1ZSxcbiAgICBjb250cm9sbGVyOiAnVWliUHJvZ3Jlc3NDb250cm9sbGVyJyxcbiAgICByZXF1aXJlOiAndWliUHJvZ3Jlc3MnLFxuICAgIHNjb3BlOiB7XG4gICAgICBtYXhQYXJhbTogJz0/bWF4J1xuICAgIH0sXG4gICAgdGVtcGxhdGVVcmw6ICd1aWIvdGVtcGxhdGUvcHJvZ3Jlc3NiYXIvcHJvZ3Jlc3MuaHRtbCdcbiAgfTtcbn0pXG5cbi5kaXJlY3RpdmUoJ3VpYkJhcicsIGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHJlcGxhY2U6IHRydWUsXG4gICAgdHJhbnNjbHVkZTogdHJ1ZSxcbiAgICByZXF1aXJlOiAnXnVpYlByb2dyZXNzJyxcbiAgICBzY29wZToge1xuICAgICAgdmFsdWU6ICc9JyxcbiAgICAgIHR5cGU6ICdAJ1xuICAgIH0sXG4gICAgdGVtcGxhdGVVcmw6ICd1aWIvdGVtcGxhdGUvcHJvZ3Jlc3NiYXIvYmFyLmh0bWwnLFxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycywgcHJvZ3Jlc3NDdHJsKSB7XG4gICAgICBwcm9ncmVzc0N0cmwuYWRkQmFyKHNjb3BlLCBlbGVtZW50LCBhdHRycyk7XG4gICAgfVxuICB9O1xufSlcblxuLmRpcmVjdGl2ZSgndWliUHJvZ3Jlc3NiYXInLCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICByZXBsYWNlOiB0cnVlLFxuICAgIHRyYW5zY2x1ZGU6IHRydWUsXG4gICAgY29udHJvbGxlcjogJ1VpYlByb2dyZXNzQ29udHJvbGxlcicsXG4gICAgc2NvcGU6IHtcbiAgICAgIHZhbHVlOiAnPScsXG4gICAgICBtYXhQYXJhbTogJz0/bWF4JyxcbiAgICAgIHR5cGU6ICdAJ1xuICAgIH0sXG4gICAgdGVtcGxhdGVVcmw6ICd1aWIvdGVtcGxhdGUvcHJvZ3Jlc3NiYXIvcHJvZ3Jlc3NiYXIuaHRtbCcsXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsZW1lbnQsIGF0dHJzLCBwcm9ncmVzc0N0cmwpIHtcbiAgICAgIHByb2dyZXNzQ3RybC5hZGRCYXIoc2NvcGUsIGFuZ3VsYXIuZWxlbWVudChlbGVtZW50LmNoaWxkcmVuKClbMF0pLCB7dGl0bGU6IGF0dHJzLnRpdGxlfSk7XG4gICAgfVxuICB9O1xufSk7XG5cbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAucmF0aW5nJywgW10pXG5cbi5jb25zdGFudCgndWliUmF0aW5nQ29uZmlnJywge1xuICBtYXg6IDUsXG4gIHN0YXRlT246IG51bGwsXG4gIHN0YXRlT2ZmOiBudWxsLFxuICBlbmFibGVSZXNldDogdHJ1ZSxcbiAgdGl0bGVzOiBbJ29uZScsICd0d28nLCAndGhyZWUnLCAnZm91cicsICdmaXZlJ11cbn0pXG5cbi5jb250cm9sbGVyKCdVaWJSYXRpbmdDb250cm9sbGVyJywgWyckc2NvcGUnLCAnJGF0dHJzJywgJ3VpYlJhdGluZ0NvbmZpZycsIGZ1bmN0aW9uKCRzY29wZSwgJGF0dHJzLCByYXRpbmdDb25maWcpIHtcbiAgdmFyIG5nTW9kZWxDdHJsID0geyAkc2V0Vmlld1ZhbHVlOiBhbmd1bGFyLm5vb3AgfSxcbiAgICBzZWxmID0gdGhpcztcblxuICB0aGlzLmluaXQgPSBmdW5jdGlvbihuZ01vZGVsQ3RybF8pIHtcbiAgICBuZ01vZGVsQ3RybCA9IG5nTW9kZWxDdHJsXztcbiAgICBuZ01vZGVsQ3RybC4kcmVuZGVyID0gdGhpcy5yZW5kZXI7XG5cbiAgICBuZ01vZGVsQ3RybC4kZm9ybWF0dGVycy5wdXNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBpZiAoYW5ndWxhci5pc051bWJlcih2YWx1ZSkgJiYgdmFsdWUgPDwgMCAhPT0gdmFsdWUpIHtcbiAgICAgICAgdmFsdWUgPSBNYXRoLnJvdW5kKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0pO1xuXG4gICAgdGhpcy5zdGF0ZU9uID0gYW5ndWxhci5pc0RlZmluZWQoJGF0dHJzLnN0YXRlT24pID8gJHNjb3BlLiRwYXJlbnQuJGV2YWwoJGF0dHJzLnN0YXRlT24pIDogcmF0aW5nQ29uZmlnLnN0YXRlT247XG4gICAgdGhpcy5zdGF0ZU9mZiA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRhdHRycy5zdGF0ZU9mZikgPyAkc2NvcGUuJHBhcmVudC4kZXZhbCgkYXR0cnMuc3RhdGVPZmYpIDogcmF0aW5nQ29uZmlnLnN0YXRlT2ZmO1xuICAgIHRoaXMuZW5hYmxlUmVzZXQgPSBhbmd1bGFyLmlzRGVmaW5lZCgkYXR0cnMuZW5hYmxlUmVzZXQpID9cbiAgICAgICRzY29wZS4kcGFyZW50LiRldmFsKCRhdHRycy5lbmFibGVSZXNldCkgOiByYXRpbmdDb25maWcuZW5hYmxlUmVzZXQ7XG4gICAgdmFyIHRtcFRpdGxlcyA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRhdHRycy50aXRsZXMpID8gJHNjb3BlLiRwYXJlbnQuJGV2YWwoJGF0dHJzLnRpdGxlcykgOiByYXRpbmdDb25maWcudGl0bGVzO1xuICAgIHRoaXMudGl0bGVzID0gYW5ndWxhci5pc0FycmF5KHRtcFRpdGxlcykgJiYgdG1wVGl0bGVzLmxlbmd0aCA+IDAgP1xuICAgICAgdG1wVGl0bGVzIDogcmF0aW5nQ29uZmlnLnRpdGxlcztcblxuICAgIHZhciByYXRpbmdTdGF0ZXMgPSBhbmd1bGFyLmlzRGVmaW5lZCgkYXR0cnMucmF0aW5nU3RhdGVzKSA/XG4gICAgICAkc2NvcGUuJHBhcmVudC4kZXZhbCgkYXR0cnMucmF0aW5nU3RhdGVzKSA6XG4gICAgICBuZXcgQXJyYXkoYW5ndWxhci5pc0RlZmluZWQoJGF0dHJzLm1heCkgPyAkc2NvcGUuJHBhcmVudC4kZXZhbCgkYXR0cnMubWF4KSA6IHJhdGluZ0NvbmZpZy5tYXgpO1xuICAgICRzY29wZS5yYW5nZSA9IHRoaXMuYnVpbGRUZW1wbGF0ZU9iamVjdHMocmF0aW5nU3RhdGVzKTtcbiAgfTtcblxuICB0aGlzLmJ1aWxkVGVtcGxhdGVPYmplY3RzID0gZnVuY3Rpb24oc3RhdGVzKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSBzdGF0ZXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICBzdGF0ZXNbaV0gPSBhbmd1bGFyLmV4dGVuZCh7IGluZGV4OiBpIH0sIHsgc3RhdGVPbjogdGhpcy5zdGF0ZU9uLCBzdGF0ZU9mZjogdGhpcy5zdGF0ZU9mZiwgdGl0bGU6IHRoaXMuZ2V0VGl0bGUoaSkgfSwgc3RhdGVzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlcztcbiAgfTtcblxuICB0aGlzLmdldFRpdGxlID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPj0gdGhpcy50aXRsZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gaW5kZXggKyAxO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnRpdGxlc1tpbmRleF07XG4gIH07XG5cbiAgJHNjb3BlLnJhdGUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmICghJHNjb3BlLnJlYWRvbmx5ICYmIHZhbHVlID49IDAgJiYgdmFsdWUgPD0gJHNjb3BlLnJhbmdlLmxlbmd0aCkge1xuICAgICAgdmFyIG5ld1ZpZXdWYWx1ZSA9IHNlbGYuZW5hYmxlUmVzZXQgJiYgbmdNb2RlbEN0cmwuJHZpZXdWYWx1ZSA9PT0gdmFsdWUgPyAwIDogdmFsdWU7XG4gICAgICBuZ01vZGVsQ3RybC4kc2V0Vmlld1ZhbHVlKG5ld1ZpZXdWYWx1ZSk7XG4gICAgICBuZ01vZGVsQ3RybC4kcmVuZGVyKCk7XG4gICAgfVxuICB9O1xuXG4gICRzY29wZS5lbnRlciA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgaWYgKCEkc2NvcGUucmVhZG9ubHkpIHtcbiAgICAgICRzY29wZS52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICAkc2NvcGUub25Ib3Zlcih7dmFsdWU6IHZhbHVlfSk7XG4gIH07XG5cbiAgJHNjb3BlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgJHNjb3BlLnZhbHVlID0gbmdNb2RlbEN0cmwuJHZpZXdWYWx1ZTtcbiAgICAkc2NvcGUub25MZWF2ZSgpO1xuICB9O1xuXG4gICRzY29wZS5vbktleWRvd24gPSBmdW5jdGlvbihldnQpIHtcbiAgICBpZiAoLygzN3wzOHwzOXw0MCkvLnRlc3QoZXZ0LndoaWNoKSkge1xuICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAkc2NvcGUucmF0ZSgkc2NvcGUudmFsdWUgKyAoZXZ0LndoaWNoID09PSAzOCB8fCBldnQud2hpY2ggPT09IDM5ID8gMSA6IC0xKSk7XG4gICAgfVxuICB9O1xuXG4gIHRoaXMucmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgJHNjb3BlLnZhbHVlID0gbmdNb2RlbEN0cmwuJHZpZXdWYWx1ZTtcbiAgICAkc2NvcGUudGl0bGUgPSBzZWxmLmdldFRpdGxlKCRzY29wZS52YWx1ZSAtIDEpO1xuICB9O1xufV0pXG5cbi5kaXJlY3RpdmUoJ3VpYlJhdGluZycsIGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHJlcXVpcmU6IFsndWliUmF0aW5nJywgJ25nTW9kZWwnXSxcbiAgICByZXN0cmljdDogJ0EnLFxuICAgIHNjb3BlOiB7XG4gICAgICByZWFkb25seTogJz0/cmVhZE9ubHknLFxuICAgICAgb25Ib3ZlcjogJyYnLFxuICAgICAgb25MZWF2ZTogJyYnXG4gICAgfSxcbiAgICBjb250cm9sbGVyOiAnVWliUmF0aW5nQ29udHJvbGxlcicsXG4gICAgdGVtcGxhdGVVcmw6ICd1aWIvdGVtcGxhdGUvcmF0aW5nL3JhdGluZy5odG1sJyxcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIGN0cmxzKSB7XG4gICAgICB2YXIgcmF0aW5nQ3RybCA9IGN0cmxzWzBdLCBuZ01vZGVsQ3RybCA9IGN0cmxzWzFdO1xuICAgICAgcmF0aW5nQ3RybC5pbml0KG5nTW9kZWxDdHJsKTtcbiAgICB9XG4gIH07XG59KTtcblxuYW5ndWxhci5tb2R1bGUoJ3VpLmJvb3RzdHJhcC50YWJzJywgW10pXG5cbi5jb250cm9sbGVyKCdVaWJUYWJzZXRDb250cm9sbGVyJywgWyckc2NvcGUnLCBmdW5jdGlvbiAoJHNjb3BlKSB7XG4gIHZhciBjdHJsID0gdGhpcyxcbiAgICBvbGRJbmRleDtcbiAgY3RybC50YWJzID0gW107XG5cbiAgY3RybC5zZWxlY3QgPSBmdW5jdGlvbihpbmRleCwgZXZ0KSB7XG4gICAgaWYgKCFkZXN0cm95ZWQpIHtcbiAgICAgIHZhciBwcmV2aW91c0luZGV4ID0gZmluZFRhYkluZGV4KG9sZEluZGV4KTtcbiAgICAgIHZhciBwcmV2aW91c1NlbGVjdGVkID0gY3RybC50YWJzW3ByZXZpb3VzSW5kZXhdO1xuICAgICAgaWYgKHByZXZpb3VzU2VsZWN0ZWQpIHtcbiAgICAgICAgcHJldmlvdXNTZWxlY3RlZC50YWIub25EZXNlbGVjdCh7XG4gICAgICAgICAgJGV2ZW50OiBldnQsXG4gICAgICAgICAgJHNlbGVjdGVkSW5kZXg6IGluZGV4XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZXZ0ICYmIGV2dC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91c1NlbGVjdGVkLnRhYi5hY3RpdmUgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNlbGVjdGVkID0gY3RybC50YWJzW2luZGV4XTtcbiAgICAgIGlmIChzZWxlY3RlZCkge1xuICAgICAgICBzZWxlY3RlZC50YWIub25TZWxlY3Qoe1xuICAgICAgICAgICRldmVudDogZXZ0XG4gICAgICAgIH0pO1xuICAgICAgICBzZWxlY3RlZC50YWIuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgY3RybC5hY3RpdmUgPSBzZWxlY3RlZC5pbmRleDtcbiAgICAgICAgb2xkSW5kZXggPSBzZWxlY3RlZC5pbmRleDtcbiAgICAgIH0gZWxzZSBpZiAoIXNlbGVjdGVkICYmIGFuZ3VsYXIuaXNEZWZpbmVkKG9sZEluZGV4KSkge1xuICAgICAgICBjdHJsLmFjdGl2ZSA9IG51bGw7XG4gICAgICAgIG9sZEluZGV4ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgY3RybC5hZGRUYWIgPSBmdW5jdGlvbiBhZGRUYWIodGFiKSB7XG4gICAgY3RybC50YWJzLnB1c2goe1xuICAgICAgdGFiOiB0YWIsXG4gICAgICBpbmRleDogdGFiLmluZGV4XG4gICAgfSk7XG4gICAgY3RybC50YWJzLnNvcnQoZnVuY3Rpb24odDEsIHQyKSB7XG4gICAgICBpZiAodDEuaW5kZXggPiB0Mi5pbmRleCkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cblxuICAgICAgaWYgKHQxLmluZGV4IDwgdDIuaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gMDtcbiAgICB9KTtcblxuICAgIGlmICh0YWIuaW5kZXggPT09IGN0cmwuYWN0aXZlIHx8ICFhbmd1bGFyLmlzRGVmaW5lZChjdHJsLmFjdGl2ZSkgJiYgY3RybC50YWJzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIG5ld0FjdGl2ZUluZGV4ID0gZmluZFRhYkluZGV4KHRhYi5pbmRleCk7XG4gICAgICBjdHJsLnNlbGVjdChuZXdBY3RpdmVJbmRleCk7XG4gICAgfVxuICB9O1xuXG4gIGN0cmwucmVtb3ZlVGFiID0gZnVuY3Rpb24gcmVtb3ZlVGFiKHRhYikge1xuICAgIHZhciBpbmRleDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGN0cmwudGFicy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGN0cmwudGFic1tpXS50YWIgPT09IHRhYikge1xuICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjdHJsLnRhYnNbaW5kZXhdLmluZGV4ID09PSBjdHJsLmFjdGl2ZSkge1xuICAgICAgdmFyIG5ld0FjdGl2ZVRhYkluZGV4ID0gaW5kZXggPT09IGN0cmwudGFicy5sZW5ndGggLSAxID9cbiAgICAgICAgaW5kZXggLSAxIDogaW5kZXggKyAxICUgY3RybC50YWJzLmxlbmd0aDtcbiAgICAgIGN0cmwuc2VsZWN0KG5ld0FjdGl2ZVRhYkluZGV4KTtcbiAgICB9XG5cbiAgICBjdHJsLnRhYnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgfTtcblxuICAkc2NvcGUuJHdhdGNoKCd0YWJzZXQuYWN0aXZlJywgZnVuY3Rpb24odmFsKSB7XG4gICAgaWYgKGFuZ3VsYXIuaXNEZWZpbmVkKHZhbCkgJiYgdmFsICE9PSBvbGRJbmRleCkge1xuICAgICAgY3RybC5zZWxlY3QoZmluZFRhYkluZGV4KHZhbCkpO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIGRlc3Ryb3llZDtcbiAgJHNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICBkZXN0cm95ZWQgPSB0cnVlO1xuICB9KTtcblxuICBmdW5jdGlvbiBmaW5kVGFiSW5kZXgoaW5kZXgpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGN0cmwudGFicy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGN0cmwudGFic1tpXS5pbmRleCA9PT0gaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XSlcblxuLmRpcmVjdGl2ZSgndWliVGFic2V0JywgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7XG4gICAgdHJhbnNjbHVkZTogdHJ1ZSxcbiAgICByZXBsYWNlOiB0cnVlLFxuICAgIHNjb3BlOiB7fSxcbiAgICBiaW5kVG9Db250cm9sbGVyOiB7XG4gICAgICBhY3RpdmU6ICc9PycsXG4gICAgICB0eXBlOiAnQCdcbiAgICB9LFxuICAgIGNvbnRyb2xsZXI6ICdVaWJUYWJzZXRDb250cm9sbGVyJyxcbiAgICBjb250cm9sbGVyQXM6ICd0YWJzZXQnLFxuICAgIHRlbXBsYXRlVXJsOiBmdW5jdGlvbihlbGVtZW50LCBhdHRycykge1xuICAgICAgcmV0dXJuIGF0dHJzLnRlbXBsYXRlVXJsIHx8ICd1aWIvdGVtcGxhdGUvdGFicy90YWJzZXQuaHRtbCc7XG4gICAgfSxcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMpIHtcbiAgICAgIHNjb3BlLnZlcnRpY2FsID0gYW5ndWxhci5pc0RlZmluZWQoYXR0cnMudmVydGljYWwpID9cbiAgICAgICAgc2NvcGUuJHBhcmVudC4kZXZhbChhdHRycy52ZXJ0aWNhbCkgOiBmYWxzZTtcbiAgICAgIHNjb3BlLmp1c3RpZmllZCA9IGFuZ3VsYXIuaXNEZWZpbmVkKGF0dHJzLmp1c3RpZmllZCkgP1xuICAgICAgICBzY29wZS4kcGFyZW50LiRldmFsKGF0dHJzLmp1c3RpZmllZCkgOiBmYWxzZTtcbiAgICB9XG4gIH07XG59KVxuXG4uZGlyZWN0aXZlKCd1aWJUYWInLCBbJyRwYXJzZScsIGZ1bmN0aW9uKCRwYXJzZSkge1xuICByZXR1cm4ge1xuICAgIHJlcXVpcmU6ICdedWliVGFic2V0JyxcbiAgICByZXBsYWNlOiB0cnVlLFxuICAgIHRlbXBsYXRlVXJsOiBmdW5jdGlvbihlbGVtZW50LCBhdHRycykge1xuICAgICAgcmV0dXJuIGF0dHJzLnRlbXBsYXRlVXJsIHx8ICd1aWIvdGVtcGxhdGUvdGFicy90YWIuaHRtbCc7XG4gICAgfSxcbiAgICB0cmFuc2NsdWRlOiB0cnVlLFxuICAgIHNjb3BlOiB7XG4gICAgICBoZWFkaW5nOiAnQCcsXG4gICAgICBpbmRleDogJz0/JyxcbiAgICAgIGNsYXNzZXM6ICdAPycsXG4gICAgICBvblNlbGVjdDogJyZzZWxlY3QnLCAvL1RoaXMgY2FsbGJhY2sgaXMgY2FsbGVkIGluIGNvbnRlbnRIZWFkaW5nVHJhbnNjbHVkZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAvL29uY2UgaXQgaW5zZXJ0cyB0aGUgdGFiJ3MgY29udGVudCBpbnRvIHRoZSBkb21cbiAgICAgIG9uRGVzZWxlY3Q6ICcmZGVzZWxlY3QnXG4gICAgfSxcbiAgICBjb250cm9sbGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIC8vRW1wdHkgY29udHJvbGxlciBzbyBvdGhlciBkaXJlY3RpdmVzIGNhbiByZXF1aXJlIGJlaW5nICd1bmRlcicgYSB0YWJcbiAgICB9LFxuICAgIGNvbnRyb2xsZXJBczogJ3RhYicsXG4gICAgbGluazogZnVuY3Rpb24oc2NvcGUsIGVsbSwgYXR0cnMsIHRhYnNldEN0cmwsIHRyYW5zY2x1ZGUpIHtcbiAgICAgIHNjb3BlLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICBpZiAoYXR0cnMuZGlzYWJsZSkge1xuICAgICAgICBzY29wZS4kcGFyZW50LiR3YXRjaCgkcGFyc2UoYXR0cnMuZGlzYWJsZSksIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgc2NvcGUuZGlzYWJsZWQgPSAhISB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhbmd1bGFyLmlzVW5kZWZpbmVkKGF0dHJzLmluZGV4KSkge1xuICAgICAgICBpZiAodGFic2V0Q3RybC50YWJzICYmIHRhYnNldEN0cmwudGFicy5sZW5ndGgpIHtcbiAgICAgICAgICBzY29wZS5pbmRleCA9IE1hdGgubWF4LmFwcGx5KG51bGwsIHRhYnNldEN0cmwudGFicy5tYXAoZnVuY3Rpb24odCkgeyByZXR1cm4gdC5pbmRleDsgfSkpICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzY29wZS5pbmRleCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGFuZ3VsYXIuaXNVbmRlZmluZWQoYXR0cnMuY2xhc3NlcykpIHtcbiAgICAgICAgc2NvcGUuY2xhc3NlcyA9ICcnO1xuICAgICAgfVxuXG4gICAgICBzY29wZS5zZWxlY3QgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgaWYgKCFzY29wZS5kaXNhYmxlZCkge1xuICAgICAgICAgIHZhciBpbmRleDtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRhYnNldEN0cmwudGFicy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRhYnNldEN0cmwudGFic1tpXS50YWIgPT09IHNjb3BlKSB7XG4gICAgICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGFic2V0Q3RybC5zZWxlY3QoaW5kZXgsIGV2dCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHRhYnNldEN0cmwuYWRkVGFiKHNjb3BlKTtcbiAgICAgIHNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdGFic2V0Q3RybC5yZW1vdmVUYWIoc2NvcGUpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vV2UgbmVlZCB0byB0cmFuc2NsdWRlIGxhdGVyLCBvbmNlIHRoZSBjb250ZW50IGNvbnRhaW5lciBpcyByZWFkeS5cbiAgICAgIC8vd2hlbiB0aGlzIGxpbmsgaGFwcGVucywgd2UncmUgaW5zaWRlIGEgdGFiIGhlYWRpbmcuXG4gICAgICBzY29wZS4kdHJhbnNjbHVkZUZuID0gdHJhbnNjbHVkZTtcbiAgICB9XG4gIH07XG59XSlcblxuLmRpcmVjdGl2ZSgndWliVGFiSGVhZGluZ1RyYW5zY2x1ZGUnLCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICByZXN0cmljdDogJ0EnLFxuICAgIHJlcXVpcmU6ICdedWliVGFiJyxcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxtKSB7XG4gICAgICBzY29wZS4kd2F0Y2goJ2hlYWRpbmdFbGVtZW50JywgZnVuY3Rpb24gdXBkYXRlSGVhZGluZ0VsZW1lbnQoaGVhZGluZykge1xuICAgICAgICBpZiAoaGVhZGluZykge1xuICAgICAgICAgIGVsbS5odG1sKCcnKTtcbiAgICAgICAgICBlbG0uYXBwZW5kKGhlYWRpbmcpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG59KVxuXG4uZGlyZWN0aXZlKCd1aWJUYWJDb250ZW50VHJhbnNjbHVkZScsIGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge1xuICAgIHJlc3RyaWN0OiAnQScsXG4gICAgcmVxdWlyZTogJ151aWJUYWJzZXQnLFxuICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbG0sIGF0dHJzKSB7XG4gICAgICB2YXIgdGFiID0gc2NvcGUuJGV2YWwoYXR0cnMudWliVGFiQ29udGVudFRyYW5zY2x1ZGUpLnRhYjtcblxuICAgICAgLy9Ob3cgb3VyIHRhYiBpcyByZWFkeSB0byBiZSB0cmFuc2NsdWRlZDogYm90aCB0aGUgdGFiIGhlYWRpbmcgYXJlYVxuICAgICAgLy9hbmQgdGhlIHRhYiBjb250ZW50IGFyZWEgYXJlIGxvYWRlZC4gIFRyYW5zY2x1ZGUgJ2VtIGJvdGguXG4gICAgICB0YWIuJHRyYW5zY2x1ZGVGbih0YWIuJHBhcmVudCwgZnVuY3Rpb24oY29udGVudHMpIHtcbiAgICAgICAgYW5ndWxhci5mb3JFYWNoKGNvbnRlbnRzLCBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgaWYgKGlzVGFiSGVhZGluZyhub2RlKSkge1xuICAgICAgICAgICAgLy9MZXQgdGFiSGVhZGluZ1RyYW5zY2x1ZGUga25vdy5cbiAgICAgICAgICAgIHRhYi5oZWFkaW5nRWxlbWVudCA9IG5vZGU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsbS5hcHBlbmQobm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBpc1RhYkhlYWRpbmcobm9kZSkge1xuICAgIHJldHVybiBub2RlLnRhZ05hbWUgJiYgKFxuICAgICAgbm9kZS5oYXNBdHRyaWJ1dGUoJ3VpYi10YWItaGVhZGluZycpIHx8XG4gICAgICBub2RlLmhhc0F0dHJpYnV0ZSgnZGF0YS11aWItdGFiLWhlYWRpbmcnKSB8fFxuICAgICAgbm9kZS5oYXNBdHRyaWJ1dGUoJ3gtdWliLXRhYi1oZWFkaW5nJykgfHxcbiAgICAgIG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAndWliLXRhYi1oZWFkaW5nJyB8fFxuICAgICAgbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdkYXRhLXVpYi10YWItaGVhZGluZycgfHxcbiAgICAgIG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAneC11aWItdGFiLWhlYWRpbmcnIHx8XG4gICAgICBub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3VpYjp0YWItaGVhZGluZydcbiAgICApO1xuICB9XG59KTtcblxuYW5ndWxhci5tb2R1bGUoJ3VpLmJvb3RzdHJhcC50aW1lcGlja2VyJywgW10pXG5cbi5jb25zdGFudCgndWliVGltZXBpY2tlckNvbmZpZycsIHtcbiAgaG91clN0ZXA6IDEsXG4gIG1pbnV0ZVN0ZXA6IDEsXG4gIHNlY29uZFN0ZXA6IDEsXG4gIHNob3dNZXJpZGlhbjogdHJ1ZSxcbiAgc2hvd1NlY29uZHM6IGZhbHNlLFxuICBtZXJpZGlhbnM6IG51bGwsXG4gIHJlYWRvbmx5SW5wdXQ6IGZhbHNlLFxuICBtb3VzZXdoZWVsOiB0cnVlLFxuICBhcnJvd2tleXM6IHRydWUsXG4gIHNob3dTcGlubmVyczogdHJ1ZSxcbiAgdGVtcGxhdGVVcmw6ICd1aWIvdGVtcGxhdGUvdGltZXBpY2tlci90aW1lcGlja2VyLmh0bWwnXG59KVxuXG4uY29udHJvbGxlcignVWliVGltZXBpY2tlckNvbnRyb2xsZXInLCBbJyRzY29wZScsICckZWxlbWVudCcsICckYXR0cnMnLCAnJHBhcnNlJywgJyRsb2cnLCAnJGxvY2FsZScsICd1aWJUaW1lcGlja2VyQ29uZmlnJywgZnVuY3Rpb24oJHNjb3BlLCAkZWxlbWVudCwgJGF0dHJzLCAkcGFyc2UsICRsb2csICRsb2NhbGUsIHRpbWVwaWNrZXJDb25maWcpIHtcbiAgdmFyIGhvdXJzTW9kZWxDdHJsLCBtaW51dGVzTW9kZWxDdHJsLCBzZWNvbmRzTW9kZWxDdHJsO1xuICB2YXIgc2VsZWN0ZWQgPSBuZXcgRGF0ZSgpLFxuICAgIHdhdGNoZXJzID0gW10sXG4gICAgbmdNb2RlbEN0cmwgPSB7ICRzZXRWaWV3VmFsdWU6IGFuZ3VsYXIubm9vcCB9LCAvLyBudWxsTW9kZWxDdHJsXG4gICAgbWVyaWRpYW5zID0gYW5ndWxhci5pc0RlZmluZWQoJGF0dHJzLm1lcmlkaWFucykgPyAkc2NvcGUuJHBhcmVudC4kZXZhbCgkYXR0cnMubWVyaWRpYW5zKSA6IHRpbWVwaWNrZXJDb25maWcubWVyaWRpYW5zIHx8ICRsb2NhbGUuREFURVRJTUVfRk9STUFUUy5BTVBNUyxcbiAgICBwYWRIb3VycyA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRhdHRycy5wYWRIb3VycykgPyAkc2NvcGUuJHBhcmVudC4kZXZhbCgkYXR0cnMucGFkSG91cnMpIDogdHJ1ZTtcblxuICAkc2NvcGUudGFiaW5kZXggPSBhbmd1bGFyLmlzRGVmaW5lZCgkYXR0cnMudGFiaW5kZXgpID8gJGF0dHJzLnRhYmluZGV4IDogMDtcbiAgJGVsZW1lbnQucmVtb3ZlQXR0cigndGFiaW5kZXgnKTtcblxuICB0aGlzLmluaXQgPSBmdW5jdGlvbihuZ01vZGVsQ3RybF8sIGlucHV0cykge1xuICAgIG5nTW9kZWxDdHJsID0gbmdNb2RlbEN0cmxfO1xuICAgIG5nTW9kZWxDdHJsLiRyZW5kZXIgPSB0aGlzLnJlbmRlcjtcblxuICAgIG5nTW9kZWxDdHJsLiRmb3JtYXR0ZXJzLnVuc2hpZnQoZnVuY3Rpb24obW9kZWxWYWx1ZSkge1xuICAgICAgcmV0dXJuIG1vZGVsVmFsdWUgPyBuZXcgRGF0ZShtb2RlbFZhbHVlKSA6IG51bGw7XG4gICAgfSk7XG5cbiAgICB2YXIgaG91cnNJbnB1dEVsID0gaW5wdXRzLmVxKDApLFxuICAgICAgICBtaW51dGVzSW5wdXRFbCA9IGlucHV0cy5lcSgxKSxcbiAgICAgICAgc2Vjb25kc0lucHV0RWwgPSBpbnB1dHMuZXEoMik7XG5cbiAgICBob3Vyc01vZGVsQ3RybCA9IGhvdXJzSW5wdXRFbC5jb250cm9sbGVyKCduZ01vZGVsJyk7XG4gICAgbWludXRlc01vZGVsQ3RybCA9IG1pbnV0ZXNJbnB1dEVsLmNvbnRyb2xsZXIoJ25nTW9kZWwnKTtcbiAgICBzZWNvbmRzTW9kZWxDdHJsID0gc2Vjb25kc0lucHV0RWwuY29udHJvbGxlcignbmdNb2RlbCcpO1xuXG4gICAgdmFyIG1vdXNld2hlZWwgPSBhbmd1bGFyLmlzRGVmaW5lZCgkYXR0cnMubW91c2V3aGVlbCkgPyAkc2NvcGUuJHBhcmVudC4kZXZhbCgkYXR0cnMubW91c2V3aGVlbCkgOiB0aW1lcGlja2VyQ29uZmlnLm1vdXNld2hlZWw7XG5cbiAgICBpZiAobW91c2V3aGVlbCkge1xuICAgICAgdGhpcy5zZXR1cE1vdXNld2hlZWxFdmVudHMoaG91cnNJbnB1dEVsLCBtaW51dGVzSW5wdXRFbCwgc2Vjb25kc0lucHV0RWwpO1xuICAgIH1cblxuICAgIHZhciBhcnJvd2tleXMgPSBhbmd1bGFyLmlzRGVmaW5lZCgkYXR0cnMuYXJyb3drZXlzKSA/ICRzY29wZS4kcGFyZW50LiRldmFsKCRhdHRycy5hcnJvd2tleXMpIDogdGltZXBpY2tlckNvbmZpZy5hcnJvd2tleXM7XG4gICAgaWYgKGFycm93a2V5cykge1xuICAgICAgdGhpcy5zZXR1cEFycm93a2V5RXZlbnRzKGhvdXJzSW5wdXRFbCwgbWludXRlc0lucHV0RWwsIHNlY29uZHNJbnB1dEVsKTtcbiAgICB9XG5cbiAgICAkc2NvcGUucmVhZG9ubHlJbnB1dCA9IGFuZ3VsYXIuaXNEZWZpbmVkKCRhdHRycy5yZWFkb25seUlucHV0KSA/ICRzY29wZS4kcGFyZW50LiRldmFsKCRhdHRycy5yZWFkb25seUlucHV0KSA6IHRpbWVwaWNrZXJDb25maWcucmVhZG9ubHlJbnB1dDtcbiAgICB0aGlzLnNldHVwSW5wdXRFdmVudHMoaG91cnNJbnB1dEVsLCBtaW51dGVzSW5wdXRFbCwgc2Vjb25kc0lucHV0RWwpO1xuICB9O1xuXG4gIHZhciBob3VyU3RlcCA9IHRpbWVwaWNrZXJDb25maWcuaG91clN0ZXA7XG4gIGlmICgkYXR0cnMuaG91clN0ZXApIHtcbiAgICB3YXRjaGVycy5wdXNoKCRzY29wZS4kcGFyZW50LiR3YXRjaCgkcGFyc2UoJGF0dHJzLmhvdXJTdGVwKSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGhvdXJTdGVwID0gK3ZhbHVlO1xuICAgIH0pKTtcbiAgfVxuXG4gIHZhciBtaW51dGVTdGVwID0gdGltZXBpY2tlckNvbmZpZy5taW51dGVTdGVwO1xuICBpZiAoJGF0dHJzLm1pbnV0ZVN0ZXApIHtcbiAgICB3YXRjaGVycy5wdXNoKCRzY29wZS4kcGFyZW50LiR3YXRjaCgkcGFyc2UoJGF0dHJzLm1pbnV0ZVN0ZXApLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgbWludXRlU3RlcCA9ICt2YWx1ZTtcbiAgICB9KSk7XG4gIH1cblxuICB2YXIgbWluO1xuICB3YXRjaGVycy5wdXNoKCRzY29wZS4kcGFyZW50LiR3YXRjaCgkcGFyc2UoJGF0dHJzLm1pbiksIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIGR0ID0gbmV3IERhdGUodmFsdWUpO1xuICAgIG1pbiA9IGlzTmFOKGR0KSA/IHVuZGVmaW5lZCA6IGR0O1xuICB9KSk7XG5cbiAgdmFyIG1heDtcbiAgd2F0Y2hlcnMucHVzaCgkc2NvcGUuJHBhcmVudC4kd2F0Y2goJHBhcnNlKCRhdHRycy5tYXgpLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciBkdCA9IG5ldyBEYXRlKHZhbHVlKTtcbiAgICBtYXggPSBpc05hTihkdCkgPyB1bmRlZmluZWQgOiBkdDtcbiAgfSkpO1xuXG4gIHZhciBkaXNhYmxlZCA9IGZhbHNlO1xuICBpZiAoJGF0dHJzLm5nRGlzYWJsZWQpIHtcbiAgICB3YXRjaGVycy5wdXNoKCRzY29wZS4kcGFyZW50LiR3YXRjaCgkcGFyc2UoJGF0dHJzLm5nRGlzYWJsZWQpLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgZGlzYWJsZWQgPSB2YWx1ZTtcbiAgICB9KSk7XG4gIH1cblxuICAkc2NvcGUubm9JbmNyZW1lbnRIb3VycyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpbmNyZW1lbnRlZFNlbGVjdGVkID0gYWRkTWludXRlcyhzZWxlY3RlZCwgaG91clN0ZXAgKiA2MCk7XG4gICAgcmV0dXJuIGRpc2FibGVkIHx8IGluY3JlbWVudGVkU2VsZWN0ZWQgPiBtYXggfHxcbiAgICAgIGluY3JlbWVudGVkU2VsZWN0ZWQgPCBzZWxlY3RlZCAmJiBpbmNyZW1lbnRlZFNlbGVjdGVkIDwgbWluO1xuICB9O1xuXG4gICRzY29wZS5ub0RlY3JlbWVudEhvdXJzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRlY3JlbWVudGVkU2VsZWN0ZWQgPSBhZGRNaW51dGVzKHNlbGVjdGVkLCAtaG91clN0ZXAgKiA2MCk7XG4gICAgcmV0dXJuIGRpc2FibGVkIHx8IGRlY3JlbWVudGVkU2VsZWN0ZWQgPCBtaW4gfHxcbiAgICAgIGRlY3JlbWVudGVkU2VsZWN0ZWQgPiBzZWxlY3RlZCAmJiBkZWNyZW1lbnRlZFNlbGVjdGVkID4gbWF4O1xuICB9O1xuXG4gICRzY29wZS5ub0luY3JlbWVudE1pbnV0ZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaW5jcmVtZW50ZWRTZWxlY3RlZCA9IGFkZE1pbnV0ZXMoc2VsZWN0ZWQsIG1pbnV0ZVN0ZXApO1xuICAgIHJldHVybiBkaXNhYmxlZCB8fCBpbmNyZW1lbnRlZFNlbGVjdGVkID4gbWF4IHx8XG4gICAgICBpbmNyZW1lbnRlZFNlbGVjdGVkIDwgc2VsZWN0ZWQgJiYgaW5jcmVtZW50ZWRTZWxlY3RlZCA8IG1pbjtcbiAgfTtcblxuICAkc2NvcGUubm9EZWNyZW1lbnRNaW51dGVzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRlY3JlbWVudGVkU2VsZWN0ZWQgPSBhZGRNaW51dGVzKHNlbGVjdGVkLCAtbWludXRlU3RlcCk7XG4gICAgcmV0dXJuIGRpc2FibGVkIHx8IGRlY3JlbWVudGVkU2VsZWN0ZWQgPCBtaW4gfHxcbiAgICAgIGRlY3JlbWVudGVkU2VsZWN0ZWQgPiBzZWxlY3RlZCAmJiBkZWNyZW1lbnRlZFNlbGVjdGVkID4gbWF4O1xuICB9O1xuXG4gICRzY29wZS5ub0luY3JlbWVudFNlY29uZHMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaW5jcmVtZW50ZWRTZWxlY3RlZCA9IGFkZFNlY29uZHMoc2VsZWN0ZWQsIHNlY29uZFN0ZXApO1xuICAgIHJldHVybiBkaXNhYmxlZCB8fCBpbmNyZW1lbnRlZFNlbGVjdGVkID4gbWF4IHx8XG4gICAgICBpbmNyZW1lbnRlZFNlbGVjdGVkIDwgc2VsZWN0ZWQgJiYgaW5jcmVtZW50ZWRTZWxlY3RlZCA8IG1pbjtcbiAgfTtcblxuICAkc2NvcGUubm9EZWNyZW1lbnRTZWNvbmRzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGRlY3JlbWVudGVkU2VsZWN0ZWQgPSBhZGRTZWNvbmRzKHNlbGVjdGVkLCAtc2Vjb25kU3RlcCk7XG4gICAgcmV0dXJuIGRpc2FibGVkIHx8IGRlY3JlbWVudGVkU2VsZWN0ZWQgPCBtaW4gfHxcbiAgICAgIGRlY3JlbWVudGVkU2VsZWN0ZWQgPiBzZWxlY3RlZCAmJiBkZWNyZW1lbnRlZFNlbGVjdGVkID4gbWF4O1xuICB9O1xuXG4gICRzY29wZS5ub1RvZ2dsZU1lcmlkaWFuID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHNlbGVjdGVkLmdldEhvdXJzKCkgPCAxMikge1xuICAgICAgcmV0dXJuIGRpc2FibGVkIHx8IGFkZE1pbnV0ZXMoc2VsZWN0ZWQsIDEyICogNjApID4gbWF4O1xuICAgIH1cblxuICAgIHJldHVybiBkaXNhYmxlZCB8fCBhZGRNaW51dGVzKHNlbGVjdGVkLCAtMTIgKiA2MCkgPCBtaW47XG4gIH07XG5cbiAgdmFyIHNlY29uZFN0ZXAgPSB0aW1lcGlja2VyQ29uZmlnLnNlY29uZFN0ZXA7XG4gIGlmICgkYXR0cnMuc2Vjb25kU3RlcCkge1xuICAgIHdhdGNoZXJzLnB1c2goJHNjb3BlLiRwYXJlbnQuJHdhdGNoKCRwYXJzZSgkYXR0cnMuc2Vjb25kU3RlcCksIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBzZWNvbmRTdGVwID0gK3ZhbHVlO1xuICAgIH0pKTtcbiAgfVxuXG4gICRzY29wZS5zaG93U2Vjb25kcyA9IHRpbWVwaWNrZXJDb25maWcuc2hvd1NlY29uZHM7XG4gIGlmICgkYXR0cnMuc2hvd1NlY29uZHMpIHtcbiAgICB3YXRjaGVycy5wdXNoKCRzY29wZS4kcGFyZW50LiR3YXRjaCgkcGFyc2UoJGF0dHJzLnNob3dTZWNvbmRzKSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICRzY29wZS5zaG93U2Vjb25kcyA9ICEhdmFsdWU7XG4gICAgfSkpO1xuICB9XG5cbiAgLy8gMTJIIC8gMjRIIG1vZGVcbiAgJHNjb3BlLnNob3dNZXJpZGlhbiA9IHRpbWVwaWNrZXJDb25maWcuc2hvd01lcmlkaWFuO1xuICBpZiAoJGF0dHJzLnNob3dNZXJpZGlhbikge1xuICAgIHdhdGNoZXJzLnB1c2goJHNjb3BlLiRwYXJlbnQuJHdhdGNoKCRwYXJzZSgkYXR0cnMuc2hvd01lcmlkaWFuKSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICRzY29wZS5zaG93TWVyaWRpYW4gPSAhIXZhbHVlO1xuXG4gICAgICBpZiAobmdNb2RlbEN0cmwuJGVycm9yLnRpbWUpIHtcbiAgICAgICAgLy8gRXZhbHVhdGUgZnJvbSB0ZW1wbGF0ZVxuICAgICAgICB2YXIgaG91cnMgPSBnZXRIb3Vyc0Zyb21UZW1wbGF0ZSgpLCBtaW51dGVzID0gZ2V0TWludXRlc0Zyb21UZW1wbGF0ZSgpO1xuICAgICAgICBpZiAoYW5ndWxhci5pc0RlZmluZWQoaG91cnMpICYmIGFuZ3VsYXIuaXNEZWZpbmVkKG1pbnV0ZXMpKSB7XG4gICAgICAgICAgc2VsZWN0ZWQuc2V0SG91cnMoaG91cnMpO1xuICAgICAgICAgIHJlZnJlc2goKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXBkYXRlVGVtcGxhdGUoKTtcbiAgICAgIH1cbiAgICB9KSk7XG4gIH1cblxuICAvLyBHZXQgJHNjb3BlLmhvdXJzIGluIDI0SCBtb2RlIGlmIHZhbGlkXG4gIGZ1bmN0aW9uIGdldEhvdXJzRnJvbVRlbXBsYXRlKCkge1xuICAgIHZhciBob3VycyA9ICskc2NvcGUuaG91cnM7XG4gICAgdmFyIHZhbGlkID0gJHNjb3BlLnNob3dNZXJpZGlhbiA/IGhvdXJzID4gMCAmJiBob3VycyA8IDEzIDpcbiAgICAgIGhvdXJzID49IDAgJiYgaG91cnMgPCAyNDtcbiAgICBpZiAoIXZhbGlkIHx8ICRzY29wZS5ob3VycyA9PT0gJycpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKCRzY29wZS5zaG93TWVyaWRpYW4pIHtcbiAgICAgIGlmIChob3VycyA9PT0gMTIpIHtcbiAgICAgICAgaG91cnMgPSAwO1xuICAgICAgfVxuICAgICAgaWYgKCRzY29wZS5tZXJpZGlhbiA9PT0gbWVyaWRpYW5zWzFdKSB7XG4gICAgICAgIGhvdXJzID0gaG91cnMgKyAxMjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGhvdXJzO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TWludXRlc0Zyb21UZW1wbGF0ZSgpIHtcbiAgICB2YXIgbWludXRlcyA9ICskc2NvcGUubWludXRlcztcbiAgICB2YXIgdmFsaWQgPSBtaW51dGVzID49IDAgJiYgbWludXRlcyA8IDYwO1xuICAgIGlmICghdmFsaWQgfHwgJHNjb3BlLm1pbnV0ZXMgPT09ICcnKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gbWludXRlcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFNlY29uZHNGcm9tVGVtcGxhdGUoKSB7XG4gICAgdmFyIHNlY29uZHMgPSArJHNjb3BlLnNlY29uZHM7XG4gICAgcmV0dXJuIHNlY29uZHMgPj0gMCAmJiBzZWNvbmRzIDwgNjAgPyBzZWNvbmRzIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFkKHZhbHVlLCBub1BhZCkge1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIHJldHVybiBhbmd1bGFyLmlzRGVmaW5lZCh2YWx1ZSkgJiYgdmFsdWUudG9TdHJpbmcoKS5sZW5ndGggPCAyICYmICFub1BhZCA/XG4gICAgICAnMCcgKyB2YWx1ZSA6IHZhbHVlLnRvU3RyaW5nKCk7XG4gIH1cblxuICAvLyBSZXNwb25kIG9uIG1vdXNld2hlZWwgc3BpblxuICB0aGlzLnNldHVwTW91c2V3aGVlbEV2ZW50cyA9IGZ1bmN0aW9uKGhvdXJzSW5wdXRFbCwgbWludXRlc0lucHV0RWwsIHNlY29uZHNJbnB1dEVsKSB7XG4gICAgdmFyIGlzU2Nyb2xsaW5nVXAgPSBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoZS5vcmlnaW5hbEV2ZW50KSB7XG4gICAgICAgIGUgPSBlLm9yaWdpbmFsRXZlbnQ7XG4gICAgICB9XG4gICAgICAvL3BpY2sgY29ycmVjdCBkZWx0YSB2YXJpYWJsZSBkZXBlbmRpbmcgb24gZXZlbnRcbiAgICAgIHZhciBkZWx0YSA9IGUud2hlZWxEZWx0YSA/IGUud2hlZWxEZWx0YSA6IC1lLmRlbHRhWTtcbiAgICAgIHJldHVybiBlLmRldGFpbCB8fCBkZWx0YSA+IDA7XG4gICAgfTtcblxuICAgIGhvdXJzSW5wdXRFbC5vbignbW91c2V3aGVlbCB3aGVlbCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmICghZGlzYWJsZWQpIHtcbiAgICAgICAgJHNjb3BlLiRhcHBseShpc1Njcm9sbGluZ1VwKGUpID8gJHNjb3BlLmluY3JlbWVudEhvdXJzKCkgOiAkc2NvcGUuZGVjcmVtZW50SG91cnMoKSk7XG4gICAgICB9XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSk7XG5cbiAgICBtaW51dGVzSW5wdXRFbC5vbignbW91c2V3aGVlbCB3aGVlbCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmICghZGlzYWJsZWQpIHtcbiAgICAgICAgJHNjb3BlLiRhcHBseShpc1Njcm9sbGluZ1VwKGUpID8gJHNjb3BlLmluY3JlbWVudE1pbnV0ZXMoKSA6ICRzY29wZS5kZWNyZW1lbnRNaW51dGVzKCkpO1xuICAgICAgfVxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0pO1xuXG4gICAgIHNlY29uZHNJbnB1dEVsLm9uKCdtb3VzZXdoZWVsIHdoZWVsJywgZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKCFkaXNhYmxlZCkge1xuICAgICAgICAkc2NvcGUuJGFwcGx5KGlzU2Nyb2xsaW5nVXAoZSkgPyAkc2NvcGUuaW5jcmVtZW50U2Vjb25kcygpIDogJHNjb3BlLmRlY3JlbWVudFNlY29uZHMoKSk7XG4gICAgICB9XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gUmVzcG9uZCBvbiB1cC9kb3duIGFycm93a2V5c1xuICB0aGlzLnNldHVwQXJyb3drZXlFdmVudHMgPSBmdW5jdGlvbihob3Vyc0lucHV0RWwsIG1pbnV0ZXNJbnB1dEVsLCBzZWNvbmRzSW5wdXRFbCkge1xuICAgIGhvdXJzSW5wdXRFbC5vbigna2V5ZG93bicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmICghZGlzYWJsZWQpIHtcbiAgICAgICAgaWYgKGUud2hpY2ggPT09IDM4KSB7IC8vIHVwXG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICRzY29wZS5pbmNyZW1lbnRIb3VycygpO1xuICAgICAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICAgICAgfSBlbHNlIGlmIChlLndoaWNoID09PSA0MCkgeyAvLyBkb3duXG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICRzY29wZS5kZWNyZW1lbnRIb3VycygpO1xuICAgICAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgbWludXRlc0lucHV0RWwub24oJ2tleWRvd24nLCBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoIWRpc2FibGVkKSB7XG4gICAgICAgIGlmIChlLndoaWNoID09PSAzOCkgeyAvLyB1cFxuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAkc2NvcGUuaW5jcmVtZW50TWludXRlcygpO1xuICAgICAgICAgICRzY29wZS4kYXBwbHkoKTtcbiAgICAgICAgfSBlbHNlIGlmIChlLndoaWNoID09PSA0MCkgeyAvLyBkb3duXG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICRzY29wZS5kZWNyZW1lbnRNaW51dGVzKCk7XG4gICAgICAgICAgJHNjb3BlLiRhcHBseSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBzZWNvbmRzSW5wdXRFbC5vbigna2V5ZG93bicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmICghZGlzYWJsZWQpIHtcbiAgICAgICAgaWYgKGUud2hpY2ggPT09IDM4KSB7IC8vIHVwXG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICRzY29wZS5pbmNyZW1lbnRTZWNvbmRzKCk7XG4gICAgICAgICAgJHNjb3BlLiRhcHBseSgpO1xuICAgICAgICB9IGVsc2UgaWYgKGUud2hpY2ggPT09IDQwKSB7IC8vIGRvd25cbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgJHNjb3BlLmRlY3JlbWVudFNlY29uZHMoKTtcbiAgICAgICAgICAkc2NvcGUuJGFwcGx5KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICB0aGlzLnNldHVwSW5wdXRFdmVudHMgPSBmdW5jdGlvbihob3Vyc0lucHV0RWwsIG1pbnV0ZXNJbnB1dEVsLCBzZWNvbmRzSW5wdXRFbCkge1xuICAgIGlmICgkc2NvcGUucmVhZG9ubHlJbnB1dCkge1xuICAgICAgJHNjb3BlLnVwZGF0ZUhvdXJzID0gYW5ndWxhci5ub29wO1xuICAgICAgJHNjb3BlLnVwZGF0ZU1pbnV0ZXMgPSBhbmd1bGFyLm5vb3A7XG4gICAgICAkc2NvcGUudXBkYXRlU2Vjb25kcyA9IGFuZ3VsYXIubm9vcDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaW52YWxpZGF0ZSA9IGZ1bmN0aW9uKGludmFsaWRIb3VycywgaW52YWxpZE1pbnV0ZXMsIGludmFsaWRTZWNvbmRzKSB7XG4gICAgICBuZ01vZGVsQ3RybC4kc2V0Vmlld1ZhbHVlKG51bGwpO1xuICAgICAgbmdNb2RlbEN0cmwuJHNldFZhbGlkaXR5KCd0aW1lJywgZmFsc2UpO1xuICAgICAgaWYgKGFuZ3VsYXIuaXNEZWZpbmVkKGludmFsaWRIb3VycykpIHtcbiAgICAgICAgJHNjb3BlLmludmFsaWRIb3VycyA9IGludmFsaWRIb3VycztcbiAgICAgICAgaWYgKGhvdXJzTW9kZWxDdHJsKSB7XG4gICAgICAgICAgaG91cnNNb2RlbEN0cmwuJHNldFZhbGlkaXR5KCdob3VycycsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYW5ndWxhci5pc0RlZmluZWQoaW52YWxpZE1pbnV0ZXMpKSB7XG4gICAgICAgICRzY29wZS5pbnZhbGlkTWludXRlcyA9IGludmFsaWRNaW51dGVzO1xuICAgICAgICBpZiAobWludXRlc01vZGVsQ3RybCkge1xuICAgICAgICAgIG1pbnV0ZXNNb2RlbEN0cmwuJHNldFZhbGlkaXR5KCdtaW51dGVzJywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChhbmd1bGFyLmlzRGVmaW5lZChpbnZhbGlkU2Vjb25kcykpIHtcbiAgICAgICAgJHNjb3BlLmludmFsaWRTZWNvbmRzID0gaW52YWxpZFNlY29uZHM7XG4gICAgICAgIGlmIChzZWNvbmRzTW9kZWxDdHJsKSB7XG4gICAgICAgICAgc2Vjb25kc01vZGVsQ3RybC4kc2V0VmFsaWRpdHkoJ3NlY29uZHMnLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgJHNjb3BlLnVwZGF0ZUhvdXJzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaG91cnMgPSBnZXRIb3Vyc0Zyb21UZW1wbGF0ZSgpLFxuICAgICAgICBtaW51dGVzID0gZ2V0TWludXRlc0Zyb21UZW1wbGF0ZSgpO1xuXG4gICAgICBuZ01vZGVsQ3RybC4kc2V0RGlydHkoKTtcblxuICAgICAgaWYgKGFuZ3VsYXIuaXNEZWZpbmVkKGhvdXJzKSAmJiBhbmd1bGFyLmlzRGVmaW5lZChtaW51dGVzKSkge1xuICAgICAgICBzZWxlY3RlZC5zZXRIb3Vycyhob3Vycyk7XG4gICAgICAgIHNlbGVjdGVkLnNldE1pbnV0ZXMobWludXRlcyk7XG4gICAgICAgIGlmIChzZWxlY3RlZCA8IG1pbiB8fCBzZWxlY3RlZCA+IG1heCkge1xuICAgICAgICAgIGludmFsaWRhdGUodHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVmcmVzaCgnaCcpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnZhbGlkYXRlKHRydWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBob3Vyc0lucHV0RWwub24oJ2JsdXInLCBmdW5jdGlvbihlKSB7XG4gICAgICBuZ01vZGVsQ3RybC4kc2V0VG91Y2hlZCgpO1xuICAgICAgaWYgKG1vZGVsSXNFbXB0eSgpKSB7XG4gICAgICAgIG1ha2VWYWxpZCgpO1xuICAgICAgfSBlbHNlIGlmICgkc2NvcGUuaG91cnMgPT09IG51bGwgfHwgJHNjb3BlLmhvdXJzID09PSAnJykge1xuICAgICAgICBpbnZhbGlkYXRlKHRydWUpO1xuICAgICAgfSBlbHNlIGlmICghJHNjb3BlLmludmFsaWRIb3VycyAmJiAkc2NvcGUuaG91cnMgPCAxMCkge1xuICAgICAgICAkc2NvcGUuJGFwcGx5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICRzY29wZS5ob3VycyA9IHBhZCgkc2NvcGUuaG91cnMsICFwYWRIb3Vycyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgJHNjb3BlLnVwZGF0ZU1pbnV0ZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBtaW51dGVzID0gZ2V0TWludXRlc0Zyb21UZW1wbGF0ZSgpLFxuICAgICAgICBob3VycyA9IGdldEhvdXJzRnJvbVRlbXBsYXRlKCk7XG5cbiAgICAgIG5nTW9kZWxDdHJsLiRzZXREaXJ0eSgpO1xuXG4gICAgICBpZiAoYW5ndWxhci5pc0RlZmluZWQobWludXRlcykgJiYgYW5ndWxhci5pc0RlZmluZWQoaG91cnMpKSB7XG4gICAgICAgIHNlbGVjdGVkLnNldEhvdXJzKGhvdXJzKTtcbiAgICAgICAgc2VsZWN0ZWQuc2V0TWludXRlcyhtaW51dGVzKTtcbiAgICAgICAgaWYgKHNlbGVjdGVkIDwgbWluIHx8IHNlbGVjdGVkID4gbWF4KSB7XG4gICAgICAgICAgaW52YWxpZGF0ZSh1bmRlZmluZWQsIHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlZnJlc2goJ20nKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW52YWxpZGF0ZSh1bmRlZmluZWQsIHRydWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBtaW51dGVzSW5wdXRFbC5vbignYmx1cicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIG5nTW9kZWxDdHJsLiRzZXRUb3VjaGVkKCk7XG4gICAgICBpZiAobW9kZWxJc0VtcHR5KCkpIHtcbiAgICAgICAgbWFrZVZhbGlkKCk7XG4gICAgICB9IGVsc2UgaWYgKCRzY29wZS5taW51dGVzID09PSBudWxsKSB7XG4gICAgICAgIGludmFsaWRhdGUodW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoISRzY29wZS5pbnZhbGlkTWludXRlcyAmJiAkc2NvcGUubWludXRlcyA8IDEwKSB7XG4gICAgICAgICRzY29wZS4kYXBwbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgJHNjb3BlLm1pbnV0ZXMgPSBwYWQoJHNjb3BlLm1pbnV0ZXMpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgICRzY29wZS51cGRhdGVTZWNvbmRzID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2Vjb25kcyA9IGdldFNlY29uZHNGcm9tVGVtcGxhdGUoKTtcblxuICAgICAgbmdNb2RlbEN0cmwuJHNldERpcnR5KCk7XG5cbiAgICAgIGlmIChhbmd1bGFyLmlzRGVmaW5lZChzZWNvbmRzKSkge1xuICAgICAgICBzZWxlY3RlZC5zZXRTZWNvbmRzKHNlY29uZHMpO1xuICAgICAgICByZWZyZXNoKCdzJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnZhbGlkYXRlKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgc2Vjb25kc0lucHV0RWwub24oJ2JsdXInLCBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAobW9kZWxJc0VtcHR5KCkpIHtcbiAgICAgICAgbWFrZVZhbGlkKCk7XG4gICAgICB9IGVsc2UgaWYgKCEkc2NvcGUuaW52YWxpZFNlY29uZHMgJiYgJHNjb3BlLnNlY29uZHMgPCAxMCkge1xuICAgICAgICAkc2NvcGUuJGFwcGx5KCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAkc2NvcGUuc2Vjb25kcyA9IHBhZCgkc2NvcGUuc2Vjb25kcyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gIH07XG5cbiAgdGhpcy5yZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGF0ZSA9IG5nTW9kZWxDdHJsLiR2aWV3VmFsdWU7XG5cbiAgICBpZiAoaXNOYU4oZGF0ZSkpIHtcbiAgICAgIG5nTW9kZWxDdHJsLiRzZXRWYWxpZGl0eSgndGltZScsIGZhbHNlKTtcbiAgICAgICRsb2cuZXJyb3IoJ1RpbWVwaWNrZXIgZGlyZWN0aXZlOiBcIm5nLW1vZGVsXCIgdmFsdWUgbXVzdCBiZSBhIERhdGUgb2JqZWN0LCBhIG51bWJlciBvZiBtaWxsaXNlY29uZHMgc2luY2UgMDEuMDEuMTk3MCBvciBhIHN0cmluZyByZXByZXNlbnRpbmcgYW4gUkZDMjgyMiBvciBJU08gODYwMSBkYXRlLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZGF0ZSkge1xuICAgICAgICBzZWxlY3RlZCA9IGRhdGU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxlY3RlZCA8IG1pbiB8fCBzZWxlY3RlZCA+IG1heCkge1xuICAgICAgICBuZ01vZGVsQ3RybC4kc2V0VmFsaWRpdHkoJ3RpbWUnLCBmYWxzZSk7XG4gICAgICAgICRzY29wZS5pbnZhbGlkSG91cnMgPSB0cnVlO1xuICAgICAgICAkc2NvcGUuaW52YWxpZE1pbnV0ZXMgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWFrZVZhbGlkKCk7XG4gICAgICB9XG4gICAgICB1cGRhdGVUZW1wbGF0ZSgpO1xuICAgIH1cbiAgfTtcblxuICAvLyBDYWxsIGludGVybmFsbHkgd2hlbiB3ZSBrbm93IHRoYXQgbW9kZWwgaXMgdmFsaWQuXG4gIGZ1bmN0aW9uIHJlZnJlc2goa2V5Ym9hcmRDaGFuZ2UpIHtcbiAgICBtYWtlVmFsaWQoKTtcbiAgICBuZ01vZGVsQ3RybC4kc2V0Vmlld1ZhbHVlKG5ldyBEYXRlKHNlbGVjdGVkKSk7XG4gICAgdXBkYXRlVGVtcGxhdGUoa2V5Ym9hcmRDaGFuZ2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFrZVZhbGlkKCkge1xuICAgIGlmIChob3Vyc01vZGVsQ3RybCkge1xuICAgICAgaG91cnNNb2RlbEN0cmwuJHNldFZhbGlkaXR5KCdob3VycycsIHRydWUpO1xuICAgIH1cblxuICAgIGlmIChtaW51dGVzTW9kZWxDdHJsKSB7XG4gICAgICBtaW51dGVzTW9kZWxDdHJsLiRzZXRWYWxpZGl0eSgnbWludXRlcycsIHRydWUpO1xuICAgIH1cblxuICAgIGlmIChzZWNvbmRzTW9kZWxDdHJsKSB7XG4gICAgICBzZWNvbmRzTW9kZWxDdHJsLiRzZXRWYWxpZGl0eSgnc2Vjb25kcycsIHRydWUpO1xuICAgIH1cblxuICAgIG5nTW9kZWxDdHJsLiRzZXRWYWxpZGl0eSgndGltZScsIHRydWUpO1xuICAgICRzY29wZS5pbnZhbGlkSG91cnMgPSBmYWxzZTtcbiAgICAkc2NvcGUuaW52YWxpZE1pbnV0ZXMgPSBmYWxzZTtcbiAgICAkc2NvcGUuaW52YWxpZFNlY29uZHMgPSBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVRlbXBsYXRlKGtleWJvYXJkQ2hhbmdlKSB7XG4gICAgaWYgKCFuZ01vZGVsQ3RybC4kbW9kZWxWYWx1ZSkge1xuICAgICAgJHNjb3BlLmhvdXJzID0gbnVsbDtcbiAgICAgICRzY29wZS5taW51dGVzID0gbnVsbDtcbiAgICAgICRzY29wZS5zZWNvbmRzID0gbnVsbDtcbiAgICAgICRzY29wZS5tZXJpZGlhbiA9IG1lcmlkaWFuc1swXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGhvdXJzID0gc2VsZWN0ZWQuZ2V0SG91cnMoKSxcbiAgICAgICAgbWludXRlcyA9IHNlbGVjdGVkLmdldE1pbnV0ZXMoKSxcbiAgICAgICAgc2Vjb25kcyA9IHNlbGVjdGVkLmdldFNlY29uZHMoKTtcblxuICAgICAgaWYgKCRzY29wZS5zaG93TWVyaWRpYW4pIHtcbiAgICAgICAgaG91cnMgPSBob3VycyA9PT0gMCB8fCBob3VycyA9PT0gMTIgPyAxMiA6IGhvdXJzICUgMTI7IC8vIENvbnZlcnQgMjQgdG8gMTIgaG91ciBzeXN0ZW1cbiAgICAgIH1cblxuICAgICAgJHNjb3BlLmhvdXJzID0ga2V5Ym9hcmRDaGFuZ2UgPT09ICdoJyA/IGhvdXJzIDogcGFkKGhvdXJzLCAhcGFkSG91cnMpO1xuICAgICAgaWYgKGtleWJvYXJkQ2hhbmdlICE9PSAnbScpIHtcbiAgICAgICAgJHNjb3BlLm1pbnV0ZXMgPSBwYWQobWludXRlcyk7XG4gICAgICB9XG4gICAgICAkc2NvcGUubWVyaWRpYW4gPSBzZWxlY3RlZC5nZXRIb3VycygpIDwgMTIgPyBtZXJpZGlhbnNbMF0gOiBtZXJpZGlhbnNbMV07XG5cbiAgICAgIGlmIChrZXlib2FyZENoYW5nZSAhPT0gJ3MnKSB7XG4gICAgICAgICRzY29wZS5zZWNvbmRzID0gcGFkKHNlY29uZHMpO1xuICAgICAgfVxuICAgICAgJHNjb3BlLm1lcmlkaWFuID0gc2VsZWN0ZWQuZ2V0SG91cnMoKSA8IDEyID8gbWVyaWRpYW5zWzBdIDogbWVyaWRpYW5zWzFdO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFNlY29uZHNUb1NlbGVjdGVkKHNlY29uZHMpIHtcbiAgICBzZWxlY3RlZCA9IGFkZFNlY29uZHMoc2VsZWN0ZWQsIHNlY29uZHMpO1xuICAgIHJlZnJlc2goKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZE1pbnV0ZXMoc2VsZWN0ZWQsIG1pbnV0ZXMpIHtcbiAgICByZXR1cm4gYWRkU2Vjb25kcyhzZWxlY3RlZCwgbWludXRlcyo2MCk7XG4gIH1cblxuICBmdW5jdGlvbiBhZGRTZWNvbmRzKGRhdGUsIHNlY29uZHMpIHtcbiAgICB2YXIgZHQgPSBuZXcgRGF0ZShkYXRlLmdldFRpbWUoKSArIHNlY29uZHMgKiAxMDAwKTtcbiAgICB2YXIgbmV3RGF0ZSA9IG5ldyBEYXRlKGRhdGUpO1xuICAgIG5ld0RhdGUuc2V0SG91cnMoZHQuZ2V0SG91cnMoKSwgZHQuZ2V0TWludXRlcygpLCBkdC5nZXRTZWNvbmRzKCkpO1xuICAgIHJldHVybiBuZXdEYXRlO1xuICB9XG5cbiAgZnVuY3Rpb24gbW9kZWxJc0VtcHR5KCkge1xuICAgIHJldHVybiAoJHNjb3BlLmhvdXJzID09PSBudWxsIHx8ICRzY29wZS5ob3VycyA9PT0gJycpICYmXG4gICAgICAoJHNjb3BlLm1pbnV0ZXMgPT09IG51bGwgfHwgJHNjb3BlLm1pbnV0ZXMgPT09ICcnKSAmJlxuICAgICAgKCEkc2NvcGUuc2hvd1NlY29uZHMgfHwgJHNjb3BlLnNob3dTZWNvbmRzICYmICgkc2NvcGUuc2Vjb25kcyA9PT0gbnVsbCB8fCAkc2NvcGUuc2Vjb25kcyA9PT0gJycpKTtcbiAgfVxuXG4gICRzY29wZS5zaG93U3Bpbm5lcnMgPSBhbmd1bGFyLmlzRGVmaW5lZCgkYXR0cnMuc2hvd1NwaW5uZXJzKSA/XG4gICAgJHNjb3BlLiRwYXJlbnQuJGV2YWwoJGF0dHJzLnNob3dTcGlubmVycykgOiB0aW1lcGlja2VyQ29uZmlnLnNob3dTcGlubmVycztcblxuICAkc2NvcGUuaW5jcmVtZW50SG91cnMgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoISRzY29wZS5ub0luY3JlbWVudEhvdXJzKCkpIHtcbiAgICAgIGFkZFNlY29uZHNUb1NlbGVjdGVkKGhvdXJTdGVwICogNjAgKiA2MCk7XG4gICAgfVxuICB9O1xuXG4gICRzY29wZS5kZWNyZW1lbnRIb3VycyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghJHNjb3BlLm5vRGVjcmVtZW50SG91cnMoKSkge1xuICAgICAgYWRkU2Vjb25kc1RvU2VsZWN0ZWQoLWhvdXJTdGVwICogNjAgKiA2MCk7XG4gICAgfVxuICB9O1xuXG4gICRzY29wZS5pbmNyZW1lbnRNaW51dGVzID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCEkc2NvcGUubm9JbmNyZW1lbnRNaW51dGVzKCkpIHtcbiAgICAgIGFkZFNlY29uZHNUb1NlbGVjdGVkKG1pbnV0ZVN0ZXAgKiA2MCk7XG4gICAgfVxuICB9O1xuXG4gICRzY29wZS5kZWNyZW1lbnRNaW51dGVzID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCEkc2NvcGUubm9EZWNyZW1lbnRNaW51dGVzKCkpIHtcbiAgICAgIGFkZFNlY29uZHNUb1NlbGVjdGVkKC1taW51dGVTdGVwICogNjApO1xuICAgIH1cbiAgfTtcblxuICAkc2NvcGUuaW5jcmVtZW50U2Vjb25kcyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghJHNjb3BlLm5vSW5jcmVtZW50U2Vjb25kcygpKSB7XG4gICAgICBhZGRTZWNvbmRzVG9TZWxlY3RlZChzZWNvbmRTdGVwKTtcbiAgICB9XG4gIH07XG5cbiAgJHNjb3BlLmRlY3JlbWVudFNlY29uZHMgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoISRzY29wZS5ub0RlY3JlbWVudFNlY29uZHMoKSkge1xuICAgICAgYWRkU2Vjb25kc1RvU2VsZWN0ZWQoLXNlY29uZFN0ZXApO1xuICAgIH1cbiAgfTtcblxuICAkc2NvcGUudG9nZ2xlTWVyaWRpYW4gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgbWludXRlcyA9IGdldE1pbnV0ZXNGcm9tVGVtcGxhdGUoKSxcbiAgICAgICAgaG91cnMgPSBnZXRIb3Vyc0Zyb21UZW1wbGF0ZSgpO1xuXG4gICAgaWYgKCEkc2NvcGUubm9Ub2dnbGVNZXJpZGlhbigpKSB7XG4gICAgICBpZiAoYW5ndWxhci5pc0RlZmluZWQobWludXRlcykgJiYgYW5ndWxhci5pc0RlZmluZWQoaG91cnMpKSB7XG4gICAgICAgIGFkZFNlY29uZHNUb1NlbGVjdGVkKDEyICogNjAgKiAoc2VsZWN0ZWQuZ2V0SG91cnMoKSA8IDEyID8gNjAgOiAtNjApKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICRzY29wZS5tZXJpZGlhbiA9ICRzY29wZS5tZXJpZGlhbiA9PT0gbWVyaWRpYW5zWzBdID8gbWVyaWRpYW5zWzFdIDogbWVyaWRpYW5zWzBdO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAkc2NvcGUuYmx1ciA9IGZ1bmN0aW9uKCkge1xuICAgIG5nTW9kZWxDdHJsLiRzZXRUb3VjaGVkKCk7XG4gIH07XG5cbiAgJHNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICB3aGlsZSAod2F0Y2hlcnMubGVuZ3RoKSB7XG4gICAgICB3YXRjaGVycy5zaGlmdCgpKCk7XG4gICAgfVxuICB9KTtcbn1dKVxuXG4uZGlyZWN0aXZlKCd1aWJUaW1lcGlja2VyJywgWyd1aWJUaW1lcGlja2VyQ29uZmlnJywgZnVuY3Rpb24odWliVGltZXBpY2tlckNvbmZpZykge1xuICByZXR1cm4ge1xuICAgIHJlcXVpcmU6IFsndWliVGltZXBpY2tlcicsICc/Xm5nTW9kZWwnXSxcbiAgICByZXN0cmljdDogJ0EnLFxuICAgIGNvbnRyb2xsZXI6ICdVaWJUaW1lcGlja2VyQ29udHJvbGxlcicsXG4gICAgY29udHJvbGxlckFzOiAndGltZXBpY2tlcicsXG4gICAgc2NvcGU6IHt9LFxuICAgIHRlbXBsYXRlVXJsOiBmdW5jdGlvbihlbGVtZW50LCBhdHRycykge1xuICAgICAgcmV0dXJuIGF0dHJzLnRlbXBsYXRlVXJsIHx8IHVpYlRpbWVwaWNrZXJDb25maWcudGVtcGxhdGVVcmw7XG4gICAgfSxcbiAgICBsaW5rOiBmdW5jdGlvbihzY29wZSwgZWxlbWVudCwgYXR0cnMsIGN0cmxzKSB7XG4gICAgICB2YXIgdGltZXBpY2tlckN0cmwgPSBjdHJsc1swXSwgbmdNb2RlbEN0cmwgPSBjdHJsc1sxXTtcblxuICAgICAgaWYgKG5nTW9kZWxDdHJsKSB7XG4gICAgICAgIHRpbWVwaWNrZXJDdHJsLmluaXQobmdNb2RlbEN0cmwsIGVsZW1lbnQuZmluZCgnaW5wdXQnKSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufV0pO1xuXG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLnR5cGVhaGVhZCcsIFsndWkuYm9vdHN0cmFwLmRlYm91bmNlJywgJ3VpLmJvb3RzdHJhcC5wb3NpdGlvbiddKVxuXG4vKipcbiAqIEEgaGVscGVyIHNlcnZpY2UgdGhhdCBjYW4gcGFyc2UgdHlwZWFoZWFkJ3Mgc3ludGF4IChzdHJpbmcgcHJvdmlkZWQgYnkgdXNlcnMpXG4gKiBFeHRyYWN0ZWQgdG8gYSBzZXBhcmF0ZSBzZXJ2aWNlIGZvciBlYXNlIG9mIHVuaXQgdGVzdGluZ1xuICovXG4gIC5mYWN0b3J5KCd1aWJUeXBlYWhlYWRQYXJzZXInLCBbJyRwYXJzZScsIGZ1bmN0aW9uKCRwYXJzZSkge1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgIDAwMDAwMTExMTExMTEwMDAwMDAwMDAwMDAwMjIyMjIyMjIwMDAwMDAwMDAwMDAwMDAwMzMzMzMzMzMzMzMzMzMzMDAwMDAwMDAwMDA0NDQ0NDQ0NDAwMFxuICAgIHZhciBUWVBFQUhFQURfUkVHRVhQID0gL15cXHMqKFtcXHNcXFNdKz8pKD86XFxzK2FzXFxzKyhbXFxzXFxTXSs/KSk/XFxzK2ZvclxccysoPzooW1xcJFxcd11bXFwkXFx3XFxkXSopKVxccytpblxccysoW1xcc1xcU10rPykkLztcbiAgICByZXR1cm4ge1xuICAgICAgcGFyc2U6IGZ1bmN0aW9uKGlucHV0KSB7XG4gICAgICAgIHZhciBtYXRjaCA9IGlucHV0Lm1hdGNoKFRZUEVBSEVBRF9SRUdFWFApO1xuICAgICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ0V4cGVjdGVkIHR5cGVhaGVhZCBzcGVjaWZpY2F0aW9uIGluIGZvcm0gb2YgXCJfbW9kZWxWYWx1ZV8gKGFzIF9sYWJlbF8pPyBmb3IgX2l0ZW1fIGluIF9jb2xsZWN0aW9uX1wiJyArXG4gICAgICAgICAgICAgICcgYnV0IGdvdCBcIicgKyBpbnB1dCArICdcIi4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaXRlbU5hbWU6IG1hdGNoWzNdLFxuICAgICAgICAgIHNvdXJjZTogJHBhcnNlKG1hdGNoWzRdKSxcbiAgICAgICAgICB2aWV3TWFwcGVyOiAkcGFyc2UobWF0Y2hbMl0gfHwgbWF0Y2hbMV0pLFxuICAgICAgICAgIG1vZGVsTWFwcGVyOiAkcGFyc2UobWF0Y2hbMV0pXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfV0pXG5cbiAgLmNvbnRyb2xsZXIoJ1VpYlR5cGVhaGVhZENvbnRyb2xsZXInLCBbJyRzY29wZScsICckZWxlbWVudCcsICckYXR0cnMnLCAnJGNvbXBpbGUnLCAnJHBhcnNlJywgJyRxJywgJyR0aW1lb3V0JywgJyRkb2N1bWVudCcsICckd2luZG93JywgJyRyb290U2NvcGUnLCAnJCRkZWJvdW5jZScsICckdWliUG9zaXRpb24nLCAndWliVHlwZWFoZWFkUGFyc2VyJyxcbiAgICBmdW5jdGlvbihvcmlnaW5hbFNjb3BlLCBlbGVtZW50LCBhdHRycywgJGNvbXBpbGUsICRwYXJzZSwgJHEsICR0aW1lb3V0LCAkZG9jdW1lbnQsICR3aW5kb3csICRyb290U2NvcGUsICQkZGVib3VuY2UsICRwb3NpdGlvbiwgdHlwZWFoZWFkUGFyc2VyKSB7XG4gICAgdmFyIEhPVF9LRVlTID0gWzksIDEzLCAyNywgMzgsIDQwXTtcbiAgICB2YXIgZXZlbnREZWJvdW5jZVRpbWUgPSAyMDA7XG4gICAgdmFyIG1vZGVsQ3RybCwgbmdNb2RlbE9wdGlvbnM7XG4gICAgLy9TVVBQT1JURUQgQVRUUklCVVRFUyAoT1BUSU9OUylcblxuICAgIC8vbWluaW1hbCBubyBvZiBjaGFyYWN0ZXJzIHRoYXQgbmVlZHMgdG8gYmUgZW50ZXJlZCBiZWZvcmUgdHlwZWFoZWFkIGtpY2tzLWluXG4gICAgdmFyIG1pbkxlbmd0aCA9IG9yaWdpbmFsU2NvcGUuJGV2YWwoYXR0cnMudHlwZWFoZWFkTWluTGVuZ3RoKTtcbiAgICBpZiAoIW1pbkxlbmd0aCAmJiBtaW5MZW5ndGggIT09IDApIHtcbiAgICAgIG1pbkxlbmd0aCA9IDE7XG4gICAgfVxuXG4gICAgb3JpZ2luYWxTY29wZS4kd2F0Y2goYXR0cnMudHlwZWFoZWFkTWluTGVuZ3RoLCBmdW5jdGlvbiAobmV3VmFsKSB7XG4gICAgICAgIG1pbkxlbmd0aCA9ICFuZXdWYWwgJiYgbmV3VmFsICE9PSAwID8gMSA6IG5ld1ZhbDtcbiAgICB9KTtcblxuICAgIC8vbWluaW1hbCB3YWl0IHRpbWUgYWZ0ZXIgbGFzdCBjaGFyYWN0ZXIgdHlwZWQgYmVmb3JlIHR5cGVhaGVhZCBraWNrcy1pblxuICAgIHZhciB3YWl0VGltZSA9IG9yaWdpbmFsU2NvcGUuJGV2YWwoYXR0cnMudHlwZWFoZWFkV2FpdE1zKSB8fCAwO1xuXG4gICAgLy9zaG91bGQgaXQgcmVzdHJpY3QgbW9kZWwgdmFsdWVzIHRvIHRoZSBvbmVzIHNlbGVjdGVkIGZyb20gdGhlIHBvcHVwIG9ubHk/XG4gICAgdmFyIGlzRWRpdGFibGUgPSBvcmlnaW5hbFNjb3BlLiRldmFsKGF0dHJzLnR5cGVhaGVhZEVkaXRhYmxlKSAhPT0gZmFsc2U7XG4gICAgb3JpZ2luYWxTY29wZS4kd2F0Y2goYXR0cnMudHlwZWFoZWFkRWRpdGFibGUsIGZ1bmN0aW9uIChuZXdWYWwpIHtcbiAgICAgIGlzRWRpdGFibGUgPSBuZXdWYWwgIT09IGZhbHNlO1xuICAgIH0pO1xuXG4gICAgLy9iaW5kaW5nIHRvIGEgdmFyaWFibGUgdGhhdCBpbmRpY2F0ZXMgaWYgbWF0Y2hlcyBhcmUgYmVpbmcgcmV0cmlldmVkIGFzeW5jaHJvbm91c2x5XG4gICAgdmFyIGlzTG9hZGluZ1NldHRlciA9ICRwYXJzZShhdHRycy50eXBlYWhlYWRMb2FkaW5nKS5hc3NpZ24gfHwgYW5ndWxhci5ub29wO1xuXG4gICAgLy9hIGZ1bmN0aW9uIHRvIGRldGVybWluZSBpZiBhbiBldmVudCBzaG91bGQgY2F1c2Ugc2VsZWN0aW9uXG4gICAgdmFyIGlzU2VsZWN0RXZlbnQgPSBhdHRycy50eXBlYWhlYWRTaG91bGRTZWxlY3QgPyAkcGFyc2UoYXR0cnMudHlwZWFoZWFkU2hvdWxkU2VsZWN0KSA6IGZ1bmN0aW9uKHNjb3BlLCB2YWxzKSB7XG4gICAgICB2YXIgZXZ0ID0gdmFscy4kZXZlbnQ7XG4gICAgICByZXR1cm4gZXZ0LndoaWNoID09PSAxMyB8fCBldnQud2hpY2ggPT09IDk7XG4gICAgfTtcblxuICAgIC8vYSBjYWxsYmFjayBleGVjdXRlZCB3aGVuIGEgbWF0Y2ggaXMgc2VsZWN0ZWRcbiAgICB2YXIgb25TZWxlY3RDYWxsYmFjayA9ICRwYXJzZShhdHRycy50eXBlYWhlYWRPblNlbGVjdCk7XG5cbiAgICAvL3Nob3VsZCBpdCBzZWxlY3QgaGlnaGxpZ2h0ZWQgcG9wdXAgdmFsdWUgd2hlbiBsb3NpbmcgZm9jdXM/XG4gICAgdmFyIGlzU2VsZWN0T25CbHVyID0gYW5ndWxhci5pc0RlZmluZWQoYXR0cnMudHlwZWFoZWFkU2VsZWN0T25CbHVyKSA/IG9yaWdpbmFsU2NvcGUuJGV2YWwoYXR0cnMudHlwZWFoZWFkU2VsZWN0T25CbHVyKSA6IGZhbHNlO1xuXG4gICAgLy9iaW5kaW5nIHRvIGEgdmFyaWFibGUgdGhhdCBpbmRpY2F0ZXMgaWYgdGhlcmUgd2VyZSBubyByZXN1bHRzIGFmdGVyIHRoZSBxdWVyeSBpcyBjb21wbGV0ZWRcbiAgICB2YXIgaXNOb1Jlc3VsdHNTZXR0ZXIgPSAkcGFyc2UoYXR0cnMudHlwZWFoZWFkTm9SZXN1bHRzKS5hc3NpZ24gfHwgYW5ndWxhci5ub29wO1xuXG4gICAgdmFyIGlucHV0Rm9ybWF0dGVyID0gYXR0cnMudHlwZWFoZWFkSW5wdXRGb3JtYXR0ZXIgPyAkcGFyc2UoYXR0cnMudHlwZWFoZWFkSW5wdXRGb3JtYXR0ZXIpIDogdW5kZWZpbmVkO1xuXG4gICAgdmFyIGFwcGVuZFRvQm9keSA9IGF0dHJzLnR5cGVhaGVhZEFwcGVuZFRvQm9keSA/IG9yaWdpbmFsU2NvcGUuJGV2YWwoYXR0cnMudHlwZWFoZWFkQXBwZW5kVG9Cb2R5KSA6IGZhbHNlO1xuXG4gICAgdmFyIGFwcGVuZFRvID0gYXR0cnMudHlwZWFoZWFkQXBwZW5kVG8gP1xuICAgICAgb3JpZ2luYWxTY29wZS4kZXZhbChhdHRycy50eXBlYWhlYWRBcHBlbmRUbykgOiBudWxsO1xuXG4gICAgdmFyIGZvY3VzRmlyc3QgPSBvcmlnaW5hbFNjb3BlLiRldmFsKGF0dHJzLnR5cGVhaGVhZEZvY3VzRmlyc3QpICE9PSBmYWxzZTtcblxuICAgIC8vSWYgaW5wdXQgbWF0Y2hlcyBhbiBpdGVtIG9mIHRoZSBsaXN0IGV4YWN0bHksIHNlbGVjdCBpdCBhdXRvbWF0aWNhbGx5XG4gICAgdmFyIHNlbGVjdE9uRXhhY3QgPSBhdHRycy50eXBlYWhlYWRTZWxlY3RPbkV4YWN0ID8gb3JpZ2luYWxTY29wZS4kZXZhbChhdHRycy50eXBlYWhlYWRTZWxlY3RPbkV4YWN0KSA6IGZhbHNlO1xuXG4gICAgLy9iaW5kaW5nIHRvIGEgdmFyaWFibGUgdGhhdCBpbmRpY2F0ZXMgaWYgZHJvcGRvd24gaXMgb3BlblxuICAgIHZhciBpc09wZW5TZXR0ZXIgPSAkcGFyc2UoYXR0cnMudHlwZWFoZWFkSXNPcGVuKS5hc3NpZ24gfHwgYW5ndWxhci5ub29wO1xuXG4gICAgdmFyIHNob3dIaW50ID0gb3JpZ2luYWxTY29wZS4kZXZhbChhdHRycy50eXBlYWhlYWRTaG93SGludCkgfHwgZmFsc2U7XG5cbiAgICAvL0lOVEVSTkFMIFZBUklBQkxFU1xuXG4gICAgLy9tb2RlbCBzZXR0ZXIgZXhlY3V0ZWQgdXBvbiBtYXRjaCBzZWxlY3Rpb25cbiAgICB2YXIgcGFyc2VkTW9kZWwgPSAkcGFyc2UoYXR0cnMubmdNb2RlbCk7XG4gICAgdmFyIGludm9rZU1vZGVsU2V0dGVyID0gJHBhcnNlKGF0dHJzLm5nTW9kZWwgKyAnKCQkJHApJyk7XG4gICAgdmFyICRzZXRNb2RlbFZhbHVlID0gZnVuY3Rpb24oc2NvcGUsIG5ld1ZhbHVlKSB7XG4gICAgICBpZiAoYW5ndWxhci5pc0Z1bmN0aW9uKHBhcnNlZE1vZGVsKG9yaWdpbmFsU2NvcGUpKSAmJlxuICAgICAgICBuZ01vZGVsT3B0aW9ucy5nZXRPcHRpb24oJ2dldHRlclNldHRlcicpKSB7XG4gICAgICAgIHJldHVybiBpbnZva2VNb2RlbFNldHRlcihzY29wZSwgeyQkJHA6IG5ld1ZhbHVlfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXJzZWRNb2RlbC5hc3NpZ24oc2NvcGUsIG5ld1ZhbHVlKTtcbiAgICB9O1xuXG4gICAgLy9leHByZXNzaW9ucyB1c2VkIGJ5IHR5cGVhaGVhZFxuICAgIHZhciBwYXJzZXJSZXN1bHQgPSB0eXBlYWhlYWRQYXJzZXIucGFyc2UoYXR0cnMudWliVHlwZWFoZWFkKTtcblxuICAgIHZhciBoYXNGb2N1cztcblxuICAgIC8vVXNlZCB0byBhdm9pZCBidWcgaW4gaU9TIHdlYnZpZXcgd2hlcmUgaU9TIGtleWJvYXJkIGRvZXMgbm90IGZpcmVcbiAgICAvL21vdXNlZG93biAmIG1vdXNldXAgZXZlbnRzXG4gICAgLy9Jc3N1ZSAjMzY5OVxuICAgIHZhciBzZWxlY3RlZDtcblxuICAgIC8vY3JlYXRlIGEgY2hpbGQgc2NvcGUgZm9yIHRoZSB0eXBlYWhlYWQgZGlyZWN0aXZlIHNvIHdlIGFyZSBub3QgcG9sbHV0aW5nIG9yaWdpbmFsIHNjb3BlXG4gICAgLy93aXRoIHR5cGVhaGVhZC1zcGVjaWZpYyBkYXRhIChtYXRjaGVzLCBxdWVyeSBldGMuKVxuICAgIHZhciBzY29wZSA9IG9yaWdpbmFsU2NvcGUuJG5ldygpO1xuICAgIHZhciBvZmZEZXN0cm95ID0gb3JpZ2luYWxTY29wZS4kb24oJyRkZXN0cm95JywgZnVuY3Rpb24oKSB7XG4gICAgICBzY29wZS4kZGVzdHJveSgpO1xuICAgIH0pO1xuICAgIHNjb3BlLiRvbignJGRlc3Ryb3knLCBvZmZEZXN0cm95KTtcblxuICAgIC8vIFdBSS1BUklBXG4gICAgdmFyIHBvcHVwSWQgPSAndHlwZWFoZWFkLScgKyBzY29wZS4kaWQgKyAnLScgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMCk7XG4gICAgZWxlbWVudC5hdHRyKHtcbiAgICAgICdhcmlhLWF1dG9jb21wbGV0ZSc6ICdsaXN0JyxcbiAgICAgICdhcmlhLWV4cGFuZGVkJzogZmFsc2UsXG4gICAgICAnYXJpYS1vd25zJzogcG9wdXBJZFxuICAgIH0pO1xuXG4gICAgdmFyIGlucHV0c0NvbnRhaW5lciwgaGludElucHV0RWxlbTtcbiAgICAvL2FkZCByZWFkLW9ubHkgaW5wdXQgdG8gc2hvdyBoaW50XG4gICAgaWYgKHNob3dIaW50KSB7XG4gICAgICBpbnB1dHNDb250YWluZXIgPSBhbmd1bGFyLmVsZW1lbnQoJzxkaXY+PC9kaXY+Jyk7XG4gICAgICBpbnB1dHNDb250YWluZXIuY3NzKCdwb3NpdGlvbicsICdyZWxhdGl2ZScpO1xuICAgICAgZWxlbWVudC5hZnRlcihpbnB1dHNDb250YWluZXIpO1xuICAgICAgaGludElucHV0RWxlbSA9IGVsZW1lbnQuY2xvbmUoKTtcbiAgICAgIGhpbnRJbnB1dEVsZW0uYXR0cigncGxhY2Vob2xkZXInLCAnJyk7XG4gICAgICBoaW50SW5wdXRFbGVtLmF0dHIoJ3RhYmluZGV4JywgJy0xJyk7XG4gICAgICBoaW50SW5wdXRFbGVtLnZhbCgnJyk7XG4gICAgICBoaW50SW5wdXRFbGVtLmNzcyh7XG4gICAgICAgICdwb3NpdGlvbic6ICdhYnNvbHV0ZScsXG4gICAgICAgICd0b3AnOiAnMHB4JyxcbiAgICAgICAgJ2xlZnQnOiAnMHB4JyxcbiAgICAgICAgJ2JvcmRlci1jb2xvcic6ICd0cmFuc3BhcmVudCcsXG4gICAgICAgICdib3gtc2hhZG93JzogJ25vbmUnLFxuICAgICAgICAnb3BhY2l0eSc6IDEsXG4gICAgICAgICdiYWNrZ3JvdW5kJzogJ25vbmUgMCUgMCUgLyBhdXRvIHJlcGVhdCBzY3JvbGwgcGFkZGluZy1ib3ggYm9yZGVyLWJveCByZ2IoMjU1LCAyNTUsIDI1NSknLFxuICAgICAgICAnY29sb3InOiAnIzk5OSdcbiAgICAgIH0pO1xuICAgICAgZWxlbWVudC5jc3Moe1xuICAgICAgICAncG9zaXRpb24nOiAncmVsYXRpdmUnLFxuICAgICAgICAndmVydGljYWwtYWxpZ24nOiAndG9wJyxcbiAgICAgICAgJ2JhY2tncm91bmQtY29sb3InOiAndHJhbnNwYXJlbnQnXG4gICAgICB9KTtcblxuICAgICAgaWYgKGhpbnRJbnB1dEVsZW0uYXR0cignaWQnKSkge1xuICAgICAgICBoaW50SW5wdXRFbGVtLnJlbW92ZUF0dHIoJ2lkJyk7IC8vIHJlbW92ZSBkdXBsaWNhdGUgaWQgaWYgcHJlc2VudC5cbiAgICAgIH1cbiAgICAgIGlucHV0c0NvbnRhaW5lci5hcHBlbmQoaGludElucHV0RWxlbSk7XG4gICAgICBoaW50SW5wdXRFbGVtLmFmdGVyKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIC8vcG9wLXVwIGVsZW1lbnQgdXNlZCB0byBkaXNwbGF5IG1hdGNoZXNcbiAgICB2YXIgcG9wVXBFbCA9IGFuZ3VsYXIuZWxlbWVudCgnPGRpdiB1aWItdHlwZWFoZWFkLXBvcHVwPjwvZGl2PicpO1xuICAgIHBvcFVwRWwuYXR0cih7XG4gICAgICBpZDogcG9wdXBJZCxcbiAgICAgIG1hdGNoZXM6ICdtYXRjaGVzJyxcbiAgICAgIGFjdGl2ZTogJ2FjdGl2ZUlkeCcsXG4gICAgICBzZWxlY3Q6ICdzZWxlY3QoYWN0aXZlSWR4LCBldnQpJyxcbiAgICAgICdtb3ZlLWluLXByb2dyZXNzJzogJ21vdmVJblByb2dyZXNzJyxcbiAgICAgIHF1ZXJ5OiAncXVlcnknLFxuICAgICAgcG9zaXRpb246ICdwb3NpdGlvbicsXG4gICAgICAnYXNzaWduLWlzLW9wZW4nOiAnYXNzaWduSXNPcGVuKGlzT3BlbiknLFxuICAgICAgZGVib3VuY2U6ICdkZWJvdW5jZVVwZGF0ZSdcbiAgICB9KTtcbiAgICAvL2N1c3RvbSBpdGVtIHRlbXBsYXRlXG4gICAgaWYgKGFuZ3VsYXIuaXNEZWZpbmVkKGF0dHJzLnR5cGVhaGVhZFRlbXBsYXRlVXJsKSkge1xuICAgICAgcG9wVXBFbC5hdHRyKCd0ZW1wbGF0ZS11cmwnLCBhdHRycy50eXBlYWhlYWRUZW1wbGF0ZVVybCk7XG4gICAgfVxuXG4gICAgaWYgKGFuZ3VsYXIuaXNEZWZpbmVkKGF0dHJzLnR5cGVhaGVhZFBvcHVwVGVtcGxhdGVVcmwpKSB7XG4gICAgICBwb3BVcEVsLmF0dHIoJ3BvcHVwLXRlbXBsYXRlLXVybCcsIGF0dHJzLnR5cGVhaGVhZFBvcHVwVGVtcGxhdGVVcmwpO1xuICAgIH1cblxuICAgIHZhciByZXNldEhpbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChzaG93SGludCkge1xuICAgICAgICBoaW50SW5wdXRFbGVtLnZhbCgnJyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciByZXNldE1hdGNoZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHNjb3BlLm1hdGNoZXMgPSBbXTtcbiAgICAgIHNjb3BlLmFjdGl2ZUlkeCA9IC0xO1xuICAgICAgZWxlbWVudC5hdHRyKCdhcmlhLWV4cGFuZGVkJywgZmFsc2UpO1xuICAgICAgcmVzZXRIaW50KCk7XG4gICAgfTtcblxuICAgIHZhciBnZXRNYXRjaElkID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgIHJldHVybiBwb3B1cElkICsgJy1vcHRpb24tJyArIGluZGV4O1xuICAgIH07XG5cbiAgICAvLyBJbmRpY2F0ZSB0aGF0IHRoZSBzcGVjaWZpZWQgbWF0Y2ggaXMgdGhlIGFjdGl2ZSAocHJlLXNlbGVjdGVkKSBpdGVtIGluIHRoZSBsaXN0IG93bmVkIGJ5IHRoaXMgdHlwZWFoZWFkLlxuICAgIC8vIFRoaXMgYXR0cmlidXRlIGlzIGFkZGVkIG9yIHJlbW92ZWQgYXV0b21hdGljYWxseSB3aGVuIHRoZSBgYWN0aXZlSWR4YCBjaGFuZ2VzLlxuICAgIHNjb3BlLiR3YXRjaCgnYWN0aXZlSWR4JywgZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyKCdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQuYXR0cignYXJpYS1hY3RpdmVkZXNjZW5kYW50JywgZ2V0TWF0Y2hJZChpbmRleCkpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIGlucHV0SXNFeGFjdE1hdGNoID0gZnVuY3Rpb24oaW5wdXRWYWx1ZSwgaW5kZXgpIHtcbiAgICAgIGlmIChzY29wZS5tYXRjaGVzLmxlbmd0aCA+IGluZGV4ICYmIGlucHV0VmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0VmFsdWUudG9VcHBlckNhc2UoKSA9PT0gc2NvcGUubWF0Y2hlc1tpbmRleF0ubGFiZWwudG9VcHBlckNhc2UoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0TWF0Y2hlc0FzeW5jID0gZnVuY3Rpb24oaW5wdXRWYWx1ZSwgZXZ0KSB7XG4gICAgICB2YXIgbG9jYWxzID0geyR2aWV3VmFsdWU6IGlucHV0VmFsdWV9O1xuICAgICAgaXNMb2FkaW5nU2V0dGVyKG9yaWdpbmFsU2NvcGUsIHRydWUpO1xuICAgICAgaXNOb1Jlc3VsdHNTZXR0ZXIob3JpZ2luYWxTY29wZSwgZmFsc2UpO1xuICAgICAgJHEud2hlbihwYXJzZXJSZXN1bHQuc291cmNlKG9yaWdpbmFsU2NvcGUsIGxvY2FscykpLnRoZW4oZnVuY3Rpb24obWF0Y2hlcykge1xuICAgICAgICAvL2l0IG1pZ2h0IGhhcHBlbiB0aGF0IHNldmVyYWwgYXN5bmMgcXVlcmllcyB3ZXJlIGluIHByb2dyZXNzIGlmIGEgdXNlciB3ZXJlIHR5cGluZyBmYXN0XG4gICAgICAgIC8vYnV0IHdlIGFyZSBpbnRlcmVzdGVkIG9ubHkgaW4gcmVzcG9uc2VzIHRoYXQgY29ycmVzcG9uZCB0byB0aGUgY3VycmVudCB2aWV3IHZhbHVlXG4gICAgICAgIHZhciBvbkN1cnJlbnRSZXF1ZXN0ID0gaW5wdXRWYWx1ZSA9PT0gbW9kZWxDdHJsLiR2aWV3VmFsdWU7XG4gICAgICAgIGlmIChvbkN1cnJlbnRSZXF1ZXN0ICYmIGhhc0ZvY3VzKSB7XG4gICAgICAgICAgaWYgKG1hdGNoZXMgJiYgbWF0Y2hlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBzY29wZS5hY3RpdmVJZHggPSBmb2N1c0ZpcnN0ID8gMCA6IC0xO1xuICAgICAgICAgICAgaXNOb1Jlc3VsdHNTZXR0ZXIob3JpZ2luYWxTY29wZSwgZmFsc2UpO1xuICAgICAgICAgICAgc2NvcGUubWF0Y2hlcy5sZW5ndGggPSAwO1xuXG4gICAgICAgICAgICAvL3RyYW5zZm9ybSBsYWJlbHNcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWF0Y2hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICBsb2NhbHNbcGFyc2VyUmVzdWx0Lml0ZW1OYW1lXSA9IG1hdGNoZXNbaV07XG4gICAgICAgICAgICAgIHNjb3BlLm1hdGNoZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgaWQ6IGdldE1hdGNoSWQoaSksXG4gICAgICAgICAgICAgICAgbGFiZWw6IHBhcnNlclJlc3VsdC52aWV3TWFwcGVyKHNjb3BlLCBsb2NhbHMpLFxuICAgICAgICAgICAgICAgIG1vZGVsOiBtYXRjaGVzW2ldXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzY29wZS5xdWVyeSA9IGlucHV0VmFsdWU7XG4gICAgICAgICAgICAvL3Bvc2l0aW9uIHBvcC11cCB3aXRoIG1hdGNoZXMgLSB3ZSBuZWVkIHRvIHJlLWNhbGN1bGF0ZSBpdHMgcG9zaXRpb24gZWFjaCB0aW1lIHdlIGFyZSBvcGVuaW5nIGEgd2luZG93XG4gICAgICAgICAgICAvL3dpdGggbWF0Y2hlcyBhcyBhIHBvcC11cCBtaWdodCBiZSBhYnNvbHV0ZS1wb3NpdGlvbmVkIGFuZCBwb3NpdGlvbiBvZiBhbiBpbnB1dCBtaWdodCBoYXZlIGNoYW5nZWQgb24gYSBwYWdlXG4gICAgICAgICAgICAvL2R1ZSB0byBvdGhlciBlbGVtZW50cyBiZWluZyByZW5kZXJlZFxuICAgICAgICAgICAgcmVjYWxjdWxhdGVQb3NpdGlvbigpO1xuXG4gICAgICAgICAgICBlbGVtZW50LmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCB0cnVlKTtcblxuICAgICAgICAgICAgLy9TZWxlY3QgdGhlIHNpbmdsZSByZW1haW5pbmcgb3B0aW9uIGlmIHVzZXIgaW5wdXQgbWF0Y2hlc1xuICAgICAgICAgICAgaWYgKHNlbGVjdE9uRXhhY3QgJiYgc2NvcGUubWF0Y2hlcy5sZW5ndGggPT09IDEgJiYgaW5wdXRJc0V4YWN0TWF0Y2goaW5wdXRWYWx1ZSwgMCkpIHtcbiAgICAgICAgICAgICAgaWYgKGFuZ3VsYXIuaXNOdW1iZXIoc2NvcGUuZGVib3VuY2VVcGRhdGUpIHx8IGFuZ3VsYXIuaXNPYmplY3Qoc2NvcGUuZGVib3VuY2VVcGRhdGUpKSB7XG4gICAgICAgICAgICAgICAgJCRkZWJvdW5jZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgIHNjb3BlLnNlbGVjdCgwLCBldnQpO1xuICAgICAgICAgICAgICAgIH0sIGFuZ3VsYXIuaXNOdW1iZXIoc2NvcGUuZGVib3VuY2VVcGRhdGUpID8gc2NvcGUuZGVib3VuY2VVcGRhdGUgOiBzY29wZS5kZWJvdW5jZVVwZGF0ZVsnZGVmYXVsdCddKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzY29wZS5zZWxlY3QoMCwgZXZ0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2hvd0hpbnQpIHtcbiAgICAgICAgICAgICAgdmFyIGZpcnN0TGFiZWwgPSBzY29wZS5tYXRjaGVzWzBdLmxhYmVsO1xuICAgICAgICAgICAgICBpZiAoYW5ndWxhci5pc1N0cmluZyhpbnB1dFZhbHVlKSAmJlxuICAgICAgICAgICAgICAgIGlucHV0VmFsdWUubGVuZ3RoID4gMCAmJlxuICAgICAgICAgICAgICAgIGZpcnN0TGFiZWwuc2xpY2UoMCwgaW5wdXRWYWx1ZS5sZW5ndGgpLnRvVXBwZXJDYXNlKCkgPT09IGlucHV0VmFsdWUudG9VcHBlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgIGhpbnRJbnB1dEVsZW0udmFsKGlucHV0VmFsdWUgKyBmaXJzdExhYmVsLnNsaWNlKGlucHV0VmFsdWUubGVuZ3RoKSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaGludElucHV0RWxlbS52YWwoJycpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc2V0TWF0Y2hlcygpO1xuICAgICAgICAgICAgaXNOb1Jlc3VsdHNTZXR0ZXIob3JpZ2luYWxTY29wZSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvbkN1cnJlbnRSZXF1ZXN0KSB7XG4gICAgICAgICAgaXNMb2FkaW5nU2V0dGVyKG9yaWdpbmFsU2NvcGUsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlc2V0TWF0Y2hlcygpO1xuICAgICAgICBpc0xvYWRpbmdTZXR0ZXIob3JpZ2luYWxTY29wZSwgZmFsc2UpO1xuICAgICAgICBpc05vUmVzdWx0c1NldHRlcihvcmlnaW5hbFNjb3BlLCB0cnVlKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvLyBiaW5kIGV2ZW50cyBvbmx5IGlmIGFwcGVuZFRvQm9keSBwYXJhbXMgZXhpc3QgLSBwZXJmb3JtYW5jZSBmZWF0dXJlXG4gICAgaWYgKGFwcGVuZFRvQm9keSkge1xuICAgICAgYW5ndWxhci5lbGVtZW50KCR3aW5kb3cpLm9uKCdyZXNpemUnLCBmaXJlUmVjYWxjdWxhdGluZyk7XG4gICAgICAkZG9jdW1lbnQuZmluZCgnYm9keScpLm9uKCdzY3JvbGwnLCBmaXJlUmVjYWxjdWxhdGluZyk7XG4gICAgfVxuXG4gICAgLy8gRGVjbGFyZSB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIG91dHNpZGUgcmVjYWxjdWxhdGluZyBmb3JcbiAgICAvLyBwcm9wZXIgZGVib3VuY2luZ1xuICAgIHZhciBkZWJvdW5jZWRSZWNhbGN1bGF0ZSA9ICQkZGVib3VuY2UoZnVuY3Rpb24oKSB7XG4gICAgICAvLyBpZiBwb3B1cCBpcyB2aXNpYmxlXG4gICAgICBpZiAoc2NvcGUubWF0Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgcmVjYWxjdWxhdGVQb3NpdGlvbigpO1xuICAgICAgfVxuXG4gICAgICBzY29wZS5tb3ZlSW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgIH0sIGV2ZW50RGVib3VuY2VUaW1lKTtcblxuICAgIC8vIERlZmF1bHQgcHJvZ3Jlc3MgdHlwZVxuICAgIHNjb3BlLm1vdmVJblByb2dyZXNzID0gZmFsc2U7XG5cbiAgICBmdW5jdGlvbiBmaXJlUmVjYWxjdWxhdGluZygpIHtcbiAgICAgIGlmICghc2NvcGUubW92ZUluUHJvZ3Jlc3MpIHtcbiAgICAgICAgc2NvcGUubW92ZUluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICBzY29wZS4kZGlnZXN0KCk7XG4gICAgICB9XG5cbiAgICAgIGRlYm91bmNlZFJlY2FsY3VsYXRlKCk7XG4gICAgfVxuXG4gICAgLy8gcmVjYWxjdWxhdGUgYWN0dWFsIHBvc2l0aW9uIGFuZCBzZXQgbmV3IHZhbHVlcyB0byBzY29wZVxuICAgIC8vIGFmdGVyIGRpZ2VzdCBsb29wIGlzIHBvcHVwIGluIHJpZ2h0IHBvc2l0aW9uXG4gICAgZnVuY3Rpb24gcmVjYWxjdWxhdGVQb3NpdGlvbigpIHtcbiAgICAgIHNjb3BlLnBvc2l0aW9uID0gYXBwZW5kVG9Cb2R5ID8gJHBvc2l0aW9uLm9mZnNldChlbGVtZW50KSA6ICRwb3NpdGlvbi5wb3NpdGlvbihlbGVtZW50KTtcbiAgICAgIHNjb3BlLnBvc2l0aW9uLnRvcCArPSBlbGVtZW50LnByb3AoJ29mZnNldEhlaWdodCcpO1xuICAgIH1cblxuICAgIC8vd2UgbmVlZCB0byBwcm9wYWdhdGUgdXNlcidzIHF1ZXJ5IHNvIHdlIGNhbiBoaWdsaWdodCBtYXRjaGVzXG4gICAgc2NvcGUucXVlcnkgPSB1bmRlZmluZWQ7XG5cbiAgICAvL0RlY2xhcmUgdGhlIHRpbWVvdXQgcHJvbWlzZSB2YXIgb3V0c2lkZSB0aGUgZnVuY3Rpb24gc2NvcGUgc28gdGhhdCBzdGFja2VkIGNhbGxzIGNhbiBiZSBjYW5jZWxsZWQgbGF0ZXJcbiAgICB2YXIgdGltZW91dFByb21pc2U7XG5cbiAgICB2YXIgc2NoZWR1bGVTZWFyY2hXaXRoVGltZW91dCA9IGZ1bmN0aW9uKGlucHV0VmFsdWUpIHtcbiAgICAgIHRpbWVvdXRQcm9taXNlID0gJHRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIGdldE1hdGNoZXNBc3luYyhpbnB1dFZhbHVlKTtcbiAgICAgIH0sIHdhaXRUaW1lKTtcbiAgICB9O1xuXG4gICAgdmFyIGNhbmNlbFByZXZpb3VzVGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRpbWVvdXRQcm9taXNlKSB7XG4gICAgICAgICR0aW1lb3V0LmNhbmNlbCh0aW1lb3V0UHJvbWlzZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJlc2V0TWF0Y2hlcygpO1xuXG4gICAgc2NvcGUuYXNzaWduSXNPcGVuID0gZnVuY3Rpb24gKGlzT3Blbikge1xuICAgICAgaXNPcGVuU2V0dGVyKG9yaWdpbmFsU2NvcGUsIGlzT3Blbik7XG4gICAgfTtcblxuICAgIHNjb3BlLnNlbGVjdCA9IGZ1bmN0aW9uKGFjdGl2ZUlkeCwgZXZ0KSB7XG4gICAgICAvL2NhbGxlZCBmcm9tIHdpdGhpbiB0aGUgJGRpZ2VzdCgpIGN5Y2xlXG4gICAgICB2YXIgbG9jYWxzID0ge307XG4gICAgICB2YXIgbW9kZWwsIGl0ZW07XG5cbiAgICAgIHNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgIGxvY2Fsc1twYXJzZXJSZXN1bHQuaXRlbU5hbWVdID0gaXRlbSA9IHNjb3BlLm1hdGNoZXNbYWN0aXZlSWR4XS5tb2RlbDtcbiAgICAgIG1vZGVsID0gcGFyc2VyUmVzdWx0Lm1vZGVsTWFwcGVyKG9yaWdpbmFsU2NvcGUsIGxvY2Fscyk7XG4gICAgICAkc2V0TW9kZWxWYWx1ZShvcmlnaW5hbFNjb3BlLCBtb2RlbCk7XG4gICAgICBtb2RlbEN0cmwuJHNldFZhbGlkaXR5KCdlZGl0YWJsZScsIHRydWUpO1xuICAgICAgbW9kZWxDdHJsLiRzZXRWYWxpZGl0eSgncGFyc2UnLCB0cnVlKTtcblxuICAgICAgb25TZWxlY3RDYWxsYmFjayhvcmlnaW5hbFNjb3BlLCB7XG4gICAgICAgICRpdGVtOiBpdGVtLFxuICAgICAgICAkbW9kZWw6IG1vZGVsLFxuICAgICAgICAkbGFiZWw6IHBhcnNlclJlc3VsdC52aWV3TWFwcGVyKG9yaWdpbmFsU2NvcGUsIGxvY2FscyksXG4gICAgICAgICRldmVudDogZXZ0XG4gICAgICB9KTtcblxuICAgICAgcmVzZXRNYXRjaGVzKCk7XG5cbiAgICAgIC8vcmV0dXJuIGZvY3VzIHRvIHRoZSBpbnB1dCBlbGVtZW50IGlmIGEgbWF0Y2ggd2FzIHNlbGVjdGVkIHZpYSBhIG1vdXNlIGNsaWNrIGV2ZW50XG4gICAgICAvLyB1c2UgdGltZW91dCB0byBhdm9pZCAkcm9vdFNjb3BlOmlucHJvZyBlcnJvclxuICAgICAgaWYgKHNjb3BlLiRldmFsKGF0dHJzLnR5cGVhaGVhZEZvY3VzT25TZWxlY3QpICE9PSBmYWxzZSkge1xuICAgICAgICAkdGltZW91dChmdW5jdGlvbigpIHsgZWxlbWVudFswXS5mb2N1cygpOyB9LCAwLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vYmluZCBrZXlib2FyZCBldmVudHM6IGFycm93cyB1cCgzOCkgLyBkb3duKDQwKSwgZW50ZXIoMTMpIGFuZCB0YWIoOSksIGVzYygyNylcbiAgICBlbGVtZW50Lm9uKCdrZXlkb3duJywgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAvL3R5cGVhaGVhZCBpcyBvcGVuIGFuZCBhbiBcImludGVyZXN0aW5nXCIga2V5IHdhcyBwcmVzc2VkXG4gICAgICBpZiAoc2NvcGUubWF0Y2hlcy5sZW5ndGggPT09IDAgfHwgSE9UX0tFWVMuaW5kZXhPZihldnQud2hpY2gpID09PSAtMSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBzaG91bGRTZWxlY3QgPSBpc1NlbGVjdEV2ZW50KG9yaWdpbmFsU2NvcGUsIHskZXZlbnQ6IGV2dH0pO1xuXG4gICAgICAvKipcbiAgICAgICAqIGlmIHRoZXJlJ3Mgbm90aGluZyBzZWxlY3RlZCAoaS5lLiBmb2N1c0ZpcnN0KSBhbmQgZW50ZXIgb3IgdGFiIGlzIGhpdFxuICAgICAgICogb3JcbiAgICAgICAqIHNoaWZ0ICsgdGFiIGlzIHByZXNzZWQgdG8gYnJpbmcgZm9jdXMgdG8gdGhlIHByZXZpb3VzIGVsZW1lbnRcbiAgICAgICAqIHRoZW4gY2xlYXIgdGhlIHJlc3VsdHNcbiAgICAgICAqL1xuICAgICAgaWYgKHNjb3BlLmFjdGl2ZUlkeCA9PT0gLTEgJiYgc2hvdWxkU2VsZWN0IHx8IGV2dC53aGljaCA9PT0gOSAmJiAhIWV2dC5zaGlmdEtleSkge1xuICAgICAgICByZXNldE1hdGNoZXMoKTtcbiAgICAgICAgc2NvcGUuJGRpZ2VzdCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdmFyIHRhcmdldDtcbiAgICAgIHN3aXRjaCAoZXZ0LndoaWNoKSB7XG4gICAgICAgIGNhc2UgMjc6IC8vIGVzY2FwZVxuICAgICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICAgIHJlc2V0TWF0Y2hlcygpO1xuICAgICAgICAgIG9yaWdpbmFsU2NvcGUuJGRpZ2VzdCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM4OiAvLyB1cCBhcnJvd1xuICAgICAgICAgIHNjb3BlLmFjdGl2ZUlkeCA9IChzY29wZS5hY3RpdmVJZHggPiAwID8gc2NvcGUuYWN0aXZlSWR4IDogc2NvcGUubWF0Y2hlcy5sZW5ndGgpIC0gMTtcbiAgICAgICAgICBzY29wZS4kZGlnZXN0KCk7XG4gICAgICAgICAgdGFyZ2V0ID0gcG9wVXBFbFswXS5xdWVyeVNlbGVjdG9yQWxsKCcudWliLXR5cGVhaGVhZC1tYXRjaCcpW3Njb3BlLmFjdGl2ZUlkeF07XG4gICAgICAgICAgdGFyZ2V0LnBhcmVudE5vZGUuc2Nyb2xsVG9wID0gdGFyZ2V0Lm9mZnNldFRvcDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0MDogLy8gZG93biBhcnJvd1xuICAgICAgICAgIHNjb3BlLmFjdGl2ZUlkeCA9IChzY29wZS5hY3RpdmVJZHggKyAxKSAlIHNjb3BlLm1hdGNoZXMubGVuZ3RoO1xuICAgICAgICAgIHNjb3BlLiRkaWdlc3QoKTtcbiAgICAgICAgICB0YXJnZXQgPSBwb3BVcEVsWzBdLnF1ZXJ5U2VsZWN0b3JBbGwoJy51aWItdHlwZWFoZWFkLW1hdGNoJylbc2NvcGUuYWN0aXZlSWR4XTtcbiAgICAgICAgICB0YXJnZXQucGFyZW50Tm9kZS5zY3JvbGxUb3AgPSB0YXJnZXQub2Zmc2V0VG9wO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmIChzaG91bGRTZWxlY3QpIHtcbiAgICAgICAgICAgIHNjb3BlLiRhcHBseShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgaWYgKGFuZ3VsYXIuaXNOdW1iZXIoc2NvcGUuZGVib3VuY2VVcGRhdGUpIHx8IGFuZ3VsYXIuaXNPYmplY3Qoc2NvcGUuZGVib3VuY2VVcGRhdGUpKSB7XG4gICAgICAgICAgICAgICAgJCRkZWJvdW5jZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgIHNjb3BlLnNlbGVjdChzY29wZS5hY3RpdmVJZHgsIGV2dCk7XG4gICAgICAgICAgICAgICAgfSwgYW5ndWxhci5pc051bWJlcihzY29wZS5kZWJvdW5jZVVwZGF0ZSkgPyBzY29wZS5kZWJvdW5jZVVwZGF0ZSA6IHNjb3BlLmRlYm91bmNlVXBkYXRlWydkZWZhdWx0J10pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNjb3BlLnNlbGVjdChzY29wZS5hY3RpdmVJZHgsIGV2dCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGVsZW1lbnQub24oJ2ZvY3VzJywgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgaGFzRm9jdXMgPSB0cnVlO1xuICAgICAgaWYgKG1pbkxlbmd0aCA9PT0gMCAmJiAhbW9kZWxDdHJsLiR2aWV3VmFsdWUpIHtcbiAgICAgICAgJHRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZ2V0TWF0Y2hlc0FzeW5jKG1vZGVsQ3RybC4kdmlld1ZhbHVlLCBldnQpO1xuICAgICAgICB9LCAwKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGVsZW1lbnQub24oJ2JsdXInLCBmdW5jdGlvbihldnQpIHtcbiAgICAgIGlmIChpc1NlbGVjdE9uQmx1ciAmJiBzY29wZS5tYXRjaGVzLmxlbmd0aCAmJiBzY29wZS5hY3RpdmVJZHggIT09IC0xICYmICFzZWxlY3RlZCkge1xuICAgICAgICBzZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIHNjb3BlLiRhcHBseShmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoYW5ndWxhci5pc09iamVjdChzY29wZS5kZWJvdW5jZVVwZGF0ZSkgJiYgYW5ndWxhci5pc051bWJlcihzY29wZS5kZWJvdW5jZVVwZGF0ZS5ibHVyKSkge1xuICAgICAgICAgICAgJCRkZWJvdW5jZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgc2NvcGUuc2VsZWN0KHNjb3BlLmFjdGl2ZUlkeCwgZXZ0KTtcbiAgICAgICAgICAgIH0sIHNjb3BlLmRlYm91bmNlVXBkYXRlLmJsdXIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzY29wZS5zZWxlY3Qoc2NvcGUuYWN0aXZlSWR4LCBldnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoIWlzRWRpdGFibGUgJiYgbW9kZWxDdHJsLiRlcnJvci5lZGl0YWJsZSkge1xuICAgICAgICBtb2RlbEN0cmwuJHNldFZpZXdWYWx1ZSgpO1xuICAgICAgICBzY29wZS4kYXBwbHkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgLy8gUmVzZXQgdmFsaWRpdHkgYXMgd2UgYXJlIGNsZWFyaW5nXG4gICAgICAgICAgbW9kZWxDdHJsLiRzZXRWYWxpZGl0eSgnZWRpdGFibGUnLCB0cnVlKTtcbiAgICAgICAgICBtb2RlbEN0cmwuJHNldFZhbGlkaXR5KCdwYXJzZScsIHRydWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgZWxlbWVudC52YWwoJycpO1xuICAgICAgfVxuICAgICAgaGFzRm9jdXMgPSBmYWxzZTtcbiAgICAgIHNlbGVjdGVkID0gZmFsc2U7XG4gICAgfSk7XG5cbiAgICAvLyBLZWVwIHJlZmVyZW5jZSB0byBjbGljayBoYW5kbGVyIHRvIHVuYmluZCBpdC5cbiAgICB2YXIgZGlzbWlzc0NsaWNrSGFuZGxlciA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgLy8gSXNzdWUgIzM5NzNcbiAgICAgIC8vIEZpcmVmb3ggdHJlYXRzIHJpZ2h0IGNsaWNrIGFzIGEgY2xpY2sgb24gZG9jdW1lbnRcbiAgICAgIGlmIChlbGVtZW50WzBdICE9PSBldnQudGFyZ2V0ICYmIGV2dC53aGljaCAhPT0gMyAmJiBzY29wZS5tYXRjaGVzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICByZXNldE1hdGNoZXMoKTtcbiAgICAgICAgaWYgKCEkcm9vdFNjb3BlLiQkcGhhc2UpIHtcbiAgICAgICAgICBvcmlnaW5hbFNjb3BlLiRkaWdlc3QoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICAkZG9jdW1lbnQub24oJ2NsaWNrJywgZGlzbWlzc0NsaWNrSGFuZGxlcik7XG5cbiAgICBvcmlnaW5hbFNjb3BlLiRvbignJGRlc3Ryb3knLCBmdW5jdGlvbigpIHtcbiAgICAgICRkb2N1bWVudC5vZmYoJ2NsaWNrJywgZGlzbWlzc0NsaWNrSGFuZGxlcik7XG4gICAgICBpZiAoYXBwZW5kVG9Cb2R5IHx8IGFwcGVuZFRvKSB7XG4gICAgICAgICRwb3B1cC5yZW1vdmUoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFwcGVuZFRvQm9keSkge1xuICAgICAgICBhbmd1bGFyLmVsZW1lbnQoJHdpbmRvdykub2ZmKCdyZXNpemUnLCBmaXJlUmVjYWxjdWxhdGluZyk7XG4gICAgICAgICRkb2N1bWVudC5maW5kKCdib2R5Jykub2ZmKCdzY3JvbGwnLCBmaXJlUmVjYWxjdWxhdGluZyk7XG4gICAgICB9XG4gICAgICAvLyBQcmV2ZW50IGpRdWVyeSBjYWNoZSBtZW1vcnkgbGVha1xuICAgICAgcG9wVXBFbC5yZW1vdmUoKTtcblxuICAgICAgaWYgKHNob3dIaW50KSB7XG4gICAgICAgICAgaW5wdXRzQ29udGFpbmVyLnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyICRwb3B1cCA9ICRjb21waWxlKHBvcFVwRWwpKHNjb3BlKTtcblxuICAgIGlmIChhcHBlbmRUb0JvZHkpIHtcbiAgICAgICRkb2N1bWVudC5maW5kKCdib2R5JykuYXBwZW5kKCRwb3B1cCk7XG4gICAgfSBlbHNlIGlmIChhcHBlbmRUbykge1xuICAgICAgYW5ndWxhci5lbGVtZW50KGFwcGVuZFRvKS5lcSgwKS5hcHBlbmQoJHBvcHVwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5hZnRlcigkcG9wdXApO1xuICAgIH1cblxuICAgIHRoaXMuaW5pdCA9IGZ1bmN0aW9uKF9tb2RlbEN0cmwpIHtcbiAgICAgIG1vZGVsQ3RybCA9IF9tb2RlbEN0cmw7XG4gICAgICBuZ01vZGVsT3B0aW9ucyA9IGV4dHJhY3RPcHRpb25zKG1vZGVsQ3RybCk7XG5cbiAgICAgIHNjb3BlLmRlYm91bmNlVXBkYXRlID0gJHBhcnNlKG5nTW9kZWxPcHRpb25zLmdldE9wdGlvbignZGVib3VuY2UnKSkob3JpZ2luYWxTY29wZSk7XG5cbiAgICAgIC8vcGx1ZyBpbnRvICRwYXJzZXJzIHBpcGVsaW5lIHRvIG9wZW4gYSB0eXBlYWhlYWQgb24gdmlldyBjaGFuZ2VzIGluaXRpYXRlZCBmcm9tIERPTVxuICAgICAgLy8kcGFyc2VycyBraWNrLWluIG9uIGFsbCB0aGUgY2hhbmdlcyBjb21pbmcgZnJvbSB0aGUgdmlldyBhcyB3ZWxsIGFzIG1hbnVhbGx5IHRyaWdnZXJlZCBieSAkc2V0Vmlld1ZhbHVlXG4gICAgICBtb2RlbEN0cmwuJHBhcnNlcnMudW5zaGlmdChmdW5jdGlvbihpbnB1dFZhbHVlKSB7XG4gICAgICAgIGhhc0ZvY3VzID0gdHJ1ZTtcblxuICAgICAgICBpZiAobWluTGVuZ3RoID09PSAwIHx8IGlucHV0VmFsdWUgJiYgaW5wdXRWYWx1ZS5sZW5ndGggPj0gbWluTGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKHdhaXRUaW1lID4gMCkge1xuICAgICAgICAgICAgY2FuY2VsUHJldmlvdXNUaW1lb3V0KCk7XG4gICAgICAgICAgICBzY2hlZHVsZVNlYXJjaFdpdGhUaW1lb3V0KGlucHV0VmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnZXRNYXRjaGVzQXN5bmMoaW5wdXRWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlzTG9hZGluZ1NldHRlcihvcmlnaW5hbFNjb3BlLCBmYWxzZSk7XG4gICAgICAgICAgY2FuY2VsUHJldmlvdXNUaW1lb3V0KCk7XG4gICAgICAgICAgcmVzZXRNYXRjaGVzKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNFZGl0YWJsZSkge1xuICAgICAgICAgIHJldHVybiBpbnB1dFZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpbnB1dFZhbHVlKSB7XG4gICAgICAgICAgLy8gUmVzZXQgaW4gY2FzZSB1c2VyIGhhZCB0eXBlZCBzb21ldGhpbmcgcHJldmlvdXNseS5cbiAgICAgICAgICBtb2RlbEN0cmwuJHNldFZhbGlkaXR5KCdlZGl0YWJsZScsIHRydWUpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgbW9kZWxDdHJsLiRzZXRWYWxpZGl0eSgnZWRpdGFibGUnLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9KTtcblxuICAgICAgbW9kZWxDdHJsLiRmb3JtYXR0ZXJzLnB1c2goZnVuY3Rpb24obW9kZWxWYWx1ZSkge1xuICAgICAgICB2YXIgY2FuZGlkYXRlVmlld1ZhbHVlLCBlbXB0eVZpZXdWYWx1ZTtcbiAgICAgICAgdmFyIGxvY2FscyA9IHt9O1xuXG4gICAgICAgIC8vIFRoZSB2YWxpZGl0eSBtYXkgYmUgc2V0IHRvIGZhbHNlIHZpYSAkcGFyc2VycyAoc2VlIGFib3ZlKSBpZlxuICAgICAgICAvLyB0aGUgbW9kZWwgaXMgcmVzdHJpY3RlZCB0byBzZWxlY3RlZCB2YWx1ZXMuIElmIHRoZSBtb2RlbFxuICAgICAgICAvLyBpcyBzZXQgbWFudWFsbHkgaXQgaXMgY29uc2lkZXJlZCB0byBiZSB2YWxpZC5cbiAgICAgICAgaWYgKCFpc0VkaXRhYmxlKSB7XG4gICAgICAgICAgbW9kZWxDdHJsLiRzZXRWYWxpZGl0eSgnZWRpdGFibGUnLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbnB1dEZvcm1hdHRlcikge1xuICAgICAgICAgIGxvY2Fscy4kbW9kZWwgPSBtb2RlbFZhbHVlO1xuICAgICAgICAgIHJldHVybiBpbnB1dEZvcm1hdHRlcihvcmlnaW5hbFNjb3BlLCBsb2NhbHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9pdCBtaWdodCBoYXBwZW4gdGhhdCB3ZSBkb24ndCBoYXZlIGVub3VnaCBpbmZvIHRvIHByb3Blcmx5IHJlbmRlciBpbnB1dCB2YWx1ZVxuICAgICAgICAvL3dlIG5lZWQgdG8gY2hlY2sgZm9yIHRoaXMgc2l0dWF0aW9uIGFuZCBzaW1wbHkgcmV0dXJuIG1vZGVsIHZhbHVlIGlmIHdlIGNhbid0IGFwcGx5IGN1c3RvbSBmb3JtYXR0aW5nXG4gICAgICAgIGxvY2Fsc1twYXJzZXJSZXN1bHQuaXRlbU5hbWVdID0gbW9kZWxWYWx1ZTtcbiAgICAgICAgY2FuZGlkYXRlVmlld1ZhbHVlID0gcGFyc2VyUmVzdWx0LnZpZXdNYXBwZXIob3JpZ2luYWxTY29wZSwgbG9jYWxzKTtcbiAgICAgICAgbG9jYWxzW3BhcnNlclJlc3VsdC5pdGVtTmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIGVtcHR5Vmlld1ZhbHVlID0gcGFyc2VyUmVzdWx0LnZpZXdNYXBwZXIob3JpZ2luYWxTY29wZSwgbG9jYWxzKTtcblxuICAgICAgICByZXR1cm4gY2FuZGlkYXRlVmlld1ZhbHVlICE9PSBlbXB0eVZpZXdWYWx1ZSA/IGNhbmRpZGF0ZVZpZXdWYWx1ZSA6IG1vZGVsVmFsdWU7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gZXh0cmFjdE9wdGlvbnMobmdNb2RlbEN0cmwpIHtcbiAgICAgIHZhciBuZ01vZGVsT3B0aW9ucztcblxuICAgICAgaWYgKGFuZ3VsYXIudmVyc2lvbi5taW5vciA8IDYpIHsgLy8gaW4gYW5ndWxhciA8IDEuNiAkb3B0aW9ucyBjb3VsZCBiZSBtaXNzaW5nXG4gICAgICAgIC8vIGd1YXJhbnRlZSBhIHZhbHVlXG4gICAgICAgIG5nTW9kZWxPcHRpb25zID0gbmdNb2RlbEN0cmwuJG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgLy8gbWltaWMgMS42KyBhcGlcbiAgICAgICAgbmdNb2RlbE9wdGlvbnMuZ2V0T3B0aW9uID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIHJldHVybiBuZ01vZGVsT3B0aW9uc1trZXldO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHsgLy8gaW4gYW5ndWxhciA+PTEuNiAkb3B0aW9ucyBpcyBhbHdheXMgcHJlc2VudFxuICAgICAgICBuZ01vZGVsT3B0aW9ucyA9IG5nTW9kZWxDdHJsLiRvcHRpb25zO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmdNb2RlbE9wdGlvbnM7XG4gICAgfVxuICB9XSlcblxuICAuZGlyZWN0aXZlKCd1aWJUeXBlYWhlYWQnLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29udHJvbGxlcjogJ1VpYlR5cGVhaGVhZENvbnRyb2xsZXInLFxuICAgICAgcmVxdWlyZTogWyduZ01vZGVsJywgJ3VpYlR5cGVhaGVhZCddLFxuICAgICAgbGluazogZnVuY3Rpb24ob3JpZ2luYWxTY29wZSwgZWxlbWVudCwgYXR0cnMsIGN0cmxzKSB7XG4gICAgICAgIGN0cmxzWzFdLmluaXQoY3RybHNbMF0pO1xuICAgICAgfVxuICAgIH07XG4gIH0pXG5cbiAgLmRpcmVjdGl2ZSgndWliVHlwZWFoZWFkUG9wdXAnLCBbJyQkZGVib3VuY2UnLCBmdW5jdGlvbigkJGRlYm91bmNlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNjb3BlOiB7XG4gICAgICAgIG1hdGNoZXM6ICc9JyxcbiAgICAgICAgcXVlcnk6ICc9JyxcbiAgICAgICAgYWN0aXZlOiAnPScsXG4gICAgICAgIHBvc2l0aW9uOiAnJicsXG4gICAgICAgIG1vdmVJblByb2dyZXNzOiAnPScsXG4gICAgICAgIHNlbGVjdDogJyYnLFxuICAgICAgICBhc3NpZ25Jc09wZW46ICcmJyxcbiAgICAgICAgZGVib3VuY2U6ICcmJ1xuICAgICAgfSxcbiAgICAgIHJlcGxhY2U6IHRydWUsXG4gICAgICB0ZW1wbGF0ZVVybDogZnVuY3Rpb24oZWxlbWVudCwgYXR0cnMpIHtcbiAgICAgICAgcmV0dXJuIGF0dHJzLnBvcHVwVGVtcGxhdGVVcmwgfHwgJ3VpYi90ZW1wbGF0ZS90eXBlYWhlYWQvdHlwZWFoZWFkLXBvcHVwLmh0bWwnO1xuICAgICAgfSxcbiAgICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycykge1xuICAgICAgICBzY29wZS50ZW1wbGF0ZVVybCA9IGF0dHJzLnRlbXBsYXRlVXJsO1xuXG4gICAgICAgIHNjb3BlLmlzT3BlbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBpc0Ryb3Bkb3duT3BlbiA9IHNjb3BlLm1hdGNoZXMubGVuZ3RoID4gMDtcbiAgICAgICAgICBzY29wZS5hc3NpZ25Jc09wZW4oeyBpc09wZW46IGlzRHJvcGRvd25PcGVuIH0pO1xuICAgICAgICAgIHJldHVybiBpc0Ryb3Bkb3duT3BlbjtcbiAgICAgICAgfTtcblxuICAgICAgICBzY29wZS5pc0FjdGl2ZSA9IGZ1bmN0aW9uKG1hdGNoSWR4KSB7XG4gICAgICAgICAgcmV0dXJuIHNjb3BlLmFjdGl2ZSA9PT0gbWF0Y2hJZHg7XG4gICAgICAgIH07XG5cbiAgICAgICAgc2NvcGUuc2VsZWN0QWN0aXZlID0gZnVuY3Rpb24obWF0Y2hJZHgpIHtcbiAgICAgICAgICBzY29wZS5hY3RpdmUgPSBtYXRjaElkeDtcbiAgICAgICAgfTtcblxuICAgICAgICBzY29wZS5zZWxlY3RNYXRjaCA9IGZ1bmN0aW9uKGFjdGl2ZUlkeCwgZXZ0KSB7XG4gICAgICAgICAgdmFyIGRlYm91bmNlID0gc2NvcGUuZGVib3VuY2UoKTtcbiAgICAgICAgICBpZiAoYW5ndWxhci5pc051bWJlcihkZWJvdW5jZSkgfHwgYW5ndWxhci5pc09iamVjdChkZWJvdW5jZSkpIHtcbiAgICAgICAgICAgICQkZGVib3VuY2UoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHNjb3BlLnNlbGVjdCh7YWN0aXZlSWR4OiBhY3RpdmVJZHgsIGV2dDogZXZ0fSk7XG4gICAgICAgICAgICB9LCBhbmd1bGFyLmlzTnVtYmVyKGRlYm91bmNlKSA/IGRlYm91bmNlIDogZGVib3VuY2VbJ2RlZmF1bHQnXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNjb3BlLnNlbGVjdCh7YWN0aXZlSWR4OiBhY3RpdmVJZHgsIGV2dDogZXZ0fSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH1dKVxuXG4gIC5kaXJlY3RpdmUoJ3VpYlR5cGVhaGVhZE1hdGNoJywgWyckdGVtcGxhdGVSZXF1ZXN0JywgJyRjb21waWxlJywgJyRwYXJzZScsIGZ1bmN0aW9uKCR0ZW1wbGF0ZVJlcXVlc3QsICRjb21waWxlLCAkcGFyc2UpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2NvcGU6IHtcbiAgICAgICAgaW5kZXg6ICc9JyxcbiAgICAgICAgbWF0Y2g6ICc9JyxcbiAgICAgICAgcXVlcnk6ICc9J1xuICAgICAgfSxcbiAgICAgIGxpbms6IGZ1bmN0aW9uKHNjb3BlLCBlbGVtZW50LCBhdHRycykge1xuICAgICAgICB2YXIgdHBsVXJsID0gJHBhcnNlKGF0dHJzLnRlbXBsYXRlVXJsKShzY29wZS4kcGFyZW50KSB8fCAndWliL3RlbXBsYXRlL3R5cGVhaGVhZC90eXBlYWhlYWQtbWF0Y2guaHRtbCc7XG4gICAgICAgICR0ZW1wbGF0ZVJlcXVlc3QodHBsVXJsKS50aGVuKGZ1bmN0aW9uKHRwbENvbnRlbnQpIHtcbiAgICAgICAgICB2YXIgdHBsRWwgPSBhbmd1bGFyLmVsZW1lbnQodHBsQ29udGVudC50cmltKCkpO1xuICAgICAgICAgIGVsZW1lbnQucmVwbGFjZVdpdGgodHBsRWwpO1xuICAgICAgICAgICRjb21waWxlKHRwbEVsKShzY29wZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH1dKVxuXG4gIC5maWx0ZXIoJ3VpYlR5cGVhaGVhZEhpZ2hsaWdodCcsIFsnJHNjZScsICckaW5qZWN0b3InLCAnJGxvZycsIGZ1bmN0aW9uKCRzY2UsICRpbmplY3RvciwgJGxvZykge1xuICAgIHZhciBpc1Nhbml0aXplUHJlc2VudDtcbiAgICBpc1Nhbml0aXplUHJlc2VudCA9ICRpbmplY3Rvci5oYXMoJyRzYW5pdGl6ZScpO1xuXG4gICAgZnVuY3Rpb24gZXNjYXBlUmVnZXhwKHF1ZXJ5VG9Fc2NhcGUpIHtcbiAgICAgIC8vIFJlZ2V4OiBjYXB0dXJlIHRoZSB3aG9sZSBxdWVyeSBzdHJpbmcgYW5kIHJlcGxhY2UgaXQgd2l0aCB0aGUgc3RyaW5nIHRoYXQgd2lsbCBiZSB1c2VkIHRvIG1hdGNoXG4gICAgICAvLyB0aGUgcmVzdWx0cywgZm9yIGV4YW1wbGUgaWYgdGhlIGNhcHR1cmUgaXMgXCJhXCIgdGhlIHJlc3VsdCB3aWxsIGJlIFxcYVxuICAgICAgcmV0dXJuIHF1ZXJ5VG9Fc2NhcGUucmVwbGFjZSgvKFsuPyorXiRbXFxdXFxcXCgpe318LV0pL2csICdcXFxcJDEnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb250YWluc0h0bWwobWF0Y2hJdGVtKSB7XG4gICAgICByZXR1cm4gLzwuKj4vZy50ZXN0KG1hdGNoSXRlbSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKG1hdGNoSXRlbSwgcXVlcnkpIHtcbiAgICAgIGlmICghaXNTYW5pdGl6ZVByZXNlbnQgJiYgY29udGFpbnNIdG1sKG1hdGNoSXRlbSkpIHtcbiAgICAgICAgJGxvZy53YXJuKCdVbnNhZmUgdXNlIG9mIHR5cGVhaGVhZCBwbGVhc2UgdXNlIG5nU2FuaXRpemUnKTsgLy8gV2FybiB0aGUgdXNlciBhYm91dCB0aGUgZGFuZ2VyXG4gICAgICB9XG4gICAgICBtYXRjaEl0ZW0gPSBxdWVyeSA/ICgnJyArIG1hdGNoSXRlbSkucmVwbGFjZShuZXcgUmVnRXhwKGVzY2FwZVJlZ2V4cChxdWVyeSksICdnaScpLCAnPHN0cm9uZz4kJjwvc3Ryb25nPicpIDogbWF0Y2hJdGVtOyAvLyBSZXBsYWNlcyB0aGUgY2FwdHVyZSBzdHJpbmcgd2l0aCBhIHRoZSBzYW1lIHN0cmluZyBpbnNpZGUgb2YgYSBcInN0cm9uZ1wiIHRhZ1xuICAgICAgaWYgKCFpc1Nhbml0aXplUHJlc2VudCkge1xuICAgICAgICBtYXRjaEl0ZW0gPSAkc2NlLnRydXN0QXNIdG1sKG1hdGNoSXRlbSk7IC8vIElmICRzYW5pdGl6ZSBpcyBub3QgcHJlc2VudCB3ZSBwYWNrIHRoZSBzdHJpbmcgaW4gYSAkc2NlIG9iamVjdCBmb3IgdGhlIG5nLWJpbmQtaHRtbCBkaXJlY3RpdmVcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRjaEl0ZW07XG4gICAgfTtcbiAgfV0pO1xuXG5hbmd1bGFyLm1vZHVsZShcInVpYi90ZW1wbGF0ZS9hY2NvcmRpb24vYWNjb3JkaW9uLWdyb3VwLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbiAoJHRlbXBsYXRlQ2FjaGUpIHtcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidWliL3RlbXBsYXRlL2FjY29yZGlvbi9hY2NvcmRpb24tZ3JvdXAuaHRtbFwiLFxuICAgIFwiPGRpdiByb2xlPVxcXCJ0YWJcXFwiIGlkPVxcXCJ7ezo6aGVhZGluZ0lkfX1cXFwiIGFyaWEtc2VsZWN0ZWQ9XFxcInt7aXNPcGVufX1cXFwiIGNsYXNzPVxcXCJwYW5lbC1oZWFkaW5nXFxcIiBuZy1rZXlwcmVzcz1cXFwidG9nZ2xlT3BlbigkZXZlbnQpXFxcIj5cXG5cIiArXG4gICAgXCIgIDxoNCBjbGFzcz1cXFwicGFuZWwtdGl0bGVcXFwiPlxcblwiICtcbiAgICBcIiAgICA8YSByb2xlPVxcXCJidXR0b25cXFwiIGRhdGEtdG9nZ2xlPVxcXCJjb2xsYXBzZVxcXCIgaHJlZiBhcmlhLWV4cGFuZGVkPVxcXCJ7e2lzT3Blbn19XFxcIiBhcmlhLWNvbnRyb2xzPVxcXCJ7ezo6cGFuZWxJZH19XFxcIiB0YWJpbmRleD1cXFwiMFxcXCIgY2xhc3M9XFxcImFjY29yZGlvbi10b2dnbGVcXFwiIG5nLWNsaWNrPVxcXCJ0b2dnbGVPcGVuKClcXFwiIHVpYi1hY2NvcmRpb24tdHJhbnNjbHVkZT1cXFwiaGVhZGluZ1xcXCIgbmctZGlzYWJsZWQ9XFxcImlzRGlzYWJsZWRcXFwiIHVpYi10YWJpbmRleC10b2dnbGU+PHNwYW4gdWliLWFjY29yZGlvbi1oZWFkZXIgbmctY2xhc3M9XFxcInsndGV4dC1tdXRlZCc6IGlzRGlzYWJsZWR9XFxcIj57e2hlYWRpbmd9fTwvc3Bhbj48L2E+XFxuXCIgK1xuICAgIFwiICA8L2g0PlxcblwiICtcbiAgICBcIjwvZGl2PlxcblwiICtcbiAgICBcIjxkaXYgaWQ9XFxcInt7OjpwYW5lbElkfX1cXFwiIGFyaWEtbGFiZWxsZWRieT1cXFwie3s6OmhlYWRpbmdJZH19XFxcIiBhcmlhLWhpZGRlbj1cXFwie3shaXNPcGVufX1cXFwiIHJvbGU9XFxcInRhYnBhbmVsXFxcIiBjbGFzcz1cXFwicGFuZWwtY29sbGFwc2UgY29sbGFwc2VcXFwiIHVpYi1jb2xsYXBzZT1cXFwiIWlzT3BlblxcXCI+XFxuXCIgK1xuICAgIFwiICA8ZGl2IGNsYXNzPVxcXCJwYW5lbC1ib2R5XFxcIiBuZy10cmFuc2NsdWRlPjwvZGl2PlxcblwiICtcbiAgICBcIjwvZGl2PlxcblwiICtcbiAgICBcIlwiKTtcbn1dKTtcblxuYW5ndWxhci5tb2R1bGUoXCJ1aWIvdGVtcGxhdGUvYWNjb3JkaW9uL2FjY29yZGlvbi5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24gKCR0ZW1wbGF0ZUNhY2hlKSB7XG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInVpYi90ZW1wbGF0ZS9hY2NvcmRpb24vYWNjb3JkaW9uLmh0bWxcIixcbiAgICBcIjxkaXYgcm9sZT1cXFwidGFibGlzdFxcXCIgY2xhc3M9XFxcInBhbmVsLWdyb3VwXFxcIiBuZy10cmFuc2NsdWRlPjwvZGl2PlwiKTtcbn1dKTtcblxuYW5ndWxhci5tb2R1bGUoXCJ1aWIvdGVtcGxhdGUvYWxlcnQvYWxlcnQuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uICgkdGVtcGxhdGVDYWNoZSkge1xuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ1aWIvdGVtcGxhdGUvYWxlcnQvYWxlcnQuaHRtbFwiLFxuICAgIFwiPGJ1dHRvbiBuZy1zaG93PVxcXCJjbG9zZWFibGVcXFwiIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImNsb3NlXFxcIiBuZy1jbGljaz1cXFwiY2xvc2UoeyRldmVudDogJGV2ZW50fSlcXFwiPlxcblwiICtcbiAgICBcIiAgPHNwYW4gYXJpYS1oaWRkZW49XFxcInRydWVcXFwiPiZ0aW1lczs8L3NwYW4+XFxuXCIgK1xuICAgIFwiICA8c3BhbiBjbGFzcz1cXFwic3Itb25seVxcXCI+Q2xvc2U8L3NwYW4+XFxuXCIgK1xuICAgIFwiPC9idXR0b24+XFxuXCIgK1xuICAgIFwiPGRpdiBuZy10cmFuc2NsdWRlPjwvZGl2PlxcblwiICtcbiAgICBcIlwiKTtcbn1dKTtcblxuYW5ndWxhci5tb2R1bGUoXCJ1aWIvdGVtcGxhdGUvY2Fyb3VzZWwvY2Fyb3VzZWwuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uICgkdGVtcGxhdGVDYWNoZSkge1xuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ1aWIvdGVtcGxhdGUvY2Fyb3VzZWwvY2Fyb3VzZWwuaHRtbFwiLFxuICAgIFwiPGRpdiBjbGFzcz1cXFwiY2Fyb3VzZWwtaW5uZXJcXFwiIG5nLXRyYW5zY2x1ZGU+PC9kaXY+XFxuXCIgK1xuICAgIFwiPGEgcm9sZT1cXFwiYnV0dG9uXFxcIiBocmVmIGNsYXNzPVxcXCJsZWZ0IGNhcm91c2VsLWNvbnRyb2xcXFwiIG5nLWNsaWNrPVxcXCJwcmV2KClcXFwiIG5nLWNsYXNzPVxcXCJ7IGRpc2FibGVkOiBpc1ByZXZEaXNhYmxlZCgpIH1cXFwiIG5nLXNob3c9XFxcInNsaWRlcy5sZW5ndGggPiAxXFxcIj5cXG5cIiArXG4gICAgXCIgIDxzcGFuIGFyaWEtaGlkZGVuPVxcXCJ0cnVlXFxcIiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1jaGV2cm9uLWxlZnRcXFwiPjwvc3Bhbj5cXG5cIiArXG4gICAgXCIgIDxzcGFuIGNsYXNzPVxcXCJzci1vbmx5XFxcIj5wcmV2aW91czwvc3Bhbj5cXG5cIiArXG4gICAgXCI8L2E+XFxuXCIgK1xuICAgIFwiPGEgcm9sZT1cXFwiYnV0dG9uXFxcIiBocmVmIGNsYXNzPVxcXCJyaWdodCBjYXJvdXNlbC1jb250cm9sXFxcIiBuZy1jbGljaz1cXFwibmV4dCgpXFxcIiBuZy1jbGFzcz1cXFwieyBkaXNhYmxlZDogaXNOZXh0RGlzYWJsZWQoKSB9XFxcIiBuZy1zaG93PVxcXCJzbGlkZXMubGVuZ3RoID4gMVxcXCI+XFxuXCIgK1xuICAgIFwiICA8c3BhbiBhcmlhLWhpZGRlbj1cXFwidHJ1ZVxcXCIgY2xhc3M9XFxcImdseXBoaWNvbiBnbHlwaGljb24tY2hldnJvbi1yaWdodFxcXCI+PC9zcGFuPlxcblwiICtcbiAgICBcIiAgPHNwYW4gY2xhc3M9XFxcInNyLW9ubHlcXFwiPm5leHQ8L3NwYW4+XFxuXCIgK1xuICAgIFwiPC9hPlxcblwiICtcbiAgICBcIjxvbCBjbGFzcz1cXFwiY2Fyb3VzZWwtaW5kaWNhdG9yc1xcXCIgbmctc2hvdz1cXFwic2xpZGVzLmxlbmd0aCA+IDFcXFwiPlxcblwiICtcbiAgICBcIiAgPGxpIG5nLXJlcGVhdD1cXFwic2xpZGUgaW4gc2xpZGVzIHwgb3JkZXJCeTppbmRleE9mU2xpZGUgdHJhY2sgYnkgJGluZGV4XFxcIiBuZy1jbGFzcz1cXFwieyBhY3RpdmU6IGlzQWN0aXZlKHNsaWRlKSB9XFxcIiBuZy1jbGljaz1cXFwic2VsZWN0KHNsaWRlKVxcXCI+XFxuXCIgK1xuICAgIFwiICAgIDxzcGFuIGNsYXNzPVxcXCJzci1vbmx5XFxcIj5zbGlkZSB7eyAkaW5kZXggKyAxIH19IG9mIHt7IHNsaWRlcy5sZW5ndGggfX08c3BhbiBuZy1pZj1cXFwiaXNBY3RpdmUoc2xpZGUpXFxcIj4sIGN1cnJlbnRseSBhY3RpdmU8L3NwYW4+PC9zcGFuPlxcblwiICtcbiAgICBcIiAgPC9saT5cXG5cIiArXG4gICAgXCI8L29sPlxcblwiICtcbiAgICBcIlwiKTtcbn1dKTtcblxuYW5ndWxhci5tb2R1bGUoXCJ1aWIvdGVtcGxhdGUvY2Fyb3VzZWwvc2xpZGUuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uICgkdGVtcGxhdGVDYWNoZSkge1xuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ1aWIvdGVtcGxhdGUvY2Fyb3VzZWwvc2xpZGUuaHRtbFwiLFxuICAgIFwiPGRpdiBjbGFzcz1cXFwidGV4dC1jZW50ZXJcXFwiIG5nLXRyYW5zY2x1ZGU+PC9kaXY+XFxuXCIgK1xuICAgIFwiXCIpO1xufV0pO1xuXG5hbmd1bGFyLm1vZHVsZShcInVpYi90ZW1wbGF0ZS9kYXRlcGlja2VyL2RhdGVwaWNrZXIuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uICgkdGVtcGxhdGVDYWNoZSkge1xuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ1aWIvdGVtcGxhdGUvZGF0ZXBpY2tlci9kYXRlcGlja2VyLmh0bWxcIixcbiAgICBcIjxkaXYgbmctc3dpdGNoPVxcXCJkYXRlcGlja2VyTW9kZVxcXCI+XFxuXCIgK1xuICAgIFwiICA8ZGl2IHVpYi1kYXlwaWNrZXIgbmctc3dpdGNoLXdoZW49XFxcImRheVxcXCIgdGFiaW5kZXg9XFxcIjBcXFwiIGNsYXNzPVxcXCJ1aWItZGF5cGlja2VyXFxcIj48L2Rpdj5cXG5cIiArXG4gICAgXCIgIDxkaXYgdWliLW1vbnRocGlja2VyIG5nLXN3aXRjaC13aGVuPVxcXCJtb250aFxcXCIgdGFiaW5kZXg9XFxcIjBcXFwiIGNsYXNzPVxcXCJ1aWItbW9udGhwaWNrZXJcXFwiPjwvZGl2PlxcblwiICtcbiAgICBcIiAgPGRpdiB1aWIteWVhcnBpY2tlciBuZy1zd2l0Y2gtd2hlbj1cXFwieWVhclxcXCIgdGFiaW5kZXg9XFxcIjBcXFwiIGNsYXNzPVxcXCJ1aWIteWVhcnBpY2tlclxcXCI+PC9kaXY+XFxuXCIgK1xuICAgIFwiPC9kaXY+XFxuXCIgK1xuICAgIFwiXCIpO1xufV0pO1xuXG5hbmd1bGFyLm1vZHVsZShcInVpYi90ZW1wbGF0ZS9kYXRlcGlja2VyL2RheS5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24gKCR0ZW1wbGF0ZUNhY2hlKSB7XG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInVpYi90ZW1wbGF0ZS9kYXRlcGlja2VyL2RheS5odG1sXCIsXG4gICAgXCI8dGFibGUgcm9sZT1cXFwiZ3JpZFxcXCIgYXJpYS1sYWJlbGxlZGJ5PVxcXCJ7ezo6dW5pcXVlSWR9fS10aXRsZVxcXCIgYXJpYS1hY3RpdmVkZXNjZW5kYW50PVxcXCJ7e2FjdGl2ZURhdGVJZH19XFxcIj5cXG5cIiArXG4gICAgXCIgIDx0aGVhZD5cXG5cIiArXG4gICAgXCIgICAgPHRyPlxcblwiICtcbiAgICBcIiAgICAgIDx0aD48YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tZGVmYXVsdCBidG4tc20gcHVsbC1sZWZ0IHVpYi1sZWZ0XFxcIiBuZy1jbGljaz1cXFwibW92ZSgtMSlcXFwiIHRhYmluZGV4PVxcXCItMVxcXCI+PGkgYXJpYS1oaWRkZW49XFxcInRydWVcXFwiIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLWNoZXZyb24tbGVmdFxcXCI+PC9pPjxzcGFuIGNsYXNzPVxcXCJzci1vbmx5XFxcIj5wcmV2aW91czwvc3Bhbj48L2J1dHRvbj48L3RoPlxcblwiICtcbiAgICBcIiAgICAgIDx0aCBjb2xzcGFuPVxcXCJ7ezo6NSArIHNob3dXZWVrc319XFxcIj48YnV0dG9uIGlkPVxcXCJ7ezo6dW5pcXVlSWR9fS10aXRsZVxcXCIgcm9sZT1cXFwiaGVhZGluZ1xcXCIgYXJpYS1saXZlPVxcXCJhc3NlcnRpdmVcXFwiIGFyaWEtYXRvbWljPVxcXCJ0cnVlXFxcIiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWRlZmF1bHQgYnRuLXNtIHVpYi10aXRsZVxcXCIgbmctY2xpY2s9XFxcInRvZ2dsZU1vZGUoKVxcXCIgbmctZGlzYWJsZWQ9XFxcImRhdGVwaWNrZXJNb2RlID09PSBtYXhNb2RlXFxcIiB0YWJpbmRleD1cXFwiLTFcXFwiPjxzdHJvbmc+e3t0aXRsZX19PC9zdHJvbmc+PC9idXR0b24+PC90aD5cXG5cIiArXG4gICAgXCIgICAgICA8dGg+PGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWRlZmF1bHQgYnRuLXNtIHB1bGwtcmlnaHQgdWliLXJpZ2h0XFxcIiBuZy1jbGljaz1cXFwibW92ZSgxKVxcXCIgdGFiaW5kZXg9XFxcIi0xXFxcIj48aSBhcmlhLWhpZGRlbj1cXFwidHJ1ZVxcXCIgY2xhc3M9XFxcImdseXBoaWNvbiBnbHlwaGljb24tY2hldnJvbi1yaWdodFxcXCI+PC9pPjxzcGFuIGNsYXNzPVxcXCJzci1vbmx5XFxcIj5uZXh0PC9zcGFuPjwvYnV0dG9uPjwvdGg+XFxuXCIgK1xuICAgIFwiICAgIDwvdHI+XFxuXCIgK1xuICAgIFwiICAgIDx0cj5cXG5cIiArXG4gICAgXCIgICAgICA8dGggbmctaWY9XFxcInNob3dXZWVrc1xcXCIgY2xhc3M9XFxcInRleHQtY2VudGVyXFxcIj48L3RoPlxcblwiICtcbiAgICBcIiAgICAgIDx0aCBuZy1yZXBlYXQ9XFxcImxhYmVsIGluIDo6bGFiZWxzIHRyYWNrIGJ5ICRpbmRleFxcXCIgY2xhc3M9XFxcInRleHQtY2VudGVyXFxcIj48c21hbGwgYXJpYS1sYWJlbD1cXFwie3s6OmxhYmVsLmZ1bGx9fVxcXCI+e3s6OmxhYmVsLmFiYnJ9fTwvc21hbGw+PC90aD5cXG5cIiArXG4gICAgXCIgICAgPC90cj5cXG5cIiArXG4gICAgXCIgIDwvdGhlYWQ+XFxuXCIgK1xuICAgIFwiICA8dGJvZHk+XFxuXCIgK1xuICAgIFwiICAgIDx0ciBjbGFzcz1cXFwidWliLXdlZWtzXFxcIiBuZy1yZXBlYXQ9XFxcInJvdyBpbiByb3dzIHRyYWNrIGJ5ICRpbmRleFxcXCIgcm9sZT1cXFwicm93XFxcIj5cXG5cIiArXG4gICAgXCIgICAgICA8dGQgbmctaWY9XFxcInNob3dXZWVrc1xcXCIgY2xhc3M9XFxcInRleHQtY2VudGVyIGg2XFxcIj48ZW0+e3sgd2Vla051bWJlcnNbJGluZGV4XSB9fTwvZW0+PC90ZD5cXG5cIiArXG4gICAgXCIgICAgICA8dGQgbmctcmVwZWF0PVxcXCJkdCBpbiByb3dcXFwiIGNsYXNzPVxcXCJ1aWItZGF5IHRleHQtY2VudGVyXFxcIiByb2xlPVxcXCJncmlkY2VsbFxcXCJcXG5cIiArXG4gICAgXCIgICAgICAgIGlkPVxcXCJ7ezo6ZHQudWlkfX1cXFwiXFxuXCIgK1xuICAgIFwiICAgICAgICBuZy1jbGFzcz1cXFwiOjpkdC5jdXN0b21DbGFzc1xcXCI+XFxuXCIgK1xuICAgIFwiICAgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tZGVmYXVsdCBidG4tc21cXFwiXFxuXCIgK1xuICAgIFwiICAgICAgICAgIHVpYi1pcy1jbGFzcz1cXFwiXFxuXCIgK1xuICAgIFwiICAgICAgICAgICAgJ2J0bi1pbmZvJyBmb3Igc2VsZWN0ZWREdCxcXG5cIiArXG4gICAgXCIgICAgICAgICAgICAnYWN0aXZlJyBmb3IgYWN0aXZlRHRcXG5cIiArXG4gICAgXCIgICAgICAgICAgICBvbiBkdFxcXCJcXG5cIiArXG4gICAgXCIgICAgICAgICAgbmctY2xpY2s9XFxcInNlbGVjdChkdC5kYXRlKVxcXCJcXG5cIiArXG4gICAgXCIgICAgICAgICAgbmctZGlzYWJsZWQ9XFxcIjo6ZHQuZGlzYWJsZWRcXFwiXFxuXCIgK1xuICAgIFwiICAgICAgICAgIHRhYmluZGV4PVxcXCItMVxcXCI+PHNwYW4gbmctY2xhc3M9XFxcIjo6eyd0ZXh0LW11dGVkJzogZHQuc2Vjb25kYXJ5LCAndGV4dC1pbmZvJzogZHQuY3VycmVudH1cXFwiPnt7OjpkdC5sYWJlbH19PC9zcGFuPjwvYnV0dG9uPlxcblwiICtcbiAgICBcIiAgICAgIDwvdGQ+XFxuXCIgK1xuICAgIFwiICAgIDwvdHI+XFxuXCIgK1xuICAgIFwiICA8L3Rib2R5PlxcblwiICtcbiAgICBcIjwvdGFibGU+XFxuXCIgK1xuICAgIFwiXCIpO1xufV0pO1xuXG5hbmd1bGFyLm1vZHVsZShcInVpYi90ZW1wbGF0ZS9kYXRlcGlja2VyL21vbnRoLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbiAoJHRlbXBsYXRlQ2FjaGUpIHtcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidWliL3RlbXBsYXRlL2RhdGVwaWNrZXIvbW9udGguaHRtbFwiLFxuICAgIFwiPHRhYmxlIHJvbGU9XFxcImdyaWRcXFwiIGFyaWEtbGFiZWxsZWRieT1cXFwie3s6OnVuaXF1ZUlkfX0tdGl0bGVcXFwiIGFyaWEtYWN0aXZlZGVzY2VuZGFudD1cXFwie3thY3RpdmVEYXRlSWR9fVxcXCI+XFxuXCIgK1xuICAgIFwiICA8dGhlYWQ+XFxuXCIgK1xuICAgIFwiICAgIDx0cj5cXG5cIiArXG4gICAgXCIgICAgICA8dGg+PGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWRlZmF1bHQgYnRuLXNtIHB1bGwtbGVmdCB1aWItbGVmdFxcXCIgbmctY2xpY2s9XFxcIm1vdmUoLTEpXFxcIiB0YWJpbmRleD1cXFwiLTFcXFwiPjxpIGFyaWEtaGlkZGVuPVxcXCJ0cnVlXFxcIiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1jaGV2cm9uLWxlZnRcXFwiPjwvaT48c3BhbiBjbGFzcz1cXFwic3Itb25seVxcXCI+cHJldmlvdXM8L3NwYW4+PC9idXR0b24+PC90aD5cXG5cIiArXG4gICAgXCIgICAgICA8dGggY29sc3Bhbj1cXFwie3s6OnllYXJIZWFkZXJDb2xzcGFufX1cXFwiPjxidXR0b24gaWQ9XFxcInt7Ojp1bmlxdWVJZH19LXRpdGxlXFxcIiByb2xlPVxcXCJoZWFkaW5nXFxcIiBhcmlhLWxpdmU9XFxcImFzc2VydGl2ZVxcXCIgYXJpYS1hdG9taWM9XFxcInRydWVcXFwiIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tZGVmYXVsdCBidG4tc20gdWliLXRpdGxlXFxcIiBuZy1jbGljaz1cXFwidG9nZ2xlTW9kZSgpXFxcIiBuZy1kaXNhYmxlZD1cXFwiZGF0ZXBpY2tlck1vZGUgPT09IG1heE1vZGVcXFwiIHRhYmluZGV4PVxcXCItMVxcXCI+PHN0cm9uZz57e3RpdGxlfX08L3N0cm9uZz48L2J1dHRvbj48L3RoPlxcblwiICtcbiAgICBcIiAgICAgIDx0aD48YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tZGVmYXVsdCBidG4tc20gcHVsbC1yaWdodCB1aWItcmlnaHRcXFwiIG5nLWNsaWNrPVxcXCJtb3ZlKDEpXFxcIiB0YWJpbmRleD1cXFwiLTFcXFwiPjxpIGFyaWEtaGlkZGVuPVxcXCJ0cnVlXFxcIiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1jaGV2cm9uLXJpZ2h0XFxcIj48L2k+PHNwYW4gY2xhc3M9XFxcInNyLW9ubHlcXFwiPm5leHQ8L3NwYW4+PC9pPjwvYnV0dG9uPjwvdGg+XFxuXCIgK1xuICAgIFwiICAgIDwvdHI+XFxuXCIgK1xuICAgIFwiICA8L3RoZWFkPlxcblwiICtcbiAgICBcIiAgPHRib2R5PlxcblwiICtcbiAgICBcIiAgICA8dHIgY2xhc3M9XFxcInVpYi1tb250aHNcXFwiIG5nLXJlcGVhdD1cXFwicm93IGluIHJvd3MgdHJhY2sgYnkgJGluZGV4XFxcIiByb2xlPVxcXCJyb3dcXFwiPlxcblwiICtcbiAgICBcIiAgICAgIDx0ZCBuZy1yZXBlYXQ9XFxcImR0IGluIHJvd1xcXCIgY2xhc3M9XFxcInVpYi1tb250aCB0ZXh0LWNlbnRlclxcXCIgcm9sZT1cXFwiZ3JpZGNlbGxcXFwiXFxuXCIgK1xuICAgIFwiICAgICAgICBpZD1cXFwie3s6OmR0LnVpZH19XFxcIlxcblwiICtcbiAgICBcIiAgICAgICAgbmctY2xhc3M9XFxcIjo6ZHQuY3VzdG9tQ2xhc3NcXFwiPlxcblwiICtcbiAgICBcIiAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWRlZmF1bHRcXFwiXFxuXCIgK1xuICAgIFwiICAgICAgICAgIHVpYi1pcy1jbGFzcz1cXFwiXFxuXCIgK1xuICAgIFwiICAgICAgICAgICAgJ2J0bi1pbmZvJyBmb3Igc2VsZWN0ZWREdCxcXG5cIiArXG4gICAgXCIgICAgICAgICAgICAnYWN0aXZlJyBmb3IgYWN0aXZlRHRcXG5cIiArXG4gICAgXCIgICAgICAgICAgICBvbiBkdFxcXCJcXG5cIiArXG4gICAgXCIgICAgICAgICAgbmctY2xpY2s9XFxcInNlbGVjdChkdC5kYXRlKVxcXCJcXG5cIiArXG4gICAgXCIgICAgICAgICAgbmctZGlzYWJsZWQ9XFxcIjo6ZHQuZGlzYWJsZWRcXFwiXFxuXCIgK1xuICAgIFwiICAgICAgICAgIHRhYmluZGV4PVxcXCItMVxcXCI+PHNwYW4gbmctY2xhc3M9XFxcIjo6eyd0ZXh0LWluZm8nOiBkdC5jdXJyZW50fVxcXCI+e3s6OmR0LmxhYmVsfX08L3NwYW4+PC9idXR0b24+XFxuXCIgK1xuICAgIFwiICAgICAgPC90ZD5cXG5cIiArXG4gICAgXCIgICAgPC90cj5cXG5cIiArXG4gICAgXCIgIDwvdGJvZHk+XFxuXCIgK1xuICAgIFwiPC90YWJsZT5cXG5cIiArXG4gICAgXCJcIik7XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKFwidWliL3RlbXBsYXRlL2RhdGVwaWNrZXIvcG9wdXAuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uKCR0ZW1wbGF0ZUNhY2hlKSB7XG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInVpYi90ZW1wbGF0ZS9kYXRlcGlja2VyL3BvcHVwLmh0bWxcIixcbiAgICBcIjxkaXY+XFxuXCIgK1xuICAgIFwiICA8dWwgY2xhc3M9XFxcInVpYi1kYXRlcGlja2VyLXBvcHVwIGRyb3Bkb3duLW1lbnUgdWliLXBvc2l0aW9uLW1lYXN1cmVcXFwiIGRyb3Bkb3duLW5lc3RlZCBuZy1pZj1cXFwiaXNPcGVuXFxcIiBuZy1rZXlkb3duPVxcXCJrZXlkb3duKCRldmVudClcXFwiIG5nLWNsaWNrPVxcXCIkZXZlbnQuc3RvcFByb3BhZ2F0aW9uKClcXFwiPlxcblwiICtcbiAgICBcIiAgICA8bGkgbmctdHJhbnNjbHVkZT48L2xpPlxcblwiICtcbiAgICBcIiAgICA8bGkgbmctaWY9XFxcInNob3dCdXR0b25CYXJcXFwiIGNsYXNzPVxcXCJ1aWItYnV0dG9uLWJhclxcXCI+XFxuXCIgK1xuICAgIFwiICAgICAgPHNwYW4gY2xhc3M9XFxcImJ0bi1ncm91cCBwdWxsLWxlZnRcXFwiPlxcblwiICtcbiAgICBcIiAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLXNtIGJ0bi1pbmZvIHVpYi1kYXRlcGlja2VyLWN1cnJlbnRcXFwiIG5nLWNsaWNrPVxcXCJzZWxlY3QoJ3RvZGF5JywgJGV2ZW50KVxcXCIgbmctZGlzYWJsZWQ9XFxcImlzRGlzYWJsZWQoJ3RvZGF5JylcXFwiPnt7IGdldFRleHQoJ2N1cnJlbnQnKSB9fTwvYnV0dG9uPlxcblwiICtcbiAgICBcIiAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLXNtIGJ0bi1kYW5nZXIgdWliLWNsZWFyXFxcIiBuZy1jbGljaz1cXFwic2VsZWN0KG51bGwsICRldmVudClcXFwiPnt7IGdldFRleHQoJ2NsZWFyJykgfX08L2J1dHRvbj5cXG5cIiArXG4gICAgXCIgICAgICA8L3NwYW4+XFxuXCIgK1xuICAgIFwiICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLXNtIGJ0bi1zdWNjZXNzIHB1bGwtcmlnaHQgdWliLWNsb3NlXFxcIiBuZy1jbGljaz1cXFwiY2xvc2UoJGV2ZW50KVxcXCI+e3sgZ2V0VGV4dCgnY2xvc2UnKSB9fTwvYnV0dG9uPlxcblwiICtcbiAgICBcIiAgICA8L2xpPlxcblwiICtcbiAgICBcIiAgPC91bD5cXG5cIiArXG4gICAgXCI8L2Rpdj5cXG5cIiArXG4gICAgXCJcIik7XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKFwidWliL3RlbXBsYXRlL2RhdGVwaWNrZXIveWVhci5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24gKCR0ZW1wbGF0ZUNhY2hlKSB7XG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInVpYi90ZW1wbGF0ZS9kYXRlcGlja2VyL3llYXIuaHRtbFwiLFxuICAgIFwiPHRhYmxlIHJvbGU9XFxcImdyaWRcXFwiIGFyaWEtbGFiZWxsZWRieT1cXFwie3s6OnVuaXF1ZUlkfX0tdGl0bGVcXFwiIGFyaWEtYWN0aXZlZGVzY2VuZGFudD1cXFwie3thY3RpdmVEYXRlSWR9fVxcXCI+XFxuXCIgK1xuICAgIFwiICA8dGhlYWQ+XFxuXCIgK1xuICAgIFwiICAgIDx0cj5cXG5cIiArXG4gICAgXCIgICAgICA8dGg+PGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWRlZmF1bHQgYnRuLXNtIHB1bGwtbGVmdCB1aWItbGVmdFxcXCIgbmctY2xpY2s9XFxcIm1vdmUoLTEpXFxcIiB0YWJpbmRleD1cXFwiLTFcXFwiPjxpIGFyaWEtaGlkZGVuPVxcXCJ0cnVlXFxcIiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1jaGV2cm9uLWxlZnRcXFwiPjwvaT48c3BhbiBjbGFzcz1cXFwic3Itb25seVxcXCI+cHJldmlvdXM8L3NwYW4+PC9idXR0b24+PC90aD5cXG5cIiArXG4gICAgXCIgICAgICA8dGggY29sc3Bhbj1cXFwie3s6OmNvbHVtbnMgLSAyfX1cXFwiPjxidXR0b24gaWQ9XFxcInt7Ojp1bmlxdWVJZH19LXRpdGxlXFxcIiByb2xlPVxcXCJoZWFkaW5nXFxcIiBhcmlhLWxpdmU9XFxcImFzc2VydGl2ZVxcXCIgYXJpYS1hdG9taWM9XFxcInRydWVcXFwiIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tZGVmYXVsdCBidG4tc20gdWliLXRpdGxlXFxcIiBuZy1jbGljaz1cXFwidG9nZ2xlTW9kZSgpXFxcIiBuZy1kaXNhYmxlZD1cXFwiZGF0ZXBpY2tlck1vZGUgPT09IG1heE1vZGVcXFwiIHRhYmluZGV4PVxcXCItMVxcXCI+PHN0cm9uZz57e3RpdGxlfX08L3N0cm9uZz48L2J1dHRvbj48L3RoPlxcblwiICtcbiAgICBcIiAgICAgIDx0aD48YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tZGVmYXVsdCBidG4tc20gcHVsbC1yaWdodCB1aWItcmlnaHRcXFwiIG5nLWNsaWNrPVxcXCJtb3ZlKDEpXFxcIiB0YWJpbmRleD1cXFwiLTFcXFwiPjxpIGFyaWEtaGlkZGVuPVxcXCJ0cnVlXFxcIiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1jaGV2cm9uLXJpZ2h0XFxcIj48L2k+PHNwYW4gY2xhc3M9XFxcInNyLW9ubHlcXFwiPm5leHQ8L3NwYW4+PC9idXR0b24+PC90aD5cXG5cIiArXG4gICAgXCIgICAgPC90cj5cXG5cIiArXG4gICAgXCIgIDwvdGhlYWQ+XFxuXCIgK1xuICAgIFwiICA8dGJvZHk+XFxuXCIgK1xuICAgIFwiICAgIDx0ciBjbGFzcz1cXFwidWliLXllYXJzXFxcIiBuZy1yZXBlYXQ9XFxcInJvdyBpbiByb3dzIHRyYWNrIGJ5ICRpbmRleFxcXCIgcm9sZT1cXFwicm93XFxcIj5cXG5cIiArXG4gICAgXCIgICAgICA8dGQgbmctcmVwZWF0PVxcXCJkdCBpbiByb3dcXFwiIGNsYXNzPVxcXCJ1aWIteWVhciB0ZXh0LWNlbnRlclxcXCIgcm9sZT1cXFwiZ3JpZGNlbGxcXFwiXFxuXCIgK1xuICAgIFwiICAgICAgICBpZD1cXFwie3s6OmR0LnVpZH19XFxcIlxcblwiICtcbiAgICBcIiAgICAgICAgbmctY2xhc3M9XFxcIjo6ZHQuY3VzdG9tQ2xhc3NcXFwiPlxcblwiICtcbiAgICBcIiAgICAgICAgPGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWRlZmF1bHRcXFwiXFxuXCIgK1xuICAgIFwiICAgICAgICAgIHVpYi1pcy1jbGFzcz1cXFwiXFxuXCIgK1xuICAgIFwiICAgICAgICAgICAgJ2J0bi1pbmZvJyBmb3Igc2VsZWN0ZWREdCxcXG5cIiArXG4gICAgXCIgICAgICAgICAgICAnYWN0aXZlJyBmb3IgYWN0aXZlRHRcXG5cIiArXG4gICAgXCIgICAgICAgICAgICBvbiBkdFxcXCJcXG5cIiArXG4gICAgXCIgICAgICAgICAgbmctY2xpY2s9XFxcInNlbGVjdChkdC5kYXRlKVxcXCJcXG5cIiArXG4gICAgXCIgICAgICAgICAgbmctZGlzYWJsZWQ9XFxcIjo6ZHQuZGlzYWJsZWRcXFwiXFxuXCIgK1xuICAgIFwiICAgICAgICAgIHRhYmluZGV4PVxcXCItMVxcXCI+PHNwYW4gbmctY2xhc3M9XFxcIjo6eyd0ZXh0LWluZm8nOiBkdC5jdXJyZW50fVxcXCI+e3s6OmR0LmxhYmVsfX08L3NwYW4+PC9idXR0b24+XFxuXCIgK1xuICAgIFwiICAgICAgPC90ZD5cXG5cIiArXG4gICAgXCIgICAgPC90cj5cXG5cIiArXG4gICAgXCIgIDwvdGJvZHk+XFxuXCIgK1xuICAgIFwiPC90YWJsZT5cXG5cIiArXG4gICAgXCJcIik7XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKFwidWliL3RlbXBsYXRlL2RhdGVwaWNrZXJQb3B1cC9wb3B1cC5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24gKCR0ZW1wbGF0ZUNhY2hlKSB7XG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInVpYi90ZW1wbGF0ZS9kYXRlcGlja2VyUG9wdXAvcG9wdXAuaHRtbFwiLFxuICAgIFwiPHVsIHJvbGU9XFxcInByZXNlbnRhdGlvblxcXCIgY2xhc3M9XFxcInVpYi1kYXRlcGlja2VyLXBvcHVwIGRyb3Bkb3duLW1lbnUgdWliLXBvc2l0aW9uLW1lYXN1cmVcXFwiIGRyb3Bkb3duLW5lc3RlZCBuZy1pZj1cXFwiaXNPcGVuXFxcIiBuZy1rZXlkb3duPVxcXCJrZXlkb3duKCRldmVudClcXFwiIG5nLWNsaWNrPVxcXCIkZXZlbnQuc3RvcFByb3BhZ2F0aW9uKClcXFwiPlxcblwiICtcbiAgICBcIiAgPGxpIG5nLXRyYW5zY2x1ZGU+PC9saT5cXG5cIiArXG4gICAgXCIgIDxsaSBuZy1pZj1cXFwic2hvd0J1dHRvbkJhclxcXCIgY2xhc3M9XFxcInVpYi1idXR0b24tYmFyXFxcIj5cXG5cIiArXG4gICAgXCIgICAgPHNwYW4gY2xhc3M9XFxcImJ0bi1ncm91cCBwdWxsLWxlZnRcXFwiPlxcblwiICtcbiAgICBcIiAgICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1zbSBidG4taW5mbyB1aWItZGF0ZXBpY2tlci1jdXJyZW50XFxcIiBuZy1jbGljaz1cXFwic2VsZWN0KCd0b2RheScsICRldmVudClcXFwiIG5nLWRpc2FibGVkPVxcXCJpc0Rpc2FibGVkKCd0b2RheScpXFxcIj57eyBnZXRUZXh0KCdjdXJyZW50JykgfX08L2J1dHRvbj5cXG5cIiArXG4gICAgXCIgICAgICA8YnV0dG9uIHR5cGU9XFxcImJ1dHRvblxcXCIgY2xhc3M9XFxcImJ0biBidG4tc20gYnRuLWRhbmdlciB1aWItY2xlYXJcXFwiIG5nLWNsaWNrPVxcXCJzZWxlY3QobnVsbCwgJGV2ZW50KVxcXCI+e3sgZ2V0VGV4dCgnY2xlYXInKSB9fTwvYnV0dG9uPlxcblwiICtcbiAgICBcIiAgICA8L3NwYW4+XFxuXCIgK1xuICAgIFwiICAgIDxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1zbSBidG4tc3VjY2VzcyBwdWxsLXJpZ2h0IHVpYi1jbG9zZVxcXCIgbmctY2xpY2s9XFxcImNsb3NlKCRldmVudClcXFwiPnt7IGdldFRleHQoJ2Nsb3NlJykgfX08L2J1dHRvbj5cXG5cIiArXG4gICAgXCIgIDwvbGk+XFxuXCIgK1xuICAgIFwiPC91bD5cXG5cIiArXG4gICAgXCJcIik7XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKFwidWliL3RlbXBsYXRlL21vZGFsL2JhY2tkcm9wLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbigkdGVtcGxhdGVDYWNoZSkge1xuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ1aWIvdGVtcGxhdGUvbW9kYWwvYmFja2Ryb3AuaHRtbFwiLFxuICAgIFwiPGRpdiBjbGFzcz1cXFwibW9kYWwtYmFja2Ryb3BcXFwiXFxuXCIgK1xuICAgIFwiICAgICB1aWItbW9kYWwtYW5pbWF0aW9uLWNsYXNzPVxcXCJmYWRlXFxcIlxcblwiICtcbiAgICBcIiAgICAgbW9kYWwtaW4tY2xhc3M9XFxcImluXFxcIlxcblwiICtcbiAgICBcIiAgICAgbmctc3R5bGU9XFxcInsnei1pbmRleCc6IDEwNDAgKyAoaW5kZXggJiYgMSB8fCAwKSArIGluZGV4KjEwfVxcXCJcXG5cIiArXG4gICAgXCI+PC9kaXY+XFxuXCIgK1xuICAgIFwiXCIpO1xufV0pO1xuXG5hbmd1bGFyLm1vZHVsZShcInVpYi90ZW1wbGF0ZS9tb2RhbC93aW5kb3cuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uICgkdGVtcGxhdGVDYWNoZSkge1xuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ1aWIvdGVtcGxhdGUvbW9kYWwvd2luZG93Lmh0bWxcIixcbiAgICBcIjxkaXYgY2xhc3M9XFxcIm1vZGFsLWRpYWxvZyB7e3NpemUgPyAnbW9kYWwtJyArIHNpemUgOiAnJ319XFxcIj48ZGl2IGNsYXNzPVxcXCJtb2RhbC1jb250ZW50XFxcIiB1aWItbW9kYWwtdHJhbnNjbHVkZT48L2Rpdj48L2Rpdj5cXG5cIiArXG4gICAgXCJcIik7XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKFwidWliL3RlbXBsYXRlL3BhZ2VyL3BhZ2VyLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbiAoJHRlbXBsYXRlQ2FjaGUpIHtcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidWliL3RlbXBsYXRlL3BhZ2VyL3BhZ2VyLmh0bWxcIixcbiAgICBcIjxsaSBuZy1jbGFzcz1cXFwie2Rpc2FibGVkOiBub1ByZXZpb3VzKCl8fG5nRGlzYWJsZWQsIHByZXZpb3VzOiBhbGlnbn1cXFwiPjxhIGhyZWYgbmctY2xpY2s9XFxcInNlbGVjdFBhZ2UocGFnZSAtIDEsICRldmVudClcXFwiIG5nLWRpc2FibGVkPVxcXCJub1ByZXZpb3VzKCl8fG5nRGlzYWJsZWRcXFwiIHVpYi10YWJpbmRleC10b2dnbGU+e3s6OmdldFRleHQoJ3ByZXZpb3VzJyl9fTwvYT48L2xpPlxcblwiICtcbiAgICBcIjxsaSBuZy1jbGFzcz1cXFwie2Rpc2FibGVkOiBub05leHQoKXx8bmdEaXNhYmxlZCwgbmV4dDogYWxpZ259XFxcIj48YSBocmVmIG5nLWNsaWNrPVxcXCJzZWxlY3RQYWdlKHBhZ2UgKyAxLCAkZXZlbnQpXFxcIiBuZy1kaXNhYmxlZD1cXFwibm9OZXh0KCl8fG5nRGlzYWJsZWRcXFwiIHVpYi10YWJpbmRleC10b2dnbGU+e3s6OmdldFRleHQoJ25leHQnKX19PC9hPjwvbGk+XFxuXCIgK1xuICAgIFwiXCIpO1xufV0pO1xuXG5hbmd1bGFyLm1vZHVsZShcInVpYi90ZW1wbGF0ZS9wYWdpbmF0aW9uL3BhZ2luYXRpb24uaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uICgkdGVtcGxhdGVDYWNoZSkge1xuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ1aWIvdGVtcGxhdGUvcGFnaW5hdGlvbi9wYWdpbmF0aW9uLmh0bWxcIixcbiAgICBcIjxsaSByb2xlPVxcXCJtZW51aXRlbVxcXCIgbmctaWY9XFxcIjo6Ym91bmRhcnlMaW5rc1xcXCIgbmctY2xhc3M9XFxcIntkaXNhYmxlZDogbm9QcmV2aW91cygpfHxuZ0Rpc2FibGVkfVxcXCIgY2xhc3M9XFxcInBhZ2luYXRpb24tZmlyc3RcXFwiPjxhIGhyZWYgbmctY2xpY2s9XFxcInNlbGVjdFBhZ2UoMSwgJGV2ZW50KVxcXCIgbmctZGlzYWJsZWQ9XFxcIm5vUHJldmlvdXMoKXx8bmdEaXNhYmxlZFxcXCIgdWliLXRhYmluZGV4LXRvZ2dsZT57ezo6Z2V0VGV4dCgnZmlyc3QnKX19PC9hPjwvbGk+XFxuXCIgK1xuICAgIFwiPGxpIHJvbGU9XFxcIm1lbnVpdGVtXFxcIiBuZy1pZj1cXFwiOjpkaXJlY3Rpb25MaW5rc1xcXCIgbmctY2xhc3M9XFxcIntkaXNhYmxlZDogbm9QcmV2aW91cygpfHxuZ0Rpc2FibGVkfVxcXCIgY2xhc3M9XFxcInBhZ2luYXRpb24tcHJldlxcXCI+PGEgaHJlZiBuZy1jbGljaz1cXFwic2VsZWN0UGFnZShwYWdlIC0gMSwgJGV2ZW50KVxcXCIgbmctZGlzYWJsZWQ9XFxcIm5vUHJldmlvdXMoKXx8bmdEaXNhYmxlZFxcXCIgdWliLXRhYmluZGV4LXRvZ2dsZT57ezo6Z2V0VGV4dCgncHJldmlvdXMnKX19PC9hPjwvbGk+XFxuXCIgK1xuICAgIFwiPGxpIHJvbGU9XFxcIm1lbnVpdGVtXFxcIiBuZy1yZXBlYXQ9XFxcInBhZ2UgaW4gcGFnZXMgdHJhY2sgYnkgJGluZGV4XFxcIiBuZy1jbGFzcz1cXFwie2FjdGl2ZTogcGFnZS5hY3RpdmUsZGlzYWJsZWQ6IG5nRGlzYWJsZWQmJiFwYWdlLmFjdGl2ZX1cXFwiIGNsYXNzPVxcXCJwYWdpbmF0aW9uLXBhZ2VcXFwiPjxhIGhyZWYgbmctY2xpY2s9XFxcInNlbGVjdFBhZ2UocGFnZS5udW1iZXIsICRldmVudClcXFwiIG5nLWRpc2FibGVkPVxcXCJuZ0Rpc2FibGVkJiYhcGFnZS5hY3RpdmVcXFwiIHVpYi10YWJpbmRleC10b2dnbGU+e3twYWdlLnRleHR9fTwvYT48L2xpPlxcblwiICtcbiAgICBcIjxsaSByb2xlPVxcXCJtZW51aXRlbVxcXCIgbmctaWY9XFxcIjo6ZGlyZWN0aW9uTGlua3NcXFwiIG5nLWNsYXNzPVxcXCJ7ZGlzYWJsZWQ6IG5vTmV4dCgpfHxuZ0Rpc2FibGVkfVxcXCIgY2xhc3M9XFxcInBhZ2luYXRpb24tbmV4dFxcXCI+PGEgaHJlZiBuZy1jbGljaz1cXFwic2VsZWN0UGFnZShwYWdlICsgMSwgJGV2ZW50KVxcXCIgbmctZGlzYWJsZWQ9XFxcIm5vTmV4dCgpfHxuZ0Rpc2FibGVkXFxcIiB1aWItdGFiaW5kZXgtdG9nZ2xlPnt7OjpnZXRUZXh0KCduZXh0Jyl9fTwvYT48L2xpPlxcblwiICtcbiAgICBcIjxsaSByb2xlPVxcXCJtZW51aXRlbVxcXCIgbmctaWY9XFxcIjo6Ym91bmRhcnlMaW5rc1xcXCIgbmctY2xhc3M9XFxcIntkaXNhYmxlZDogbm9OZXh0KCl8fG5nRGlzYWJsZWR9XFxcIiBjbGFzcz1cXFwicGFnaW5hdGlvbi1sYXN0XFxcIj48YSBocmVmIG5nLWNsaWNrPVxcXCJzZWxlY3RQYWdlKHRvdGFsUGFnZXMsICRldmVudClcXFwiIG5nLWRpc2FibGVkPVxcXCJub05leHQoKXx8bmdEaXNhYmxlZFxcXCIgdWliLXRhYmluZGV4LXRvZ2dsZT57ezo6Z2V0VGV4dCgnbGFzdCcpfX08L2E+PC9saT5cXG5cIiArXG4gICAgXCJcIik7XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKFwidWliL3RlbXBsYXRlL3Rvb2x0aXAvdG9vbHRpcC1odG1sLXBvcHVwLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbiAoJHRlbXBsYXRlQ2FjaGUpIHtcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidWliL3RlbXBsYXRlL3Rvb2x0aXAvdG9vbHRpcC1odG1sLXBvcHVwLmh0bWxcIixcbiAgICBcIjxkaXYgY2xhc3M9XFxcInRvb2x0aXAtYXJyb3dcXFwiPjwvZGl2PlxcblwiICtcbiAgICBcIjxkaXYgY2xhc3M9XFxcInRvb2x0aXAtaW5uZXJcXFwiIG5nLWJpbmQtaHRtbD1cXFwiY29udGVudEV4cCgpXFxcIj48L2Rpdj5cXG5cIiArXG4gICAgXCJcIik7XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKFwidWliL3RlbXBsYXRlL3Rvb2x0aXAvdG9vbHRpcC1wb3B1cC5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24gKCR0ZW1wbGF0ZUNhY2hlKSB7XG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInVpYi90ZW1wbGF0ZS90b29sdGlwL3Rvb2x0aXAtcG9wdXAuaHRtbFwiLFxuICAgIFwiPGRpdiBjbGFzcz1cXFwidG9vbHRpcC1hcnJvd1xcXCI+PC9kaXY+XFxuXCIgK1xuICAgIFwiPGRpdiBjbGFzcz1cXFwidG9vbHRpcC1pbm5lclxcXCIgbmctYmluZD1cXFwiY29udGVudFxcXCI+PC9kaXY+XFxuXCIgK1xuICAgIFwiXCIpO1xufV0pO1xuXG5hbmd1bGFyLm1vZHVsZShcInVpYi90ZW1wbGF0ZS90b29sdGlwL3Rvb2x0aXAtdGVtcGxhdGUtcG9wdXAuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uICgkdGVtcGxhdGVDYWNoZSkge1xuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ1aWIvdGVtcGxhdGUvdG9vbHRpcC90b29sdGlwLXRlbXBsYXRlLXBvcHVwLmh0bWxcIixcbiAgICBcIjxkaXYgY2xhc3M9XFxcInRvb2x0aXAtYXJyb3dcXFwiPjwvZGl2PlxcblwiICtcbiAgICBcIjxkaXYgY2xhc3M9XFxcInRvb2x0aXAtaW5uZXJcXFwiXFxuXCIgK1xuICAgIFwiICB1aWItdG9vbHRpcC10ZW1wbGF0ZS10cmFuc2NsdWRlPVxcXCJjb250ZW50RXhwKClcXFwiXFxuXCIgK1xuICAgIFwiICB0b29sdGlwLXRlbXBsYXRlLXRyYW5zY2x1ZGUtc2NvcGU9XFxcIm9yaWdpblNjb3BlKClcXFwiPjwvZGl2PlxcblwiICtcbiAgICBcIlwiKTtcbn1dKTtcblxuYW5ndWxhci5tb2R1bGUoXCJ1aWIvdGVtcGxhdGUvcG9wb3Zlci9wb3BvdmVyLWh0bWwuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uICgkdGVtcGxhdGVDYWNoZSkge1xuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ1aWIvdGVtcGxhdGUvcG9wb3Zlci9wb3BvdmVyLWh0bWwuaHRtbFwiLFxuICAgIFwiPGRpdiBjbGFzcz1cXFwiYXJyb3dcXFwiPjwvZGl2PlxcblwiICtcbiAgICBcIlxcblwiICtcbiAgICBcIjxkaXYgY2xhc3M9XFxcInBvcG92ZXItaW5uZXJcXFwiPlxcblwiICtcbiAgICBcIiAgICA8aDMgY2xhc3M9XFxcInBvcG92ZXItdGl0bGVcXFwiIG5nLWJpbmQ9XFxcInVpYlRpdGxlXFxcIiBuZy1pZj1cXFwidWliVGl0bGVcXFwiPjwvaDM+XFxuXCIgK1xuICAgIFwiICAgIDxkaXYgY2xhc3M9XFxcInBvcG92ZXItY29udGVudFxcXCIgbmctYmluZC1odG1sPVxcXCJjb250ZW50RXhwKClcXFwiPjwvZGl2PlxcblwiICtcbiAgICBcIjwvZGl2PlxcblwiICtcbiAgICBcIlwiKTtcbn1dKTtcblxuYW5ndWxhci5tb2R1bGUoXCJ1aWIvdGVtcGxhdGUvcG9wb3Zlci9wb3BvdmVyLXRlbXBsYXRlLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbiAoJHRlbXBsYXRlQ2FjaGUpIHtcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidWliL3RlbXBsYXRlL3BvcG92ZXIvcG9wb3Zlci10ZW1wbGF0ZS5odG1sXCIsXG4gICAgXCI8ZGl2IGNsYXNzPVxcXCJhcnJvd1xcXCI+PC9kaXY+XFxuXCIgK1xuICAgIFwiXFxuXCIgK1xuICAgIFwiPGRpdiBjbGFzcz1cXFwicG9wb3Zlci1pbm5lclxcXCI+XFxuXCIgK1xuICAgIFwiICAgIDxoMyBjbGFzcz1cXFwicG9wb3Zlci10aXRsZVxcXCIgbmctYmluZD1cXFwidWliVGl0bGVcXFwiIG5nLWlmPVxcXCJ1aWJUaXRsZVxcXCI+PC9oMz5cXG5cIiArXG4gICAgXCIgICAgPGRpdiBjbGFzcz1cXFwicG9wb3Zlci1jb250ZW50XFxcIlxcblwiICtcbiAgICBcIiAgICAgIHVpYi10b29sdGlwLXRlbXBsYXRlLXRyYW5zY2x1ZGU9XFxcImNvbnRlbnRFeHAoKVxcXCJcXG5cIiArXG4gICAgXCIgICAgICB0b29sdGlwLXRlbXBsYXRlLXRyYW5zY2x1ZGUtc2NvcGU9XFxcIm9yaWdpblNjb3BlKClcXFwiPjwvZGl2PlxcblwiICtcbiAgICBcIjwvZGl2PlxcblwiICtcbiAgICBcIlwiKTtcbn1dKTtcblxuYW5ndWxhci5tb2R1bGUoXCJ1aWIvdGVtcGxhdGUvcG9wb3Zlci9wb3BvdmVyLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbiAoJHRlbXBsYXRlQ2FjaGUpIHtcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidWliL3RlbXBsYXRlL3BvcG92ZXIvcG9wb3Zlci5odG1sXCIsXG4gICAgXCI8ZGl2IGNsYXNzPVxcXCJhcnJvd1xcXCI+PC9kaXY+XFxuXCIgK1xuICAgIFwiXFxuXCIgK1xuICAgIFwiPGRpdiBjbGFzcz1cXFwicG9wb3Zlci1pbm5lclxcXCI+XFxuXCIgK1xuICAgIFwiICAgIDxoMyBjbGFzcz1cXFwicG9wb3Zlci10aXRsZVxcXCIgbmctYmluZD1cXFwidWliVGl0bGVcXFwiIG5nLWlmPVxcXCJ1aWJUaXRsZVxcXCI+PC9oMz5cXG5cIiArXG4gICAgXCIgICAgPGRpdiBjbGFzcz1cXFwicG9wb3Zlci1jb250ZW50XFxcIiBuZy1iaW5kPVxcXCJjb250ZW50XFxcIj48L2Rpdj5cXG5cIiArXG4gICAgXCI8L2Rpdj5cXG5cIiArXG4gICAgXCJcIik7XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKFwidWliL3RlbXBsYXRlL3Byb2dyZXNzYmFyL2Jhci5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24gKCR0ZW1wbGF0ZUNhY2hlKSB7XG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInVpYi90ZW1wbGF0ZS9wcm9ncmVzc2Jhci9iYXIuaHRtbFwiLFxuICAgIFwiPGRpdiBjbGFzcz1cXFwicHJvZ3Jlc3MtYmFyXFxcIiBuZy1jbGFzcz1cXFwidHlwZSAmJiAncHJvZ3Jlc3MtYmFyLScgKyB0eXBlXFxcIiByb2xlPVxcXCJwcm9ncmVzc2JhclxcXCIgYXJpYS12YWx1ZW5vdz1cXFwie3t2YWx1ZX19XFxcIiBhcmlhLXZhbHVlbWluPVxcXCIwXFxcIiBhcmlhLXZhbHVlbWF4PVxcXCJ7e21heH19XFxcIiBuZy1zdHlsZT1cXFwie3dpZHRoOiAocGVyY2VudCA8IDEwMCA/IHBlcmNlbnQgOiAxMDApICsgJyUnfVxcXCIgYXJpYS12YWx1ZXRleHQ9XFxcInt7cGVyY2VudCB8IG51bWJlcjowfX0lXFxcIiBhcmlhLWxhYmVsbGVkYnk9XFxcInt7Ojp0aXRsZX19XFxcIiBuZy10cmFuc2NsdWRlPjwvZGl2PlxcblwiICtcbiAgICBcIlwiKTtcbn1dKTtcblxuYW5ndWxhci5tb2R1bGUoXCJ1aWIvdGVtcGxhdGUvcHJvZ3Jlc3NiYXIvcHJvZ3Jlc3MuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uICgkdGVtcGxhdGVDYWNoZSkge1xuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ1aWIvdGVtcGxhdGUvcHJvZ3Jlc3NiYXIvcHJvZ3Jlc3MuaHRtbFwiLFxuICAgIFwiPGRpdiBjbGFzcz1cXFwicHJvZ3Jlc3NcXFwiIG5nLXRyYW5zY2x1ZGUgYXJpYS1sYWJlbGxlZGJ5PVxcXCJ7ezo6dGl0bGV9fVxcXCI+PC9kaXY+XCIpO1xufV0pO1xuXG5hbmd1bGFyLm1vZHVsZShcInVpYi90ZW1wbGF0ZS9wcm9ncmVzc2Jhci9wcm9ncmVzc2Jhci5odG1sXCIsIFtdKS5ydW4oW1wiJHRlbXBsYXRlQ2FjaGVcIiwgZnVuY3Rpb24gKCR0ZW1wbGF0ZUNhY2hlKSB7XG4gICR0ZW1wbGF0ZUNhY2hlLnB1dChcInVpYi90ZW1wbGF0ZS9wcm9ncmVzc2Jhci9wcm9ncmVzc2Jhci5odG1sXCIsXG4gICAgXCI8ZGl2IGNsYXNzPVxcXCJwcm9ncmVzc1xcXCI+XFxuXCIgK1xuICAgIFwiICA8ZGl2IGNsYXNzPVxcXCJwcm9ncmVzcy1iYXJcXFwiIG5nLWNsYXNzPVxcXCJ0eXBlICYmICdwcm9ncmVzcy1iYXItJyArIHR5cGVcXFwiIHJvbGU9XFxcInByb2dyZXNzYmFyXFxcIiBhcmlhLXZhbHVlbm93PVxcXCJ7e3ZhbHVlfX1cXFwiIGFyaWEtdmFsdWVtaW49XFxcIjBcXFwiIGFyaWEtdmFsdWVtYXg9XFxcInt7bWF4fX1cXFwiIG5nLXN0eWxlPVxcXCJ7d2lkdGg6IChwZXJjZW50IDwgMTAwID8gcGVyY2VudCA6IDEwMCkgKyAnJSd9XFxcIiBhcmlhLXZhbHVldGV4dD1cXFwie3twZXJjZW50IHwgbnVtYmVyOjB9fSVcXFwiIGFyaWEtbGFiZWxsZWRieT1cXFwie3s6OnRpdGxlfX1cXFwiIG5nLXRyYW5zY2x1ZGU+PC9kaXY+XFxuXCIgK1xuICAgIFwiPC9kaXY+XFxuXCIgK1xuICAgIFwiXCIpO1xufV0pO1xuXG5hbmd1bGFyLm1vZHVsZShcInVpYi90ZW1wbGF0ZS9yYXRpbmcvcmF0aW5nLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbiAoJHRlbXBsYXRlQ2FjaGUpIHtcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidWliL3RlbXBsYXRlL3JhdGluZy9yYXRpbmcuaHRtbFwiLFxuICAgIFwiPHNwYW4gbmctbW91c2VsZWF2ZT1cXFwicmVzZXQoKVxcXCIgbmcta2V5ZG93bj1cXFwib25LZXlkb3duKCRldmVudClcXFwiIHRhYmluZGV4PVxcXCIwXFxcIiByb2xlPVxcXCJzbGlkZXJcXFwiIGFyaWEtdmFsdWVtaW49XFxcIjBcXFwiIGFyaWEtdmFsdWVtYXg9XFxcInt7cmFuZ2UubGVuZ3RofX1cXFwiIGFyaWEtdmFsdWVub3c9XFxcInt7dmFsdWV9fVxcXCIgYXJpYS12YWx1ZXRleHQ9XFxcInt7dGl0bGV9fVxcXCI+XFxuXCIgK1xuICAgIFwiICAgIDxzcGFuIG5nLXJlcGVhdC1zdGFydD1cXFwiciBpbiByYW5nZSB0cmFjayBieSAkaW5kZXhcXFwiIGNsYXNzPVxcXCJzci1vbmx5XFxcIj4oe3sgJGluZGV4IDwgdmFsdWUgPyAnKicgOiAnICcgfX0pPC9zcGFuPlxcblwiICtcbiAgICBcIiAgICA8aSBuZy1yZXBlYXQtZW5kIG5nLW1vdXNlZW50ZXI9XFxcImVudGVyKCRpbmRleCArIDEpXFxcIiBuZy1jbGljaz1cXFwicmF0ZSgkaW5kZXggKyAxKVxcXCIgY2xhc3M9XFxcImdseXBoaWNvblxcXCIgbmctY2xhc3M9XFxcIiRpbmRleCA8IHZhbHVlICYmIChyLnN0YXRlT24gfHwgJ2dseXBoaWNvbi1zdGFyJykgfHwgKHIuc3RhdGVPZmYgfHwgJ2dseXBoaWNvbi1zdGFyLWVtcHR5JylcXFwiIG5nLWF0dHItdGl0bGU9XFxcInt7ci50aXRsZX19XFxcIj48L2k+XFxuXCIgK1xuICAgIFwiPC9zcGFuPlxcblwiICtcbiAgICBcIlwiKTtcbn1dKTtcblxuYW5ndWxhci5tb2R1bGUoXCJ1aWIvdGVtcGxhdGUvdGFicy90YWIuaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uICgkdGVtcGxhdGVDYWNoZSkge1xuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ1aWIvdGVtcGxhdGUvdGFicy90YWIuaHRtbFwiLFxuICAgIFwiPGxpIG5nLWNsYXNzPVxcXCJbe2FjdGl2ZTogYWN0aXZlLCBkaXNhYmxlZDogZGlzYWJsZWR9LCBjbGFzc2VzXVxcXCIgY2xhc3M9XFxcInVpYi10YWIgbmF2LWl0ZW1cXFwiPlxcblwiICtcbiAgICBcIiAgPGEgaHJlZiBuZy1jbGljaz1cXFwic2VsZWN0KCRldmVudClcXFwiIGNsYXNzPVxcXCJuYXYtbGlua1xcXCIgdWliLXRhYi1oZWFkaW5nLXRyYW5zY2x1ZGU+e3toZWFkaW5nfX08L2E+XFxuXCIgK1xuICAgIFwiPC9saT5cXG5cIiArXG4gICAgXCJcIik7XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKFwidWliL3RlbXBsYXRlL3RhYnMvdGFic2V0Lmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbiAoJHRlbXBsYXRlQ2FjaGUpIHtcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidWliL3RlbXBsYXRlL3RhYnMvdGFic2V0Lmh0bWxcIixcbiAgICBcIjxkaXY+XFxuXCIgK1xuICAgIFwiICA8dWwgY2xhc3M9XFxcIm5hdiBuYXYte3t0YWJzZXQudHlwZSB8fCAndGFicyd9fVxcXCIgbmctY2xhc3M9XFxcInsnbmF2LXN0YWNrZWQnOiB2ZXJ0aWNhbCwgJ25hdi1qdXN0aWZpZWQnOiBqdXN0aWZpZWR9XFxcIiBuZy10cmFuc2NsdWRlPjwvdWw+XFxuXCIgK1xuICAgIFwiICA8ZGl2IGNsYXNzPVxcXCJ0YWItY29udGVudFxcXCI+XFxuXCIgK1xuICAgIFwiICAgIDxkaXYgY2xhc3M9XFxcInRhYi1wYW5lXFxcIlxcblwiICtcbiAgICBcIiAgICAgICAgIG5nLXJlcGVhdD1cXFwidGFiIGluIHRhYnNldC50YWJzXFxcIlxcblwiICtcbiAgICBcIiAgICAgICAgIG5nLWNsYXNzPVxcXCJ7YWN0aXZlOiB0YWJzZXQuYWN0aXZlID09PSB0YWIuaW5kZXh9XFxcIlxcblwiICtcbiAgICBcIiAgICAgICAgIHVpYi10YWItY29udGVudC10cmFuc2NsdWRlPVxcXCJ0YWJcXFwiPlxcblwiICtcbiAgICBcIiAgICA8L2Rpdj5cXG5cIiArXG4gICAgXCIgIDwvZGl2PlxcblwiICtcbiAgICBcIjwvZGl2PlxcblwiICtcbiAgICBcIlwiKTtcbn1dKTtcblxuYW5ndWxhci5tb2R1bGUoXCJ1aWIvdGVtcGxhdGUvdGltZXBpY2tlci90aW1lcGlja2VyLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbiAoJHRlbXBsYXRlQ2FjaGUpIHtcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidWliL3RlbXBsYXRlL3RpbWVwaWNrZXIvdGltZXBpY2tlci5odG1sXCIsXG4gICAgXCI8dGFibGUgY2xhc3M9XFxcInVpYi10aW1lcGlja2VyXFxcIj5cXG5cIiArXG4gICAgXCIgIDx0Ym9keT5cXG5cIiArXG4gICAgXCIgICAgPHRyIGNsYXNzPVxcXCJ0ZXh0LWNlbnRlclxcXCIgbmctc2hvdz1cXFwiOjpzaG93U3Bpbm5lcnNcXFwiPlxcblwiICtcbiAgICBcIiAgICAgIDx0ZCBjbGFzcz1cXFwidWliLWluY3JlbWVudCBob3Vyc1xcXCI+PGEgbmctY2xpY2s9XFxcImluY3JlbWVudEhvdXJzKClcXFwiIG5nLWNsYXNzPVxcXCJ7ZGlzYWJsZWQ6IG5vSW5jcmVtZW50SG91cnMoKX1cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWxpbmtcXFwiIG5nLWRpc2FibGVkPVxcXCJub0luY3JlbWVudEhvdXJzKClcXFwiIHRhYmluZGV4PVxcXCItMVxcXCI+PHNwYW4gY2xhc3M9XFxcImdseXBoaWNvbiBnbHlwaGljb24tY2hldnJvbi11cFxcXCI+PC9zcGFuPjwvYT48L3RkPlxcblwiICtcbiAgICBcIiAgICAgIDx0ZD4mbmJzcDs8L3RkPlxcblwiICtcbiAgICBcIiAgICAgIDx0ZCBjbGFzcz1cXFwidWliLWluY3JlbWVudCBtaW51dGVzXFxcIj48YSBuZy1jbGljaz1cXFwiaW5jcmVtZW50TWludXRlcygpXFxcIiBuZy1jbGFzcz1cXFwie2Rpc2FibGVkOiBub0luY3JlbWVudE1pbnV0ZXMoKX1cXFwiIGNsYXNzPVxcXCJidG4gYnRuLWxpbmtcXFwiIG5nLWRpc2FibGVkPVxcXCJub0luY3JlbWVudE1pbnV0ZXMoKVxcXCIgdGFiaW5kZXg9XFxcIi0xXFxcIj48c3BhbiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1jaGV2cm9uLXVwXFxcIj48L3NwYW4+PC9hPjwvdGQ+XFxuXCIgK1xuICAgIFwiICAgICAgPHRkIG5nLXNob3c9XFxcInNob3dTZWNvbmRzXFxcIj4mbmJzcDs8L3RkPlxcblwiICtcbiAgICBcIiAgICAgIDx0ZCBuZy1zaG93PVxcXCJzaG93U2Vjb25kc1xcXCIgY2xhc3M9XFxcInVpYi1pbmNyZW1lbnQgc2Vjb25kc1xcXCI+PGEgbmctY2xpY2s9XFxcImluY3JlbWVudFNlY29uZHMoKVxcXCIgbmctY2xhc3M9XFxcIntkaXNhYmxlZDogbm9JbmNyZW1lbnRTZWNvbmRzKCl9XFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1saW5rXFxcIiBuZy1kaXNhYmxlZD1cXFwibm9JbmNyZW1lbnRTZWNvbmRzKClcXFwiIHRhYmluZGV4PVxcXCItMVxcXCI+PHNwYW4gY2xhc3M9XFxcImdseXBoaWNvbiBnbHlwaGljb24tY2hldnJvbi11cFxcXCI+PC9zcGFuPjwvYT48L3RkPlxcblwiICtcbiAgICBcIiAgICAgIDx0ZCBuZy1zaG93PVxcXCJzaG93TWVyaWRpYW5cXFwiPjwvdGQ+XFxuXCIgK1xuICAgIFwiICAgIDwvdHI+XFxuXCIgK1xuICAgIFwiICAgIDx0cj5cXG5cIiArXG4gICAgXCIgICAgICA8dGQgY2xhc3M9XFxcImZvcm0tZ3JvdXAgdWliLXRpbWUgaG91cnNcXFwiIG5nLWNsYXNzPVxcXCJ7J2hhcy1lcnJvcic6IGludmFsaWRIb3Vyc31cXFwiPlxcblwiICtcbiAgICBcIiAgICAgICAgPGlucHV0IHR5cGU9XFxcInRleHRcXFwiIHBsYWNlaG9sZGVyPVxcXCJISFxcXCIgbmctbW9kZWw9XFxcImhvdXJzXFxcIiBuZy1jaGFuZ2U9XFxcInVwZGF0ZUhvdXJzKClcXFwiIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2wgdGV4dC1jZW50ZXJcXFwiIG5nLXJlYWRvbmx5PVxcXCI6OnJlYWRvbmx5SW5wdXRcXFwiIG1heGxlbmd0aD1cXFwiMlxcXCIgdGFiaW5kZXg9XFxcInt7Ojp0YWJpbmRleH19XFxcIiBuZy1kaXNhYmxlZD1cXFwibm9JbmNyZW1lbnRIb3VycygpXFxcIiBuZy1ibHVyPVxcXCJibHVyKClcXFwiPlxcblwiICtcbiAgICBcIiAgICAgIDwvdGQ+XFxuXCIgK1xuICAgIFwiICAgICAgPHRkIGNsYXNzPVxcXCJ1aWItc2VwYXJhdG9yXFxcIj46PC90ZD5cXG5cIiArXG4gICAgXCIgICAgICA8dGQgY2xhc3M9XFxcImZvcm0tZ3JvdXAgdWliLXRpbWUgbWludXRlc1xcXCIgbmctY2xhc3M9XFxcInsnaGFzLWVycm9yJzogaW52YWxpZE1pbnV0ZXN9XFxcIj5cXG5cIiArXG4gICAgXCIgICAgICAgIDxpbnB1dCB0eXBlPVxcXCJ0ZXh0XFxcIiBwbGFjZWhvbGRlcj1cXFwiTU1cXFwiIG5nLW1vZGVsPVxcXCJtaW51dGVzXFxcIiBuZy1jaGFuZ2U9XFxcInVwZGF0ZU1pbnV0ZXMoKVxcXCIgY2xhc3M9XFxcImZvcm0tY29udHJvbCB0ZXh0LWNlbnRlclxcXCIgbmctcmVhZG9ubHk9XFxcIjo6cmVhZG9ubHlJbnB1dFxcXCIgbWF4bGVuZ3RoPVxcXCIyXFxcIiB0YWJpbmRleD1cXFwie3s6OnRhYmluZGV4fX1cXFwiIG5nLWRpc2FibGVkPVxcXCJub0luY3JlbWVudE1pbnV0ZXMoKVxcXCIgbmctYmx1cj1cXFwiYmx1cigpXFxcIj5cXG5cIiArXG4gICAgXCIgICAgICA8L3RkPlxcblwiICtcbiAgICBcIiAgICAgIDx0ZCBuZy1zaG93PVxcXCJzaG93U2Vjb25kc1xcXCIgY2xhc3M9XFxcInVpYi1zZXBhcmF0b3JcXFwiPjo8L3RkPlxcblwiICtcbiAgICBcIiAgICAgIDx0ZCBjbGFzcz1cXFwiZm9ybS1ncm91cCB1aWItdGltZSBzZWNvbmRzXFxcIiBuZy1jbGFzcz1cXFwieydoYXMtZXJyb3InOiBpbnZhbGlkU2Vjb25kc31cXFwiIG5nLXNob3c9XFxcInNob3dTZWNvbmRzXFxcIj5cXG5cIiArXG4gICAgXCIgICAgICAgIDxpbnB1dCB0eXBlPVxcXCJ0ZXh0XFxcIiBwbGFjZWhvbGRlcj1cXFwiU1NcXFwiIG5nLW1vZGVsPVxcXCJzZWNvbmRzXFxcIiBuZy1jaGFuZ2U9XFxcInVwZGF0ZVNlY29uZHMoKVxcXCIgY2xhc3M9XFxcImZvcm0tY29udHJvbCB0ZXh0LWNlbnRlclxcXCIgbmctcmVhZG9ubHk9XFxcInJlYWRvbmx5SW5wdXRcXFwiIG1heGxlbmd0aD1cXFwiMlxcXCIgdGFiaW5kZXg9XFxcInt7Ojp0YWJpbmRleH19XFxcIiBuZy1kaXNhYmxlZD1cXFwibm9JbmNyZW1lbnRTZWNvbmRzKClcXFwiIG5nLWJsdXI9XFxcImJsdXIoKVxcXCI+XFxuXCIgK1xuICAgIFwiICAgICAgPC90ZD5cXG5cIiArXG4gICAgXCIgICAgICA8dGQgbmctc2hvdz1cXFwic2hvd01lcmlkaWFuXFxcIiBjbGFzcz1cXFwidWliLXRpbWUgYW0tcG1cXFwiPjxidXR0b24gdHlwZT1cXFwiYnV0dG9uXFxcIiBuZy1jbGFzcz1cXFwie2Rpc2FibGVkOiBub1RvZ2dsZU1lcmlkaWFuKCl9XFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1kZWZhdWx0IHRleHQtY2VudGVyXFxcIiBuZy1jbGljaz1cXFwidG9nZ2xlTWVyaWRpYW4oKVxcXCIgbmctZGlzYWJsZWQ9XFxcIm5vVG9nZ2xlTWVyaWRpYW4oKVxcXCIgdGFiaW5kZXg9XFxcInt7Ojp0YWJpbmRleH19XFxcIj57e21lcmlkaWFufX08L2J1dHRvbj48L3RkPlxcblwiICtcbiAgICBcIiAgICA8L3RyPlxcblwiICtcbiAgICBcIiAgICA8dHIgY2xhc3M9XFxcInRleHQtY2VudGVyXFxcIiBuZy1zaG93PVxcXCI6OnNob3dTcGlubmVyc1xcXCI+XFxuXCIgK1xuICAgIFwiICAgICAgPHRkIGNsYXNzPVxcXCJ1aWItZGVjcmVtZW50IGhvdXJzXFxcIj48YSBuZy1jbGljaz1cXFwiZGVjcmVtZW50SG91cnMoKVxcXCIgbmctY2xhc3M9XFxcIntkaXNhYmxlZDogbm9EZWNyZW1lbnRIb3VycygpfVxcXCIgY2xhc3M9XFxcImJ0biBidG4tbGlua1xcXCIgbmctZGlzYWJsZWQ9XFxcIm5vRGVjcmVtZW50SG91cnMoKVxcXCIgdGFiaW5kZXg9XFxcIi0xXFxcIj48c3BhbiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1jaGV2cm9uLWRvd25cXFwiPjwvc3Bhbj48L2E+PC90ZD5cXG5cIiArXG4gICAgXCIgICAgICA8dGQ+Jm5ic3A7PC90ZD5cXG5cIiArXG4gICAgXCIgICAgICA8dGQgY2xhc3M9XFxcInVpYi1kZWNyZW1lbnQgbWludXRlc1xcXCI+PGEgbmctY2xpY2s9XFxcImRlY3JlbWVudE1pbnV0ZXMoKVxcXCIgbmctY2xhc3M9XFxcIntkaXNhYmxlZDogbm9EZWNyZW1lbnRNaW51dGVzKCl9XFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1saW5rXFxcIiBuZy1kaXNhYmxlZD1cXFwibm9EZWNyZW1lbnRNaW51dGVzKClcXFwiIHRhYmluZGV4PVxcXCItMVxcXCI+PHNwYW4gY2xhc3M9XFxcImdseXBoaWNvbiBnbHlwaGljb24tY2hldnJvbi1kb3duXFxcIj48L3NwYW4+PC9hPjwvdGQ+XFxuXCIgK1xuICAgIFwiICAgICAgPHRkIG5nLXNob3c9XFxcInNob3dTZWNvbmRzXFxcIj4mbmJzcDs8L3RkPlxcblwiICtcbiAgICBcIiAgICAgIDx0ZCBuZy1zaG93PVxcXCJzaG93U2Vjb25kc1xcXCIgY2xhc3M9XFxcInVpYi1kZWNyZW1lbnQgc2Vjb25kc1xcXCI+PGEgbmctY2xpY2s9XFxcImRlY3JlbWVudFNlY29uZHMoKVxcXCIgbmctY2xhc3M9XFxcIntkaXNhYmxlZDogbm9EZWNyZW1lbnRTZWNvbmRzKCl9XFxcIiBjbGFzcz1cXFwiYnRuIGJ0bi1saW5rXFxcIiBuZy1kaXNhYmxlZD1cXFwibm9EZWNyZW1lbnRTZWNvbmRzKClcXFwiIHRhYmluZGV4PVxcXCItMVxcXCI+PHNwYW4gY2xhc3M9XFxcImdseXBoaWNvbiBnbHlwaGljb24tY2hldnJvbi1kb3duXFxcIj48L3NwYW4+PC9hPjwvdGQ+XFxuXCIgK1xuICAgIFwiICAgICAgPHRkIG5nLXNob3c9XFxcInNob3dNZXJpZGlhblxcXCI+PC90ZD5cXG5cIiArXG4gICAgXCIgICAgPC90cj5cXG5cIiArXG4gICAgXCIgIDwvdGJvZHk+XFxuXCIgK1xuICAgIFwiPC90YWJsZT5cXG5cIiArXG4gICAgXCJcIik7XG59XSk7XG5cbmFuZ3VsYXIubW9kdWxlKFwidWliL3RlbXBsYXRlL3R5cGVhaGVhZC90eXBlYWhlYWQtbWF0Y2guaHRtbFwiLCBbXSkucnVuKFtcIiR0ZW1wbGF0ZUNhY2hlXCIsIGZ1bmN0aW9uICgkdGVtcGxhdGVDYWNoZSkge1xuICAkdGVtcGxhdGVDYWNoZS5wdXQoXCJ1aWIvdGVtcGxhdGUvdHlwZWFoZWFkL3R5cGVhaGVhZC1tYXRjaC5odG1sXCIsXG4gICAgXCI8YSBocmVmXFxuXCIgK1xuICAgIFwiICAgdGFiaW5kZXg9XFxcIi0xXFxcIlxcblwiICtcbiAgICBcIiAgIG5nLWJpbmQtaHRtbD1cXFwibWF0Y2gubGFiZWwgfCB1aWJUeXBlYWhlYWRIaWdobGlnaHQ6cXVlcnlcXFwiXFxuXCIgK1xuICAgIFwiICAgbmctYXR0ci10aXRsZT1cXFwie3ttYXRjaC5sYWJlbH19XFxcIj48L2E+XFxuXCIgK1xuICAgIFwiXCIpO1xufV0pO1xuXG5hbmd1bGFyLm1vZHVsZShcInVpYi90ZW1wbGF0ZS90eXBlYWhlYWQvdHlwZWFoZWFkLXBvcHVwLmh0bWxcIiwgW10pLnJ1bihbXCIkdGVtcGxhdGVDYWNoZVwiLCBmdW5jdGlvbiAoJHRlbXBsYXRlQ2FjaGUpIHtcbiAgJHRlbXBsYXRlQ2FjaGUucHV0KFwidWliL3RlbXBsYXRlL3R5cGVhaGVhZC90eXBlYWhlYWQtcG9wdXAuaHRtbFwiLFxuICAgIFwiPHVsIGNsYXNzPVxcXCJkcm9wZG93bi1tZW51XFxcIiBuZy1zaG93PVxcXCJpc09wZW4oKSAmJiAhbW92ZUluUHJvZ3Jlc3NcXFwiIG5nLXN0eWxlPVxcXCJ7dG9wOiBwb3NpdGlvbigpLnRvcCsncHgnLCBsZWZ0OiBwb3NpdGlvbigpLmxlZnQrJ3B4J31cXFwiIHJvbGU9XFxcImxpc3Rib3hcXFwiIGFyaWEtaGlkZGVuPVxcXCJ7eyFpc09wZW4oKX19XFxcIj5cXG5cIiArXG4gICAgXCIgICAgPGxpIGNsYXNzPVxcXCJ1aWItdHlwZWFoZWFkLW1hdGNoXFxcIiBuZy1yZXBlYXQ9XFxcIm1hdGNoIGluIG1hdGNoZXMgdHJhY2sgYnkgJGluZGV4XFxcIiBuZy1jbGFzcz1cXFwie2FjdGl2ZTogaXNBY3RpdmUoJGluZGV4KSB9XFxcIiBuZy1tb3VzZWVudGVyPVxcXCJzZWxlY3RBY3RpdmUoJGluZGV4KVxcXCIgbmctY2xpY2s9XFxcInNlbGVjdE1hdGNoKCRpbmRleCwgJGV2ZW50KVxcXCIgcm9sZT1cXFwib3B0aW9uXFxcIiBpZD1cXFwie3s6Om1hdGNoLmlkfX1cXFwiPlxcblwiICtcbiAgICBcIiAgICAgICAgPGRpdiB1aWItdHlwZWFoZWFkLW1hdGNoIGluZGV4PVxcXCIkaW5kZXhcXFwiIG1hdGNoPVxcXCJtYXRjaFxcXCIgcXVlcnk9XFxcInF1ZXJ5XFxcIiB0ZW1wbGF0ZS11cmw9XFxcInRlbXBsYXRlVXJsXFxcIj48L2Rpdj5cXG5cIiArXG4gICAgXCIgICAgPC9saT5cXG5cIiArXG4gICAgXCI8L3VsPlxcblwiICtcbiAgICBcIlwiKTtcbn1dKTtcbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAuY2Fyb3VzZWwnKS5ydW4oZnVuY3Rpb24oKSB7IWFuZ3VsYXIuJCRjc3AoKS5ub0lubGluZVN0eWxlICYmICFhbmd1bGFyLiQkdWliQ2Fyb3VzZWxDc3MgJiYgYW5ndWxhci5lbGVtZW50KGRvY3VtZW50KS5maW5kKCdoZWFkJykucHJlcGVuZCgnPHN0eWxlIHR5cGU9XCJ0ZXh0L2Nzc1wiPi5uZy1hbmltYXRlLml0ZW06bm90KC5sZWZ0KTpub3QoLnJpZ2h0KXstd2Via2l0LXRyYW5zaXRpb246MHMgZWFzZS1pbi1vdXQgbGVmdDt0cmFuc2l0aW9uOjBzIGVhc2UtaW4tb3V0IGxlZnR9PC9zdHlsZT4nKTsgYW5ndWxhci4kJHVpYkNhcm91c2VsQ3NzID0gdHJ1ZTsgfSk7XG5hbmd1bGFyLm1vZHVsZSgndWkuYm9vdHN0cmFwLmRhdGVwaWNrZXInKS5ydW4oZnVuY3Rpb24oKSB7IWFuZ3VsYXIuJCRjc3AoKS5ub0lubGluZVN0eWxlICYmICFhbmd1bGFyLiQkdWliRGF0ZXBpY2tlckNzcyAmJiBhbmd1bGFyLmVsZW1lbnQoZG9jdW1lbnQpLmZpbmQoJ2hlYWQnKS5wcmVwZW5kKCc8c3R5bGUgdHlwZT1cInRleHQvY3NzXCI+LnVpYi1kYXRlcGlja2VyIC51aWItdGl0bGV7d2lkdGg6MTAwJTt9LnVpYi1kYXkgYnV0dG9uLC51aWItbW9udGggYnV0dG9uLC51aWIteWVhciBidXR0b257bWluLXdpZHRoOjEwMCU7fS51aWItbGVmdCwudWliLXJpZ2h0e3dpZHRoOjEwMCV9PC9zdHlsZT4nKTsgYW5ndWxhci4kJHVpYkRhdGVwaWNrZXJDc3MgPSB0cnVlOyB9KTtcbmFuZ3VsYXIubW9kdWxlKCd1aS5ib290c3RyYXAucG9zaXRpb24nKS5ydW4oZnVuY3Rpb24oKSB7IWFuZ3VsYXIuJCRjc3AoKS5ub0lubGluZVN0eWxlICYmICFhbmd1bGFyLiQkdWliUG9zaXRpb25Dc3MgJiYgYW5ndWxhci5lbGVtZW50KGRvY3VtZW50KS5maW5kKCdoZWFkJykucHJlcGVuZCgnPHN0eWxlIHR5cGU9XCJ0ZXh0L2Nzc1wiPi51aWItcG9zaXRpb24tbWVhc3VyZXtkaXNwbGF5OmJsb2NrICFpbXBvcnRhbnQ7dmlzaWJpbGl0eTpoaWRkZW4gIWltcG9ydGFudDtwb3NpdGlvbjphYnNvbHV0ZSAhaW1wb3J0YW50O3RvcDotOTk5OXB4ICFpbXBvcnRhbnQ7bGVmdDotOTk5OXB4ICFpbXBvcnRhbnQ7fS51aWItcG9zaXRpb24tc2Nyb2xsYmFyLW1lYXN1cmV7cG9zaXRpb246YWJzb2x1dGUgIWltcG9ydGFudDt0b3A6LTk5OTlweCAhaW1wb3J0YW50O3dpZHRoOjUwcHggIWltcG9ydGFudDtoZWlnaHQ6NTBweCAhaW1wb3J0YW50O292ZXJmbG93OnNjcm9sbCAhaW1wb3J0YW50O30udWliLXBvc2l0aW9uLWJvZHktc2Nyb2xsYmFyLW1lYXN1cmV7b3ZlcmZsb3c6c2Nyb2xsICFpbXBvcnRhbnQ7fTwvc3R5bGU+Jyk7IGFuZ3VsYXIuJCR1aWJQb3NpdGlvbkNzcyA9IHRydWU7IH0pO1xuYW5ndWxhci5tb2R1bGUoJ3VpLmJvb3RzdHJhcC5kYXRlcGlja2VyUG9wdXAnKS5ydW4oZnVuY3Rpb24oKSB7IWFuZ3VsYXIuJCRjc3AoKS5ub0lubGluZVN0eWxlICYmICFhbmd1bGFyLiQkdWliRGF0ZXBpY2tlcnBvcHVwQ3NzICYmIGFuZ3VsYXIuZWxlbWVudChkb2N1bWVudCkuZmluZCgnaGVhZCcpLnByZXBlbmQoJzxzdHlsZSB0eXBlPVwidGV4dC9jc3NcIj4udWliLWRhdGVwaWNrZXItcG9wdXAuZHJvcGRvd24tbWVudXtkaXNwbGF5OmJsb2NrO2Zsb2F0Om5vbmU7bWFyZ2luOjA7fS51aWItYnV0dG9uLWJhcntwYWRkaW5nOjEwcHggOXB4IDJweDt9PC9zdHlsZT4nKTsgYW5ndWxhci4kJHVpYkRhdGVwaWNrZXJwb3B1cENzcyA9IHRydWU7IH0pO1xuYW5ndWxhci5tb2R1bGUoJ3VpLmJvb3RzdHJhcC50b29sdGlwJykucnVuKGZ1bmN0aW9uKCkgeyFhbmd1bGFyLiQkY3NwKCkubm9JbmxpbmVTdHlsZSAmJiAhYW5ndWxhci4kJHVpYlRvb2x0aXBDc3MgJiYgYW5ndWxhci5lbGVtZW50KGRvY3VtZW50KS5maW5kKCdoZWFkJykucHJlcGVuZCgnPHN0eWxlIHR5cGU9XCJ0ZXh0L2Nzc1wiPlt1aWItdG9vbHRpcC1wb3B1cF0udG9vbHRpcC50b3AtbGVmdCA+IC50b29sdGlwLWFycm93LFt1aWItdG9vbHRpcC1wb3B1cF0udG9vbHRpcC50b3AtcmlnaHQgPiAudG9vbHRpcC1hcnJvdyxbdWliLXRvb2x0aXAtcG9wdXBdLnRvb2x0aXAuYm90dG9tLWxlZnQgPiAudG9vbHRpcC1hcnJvdyxbdWliLXRvb2x0aXAtcG9wdXBdLnRvb2x0aXAuYm90dG9tLXJpZ2h0ID4gLnRvb2x0aXAtYXJyb3csW3VpYi10b29sdGlwLXBvcHVwXS50b29sdGlwLmxlZnQtdG9wID4gLnRvb2x0aXAtYXJyb3csW3VpYi10b29sdGlwLXBvcHVwXS50b29sdGlwLmxlZnQtYm90dG9tID4gLnRvb2x0aXAtYXJyb3csW3VpYi10b29sdGlwLXBvcHVwXS50b29sdGlwLnJpZ2h0LXRvcCA+IC50b29sdGlwLWFycm93LFt1aWItdG9vbHRpcC1wb3B1cF0udG9vbHRpcC5yaWdodC1ib3R0b20gPiAudG9vbHRpcC1hcnJvdyxbdWliLXRvb2x0aXAtaHRtbC1wb3B1cF0udG9vbHRpcC50b3AtbGVmdCA+IC50b29sdGlwLWFycm93LFt1aWItdG9vbHRpcC1odG1sLXBvcHVwXS50b29sdGlwLnRvcC1yaWdodCA+IC50b29sdGlwLWFycm93LFt1aWItdG9vbHRpcC1odG1sLXBvcHVwXS50b29sdGlwLmJvdHRvbS1sZWZ0ID4gLnRvb2x0aXAtYXJyb3csW3VpYi10b29sdGlwLWh0bWwtcG9wdXBdLnRvb2x0aXAuYm90dG9tLXJpZ2h0ID4gLnRvb2x0aXAtYXJyb3csW3VpYi10b29sdGlwLWh0bWwtcG9wdXBdLnRvb2x0aXAubGVmdC10b3AgPiAudG9vbHRpcC1hcnJvdyxbdWliLXRvb2x0aXAtaHRtbC1wb3B1cF0udG9vbHRpcC5sZWZ0LWJvdHRvbSA+IC50b29sdGlwLWFycm93LFt1aWItdG9vbHRpcC1odG1sLXBvcHVwXS50b29sdGlwLnJpZ2h0LXRvcCA+IC50b29sdGlwLWFycm93LFt1aWItdG9vbHRpcC1odG1sLXBvcHVwXS50b29sdGlwLnJpZ2h0LWJvdHRvbSA+IC50b29sdGlwLWFycm93LFt1aWItdG9vbHRpcC10ZW1wbGF0ZS1wb3B1cF0udG9vbHRpcC50b3AtbGVmdCA+IC50b29sdGlwLWFycm93LFt1aWItdG9vbHRpcC10ZW1wbGF0ZS1wb3B1cF0udG9vbHRpcC50b3AtcmlnaHQgPiAudG9vbHRpcC1hcnJvdyxbdWliLXRvb2x0aXAtdGVtcGxhdGUtcG9wdXBdLnRvb2x0aXAuYm90dG9tLWxlZnQgPiAudG9vbHRpcC1hcnJvdyxbdWliLXRvb2x0aXAtdGVtcGxhdGUtcG9wdXBdLnRvb2x0aXAuYm90dG9tLXJpZ2h0ID4gLnRvb2x0aXAtYXJyb3csW3VpYi10b29sdGlwLXRlbXBsYXRlLXBvcHVwXS50b29sdGlwLmxlZnQtdG9wID4gLnRvb2x0aXAtYXJyb3csW3VpYi10b29sdGlwLXRlbXBsYXRlLXBvcHVwXS50b29sdGlwLmxlZnQtYm90dG9tID4gLnRvb2x0aXAtYXJyb3csW3VpYi10b29sdGlwLXRlbXBsYXRlLXBvcHVwXS50b29sdGlwLnJpZ2h0LXRvcCA+IC50b29sdGlwLWFycm93LFt1aWItdG9vbHRpcC10ZW1wbGF0ZS1wb3B1cF0udG9vbHRpcC5yaWdodC1ib3R0b20gPiAudG9vbHRpcC1hcnJvdyxbdWliLXBvcG92ZXItcG9wdXBdLnBvcG92ZXIudG9wLWxlZnQgPiAuYXJyb3csW3VpYi1wb3BvdmVyLXBvcHVwXS5wb3BvdmVyLnRvcC1yaWdodCA+IC5hcnJvdyxbdWliLXBvcG92ZXItcG9wdXBdLnBvcG92ZXIuYm90dG9tLWxlZnQgPiAuYXJyb3csW3VpYi1wb3BvdmVyLXBvcHVwXS5wb3BvdmVyLmJvdHRvbS1yaWdodCA+IC5hcnJvdyxbdWliLXBvcG92ZXItcG9wdXBdLnBvcG92ZXIubGVmdC10b3AgPiAuYXJyb3csW3VpYi1wb3BvdmVyLXBvcHVwXS5wb3BvdmVyLmxlZnQtYm90dG9tID4gLmFycm93LFt1aWItcG9wb3Zlci1wb3B1cF0ucG9wb3Zlci5yaWdodC10b3AgPiAuYXJyb3csW3VpYi1wb3BvdmVyLXBvcHVwXS5wb3BvdmVyLnJpZ2h0LWJvdHRvbSA+IC5hcnJvdyxbdWliLXBvcG92ZXItaHRtbC1wb3B1cF0ucG9wb3Zlci50b3AtbGVmdCA+IC5hcnJvdyxbdWliLXBvcG92ZXItaHRtbC1wb3B1cF0ucG9wb3Zlci50b3AtcmlnaHQgPiAuYXJyb3csW3VpYi1wb3BvdmVyLWh0bWwtcG9wdXBdLnBvcG92ZXIuYm90dG9tLWxlZnQgPiAuYXJyb3csW3VpYi1wb3BvdmVyLWh0bWwtcG9wdXBdLnBvcG92ZXIuYm90dG9tLXJpZ2h0ID4gLmFycm93LFt1aWItcG9wb3Zlci1odG1sLXBvcHVwXS5wb3BvdmVyLmxlZnQtdG9wID4gLmFycm93LFt1aWItcG9wb3Zlci1odG1sLXBvcHVwXS5wb3BvdmVyLmxlZnQtYm90dG9tID4gLmFycm93LFt1aWItcG9wb3Zlci1odG1sLXBvcHVwXS5wb3BvdmVyLnJpZ2h0LXRvcCA+IC5hcnJvdyxbdWliLXBvcG92ZXItaHRtbC1wb3B1cF0ucG9wb3Zlci5yaWdodC1ib3R0b20gPiAuYXJyb3csW3VpYi1wb3BvdmVyLXRlbXBsYXRlLXBvcHVwXS5wb3BvdmVyLnRvcC1sZWZ0ID4gLmFycm93LFt1aWItcG9wb3Zlci10ZW1wbGF0ZS1wb3B1cF0ucG9wb3Zlci50b3AtcmlnaHQgPiAuYXJyb3csW3VpYi1wb3BvdmVyLXRlbXBsYXRlLXBvcHVwXS5wb3BvdmVyLmJvdHRvbS1sZWZ0ID4gLmFycm93LFt1aWItcG9wb3Zlci10ZW1wbGF0ZS1wb3B1cF0ucG9wb3Zlci5ib3R0b20tcmlnaHQgPiAuYXJyb3csW3VpYi1wb3BvdmVyLXRlbXBsYXRlLXBvcHVwXS5wb3BvdmVyLmxlZnQtdG9wID4gLmFycm93LFt1aWItcG9wb3Zlci10ZW1wbGF0ZS1wb3B1cF0ucG9wb3Zlci5sZWZ0LWJvdHRvbSA+IC5hcnJvdyxbdWliLXBvcG92ZXItdGVtcGxhdGUtcG9wdXBdLnBvcG92ZXIucmlnaHQtdG9wID4gLmFycm93LFt1aWItcG9wb3Zlci10ZW1wbGF0ZS1wb3B1cF0ucG9wb3Zlci5yaWdodC1ib3R0b20gPiAuYXJyb3d7dG9wOmF1dG87Ym90dG9tOmF1dG87bGVmdDphdXRvO3JpZ2h0OmF1dG87bWFyZ2luOjA7fVt1aWItcG9wb3Zlci1wb3B1cF0ucG9wb3ZlcixbdWliLXBvcG92ZXItaHRtbC1wb3B1cF0ucG9wb3ZlcixbdWliLXBvcG92ZXItdGVtcGxhdGUtcG9wdXBdLnBvcG92ZXJ7ZGlzcGxheTpibG9jayAhaW1wb3J0YW50O308L3N0eWxlPicpOyBhbmd1bGFyLiQkdWliVG9vbHRpcENzcyA9IHRydWU7IH0pO1xuYW5ndWxhci5tb2R1bGUoJ3VpLmJvb3RzdHJhcC50aW1lcGlja2VyJykucnVuKGZ1bmN0aW9uKCkgeyFhbmd1bGFyLiQkY3NwKCkubm9JbmxpbmVTdHlsZSAmJiAhYW5ndWxhci4kJHVpYlRpbWVwaWNrZXJDc3MgJiYgYW5ndWxhci5lbGVtZW50KGRvY3VtZW50KS5maW5kKCdoZWFkJykucHJlcGVuZCgnPHN0eWxlIHR5cGU9XCJ0ZXh0L2Nzc1wiPi51aWItdGltZSBpbnB1dHt3aWR0aDo1MHB4O308L3N0eWxlPicpOyBhbmd1bGFyLiQkdWliVGltZXBpY2tlckNzcyA9IHRydWU7IH0pO1xuYW5ndWxhci5tb2R1bGUoJ3VpLmJvb3RzdHJhcC50eXBlYWhlYWQnKS5ydW4oZnVuY3Rpb24oKSB7IWFuZ3VsYXIuJCRjc3AoKS5ub0lubGluZVN0eWxlICYmICFhbmd1bGFyLiQkdWliVHlwZWFoZWFkQ3NzICYmIGFuZ3VsYXIuZWxlbWVudChkb2N1bWVudCkuZmluZCgnaGVhZCcpLnByZXBlbmQoJzxzdHlsZSB0eXBlPVwidGV4dC9jc3NcIj5bdWliLXR5cGVhaGVhZC1wb3B1cF0uZHJvcGRvd24tbWVudXtkaXNwbGF5OmJsb2NrO308L3N0eWxlPicpOyBhbmd1bGFyLiQkdWliVHlwZWFoZWFkQ3NzID0gdHJ1ZTsgfSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYW5ndWxhci11aS1ib290c3RyYXAvZGlzdC91aS1ib290c3RyYXAtdHBscy5qc1xuLy8gbW9kdWxlIGlkID0gMTM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///135\n")},function(module,exports){eval("/*global angular:true, browser:true */\n\n/**\n * @license HTTP Auth Interceptor Module for AngularJS\n * (c) 2012 Witold Szczerba\n * License: MIT\n */\n\n(function () {\n  'use strict';\n\n  angular.module('http-auth-interceptor', ['http-auth-interceptor-buffer'])\n\n  .factory('authService', ['$rootScope','httpBuffer', function($rootScope, httpBuffer) {\n    return {\n      /**\n       * Call this function to indicate that authentication was successfull and trigger a\n       * retry of all deferred requests.\n       * @param data an optional argument to pass on to $broadcast which may be useful for\n       * example if you need to pass through details of the user that was logged in\n       * @param configUpdater an optional transformation function that can modify the\n       * requests that are retried after having logged in.  This can be used for example\n       * to add an authentication token.  It must return the request.\n       */\n      loginConfirmed: function(data, configUpdater) {\n        var updater = configUpdater || function(config) {return config;};\n        $rootScope.$broadcast('event:auth-loginConfirmed', data);\n        httpBuffer.retryAll(updater);\n      },\n\n      /**\n       * Call this function to indicate that authentication should not proceed.\n       * All deferred requests will be abandoned or rejected (if reason is provided).\n       * @param data an optional argument to pass on to $broadcast.\n       * @param reason if provided, the requests are rejected; abandoned otherwise.\n       */\n      loginCancelled: function(data, reason) {\n        httpBuffer.rejectAll(reason);\n        $rootScope.$broadcast('event:auth-loginCancelled', data);\n      }\n    };\n  }])\n\n  /**\n   * $http interceptor.\n   * On 401 response (without 'ignoreAuthModule' option) stores the request\n   * and broadcasts 'event:auth-loginRequired'.\n   * On 403 response (without 'ignoreAuthModule' option) discards the request\n   * and broadcasts 'event:auth-forbidden'.\n   */\n  .config(['$httpProvider', function($httpProvider) {\n    $httpProvider.interceptors.push(['$rootScope', '$q', 'httpBuffer', function($rootScope, $q, httpBuffer) {\n      return {\n        responseError: function(rejection) {\n          var config = rejection.config || {};\n          if (!config.ignoreAuthModule) {\n            switch (rejection.status) {\n              case 401:\n                var deferred = $q.defer();\n                var bufferLength = httpBuffer.append(config, deferred);\n                if (bufferLength === 1)\n                  $rootScope.$broadcast('event:auth-loginRequired', rejection);\n                return deferred.promise;\n              case 403:\n                $rootScope.$broadcast('event:auth-forbidden', rejection);\n                break;\n            }\n          }\n          // otherwise, default behaviour\n          return $q.reject(rejection);\n        }\n      };\n    }]);\n  }]);\n\n  /**\n   * Private module, a utility, required internally by 'http-auth-interceptor'.\n   */\n  angular.module('http-auth-interceptor-buffer', [])\n\n  .factory('httpBuffer', ['$injector', function($injector) {\n    /** Holds all the requests, so they can be re-requested in future. */\n    var buffer = [];\n\n    /** Service initialized later because of circular dependency problem. */\n    var $http;\n\n    function retryHttpRequest(config, deferred) {\n      function successCallback(response) {\n        deferred.resolve(response);\n      }\n      function errorCallback(response) {\n        deferred.reject(response);\n      }\n      $http = $http || $injector.get('$http');\n      $http(config).then(successCallback, errorCallback);\n    }\n\n    return {\n      /**\n       * Appends HTTP request configuration object with deferred response attached to buffer.\n       * @return {Number} The new length of the buffer.\n       */\n      append: function(config, deferred) {\n        return buffer.push({\n          config: config,\n          deferred: deferred\n        });\n      },\n\n      /**\n       * Abandon or reject (if reason provided) all the buffered requests.\n       */\n      rejectAll: function(reason) {\n        if (reason) {\n          for (var i = 0; i < buffer.length; ++i) {\n            buffer[i].deferred.reject(reason);\n          }\n        }\n        buffer = [];\n      },\n\n      /**\n       * Retries all the buffered requests clears the buffer.\n       */\n      retryAll: function(updater) {\n        for (var i = 0; i < buffer.length; ++i) {\n          var _cfg = updater(buffer[i].config);\n          if (_cfg !== false)\n            retryHttpRequest(_cfg, buffer[i].deferred);\n        }\n        buffer = [];\n      }\n    };\n  }]);\n})();\n\n/* commonjs package manager support (eg componentjs) */\nif (typeof module !== \"undefined\" && typeof exports !== \"undefined\" && module.exports === exports){\n  module.exports = 'http-auth-interceptor';\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTM2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FuZ3VsYXItaHR0cC1hdXRoL3NyYy9odHRwLWF1dGgtaW50ZXJjZXB0b3IuanM/YjBlMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKmdsb2JhbCBhbmd1bGFyOnRydWUsIGJyb3dzZXI6dHJ1ZSAqL1xuXG4vKipcbiAqIEBsaWNlbnNlIEhUVFAgQXV0aCBJbnRlcmNlcHRvciBNb2R1bGUgZm9yIEFuZ3VsYXJKU1xuICogKGMpIDIwMTIgV2l0b2xkIFN6Y3plcmJhXG4gKiBMaWNlbnNlOiBNSVRcbiAqL1xuXG4oZnVuY3Rpb24gKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgYW5ndWxhci5tb2R1bGUoJ2h0dHAtYXV0aC1pbnRlcmNlcHRvcicsIFsnaHR0cC1hdXRoLWludGVyY2VwdG9yLWJ1ZmZlciddKVxuXG4gIC5mYWN0b3J5KCdhdXRoU2VydmljZScsIFsnJHJvb3RTY29wZScsJ2h0dHBCdWZmZXInLCBmdW5jdGlvbigkcm9vdFNjb3BlLCBodHRwQnVmZmVyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8qKlxuICAgICAgICogQ2FsbCB0aGlzIGZ1bmN0aW9uIHRvIGluZGljYXRlIHRoYXQgYXV0aGVudGljYXRpb24gd2FzIHN1Y2Nlc3NmdWxsIGFuZCB0cmlnZ2VyIGFcbiAgICAgICAqIHJldHJ5IG9mIGFsbCBkZWZlcnJlZCByZXF1ZXN0cy5cbiAgICAgICAqIEBwYXJhbSBkYXRhIGFuIG9wdGlvbmFsIGFyZ3VtZW50IHRvIHBhc3Mgb24gdG8gJGJyb2FkY2FzdCB3aGljaCBtYXkgYmUgdXNlZnVsIGZvclxuICAgICAgICogZXhhbXBsZSBpZiB5b3UgbmVlZCB0byBwYXNzIHRocm91Z2ggZGV0YWlscyBvZiB0aGUgdXNlciB0aGF0IHdhcyBsb2dnZWQgaW5cbiAgICAgICAqIEBwYXJhbSBjb25maWdVcGRhdGVyIGFuIG9wdGlvbmFsIHRyYW5zZm9ybWF0aW9uIGZ1bmN0aW9uIHRoYXQgY2FuIG1vZGlmeSB0aGVcbiAgICAgICAqIHJlcXVlc3RzIHRoYXQgYXJlIHJldHJpZWQgYWZ0ZXIgaGF2aW5nIGxvZ2dlZCBpbi4gIFRoaXMgY2FuIGJlIHVzZWQgZm9yIGV4YW1wbGVcbiAgICAgICAqIHRvIGFkZCBhbiBhdXRoZW50aWNhdGlvbiB0b2tlbi4gIEl0IG11c3QgcmV0dXJuIHRoZSByZXF1ZXN0LlxuICAgICAgICovXG4gICAgICBsb2dpbkNvbmZpcm1lZDogZnVuY3Rpb24oZGF0YSwgY29uZmlnVXBkYXRlcikge1xuICAgICAgICB2YXIgdXBkYXRlciA9IGNvbmZpZ1VwZGF0ZXIgfHwgZnVuY3Rpb24oY29uZmlnKSB7cmV0dXJuIGNvbmZpZzt9O1xuICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2V2ZW50OmF1dGgtbG9naW5Db25maXJtZWQnLCBkYXRhKTtcbiAgICAgICAgaHR0cEJ1ZmZlci5yZXRyeUFsbCh1cGRhdGVyKTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FsbCB0aGlzIGZ1bmN0aW9uIHRvIGluZGljYXRlIHRoYXQgYXV0aGVudGljYXRpb24gc2hvdWxkIG5vdCBwcm9jZWVkLlxuICAgICAgICogQWxsIGRlZmVycmVkIHJlcXVlc3RzIHdpbGwgYmUgYWJhbmRvbmVkIG9yIHJlamVjdGVkIChpZiByZWFzb24gaXMgcHJvdmlkZWQpLlxuICAgICAgICogQHBhcmFtIGRhdGEgYW4gb3B0aW9uYWwgYXJndW1lbnQgdG8gcGFzcyBvbiB0byAkYnJvYWRjYXN0LlxuICAgICAgICogQHBhcmFtIHJlYXNvbiBpZiBwcm92aWRlZCwgdGhlIHJlcXVlc3RzIGFyZSByZWplY3RlZDsgYWJhbmRvbmVkIG90aGVyd2lzZS5cbiAgICAgICAqL1xuICAgICAgbG9naW5DYW5jZWxsZWQ6IGZ1bmN0aW9uKGRhdGEsIHJlYXNvbikge1xuICAgICAgICBodHRwQnVmZmVyLnJlamVjdEFsbChyZWFzb24pO1xuICAgICAgICAkcm9vdFNjb3BlLiRicm9hZGNhc3QoJ2V2ZW50OmF1dGgtbG9naW5DYW5jZWxsZWQnLCBkYXRhKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XSlcblxuICAvKipcbiAgICogJGh0dHAgaW50ZXJjZXB0b3IuXG4gICAqIE9uIDQwMSByZXNwb25zZSAod2l0aG91dCAnaWdub3JlQXV0aE1vZHVsZScgb3B0aW9uKSBzdG9yZXMgdGhlIHJlcXVlc3RcbiAgICogYW5kIGJyb2FkY2FzdHMgJ2V2ZW50OmF1dGgtbG9naW5SZXF1aXJlZCcuXG4gICAqIE9uIDQwMyByZXNwb25zZSAod2l0aG91dCAnaWdub3JlQXV0aE1vZHVsZScgb3B0aW9uKSBkaXNjYXJkcyB0aGUgcmVxdWVzdFxuICAgKiBhbmQgYnJvYWRjYXN0cyAnZXZlbnQ6YXV0aC1mb3JiaWRkZW4nLlxuICAgKi9cbiAgLmNvbmZpZyhbJyRodHRwUHJvdmlkZXInLCBmdW5jdGlvbigkaHR0cFByb3ZpZGVyKSB7XG4gICAgJGh0dHBQcm92aWRlci5pbnRlcmNlcHRvcnMucHVzaChbJyRyb290U2NvcGUnLCAnJHEnLCAnaHR0cEJ1ZmZlcicsIGZ1bmN0aW9uKCRyb290U2NvcGUsICRxLCBodHRwQnVmZmVyKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZXNwb25zZUVycm9yOiBmdW5jdGlvbihyZWplY3Rpb24pIHtcbiAgICAgICAgICB2YXIgY29uZmlnID0gcmVqZWN0aW9uLmNvbmZpZyB8fCB7fTtcbiAgICAgICAgICBpZiAoIWNvbmZpZy5pZ25vcmVBdXRoTW9kdWxlKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHJlamVjdGlvbi5zdGF0dXMpIHtcbiAgICAgICAgICAgICAgY2FzZSA0MDE6XG4gICAgICAgICAgICAgICAgdmFyIGRlZmVycmVkID0gJHEuZGVmZXIoKTtcbiAgICAgICAgICAgICAgICB2YXIgYnVmZmVyTGVuZ3RoID0gaHR0cEJ1ZmZlci5hcHBlbmQoY29uZmlnLCBkZWZlcnJlZCk7XG4gICAgICAgICAgICAgICAgaWYgKGJ1ZmZlckxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgICAgICAgICRyb290U2NvcGUuJGJyb2FkY2FzdCgnZXZlbnQ6YXV0aC1sb2dpblJlcXVpcmVkJywgcmVqZWN0aW9uKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICAgICAgICAgICAgY2FzZSA0MDM6XG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kYnJvYWRjYXN0KCdldmVudDphdXRoLWZvcmJpZGRlbicsIHJlamVjdGlvbik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIG90aGVyd2lzZSwgZGVmYXVsdCBiZWhhdmlvdXJcbiAgICAgICAgICByZXR1cm4gJHEucmVqZWN0KHJlamVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfV0pO1xuICB9XSk7XG5cbiAgLyoqXG4gICAqIFByaXZhdGUgbW9kdWxlLCBhIHV0aWxpdHksIHJlcXVpcmVkIGludGVybmFsbHkgYnkgJ2h0dHAtYXV0aC1pbnRlcmNlcHRvcicuXG4gICAqL1xuICBhbmd1bGFyLm1vZHVsZSgnaHR0cC1hdXRoLWludGVyY2VwdG9yLWJ1ZmZlcicsIFtdKVxuXG4gIC5mYWN0b3J5KCdodHRwQnVmZmVyJywgWyckaW5qZWN0b3InLCBmdW5jdGlvbigkaW5qZWN0b3IpIHtcbiAgICAvKiogSG9sZHMgYWxsIHRoZSByZXF1ZXN0cywgc28gdGhleSBjYW4gYmUgcmUtcmVxdWVzdGVkIGluIGZ1dHVyZS4gKi9cbiAgICB2YXIgYnVmZmVyID0gW107XG5cbiAgICAvKiogU2VydmljZSBpbml0aWFsaXplZCBsYXRlciBiZWNhdXNlIG9mIGNpcmN1bGFyIGRlcGVuZGVuY3kgcHJvYmxlbS4gKi9cbiAgICB2YXIgJGh0dHA7XG5cbiAgICBmdW5jdGlvbiByZXRyeUh0dHBSZXF1ZXN0KGNvbmZpZywgZGVmZXJyZWQpIHtcbiAgICAgIGZ1bmN0aW9uIHN1Y2Nlc3NDYWxsYmFjayhyZXNwb25zZSkge1xuICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGVycm9yQ2FsbGJhY2socmVzcG9uc2UpIHtcbiAgICAgICAgZGVmZXJyZWQucmVqZWN0KHJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICAgICRodHRwID0gJGh0dHAgfHwgJGluamVjdG9yLmdldCgnJGh0dHAnKTtcbiAgICAgICRodHRwKGNvbmZpZykudGhlbihzdWNjZXNzQ2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAvKipcbiAgICAgICAqIEFwcGVuZHMgSFRUUCByZXF1ZXN0IGNvbmZpZ3VyYXRpb24gb2JqZWN0IHdpdGggZGVmZXJyZWQgcmVzcG9uc2UgYXR0YWNoZWQgdG8gYnVmZmVyLlxuICAgICAgICogQHJldHVybiB7TnVtYmVyfSBUaGUgbmV3IGxlbmd0aCBvZiB0aGUgYnVmZmVyLlxuICAgICAgICovXG4gICAgICBhcHBlbmQ6IGZ1bmN0aW9uKGNvbmZpZywgZGVmZXJyZWQpIHtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlci5wdXNoKHtcbiAgICAgICAgICBjb25maWc6IGNvbmZpZyxcbiAgICAgICAgICBkZWZlcnJlZDogZGVmZXJyZWRcbiAgICAgICAgfSk7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIEFiYW5kb24gb3IgcmVqZWN0IChpZiByZWFzb24gcHJvdmlkZWQpIGFsbCB0aGUgYnVmZmVyZWQgcmVxdWVzdHMuXG4gICAgICAgKi9cbiAgICAgIHJlamVjdEFsbDogZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgICAgIGlmIChyZWFzb24pIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlci5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgYnVmZmVyW2ldLmRlZmVycmVkLnJlamVjdChyZWFzb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBidWZmZXIgPSBbXTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogUmV0cmllcyBhbGwgdGhlIGJ1ZmZlcmVkIHJlcXVlc3RzIGNsZWFycyB0aGUgYnVmZmVyLlxuICAgICAgICovXG4gICAgICByZXRyeUFsbDogZnVuY3Rpb24odXBkYXRlcikge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlci5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHZhciBfY2ZnID0gdXBkYXRlcihidWZmZXJbaV0uY29uZmlnKTtcbiAgICAgICAgICBpZiAoX2NmZyAhPT0gZmFsc2UpXG4gICAgICAgICAgICByZXRyeUh0dHBSZXF1ZXN0KF9jZmcsIGJ1ZmZlcltpXS5kZWZlcnJlZCk7XG4gICAgICAgIH1cbiAgICAgICAgYnVmZmVyID0gW107XG4gICAgICB9XG4gICAgfTtcbiAgfV0pO1xufSkoKTtcblxuLyogY29tbW9uanMgcGFja2FnZSBtYW5hZ2VyIHN1cHBvcnQgKGVnIGNvbXBvbmVudGpzKSAqL1xuaWYgKHR5cGVvZiBtb2R1bGUgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGV4cG9ydHMgIT09IFwidW5kZWZpbmVkXCIgJiYgbW9kdWxlLmV4cG9ydHMgPT09IGV4cG9ydHMpe1xuICBtb2R1bGUuZXhwb3J0cyA9ICdodHRwLWF1dGgtaW50ZXJjZXB0b3InO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYW5ndWxhci1odHRwLWF1dGgvc3JjL2h0dHAtYXV0aC1pbnRlcmNlcHRvci5qc1xuLy8gbW9kdWxlIGlkID0gMTM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///136\n")},function(module,exports){eval("// removed by extract-text-webpack-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTM3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vYXBwL3N0eWxlcy9tYWluLnN0eWw/OTY3MSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYXBwL3N0eWxlcy9tYWluLnN0eWxcbi8vIG1vZHVsZSBpZCA9IDEzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///137\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nangular.module('app.services', []);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTM4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2FwcC9zZXJ2aWNlcy9pbmRleC50cz84MTZkIl0sInNvdXJjZXNDb250ZW50IjpbImFuZ3VsYXIubW9kdWxlKCdhcHAuc2VydmljZXMnLCBbXSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gYXBwL3NlcnZpY2VzL2luZGV4LnRzIl0sIm1hcHBpbmdzIjoiOztBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///138\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar _angular = __webpack_require__(7);\n\nvar angular = _interopRequireWildcard(_angular);\n\n__webpack_require__(140);\n\n__webpack_require__(154);\n\n__webpack_require__(192);\n\n__webpack_require__(199);\n\n__webpack_require__(201);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nangular.module('app.components', ['app.components.index-view', 'app.components.trend-view', 'app.components.word-cloud-view', 'app.components.search-view', 'app.components.plotly']);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTM5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2FwcC9jb21wb25lbnRzL2luZGV4LnRzPzMxZmQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuaW1wb3J0ICogYXMgYW5ndWxhciBmcm9tICdhbmd1bGFyJztcbmltcG9ydCAnY29tcG9uZW50cy9pbmRleC12aWV3L2luZGV4LXZpZXctY29tcG9uZW50JztcbmltcG9ydCAnY29tcG9uZW50cy90cmVuZC12aWV3L3RyZW5kLXZpZXctY29tcG9uZW50JztcbmltcG9ydCAnY29tcG9uZW50cy93b3JkLWNsb3VkLXZpZXcvd29yZC1jbG91ZC12aWV3LWNvbXBvbmVudCc7XG5pbXBvcnQgJ2NvbXBvbmVudHMvc2VhcmNoLXZpZXcvc2VhcmNoLXZpZXctY29tcG9uZW50JztcbmltcG9ydCAnY29tcG9uZW50cy9wbG90bHkvcGxvdGx5LWNvbXBvbmVudCc7XG5hbmd1bGFyLm1vZHVsZSgnYXBwLmNvbXBvbmVudHMnLCBbXG4gICAgJ2FwcC5jb21wb25lbnRzLmluZGV4LXZpZXcnLFxuICAgICdhcHAuY29tcG9uZW50cy50cmVuZC12aWV3JyxcbiAgICAnYXBwLmNvbXBvbmVudHMud29yZC1jbG91ZC12aWV3JyxcbiAgICAnYXBwLmNvbXBvbmVudHMuc2VhcmNoLXZpZXcnLFxuICAgICdhcHAuY29tcG9uZW50cy5wbG90bHknXG5dKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBhcHAvY29tcG9uZW50cy9pbmRleC50cyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7OztBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///139\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar _classCallCheck2 = __webpack_require__(19);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _angular = __webpack_require__(7);\n\nvar angular = _interopRequireWildcard(_angular);\n\nvar _octavoComponentController = __webpack_require__(34);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar IndexViewComponent = function IndexViewComponent() {\n    (0, _classCallCheck3.default)(this, IndexViewComponent);\n\n    this.controller = _octavoComponentController.OctavoComponentController;\n    this.template = __webpack_require__(152)();\n};\n\nangular.module('app.components.index-view', []).component('indexView', new IndexViewComponent());//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2FwcC9jb21wb25lbnRzL2luZGV4LXZpZXcvaW5kZXgtdmlldy1jb21wb25lbnQudHM/NjY1YyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5pbXBvcnQgKiBhcyBhbmd1bGFyIGZyb20gJ2FuZ3VsYXInO1xuaW1wb3J0IHsgT2N0YXZvQ29tcG9uZW50Q29udHJvbGxlciB9IGZyb20gJy4uL29jdGF2by1jb21wb25lbnQtY29udHJvbGxlcic7XG5jbGFzcyBJbmRleFZpZXdDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNvbnRyb2xsZXIgPSBPY3Rhdm9Db21wb25lbnRDb250cm9sbGVyO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gcmVxdWlyZSgnLi9pbmRleC12aWV3LnB1ZycpKCk7XG4gICAgfVxufVxuYW5ndWxhci5tb2R1bGUoJ2FwcC5jb21wb25lbnRzLmluZGV4LXZpZXcnLCBbXSlcbiAgICAuY29tcG9uZW50KCdpbmRleFZpZXcnLCBuZXcgSW5kZXhWaWV3Q29tcG9uZW50KCkpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGFwcC9jb21wb25lbnRzL2luZGV4LXZpZXcvaW5kZXgtdmlldy1jb21wb25lbnQudHMiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7Ozs7O0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///140\n")},function(module,exports,__webpack_require__){eval('module.exports = { "default": __webpack_require__(142), __esModule: true };//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvYXNzaWduLmpzP2MyODMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9hc3NpZ25cIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2Fzc2lnbi5qc1xuLy8gbW9kdWxlIGlkID0gMTQxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///141\n')},function(module,exports,__webpack_require__){eval("__webpack_require__(143);\nmodule.exports = __webpack_require__(4).Object.assign;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvYXNzaWduLmpzPzU3N2IiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmFzc2lnbicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0LmFzc2lnbjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvYXNzaWduLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///142\n")},function(module,exports,__webpack_require__){eval("// 19.1.3.1 Object.assign(target, source)\nvar $export = __webpack_require__(11);\n\n$export($export.S + $export.F, 'Object', { assign: __webpack_require__(145) });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduLmpzPzQ3OGMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gMTkuMS4zLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSlcbnZhciAkZXhwb3J0ID0gcmVxdWlyZSgnLi9fZXhwb3J0Jyk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GLCAnT2JqZWN0JywgeyBhc3NpZ246IHJlcXVpcmUoJy4vX29iamVjdC1hc3NpZ24nKSB9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuYXNzaWduLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///143\n")},function(module,exports){eval("module.exports = function (it) {\n  if (typeof it != 'function') throw TypeError(it + ' is not a function!');\n  return it;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQ0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hLWZ1bmN0aW9uLmpzPzk0ZTkiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKHR5cGVvZiBpdCAhPSAnZnVuY3Rpb24nKSB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uIScpO1xuICByZXR1cm4gaXQ7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2EtZnVuY3Rpb24uanNcbi8vIG1vZHVsZSBpZCA9IDE0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///144\n")},function(module,exports,__webpack_require__){"use strict";eval("\n// 19.1.2.1 Object.assign(target, source, ...)\nvar getKeys = __webpack_require__(36);\nvar gOPS = __webpack_require__(56);\nvar pIE = __webpack_require__(38);\nvar toObject = __webpack_require__(57);\nvar IObject = __webpack_require__(99);\nvar $assign = Object.assign;\n\n// should work with symbols and should have deterministic property order (V8 bug)\nmodule.exports = !$assign || __webpack_require__(23)(function () {\n  var A = {};\n  var B = {};\n  // eslint-disable-next-line no-undef\n  var S = Symbol();\n  var K = 'abcdefghijklmnopqrst';\n  A[S] = 7;\n  K.split('').forEach(function (k) { B[k] = k; });\n  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;\n}) ? function assign(target, source) { // eslint-disable-line no-unused-vars\n  var T = toObject(target);\n  var aLen = arguments.length;\n  var index = 1;\n  var getSymbols = gOPS.f;\n  var isEnum = pIE.f;\n  while (aLen > index) {\n    var S = IObject(arguments[index++]);\n    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);\n    var length = keys.length;\n    var j = 0;\n    var key;\n    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];\n  } return T;\n} : $assign;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQ1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtYXNzaWduLmpzPzRlOGQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuLy8gMTkuMS4yLjEgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHNvdXJjZSwgLi4uKVxudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xudmFyIGdPUFMgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpO1xudmFyIHBJRSA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIElPYmplY3QgPSByZXF1aXJlKCcuL19pb2JqZWN0Jyk7XG52YXIgJGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8vIHNob3VsZCB3b3JrIHdpdGggc3ltYm9scyBhbmQgc2hvdWxkIGhhdmUgZGV0ZXJtaW5pc3RpYyBwcm9wZXJ0eSBvcmRlciAoVjggYnVnKVxubW9kdWxlLmV4cG9ydHMgPSAhJGFzc2lnbiB8fCByZXF1aXJlKCcuL19mYWlscycpKGZ1bmN0aW9uICgpIHtcbiAgdmFyIEEgPSB7fTtcbiAgdmFyIEIgPSB7fTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIHZhciBTID0gU3ltYm9sKCk7XG4gIHZhciBLID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0JztcbiAgQVtTXSA9IDc7XG4gIEsuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGspIHsgQltrXSA9IGs7IH0pO1xuICByZXR1cm4gJGFzc2lnbih7fSwgQSlbU10gIT0gNyB8fCBPYmplY3Qua2V5cygkYXNzaWduKHt9LCBCKSkuam9pbignJykgIT0gSztcbn0pID8gZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgdmFyIFQgPSB0b09iamVjdCh0YXJnZXQpO1xuICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBpbmRleCA9IDE7XG4gIHZhciBnZXRTeW1ib2xzID0gZ09QUy5mO1xuICB2YXIgaXNFbnVtID0gcElFLmY7XG4gIHdoaWxlIChhTGVuID4gaW5kZXgpIHtcbiAgICB2YXIgUyA9IElPYmplY3QoYXJndW1lbnRzW2luZGV4KytdKTtcbiAgICB2YXIga2V5cyA9IGdldFN5bWJvbHMgPyBnZXRLZXlzKFMpLmNvbmNhdChnZXRTeW1ib2xzKFMpKSA6IGdldEtleXMoUyk7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBqID0gMDtcbiAgICB2YXIga2V5O1xuICAgIHdoaWxlIChsZW5ndGggPiBqKSBpZiAoaXNFbnVtLmNhbGwoUywga2V5ID0ga2V5c1tqKytdKSkgVFtrZXldID0gU1trZXldO1xuICB9IHJldHVybiBUO1xufSA6ICRhc3NpZ247XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fb2JqZWN0LWFzc2lnbi5qc1xuLy8gbW9kdWxlIGlkID0gMTQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///145\n")},function(module,exports,__webpack_require__){eval("// false -> Array#indexOf\n// true  -> Array#includes\nvar toIObject = __webpack_require__(15);\nvar toLength = __webpack_require__(147);\nvar toAbsoluteIndex = __webpack_require__(148);\nmodule.exports = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIObject($this);\n    var length = toLength(O.length);\n    var index = toAbsoluteIndex(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare\n    if (IS_INCLUDES && el != el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare\n      if (value != value) return true;\n    // Array#indexOf ignores holes, Array#includes - not\n    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {\n      if (O[index] === el) return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQ2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qcz9iYzU3Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGZhbHNlIC0+IEFycmF5I2luZGV4T2Zcbi8vIHRydWUgIC0+IEFycmF5I2luY2x1ZGVzXG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKElTX0lOQ0xVREVTKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGVsLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgTyA9IHRvSU9iamVjdCgkdGhpcyk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpO1xuICAgIHZhciB2YWx1ZTtcbiAgICAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIGlmIChJU19JTkNMVURFUyAmJiBlbCAhPSBlbCkgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSB7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgICBpZiAodmFsdWUgIT0gdmFsdWUpIHJldHVybiB0cnVlO1xuICAgIC8vIEFycmF5I2luZGV4T2YgaWdub3JlcyBob2xlcywgQXJyYXkjaW5jbHVkZXMgLSBub3RcbiAgICB9IGVsc2UgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIGlmIChJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKSB7XG4gICAgICBpZiAoT1tpbmRleF0gPT09IGVsKSByZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcbiAgICB9IHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG4gIH07XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2FycmF5LWluY2x1ZGVzLmpzXG4vLyBtb2R1bGUgaWQgPSAxNDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///146\n")},function(module,exports,__webpack_require__){eval("// 7.1.15 ToLength\nvar toInteger = __webpack_require__(52);\nvar min = Math.min;\nmodule.exports = function (it) {\n  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQ3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1sZW5ndGguanM/NDExMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyA3LjEuMTUgVG9MZW5ndGhcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgbWluID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgPiAwID8gbWluKHRvSW50ZWdlcihpdCksIDB4MWZmZmZmZmZmZmZmZmYpIDogMDsgLy8gcG93KDIsIDUzKSAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1sZW5ndGguanNcbi8vIG1vZHVsZSBpZCA9IDE0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///147\n")},function(module,exports,__webpack_require__){eval("var toInteger = __webpack_require__(52);\nvar max = Math.max;\nvar min = Math.min;\nmodule.exports = function (index, length) {\n  index = toInteger(index);\n  return index < 0 ? max(index + length, 0) : min(index, length);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQ4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL190by1hYnNvbHV0ZS1pbmRleC5qcz83ZTQwIl0sInNvdXJjZXNDb250ZW50IjpbInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgbWF4ID0gTWF0aC5tYXg7XG52YXIgbWluID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoKSB7XG4gIGluZGV4ID0gdG9JbnRlZ2VyKGluZGV4KTtcbiAgcmV0dXJuIGluZGV4IDwgMCA/IG1heChpbmRleCArIGxlbmd0aCwgMCkgOiBtaW4oaW5kZXgsIGxlbmd0aCk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3RvLWFic29sdXRlLWluZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAxNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///148\n")},function(module,exports,__webpack_require__){eval('module.exports = { "default": __webpack_require__(150), __esModule: true };//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQ5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzPzBiODMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9kZWZpbmUtcHJvcGVydHlcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2RlZmluZS1wcm9wZXJ0eS5qc1xuLy8gbW9kdWxlIGlkID0gMTQ5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///149\n')},function(module,exports,__webpack_require__){eval("__webpack_require__(151);\nvar $Object = __webpack_require__(4).Object;\nmodule.exports = function defineProperty(it, key, desc) {\n  return $Object.defineProperty(it, key, desc);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTUwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzP2Y1YjAiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmRlZmluZS1wcm9wZXJ0eScpO1xudmFyICRPYmplY3QgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBkZXNjKSB7XG4gIHJldHVybiAkT2JqZWN0LmRlZmluZVByb3BlcnR5KGl0LCBrZXksIGRlc2MpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZGVmaW5lLXByb3BlcnR5LmpzXG4vLyBtb2R1bGUgaWQgPSAxNTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///150\n")},function(module,exports,__webpack_require__){eval("var $export = __webpack_require__(11);\n// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)\n$export($export.S + $export.F * !__webpack_require__(13), 'Object', { defineProperty: __webpack_require__(12).f });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTUxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5LmpzPzk4MjkiXSwic291cmNlc0NvbnRlbnQiOlsidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbi8vIDE5LjEuMi40IC8gMTUuMi4zLjYgT2JqZWN0LmRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpXG4kZXhwb3J0KCRleHBvcnQuUyArICRleHBvcnQuRiAqICFyZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpLCAnT2JqZWN0JywgeyBkZWZpbmVQcm9wZXJ0eTogcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZiB9KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuZGVmaW5lLXByb3BlcnR5LmpzXG4vLyBtb2R1bGUgaWQgPSAxNTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///151\n")},function(module,exports,__webpack_require__){eval('var pug = __webpack_require__(39);\n\nfunction template(locals) {var pug_html = "", pug_mixins = {}, pug_interp;pug_html = pug_html + "\\u003Cdiv class=\\"container\\"\\u003E\\u003Ch1\\u003EOctavo UI\\u003C\\u002Fh1\\u003E\\u003Cdiv class=\\"form-group has-feedback\\" ng-class=\\"{ \'has-success\' : $ctrl.isEndpointValid === true, \'has-error\' : $ctrl.isEndpointValid === false}\\"\\u003E\\u003Clabel\\u003EEndpoint\\u003C\\u002Flabel\\u003E\\u003Cinput class=\\"form-control\\" type=\\"text\\" ng-model=\\"$ctrl.endpoint\\" ng-change=\\"$ctrl.endpointChanged()\\"\\u003E\\u003Cspan class=\\"glyphicon glyphicon-ok form-control-feedback\\" ng-show=\\"$ctrl.isEndpointValid\\"\\u003E\\u003C\\u002Fspan\\u003E\\u003Cspan class=\\"glyphicon glyphicon-remove form-control-feedback\\" ng-show=\\"!$ctrl.isEndpointValid\\"\\u003E\\u003C\\u002Fspan\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cul\\u003E\\u003Cli\\u003E\\u003Ca ui-sref=\\"search($ctrl)\\"\\u003Esearch\\u003C\\u002Fa\\u003E\\u003C\\u002Fli\\u003E\\u003Cli\\u003E\\u003Ca ui-sref=\\"trend($ctrl)\\"\\u003Etrend graphs\\u003C\\u002Fa\\u003E\\u003C\\u002Fli\\u003E\\u003Cli\\u003E\\u003Ca ui-sref=\\"word-cloud($ctrl)\\"\\u003Ecollocation word clouds\\u003C\\u002Fa\\u003E\\u003C\\u002Fli\\u003E\\u003C\\u002Ful\\u003E\\u003C\\u002Fdiv\\u003E";;return pug_html;};\nmodule.exports = template;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTUyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vYXBwL2NvbXBvbmVudHMvaW5kZXgtdmlldy9pbmRleC12aWV3LnB1Zz8yZjIxIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBwdWcgPSByZXF1aXJlKFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9wdWctcnVudGltZS9pbmRleC5qc1wiKTtcblxuZnVuY3Rpb24gdGVtcGxhdGUobG9jYWxzKSB7dmFyIHB1Z19odG1sID0gXCJcIiwgcHVnX21peGlucyA9IHt9LCBwdWdfaW50ZXJwO3B1Z19odG1sID0gcHVnX2h0bWwgKyBcIlxcdTAwM0NkaXYgY2xhc3M9XFxcImNvbnRhaW5lclxcXCJcXHUwMDNFXFx1MDAzQ2gxXFx1MDAzRU9jdGF2byBVSVxcdTAwM0NcXHUwMDJGaDFcXHUwMDNFXFx1MDAzQ2RpdiBjbGFzcz1cXFwiZm9ybS1ncm91cCBoYXMtZmVlZGJhY2tcXFwiIG5nLWNsYXNzPVxcXCJ7ICdoYXMtc3VjY2VzcycgOiAkY3RybC5pc0VuZHBvaW50VmFsaWQgPT09IHRydWUsICdoYXMtZXJyb3InIDogJGN0cmwuaXNFbmRwb2ludFZhbGlkID09PSBmYWxzZX1cXFwiXFx1MDAzRVxcdTAwM0NsYWJlbFxcdTAwM0VFbmRwb2ludFxcdTAwM0NcXHUwMDJGbGFiZWxcXHUwMDNFXFx1MDAzQ2lucHV0IGNsYXNzPVxcXCJmb3JtLWNvbnRyb2xcXFwiIHR5cGU9XFxcInRleHRcXFwiIG5nLW1vZGVsPVxcXCIkY3RybC5lbmRwb2ludFxcXCIgbmctY2hhbmdlPVxcXCIkY3RybC5lbmRwb2ludENoYW5nZWQoKVxcXCJcXHUwMDNFXFx1MDAzQ3NwYW4gY2xhc3M9XFxcImdseXBoaWNvbiBnbHlwaGljb24tb2sgZm9ybS1jb250cm9sLWZlZWRiYWNrXFxcIiBuZy1zaG93PVxcXCIkY3RybC5pc0VuZHBvaW50VmFsaWRcXFwiXFx1MDAzRVxcdTAwM0NcXHUwMDJGc3BhblxcdTAwM0VcXHUwMDNDc3BhbiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1yZW1vdmUgZm9ybS1jb250cm9sLWZlZWRiYWNrXFxcIiBuZy1zaG93PVxcXCIhJGN0cmwuaXNFbmRwb2ludFZhbGlkXFxcIlxcdTAwM0VcXHUwMDNDXFx1MDAyRnNwYW5cXHUwMDNFXFx1MDAzQ1xcdTAwMkZkaXZcXHUwMDNFXFx1MDAzQ3VsXFx1MDAzRVxcdTAwM0NsaVxcdTAwM0VcXHUwMDNDYSB1aS1zcmVmPVxcXCJzZWFyY2goJGN0cmwpXFxcIlxcdTAwM0VzZWFyY2hcXHUwMDNDXFx1MDAyRmFcXHUwMDNFXFx1MDAzQ1xcdTAwMkZsaVxcdTAwM0VcXHUwMDNDbGlcXHUwMDNFXFx1MDAzQ2EgdWktc3JlZj1cXFwidHJlbmQoJGN0cmwpXFxcIlxcdTAwM0V0cmVuZCBncmFwaHNcXHUwMDNDXFx1MDAyRmFcXHUwMDNFXFx1MDAzQ1xcdTAwMkZsaVxcdTAwM0VcXHUwMDNDbGlcXHUwMDNFXFx1MDAzQ2EgdWktc3JlZj1cXFwid29yZC1jbG91ZCgkY3RybClcXFwiXFx1MDAzRWNvbGxvY2F0aW9uIHdvcmQgY2xvdWRzXFx1MDAzQ1xcdTAwMkZhXFx1MDAzRVxcdTAwM0NcXHUwMDJGbGlcXHUwMDNFXFx1MDAzQ1xcdTAwMkZ1bFxcdTAwM0VcXHUwMDNDXFx1MDAyRmRpdlxcdTAwM0VcIjs7cmV0dXJuIHB1Z19odG1sO307XG5tb2R1bGUuZXhwb3J0cyA9IHRlbXBsYXRlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYXBwL2NvbXBvbmVudHMvaW5kZXgtdmlldy9pbmRleC12aWV3LnB1Z1xuLy8gbW9kdWxlIGlkID0gMTUyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///152\n')},function(module,exports){eval("/* (ignored) *///# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTUzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2ZzIChpZ25vcmVkKT81NDg4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIChpZ25vcmVkKSAqL1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIGZzIChpZ25vcmVkKVxuLy8gbW9kdWxlIGlkID0gMTUzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///153\n")},function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\nexports.TrendViewComponent = exports.TrendViewComponentController = undefined;\n\nvar _getIterator2 = __webpack_require__(58);\n\nvar _getIterator3 = _interopRequireDefault(_getIterator2);\n\nvar _stringify = __webpack_require__(62);\n\nvar _stringify2 = _interopRequireDefault(_stringify);\n\nvar _getPrototypeOf = __webpack_require__(41);\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _createClass2 = __webpack_require__(27);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = __webpack_require__(63);\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _get2 = __webpack_require__(67);\n\nvar _get3 = _interopRequireDefault(_get2);\n\nvar _inherits2 = __webpack_require__(68);\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _classCallCheck2 = __webpack_require__(19);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _angular = __webpack_require__(7);\n\nvar angular = _interopRequireWildcard(_angular);\n\n__webpack_require__(69);\n\nvar _octavoComponentController = __webpack_require__(34);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar Field = function Field(id, description) {\n    (0, _classCallCheck3.default)(this, Field);\n\n    this.id = id;\n    this.description = description;\n};\n\nvar TrendViewComponentController = exports.TrendViewComponentController = function (_OctavoComponentContr) {\n    TrendViewComponentController.$inject = ["$q", "$http", "$httpParamSerializer", "$stateParams", "$state"];\n    (0, _inherits3.default)(TrendViewComponentController, _OctavoComponentContr);\n\n    /* @ngInject */\n    function TrendViewComponentController($q, $http, $httpParamSerializer, $stateParams, $state) {\n        (0, _classCallCheck3.default)(this, TrendViewComponentController);\n\n        var _this = (0, _possibleConstructorReturn3.default)(this, (TrendViewComponentController.__proto__ || (0, _getPrototypeOf2.default)(TrendViewComponentController)).call(this, $http, $stateParams, $state));\n\n        _this.$q = $q;\n        _this.$httpParamSerializer = $httpParamSerializer;\n        if (!_this.plotAbsolute) _this.plotAbsolute = false;\n        if (!_this.plotTermFreq) _this.plotTermFreq = false;\n        if (!_this.query) _this.query = "";\n        if (!_this.comparisonQuery) _this.comparisonQuery = "";\n        if (!_this.furtherOptions) _this.furtherOptions = "";\n        return _this;\n    }\n\n    (0, _createClass3.default)(TrendViewComponentController, [{\n        key: "endpointUpdated",\n        value: function endpointUpdated(indexInfo) {\n            this.attrs = [];\n            for (var field in indexInfo.commonFields) {\n                this.attrs.push(new Field(field, indexInfo.commonFields[field].description));\n            }this.availableLevels = indexInfo.levels.map(function (level) {\n                return level.id;\n            });\n            if (!this.defaultLevel) this.defaultLevel = this.availableLevels[this.availableLevels.length - 1];\n            if (this.attr && this.query) this.doRunQuery();\n        }\n    }, {\n        key: "doRunQuery",\n        value: function doRunQuery() {\n            var _this2 = this;\n\n            (0, _get3.default)(TrendViewComponentController.prototype.__proto__ || (0, _getPrototypeOf2.default)(TrendViewComponentController.prototype), "doRunQuery", this).call(this);\n            var params = this.$httpParamSerializer({\n                field: this.attr,\n                fieldLength: this.attrLength !== -1 ? this.attrLength : undefined,\n                query: this.defaultLevel && this.query.indexOf("<") !== 0 ? "<" + this.defaultLevel + "§" + this.query + "§" + this.defaultLevel + ">" : this.query\n            }) + "&" + this.furtherOptions;\n            this.queryURL = this.endpoint + "queryStats" + "?" + params;\n            var q1 = this.$http.post(this.endpoint + "queryStats", params, {\n                headers: { "Content-Type": "application/x-www-form-urlencoded" }\n            });\n            var q2 = !this.plotAbsolute ? this.$http.post(this.endpoint + "queryStats", this.$httpParamSerializer({\n                field: this.attr,\n                fieldLength: this.attrLength !== -1 ? this.attrLength : undefined,\n                query: this.defaultLevel && this.comparisonQuery.indexOf("<") !== 0 ? "<" + this.defaultLevel + "§" + this.comparisonQuery + "§" + this.defaultLevel + ">" : this.comparisonQuery\n            }), {\n                headers: { "Content-Type": "application/x-www-form-urlencoded" }\n            }) : this.$q.resolve(null);\n            this.$q.all([q1, q2]).then(function (responses) {\n                _this2.response = JSON.parse((0, _stringify2.default)(!_this2.plotAbsolute ? [responses[0].data, responses[1].data] : responses[0].data));\n                _this2.queryRunning = false;\n                var data = {\n                    x: [],\n                    y: [],\n                    mode: "lines+markers"\n                };\n                _this2.sampleAttrs = responses[0].data.results.grouped.slice(0, 5).map(function (g) {\n                    return g.fields[_this2.attr];\n                });\n                var cmap = {};\n                if (!_this2.plotAbsolute) {\n                    var _iteratorNormalCompletion = true;\n                    var _didIteratorError = false;\n                    var _iteratorError = undefined;\n\n                    try {\n                        for (var _iterator = (0, _getIterator3.default)(responses[1].data.results.grouped), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                            var group = _step.value;\n\n                            cmap[group.fields[_this2.attr]] = group.stats;\n                        }\n                    } catch (err) {\n                        _didIteratorError = true;\n                        _iteratorError = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion && _iterator.return) {\n                                _iterator.return();\n                            }\n                        } finally {\n                            if (_didIteratorError) {\n                                throw _iteratorError;\n                            }\n                        }\n                    }\n                }var _iteratorNormalCompletion2 = true;\n                var _didIteratorError2 = false;\n                var _iteratorError2 = undefined;\n\n                try {\n                    for (var _iterator2 = (0, _getIterator3.default)(responses[0].data.results.grouped), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                        var _group = _step2.value;\n\n                        if (!_this2.plotAbsolute) {\n                            _group.stats.docFreq = 1000000 * _group.stats.docFreq / cmap[_group.fields[_this2.attr]].docFreq;\n                            _group.stats.totalTermFreq = 1000000 * _group.stats.totalTermFreq / cmap[_group.fields[_this2.attr]].totalTermFreq;\n                        }\n                        var ts = Date.parse("" + _group.fields[_this2.attr]);\n                        if (!isNaN(ts)) _group.fields[_this2.attr] = new Date(ts);\n                    }\n                } catch (err) {\n                    _didIteratorError2 = true;\n                    _iteratorError2 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                            _iterator2.return();\n                        }\n                    } finally {\n                        if (_didIteratorError2) {\n                            throw _iteratorError2;\n                        }\n                    }\n                }\n\n                responses[0].data.results.grouped.sort(function (a, b) {\n                    if (a.fields[_this2.attr] < b.fields[_this2.attr]) return -1;\n                    if (a.fields[_this2.attr] > b.fields[_this2.attr]) return 1;\n                    return 0;\n                });\n                var _iteratorNormalCompletion3 = true;\n                var _didIteratorError3 = false;\n                var _iteratorError3 = undefined;\n\n                try {\n                    for (var _iterator3 = (0, _getIterator3.default)(responses[0].data.results.grouped), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                        var _group2 = _step3.value;\n\n                        data.x.push(_group2.fields[_this2.attr]);\n                        data.y.push(!_this2.plotTermFreq ? _group2.stats.docFreq : _group2.stats.totalTermFreq);\n                    }\n                } catch (err) {\n                    _didIteratorError3 = true;\n                    _iteratorError3 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                            _iterator3.return();\n                        }\n                    } finally {\n                        if (_didIteratorError3) {\n                            throw _iteratorError3;\n                        }\n                    }\n                }\n\n                _this2.layout = {\n                    title: !_this2.plotTermFreq ? !_this2.plotAbsolute ? "Document frequency per million documents" : "Absolute document frequency" : !_this2.plotAbsolute ? "Term frequency per million words" : "Absolute term frequency"\n                };\n                _this2.data = [data];\n            }, function (error) {\n                _this2.queryRunning = false;\n                _this2.error = error;\n            });\n        }\n    }]);\n    return TrendViewComponentController;\n}(_octavoComponentController.OctavoComponentController);\n\nvar TrendViewComponent = exports.TrendViewComponent = function TrendViewComponent() {\n    (0, _classCallCheck3.default)(this, TrendViewComponent);\n\n    this.controller = TrendViewComponentController;\n    this.template = __webpack_require__(191)();\n};\n\nangular.module("app.components.trend-view", []).component("trendView", new TrendViewComponent());//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTU0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2FwcC9jb21wb25lbnRzL3RyZW5kLXZpZXcvdHJlbmQtdmlldy1jb21wb25lbnQudHM/NGVjNiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCAqIGFzIGFuZ3VsYXIgZnJvbSBcImFuZ3VsYXJcIjtcbmltcG9ydCBcIm5nLXByZXR0eWpzb24vZGlzdC9uZy1wcmV0dHlqc29uLm1pbi5qc1wiO1xuaW1wb3J0IHsgT2N0YXZvQ29tcG9uZW50Q29udHJvbGxlciB9IGZyb20gXCIuLi9vY3Rhdm8tY29tcG9uZW50LWNvbnRyb2xsZXJcIjtcbmNsYXNzIEZpZWxkIHtcbiAgICBjb25zdHJ1Y3RvcihpZCwgZGVzY3JpcHRpb24pIHtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFRyZW5kVmlld0NvbXBvbmVudENvbnRyb2xsZXIgZXh0ZW5kcyBPY3Rhdm9Db21wb25lbnRDb250cm9sbGVyIHtcbiAgICAvKiBAbmdJbmplY3QgKi9cbiAgICBjb25zdHJ1Y3RvcigkcSwgJGh0dHAsICRodHRwUGFyYW1TZXJpYWxpemVyLCAkc3RhdGVQYXJhbXMsICRzdGF0ZSkge1xuICAgICAgICBzdXBlcigkaHR0cCwgJHN0YXRlUGFyYW1zLCAkc3RhdGUpO1xuICAgICAgICB0aGlzLiRxID0gJHE7XG4gICAgICAgIHRoaXMuJGh0dHBQYXJhbVNlcmlhbGl6ZXIgPSAkaHR0cFBhcmFtU2VyaWFsaXplcjtcbiAgICAgICAgaWYgKCF0aGlzLnBsb3RBYnNvbHV0ZSlcbiAgICAgICAgICAgIHRoaXMucGxvdEFic29sdXRlID0gZmFsc2U7XG4gICAgICAgIGlmICghdGhpcy5wbG90VGVybUZyZXEpXG4gICAgICAgICAgICB0aGlzLnBsb3RUZXJtRnJlcSA9IGZhbHNlO1xuICAgICAgICBpZiAoIXRoaXMucXVlcnkpXG4gICAgICAgICAgICB0aGlzLnF1ZXJ5ID0gXCJcIjtcbiAgICAgICAgaWYgKCF0aGlzLmNvbXBhcmlzb25RdWVyeSlcbiAgICAgICAgICAgIHRoaXMuY29tcGFyaXNvblF1ZXJ5ID0gXCJcIjtcbiAgICAgICAgaWYgKCF0aGlzLmZ1cnRoZXJPcHRpb25zKVxuICAgICAgICAgICAgdGhpcy5mdXJ0aGVyT3B0aW9ucyA9IFwiXCI7XG4gICAgfVxuICAgIGVuZHBvaW50VXBkYXRlZChpbmRleEluZm8pIHtcbiAgICAgICAgdGhpcy5hdHRycyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBmaWVsZCBpbiBpbmRleEluZm8uY29tbW9uRmllbGRzKVxuICAgICAgICAgICAgdGhpcy5hdHRycy5wdXNoKG5ldyBGaWVsZChmaWVsZCwgaW5kZXhJbmZvLmNvbW1vbkZpZWxkc1tmaWVsZF0uZGVzY3JpcHRpb24pKTtcbiAgICAgICAgdGhpcy5hdmFpbGFibGVMZXZlbHMgPSBpbmRleEluZm8ubGV2ZWxzLm1hcChsZXZlbCA9PiBsZXZlbC5pZCk7XG4gICAgICAgIGlmICghdGhpcy5kZWZhdWx0TGV2ZWwpXG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRMZXZlbCA9IHRoaXMuYXZhaWxhYmxlTGV2ZWxzW3RoaXMuYXZhaWxhYmxlTGV2ZWxzLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAodGhpcy5hdHRyICYmIHRoaXMucXVlcnkpXG4gICAgICAgICAgICB0aGlzLmRvUnVuUXVlcnkoKTtcbiAgICB9XG4gICAgZG9SdW5RdWVyeSgpIHtcbiAgICAgICAgc3VwZXIuZG9SdW5RdWVyeSgpO1xuICAgICAgICBsZXQgcGFyYW1zID0gdGhpcy4kaHR0cFBhcmFtU2VyaWFsaXplcih7XG4gICAgICAgICAgICBmaWVsZDogdGhpcy5hdHRyLFxuICAgICAgICAgICAgZmllbGRMZW5ndGg6IHRoaXMuYXR0ckxlbmd0aCAhPT0gLTEgPyB0aGlzLmF0dHJMZW5ndGggOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBxdWVyeTogdGhpcy5kZWZhdWx0TGV2ZWwgJiYgdGhpcy5xdWVyeS5pbmRleE9mKFwiPFwiKSAhPT0gMFxuICAgICAgICAgICAgICAgID8gXCI8XCIgK1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlZmF1bHRMZXZlbCArXG4gICAgICAgICAgICAgICAgICAgIFwiwqdcIiArXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucXVlcnkgK1xuICAgICAgICAgICAgICAgICAgICBcIsKnXCIgK1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlZmF1bHRMZXZlbCArXG4gICAgICAgICAgICAgICAgICAgIFwiPlwiXG4gICAgICAgICAgICAgICAgOiB0aGlzLnF1ZXJ5XG4gICAgICAgIH0pICtcbiAgICAgICAgICAgIFwiJlwiICtcbiAgICAgICAgICAgIHRoaXMuZnVydGhlck9wdGlvbnM7XG4gICAgICAgIHRoaXMucXVlcnlVUkwgPSB0aGlzLmVuZHBvaW50ICsgXCJxdWVyeVN0YXRzXCIgKyBcIj9cIiArIHBhcmFtcztcbiAgICAgICAgbGV0IHExID0gdGhpcy4kaHR0cC5wb3N0KHRoaXMuZW5kcG9pbnQgKyBcInF1ZXJ5U3RhdHNcIiwgcGFyYW1zLCB7XG4gICAgICAgICAgICBoZWFkZXJzOiB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIgfVxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IHEyID0gIXRoaXMucGxvdEFic29sdXRlXG4gICAgICAgICAgICA/IHRoaXMuJGh0dHAucG9zdCh0aGlzLmVuZHBvaW50ICsgXCJxdWVyeVN0YXRzXCIsIHRoaXMuJGh0dHBQYXJhbVNlcmlhbGl6ZXIoe1xuICAgICAgICAgICAgICAgIGZpZWxkOiB0aGlzLmF0dHIsXG4gICAgICAgICAgICAgICAgZmllbGRMZW5ndGg6IHRoaXMuYXR0ckxlbmd0aCAhPT0gLTEgPyB0aGlzLmF0dHJMZW5ndGggOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgcXVlcnk6IHRoaXMuZGVmYXVsdExldmVsICYmIHRoaXMuY29tcGFyaXNvblF1ZXJ5LmluZGV4T2YoXCI8XCIpICE9PSAwXG4gICAgICAgICAgICAgICAgICAgID8gXCI8XCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWZhdWx0TGV2ZWwgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCLCp1wiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcGFyaXNvblF1ZXJ5ICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiwqdcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlZmF1bHRMZXZlbCArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIj5cIlxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuY29tcGFyaXNvblF1ZXJ5XG4gICAgICAgICAgICB9KSwge1xuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgOiB0aGlzLiRxLnJlc29sdmUobnVsbCk7XG4gICAgICAgIHRoaXMuJHEuYWxsKFtxMSwgcTJdKS50aGVuKChyZXNwb25zZXMpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVzcG9uc2UgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KCF0aGlzLnBsb3RBYnNvbHV0ZVxuICAgICAgICAgICAgICAgID8gW3Jlc3BvbnNlc1swXS5kYXRhLCByZXNwb25zZXNbMV0uZGF0YV1cbiAgICAgICAgICAgICAgICA6IHJlc3BvbnNlc1swXS5kYXRhKSk7XG4gICAgICAgICAgICB0aGlzLnF1ZXJ5UnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgeDogW10sXG4gICAgICAgICAgICAgICAgeTogW10sXG4gICAgICAgICAgICAgICAgbW9kZTogXCJsaW5lcyttYXJrZXJzXCJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnNhbXBsZUF0dHJzID0gcmVzcG9uc2VzWzBdLmRhdGEucmVzdWx0cy5ncm91cGVkXG4gICAgICAgICAgICAgICAgLnNsaWNlKDAsIDUpXG4gICAgICAgICAgICAgICAgLm1hcChnID0+IGcuZmllbGRzW3RoaXMuYXR0cl0pO1xuICAgICAgICAgICAgbGV0IGNtYXAgPSB7fTtcbiAgICAgICAgICAgIGlmICghdGhpcy5wbG90QWJzb2x1dGUpXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZ3JvdXAgb2YgcmVzcG9uc2VzWzFdLmRhdGEucmVzdWx0cy5ncm91cGVkKVxuICAgICAgICAgICAgICAgICAgICBjbWFwW2dyb3VwLmZpZWxkc1t0aGlzLmF0dHJdXSA9IGdyb3VwLnN0YXRzO1xuICAgICAgICAgICAgZm9yIChsZXQgZ3JvdXAgb2YgcmVzcG9uc2VzWzBdLmRhdGEucmVzdWx0cy5ncm91cGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnBsb3RBYnNvbHV0ZSkge1xuICAgICAgICAgICAgICAgICAgICBncm91cC5zdGF0cy5kb2NGcmVxID1cbiAgICAgICAgICAgICAgICAgICAgICAgIDEwMDAwMDAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwLnN0YXRzLmRvY0ZyZXEgL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNtYXBbZ3JvdXAuZmllbGRzW3RoaXMuYXR0cl1dLmRvY0ZyZXE7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwLnN0YXRzLnRvdGFsVGVybUZyZXEgPVxuICAgICAgICAgICAgICAgICAgICAgICAgMTAwMDAwMCAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXAuc3RhdHMudG90YWxUZXJtRnJlcSAvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY21hcFtncm91cC5maWVsZHNbdGhpcy5hdHRyXV0udG90YWxUZXJtRnJlcTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHRzID0gRGF0ZS5wYXJzZShcIlwiICsgZ3JvdXAuZmllbGRzW3RoaXMuYXR0cl0pO1xuICAgICAgICAgICAgICAgIGlmICghaXNOYU4odHMpKVxuICAgICAgICAgICAgICAgICAgICBncm91cC5maWVsZHNbdGhpcy5hdHRyXSA9IG5ldyBEYXRlKHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3BvbnNlc1swXS5kYXRhLnJlc3VsdHMuZ3JvdXBlZC5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGEuZmllbGRzW3RoaXMuYXR0cl0gPCBiLmZpZWxkc1t0aGlzLmF0dHJdKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgaWYgKGEuZmllbGRzW3RoaXMuYXR0cl0gPiBiLmZpZWxkc1t0aGlzLmF0dHJdKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZm9yIChsZXQgZ3JvdXAgb2YgcmVzcG9uc2VzWzBdLmRhdGEucmVzdWx0cy5ncm91cGVkKSB7XG4gICAgICAgICAgICAgICAgZGF0YS54LnB1c2goZ3JvdXAuZmllbGRzW3RoaXMuYXR0cl0pO1xuICAgICAgICAgICAgICAgIGRhdGEueS5wdXNoKCF0aGlzLnBsb3RUZXJtRnJlcSA/IGdyb3VwLnN0YXRzLmRvY0ZyZXEgOiBncm91cC5zdGF0cy50b3RhbFRlcm1GcmVxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubGF5b3V0ID0ge1xuICAgICAgICAgICAgICAgIHRpdGxlOiAhdGhpcy5wbG90VGVybUZyZXFcbiAgICAgICAgICAgICAgICAgICAgPyAhdGhpcy5wbG90QWJzb2x1dGVcbiAgICAgICAgICAgICAgICAgICAgICAgID8gXCJEb2N1bWVudCBmcmVxdWVuY3kgcGVyIG1pbGxpb24gZG9jdW1lbnRzXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogXCJBYnNvbHV0ZSBkb2N1bWVudCBmcmVxdWVuY3lcIlxuICAgICAgICAgICAgICAgICAgICA6ICF0aGlzLnBsb3RBYnNvbHV0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBcIlRlcm0gZnJlcXVlbmN5IHBlciBtaWxsaW9uIHdvcmRzXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogXCJBYnNvbHV0ZSB0ZXJtIGZyZXF1ZW5jeVwiXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5kYXRhID0gW2RhdGFdO1xuICAgICAgICB9LCBlcnJvciA9PiB7XG4gICAgICAgICAgICB0aGlzLnF1ZXJ5UnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgVHJlbmRWaWV3Q29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jb250cm9sbGVyID0gVHJlbmRWaWV3Q29tcG9uZW50Q29udHJvbGxlcjtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IHJlcXVpcmUoXCIuL3RyZW5kLXZpZXcucHVnXCIpKCk7XG4gICAgfVxufVxuYW5ndWxhclxuICAgIC5tb2R1bGUoXCJhcHAuY29tcG9uZW50cy50cmVuZC12aWV3XCIsIFtdKVxuICAgIC5jb21wb25lbnQoXCJ0cmVuZFZpZXdcIiwgbmV3IFRyZW5kVmlld0NvbXBvbmVudCgpKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBhcHAvY29tcG9uZW50cy90cmVuZC12aWV3L3RyZW5kLXZpZXctY29tcG9uZW50LnRzIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBWkE7QUFjQTtBQUNBOzs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBRUE7QUFBQTtBQUNBO0FBRUE7QUFFQTs7O0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBZUE7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUhBO0FBYUE7QUFEQTtBQUlBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBREE7QUFEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFkQTtBQUFBO0FBQ0E7QUFEQTtBQWlCQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBSUE7QUFJQTtBQUNBO0FBQ0E7QUFFQTtBQS9CQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUErQkE7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQXRDQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBdUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQTFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUEwQ0E7QUFDQTtBQURBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///154\n')},function(module,exports,__webpack_require__){eval("__webpack_require__(100);\n__webpack_require__(104);\nmodule.exports = __webpack_require__(163);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTU1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9nZXQtaXRlcmF0b3IuanM/N2YxNCJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKCcuLi9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXM2LnN0cmluZy5pdGVyYXRvcicpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9tb2R1bGVzL2NvcmUuZ2V0LWl0ZXJhdG9yJyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vZ2V0LWl0ZXJhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///155\n")},function(module,exports,__webpack_require__){"use strict";eval("\nvar addToUnscopables = __webpack_require__(157);\nvar step = __webpack_require__(158);\nvar Iterators = __webpack_require__(40);\nvar toIObject = __webpack_require__(15);\n\n// 22.1.3.4 Array.prototype.entries()\n// 22.1.3.13 Array.prototype.keys()\n// 22.1.3.29 Array.prototype.values()\n// 22.1.3.30 Array.prototype[@@iterator]()\nmodule.exports = __webpack_require__(101)(Array, 'Array', function (iterated, kind) {\n  this._t = toIObject(iterated); // target\n  this._i = 0;                   // next index\n  this._k = kind;                // kind\n// 22.1.5.2.1 %ArrayIteratorPrototype%.next()\n}, function () {\n  var O = this._t;\n  var kind = this._k;\n  var index = this._i++;\n  if (!O || index >= O.length) {\n    this._t = undefined;\n    return step(1);\n  }\n  if (kind == 'keys') return step(0, index);\n  if (kind == 'values') return step(0, O[index]);\n  return step(0, [index, O[index]]);\n}, 'values');\n\n// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)\nIterators.Arguments = Iterators.Array;\n\naddToUnscopables('keys');\naddToUnscopables('values');\naddToUnscopables('entries');\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTU2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvci5qcz9jNDY5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnZhciBhZGRUb1Vuc2NvcGFibGVzID0gcmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJyk7XG52YXIgc3RlcCA9IHJlcXVpcmUoJy4vX2l0ZXItc3RlcCcpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcblxuLy8gMjIuMS4zLjQgQXJyYXkucHJvdG90eXBlLmVudHJpZXMoKVxuLy8gMjIuMS4zLjEzIEFycmF5LnByb3RvdHlwZS5rZXlzKClcbi8vIDIyLjEuMy4yOSBBcnJheS5wcm90b3R5cGUudmFsdWVzKClcbi8vIDIyLjEuMy4zMCBBcnJheS5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19pdGVyLWRlZmluZScpKEFycmF5LCAnQXJyYXknLCBmdW5jdGlvbiAoaXRlcmF0ZWQsIGtpbmQpIHtcbiAgdGhpcy5fdCA9IHRvSU9iamVjdChpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuICB0aGlzLl9rID0ga2luZDsgICAgICAgICAgICAgICAgLy8ga2luZFxuLy8gMjIuMS41LjIuMSAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbiAoKSB7XG4gIHZhciBPID0gdGhpcy5fdDtcbiAgdmFyIGtpbmQgPSB0aGlzLl9rO1xuICB2YXIgaW5kZXggPSB0aGlzLl9pKys7XG4gIGlmICghTyB8fCBpbmRleCA+PSBPLmxlbmd0aCkge1xuICAgIHRoaXMuX3QgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHN0ZXAoMSk7XG4gIH1cbiAgaWYgKGtpbmQgPT0gJ2tleXMnKSByZXR1cm4gc3RlcCgwLCBpbmRleCk7XG4gIGlmIChraW5kID09ICd2YWx1ZXMnKSByZXR1cm4gc3RlcCgwLCBPW2luZGV4XSk7XG4gIHJldHVybiBzdGVwKDAsIFtpbmRleCwgT1tpbmRleF1dKTtcbn0sICd2YWx1ZXMnKTtcblxuLy8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlICg5LjQuNC42LCA5LjQuNC43KVxuSXRlcmF0b3JzLkFyZ3VtZW50cyA9IEl0ZXJhdG9ycy5BcnJheTtcblxuYWRkVG9VbnNjb3BhYmxlcygna2V5cycpO1xuYWRkVG9VbnNjb3BhYmxlcygndmFsdWVzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCdlbnRyaWVzJyk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYuYXJyYXkuaXRlcmF0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDE1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///156\n")},function(module,exports){eval("module.exports = function () { /* empty */ };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTU3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hZGQtdG8tdW5zY29wYWJsZXMuanM/ZTI2NyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19hZGQtdG8tdW5zY29wYWJsZXMuanNcbi8vIG1vZHVsZSBpZCA9IDE1N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///157\n")},function(module,exports){eval("module.exports = function (done, value) {\n  return { value: value, done: !!done };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTU4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLXN0ZXAuanM/MTA2NiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChkb25lLCB2YWx1ZSkge1xuICByZXR1cm4geyB2YWx1ZTogdmFsdWUsIGRvbmU6ICEhZG9uZSB9O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLXN0ZXAuanNcbi8vIG1vZHVsZSBpZCA9IDE1OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///158\n")},function(module,exports,__webpack_require__){"use strict";eval("\nvar create = __webpack_require__(60);\nvar descriptor = __webpack_require__(35);\nvar setToStringTag = __webpack_require__(61);\nvar IteratorPrototype = {};\n\n// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\n__webpack_require__(20)(IteratorPrototype, __webpack_require__(10)('iterator'), function () { return this; });\n\nmodule.exports = function (Constructor, NAME, next) {\n  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });\n  setToStringTag(Constructor, NAME + ' Iterator');\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTU5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pdGVyLWNyZWF0ZS5qcz9mNzg1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyk7XG52YXIgZGVzY3JpcHRvciA9IHJlcXVpcmUoJy4vX3Byb3BlcnR5LWRlc2MnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcblxuLy8gMjUuMS4yLjEuMSAlSXRlcmF0b3JQcm90b3R5cGUlW0BAaXRlcmF0b3JdKClcbnJlcXVpcmUoJy4vX2hpZGUnKShJdGVyYXRvclByb3RvdHlwZSwgcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyksIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCkge1xuICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBjcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUsIHsgbmV4dDogZGVzY3JpcHRvcigxLCBuZXh0KSB9KTtcbiAgc2V0VG9TdHJpbmdUYWcoQ29uc3RydWN0b3IsIE5BTUUgKyAnIEl0ZXJhdG9yJyk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2l0ZXItY3JlYXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///159\n")},function(module,exports,__webpack_require__){eval("var dP = __webpack_require__(12);\nvar anObject = __webpack_require__(21);\nvar getKeys = __webpack_require__(36);\n\nmodule.exports = __webpack_require__(13) ? Object.defineProperties : function defineProperties(O, Properties) {\n  anObject(O);\n  var keys = getKeys(Properties);\n  var length = keys.length;\n  var i = 0;\n  var P;\n  while (length > i) dP.f(O, P = keys[i++], Properties[P]);\n  return O;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTYwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZHBzLmpzP2FhMmEiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIHZhciBrZXlzID0gZ2V0S2V5cyhQcm9wZXJ0aWVzKTtcbiAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICB2YXIgaSA9IDA7XG4gIHZhciBQO1xuICB3aGlsZSAobGVuZ3RoID4gaSkgZFAuZihPLCBQID0ga2V5c1tpKytdLCBQcm9wZXJ0aWVzW1BdKTtcbiAgcmV0dXJuIE87XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX29iamVjdC1kcHMuanNcbi8vIG1vZHVsZSBpZCA9IDE2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///160\n")},function(module,exports,__webpack_require__){eval("var document = __webpack_require__(9).document;\nmodule.exports = document && document.documentElement;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTYxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19odG1sLmpzPzQ0ZjIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGRvY3VtZW50ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnQ7XG5tb2R1bGUuZXhwb3J0cyA9IGRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19odG1sLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///161\n")},function(module,exports,__webpack_require__){eval("var toInteger = __webpack_require__(52);\nvar defined = __webpack_require__(51);\n// true  -> String#at\n// false -> String#codePointAt\nmodule.exports = function (TO_STRING) {\n  return function (that, pos) {\n    var s = String(defined(that));\n    var i = toInteger(pos);\n    var l = s.length;\n    var a, b;\n    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;\n    a = s.charCodeAt(i);\n    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff\n      ? TO_STRING ? s.charAt(i) : a\n      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTYyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zdHJpbmctYXQuanM/ODdhZSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi9fdG8taW50ZWdlcicpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG4vLyB0cnVlICAtPiBTdHJpbmcjYXRcbi8vIGZhbHNlIC0+IFN0cmluZyNjb2RlUG9pbnRBdFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoVE9fU1RSSU5HKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodGhhdCwgcG9zKSB7XG4gICAgdmFyIHMgPSBTdHJpbmcoZGVmaW5lZCh0aGF0KSk7XG4gICAgdmFyIGkgPSB0b0ludGVnZXIocG9zKTtcbiAgICB2YXIgbCA9IHMubGVuZ3RoO1xuICAgIHZhciBhLCBiO1xuICAgIGlmIChpIDwgMCB8fCBpID49IGwpIHJldHVybiBUT19TVFJJTkcgPyAnJyA6IHVuZGVmaW5lZDtcbiAgICBhID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIHJldHVybiBhIDwgMHhkODAwIHx8IGEgPiAweGRiZmYgfHwgaSArIDEgPT09IGwgfHwgKGIgPSBzLmNoYXJDb2RlQXQoaSArIDEpKSA8IDB4ZGMwMCB8fCBiID4gMHhkZmZmXG4gICAgICA/IFRPX1NUUklORyA/IHMuY2hhckF0KGkpIDogYVxuICAgICAgOiBUT19TVFJJTkcgPyBzLnNsaWNlKGksIGkgKyAyKSA6IChhIC0gMHhkODAwIDw8IDEwKSArIChiIC0gMHhkYzAwKSArIDB4MTAwMDA7XG4gIH07XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX3N0cmluZy1hdC5qc1xuLy8gbW9kdWxlIGlkID0gMTYyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///162\n")},function(module,exports,__webpack_require__){eval("var anObject = __webpack_require__(21);\nvar get = __webpack_require__(164);\nmodule.exports = __webpack_require__(4).getIterator = function (it) {\n  var iterFn = get(it);\n  if (typeof iterFn != 'function') throw TypeError(it + ' is not iterable!');\n  return anObject(iterFn.call(it));\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTYzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2NvcmUuZ2V0LWl0ZXJhdG9yLmpzPzgzYzUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgZ2V0ID0gcmVxdWlyZSgnLi9jb3JlLmdldC1pdGVyYXRvci1tZXRob2QnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fY29yZScpLmdldEl0ZXJhdG9yID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBpdGVyRm4gPSBnZXQoaXQpO1xuICBpZiAodHlwZW9mIGl0ZXJGbiAhPSAnZnVuY3Rpb24nKSB0aHJvdyBUeXBlRXJyb3IoaXQgKyAnIGlzIG5vdCBpdGVyYWJsZSEnKTtcbiAgcmV0dXJuIGFuT2JqZWN0KGl0ZXJGbi5jYWxsKGl0KSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDE2M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///163\n")},function(module,exports,__webpack_require__){eval("var classof = __webpack_require__(165);\nvar ITERATOR = __webpack_require__(10)('iterator');\nvar Iterators = __webpack_require__(40);\nmodule.exports = __webpack_require__(4).getIteratorMethod = function (it) {\n  if (it != undefined) return it[ITERATOR]\n    || it['@@iterator']\n    || Iterators[classof(it)];\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTY0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2NvcmUuZ2V0LWl0ZXJhdG9yLW1ldGhvZC5qcz9kZGZiIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBjbGFzc29mID0gcmVxdWlyZSgnLi9fY2xhc3NvZicpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi9faXRlcmF0b3JzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vX2NvcmUnKS5nZXRJdGVyYXRvck1ldGhvZCA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgIT0gdW5kZWZpbmVkKSByZXR1cm4gaXRbSVRFUkFUT1JdXG4gICAgfHwgaXRbJ0BAaXRlcmF0b3InXVxuICAgIHx8IEl0ZXJhdG9yc1tjbGFzc29mKGl0KV07XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvY29yZS5nZXQtaXRlcmF0b3ItbWV0aG9kLmpzXG4vLyBtb2R1bGUgaWQgPSAxNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///164\n")},function(module,exports,__webpack_require__){eval("// getting tag from 19.1.3.6 Object.prototype.toString()\nvar cof = __webpack_require__(50);\nvar TAG = __webpack_require__(10)('toStringTag');\n// ES3 wrong here\nvar ARG = cof(function () { return arguments; }()) == 'Arguments';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function (it, key) {\n  try {\n    return it[key];\n  } catch (e) { /* empty */ }\n};\n\nmodule.exports = function (it) {\n  var O, T, B;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T\n    // builtinTag case\n    : ARG ? cof(O)\n    // ES3 arguments fallback\n    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTY1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19jbGFzc29mLmpzPzQ1OGYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZ2V0dGluZyB0YWcgZnJvbSAxOS4xLjMuNiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKClcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbnZhciBUQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKTtcbi8vIEVTMyB3cm9uZyBoZXJlXG52YXIgQVJHID0gY29mKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA9PSAnQXJndW1lbnRzJztcblxuLy8gZmFsbGJhY2sgZm9yIElFMTEgU2NyaXB0IEFjY2VzcyBEZW5pZWQgZXJyb3JcbnZhciB0cnlHZXQgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICB0cnkge1xuICAgIHJldHVybiBpdFtrZXldO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBPLCBULCBCO1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/ICdVbmRlZmluZWQnIDogaXQgPT09IG51bGwgPyAnTnVsbCdcbiAgICAvLyBAQHRvU3RyaW5nVGFnIGNhc2VcbiAgICA6IHR5cGVvZiAoVCA9IHRyeUdldChPID0gT2JqZWN0KGl0KSwgVEFHKSkgPT0gJ3N0cmluZycgPyBUXG4gICAgLy8gYnVpbHRpblRhZyBjYXNlXG4gICAgOiBBUkcgPyBjb2YoTylcbiAgICAvLyBFUzMgYXJndW1lbnRzIGZhbGxiYWNrXG4gICAgOiAoQiA9IGNvZihPKSkgPT0gJ09iamVjdCcgJiYgdHlwZW9mIE8uY2FsbGVlID09ICdmdW5jdGlvbicgPyAnQXJndW1lbnRzJyA6IEI7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2NsYXNzb2YuanNcbi8vIG1vZHVsZSBpZCA9IDE2NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///165\n")},function(module,exports,__webpack_require__){eval("var core = __webpack_require__(4);\nvar $JSON = core.JSON || (core.JSON = { stringify: JSON.stringify });\nmodule.exports = function stringify(it) { // eslint-disable-line no-unused-vars\n  return $JSON.stringify.apply($JSON, arguments);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTY2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9qc29uL3N0cmluZ2lmeS5qcz9hYTQyIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBjb3JlID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpO1xudmFyICRKU09OID0gY29yZS5KU09OIHx8IChjb3JlLkpTT04gPSB7IHN0cmluZ2lmeTogSlNPTi5zdHJpbmdpZnkgfSk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gIHJldHVybiAkSlNPTi5zdHJpbmdpZnkuYXBwbHkoJEpTT04sIGFyZ3VtZW50cyk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL2pzb24vc3RyaW5naWZ5LmpzXG4vLyBtb2R1bGUgaWQgPSAxNjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///166\n")},function(module,exports,__webpack_require__){eval("__webpack_require__(168);\nmodule.exports = __webpack_require__(4).Object.getPrototypeOf;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTY3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZ2V0LXByb3RvdHlwZS1vZi5qcz83ZDJlIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtcHJvdG90eXBlLW9mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L2dldC1wcm90b3R5cGUtb2YuanNcbi8vIG1vZHVsZSBpZCA9IDE2N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///167\n")},function(module,exports,__webpack_require__){eval("// 19.1.2.9 Object.getPrototypeOf(O)\nvar toObject = __webpack_require__(57);\nvar $getPrototypeOf = __webpack_require__(103);\n\n__webpack_require__(105)('getPrototypeOf', function () {\n  return function getPrototypeOf(it) {\n    return $getPrototypeOf(toObject(it));\n  };\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTY4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LXByb3RvdHlwZS1vZi5qcz8yYTFlIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIDE5LjEuMi45IE9iamVjdC5nZXRQcm90b3R5cGVPZihPKVxudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8tb2JqZWN0Jyk7XG52YXIgJGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2dldFByb3RvdHlwZU9mJywgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZnVuY3Rpb24gZ2V0UHJvdG90eXBlT2YoaXQpIHtcbiAgICByZXR1cm4gJGdldFByb3RvdHlwZU9mKHRvT2JqZWN0KGl0KSk7XG4gIH07XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LXByb3RvdHlwZS1vZi5qc1xuLy8gbW9kdWxlIGlkID0gMTY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///168\n")},function(module,exports,__webpack_require__){eval('module.exports = { "default": __webpack_require__(170), __esModule: true };//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTY5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9zeW1ib2wvaXRlcmF0b3IuanM/NjczOCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sL2l0ZXJhdG9yXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbC9pdGVyYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gMTY5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///169\n')},function(module,exports,__webpack_require__){eval("__webpack_require__(104);\n__webpack_require__(100);\nmodule.exports = __webpack_require__(64).f('iterator');\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTcwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaXRlcmF0b3IuanM/ZmU3ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5zdHJpbmcuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvd2ViLmRvbS5pdGVyYWJsZScpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL193a3MtZXh0JykuZignaXRlcmF0b3InKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaXRlcmF0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDE3MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///170\n")},function(module,exports,__webpack_require__){eval('module.exports = { "default": __webpack_require__(172), __esModule: true };//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTcxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9zeW1ib2wuanM/ZTUwNSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHsgXCJkZWZhdWx0XCI6IHJlcXVpcmUoXCJjb3JlLWpzL2xpYnJhcnkvZm4vc3ltYm9sXCIpLCBfX2VzTW9kdWxlOiB0cnVlIH07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYmFiZWwtcnVudGltZS9jb3JlLWpzL3N5bWJvbC5qc1xuLy8gbW9kdWxlIGlkID0gMTcxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///171\n')},function(module,exports,__webpack_require__){eval("__webpack_require__(173);\n__webpack_require__(178);\n__webpack_require__(179);\n__webpack_require__(180);\nmodule.exports = __webpack_require__(4).Symbol;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTcyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaW5kZXguanM/MDcwNyJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKCcuLi8uLi9tb2R1bGVzL2VzNi5zeW1ib2wnKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC50by1zdHJpbmcnKTtcbnJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM3LnN5bWJvbC5hc3luYy1pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczcuc3ltYm9sLm9ic2VydmFibGUnKTtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9fY29yZScpLlN5bWJvbDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9zeW1ib2wvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDE3MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///172\n")},function(module,exports,__webpack_require__){"use strict";eval("\n// ECMAScript 6 symbols shim\nvar global = __webpack_require__(9);\nvar has = __webpack_require__(14);\nvar DESCRIPTORS = __webpack_require__(13);\nvar $export = __webpack_require__(11);\nvar redefine = __webpack_require__(102);\nvar META = __webpack_require__(174).KEY;\nvar $fails = __webpack_require__(23);\nvar shared = __webpack_require__(54);\nvar setToStringTag = __webpack_require__(61);\nvar uid = __webpack_require__(37);\nvar wks = __webpack_require__(10);\nvar wksExt = __webpack_require__(64);\nvar wksDefine = __webpack_require__(65);\nvar enumKeys = __webpack_require__(175);\nvar isArray = __webpack_require__(176);\nvar anObject = __webpack_require__(21);\nvar isObject = __webpack_require__(22);\nvar toIObject = __webpack_require__(15);\nvar toPrimitive = __webpack_require__(49);\nvar createDesc = __webpack_require__(35);\nvar _create = __webpack_require__(60);\nvar gOPNExt = __webpack_require__(177);\nvar $GOPD = __webpack_require__(66);\nvar $DP = __webpack_require__(12);\nvar $keys = __webpack_require__(36);\nvar gOPD = $GOPD.f;\nvar dP = $DP.f;\nvar gOPN = gOPNExt.f;\nvar $Symbol = global.Symbol;\nvar $JSON = global.JSON;\nvar _stringify = $JSON && $JSON.stringify;\nvar PROTOTYPE = 'prototype';\nvar HIDDEN = wks('_hidden');\nvar TO_PRIMITIVE = wks('toPrimitive');\nvar isEnum = {}.propertyIsEnumerable;\nvar SymbolRegistry = shared('symbol-registry');\nvar AllSymbols = shared('symbols');\nvar OPSymbols = shared('op-symbols');\nvar ObjectProto = Object[PROTOTYPE];\nvar USE_NATIVE = typeof $Symbol == 'function';\nvar QObject = global.QObject;\n// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173\nvar setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;\n\n// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687\nvar setSymbolDesc = DESCRIPTORS && $fails(function () {\n  return _create(dP({}, 'a', {\n    get: function () { return dP(this, 'a', { value: 7 }).a; }\n  })).a != 7;\n}) ? function (it, key, D) {\n  var protoDesc = gOPD(ObjectProto, key);\n  if (protoDesc) delete ObjectProto[key];\n  dP(it, key, D);\n  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);\n} : dP;\n\nvar wrap = function (tag) {\n  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);\n  sym._k = tag;\n  return sym;\n};\n\nvar isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {\n  return typeof it == 'symbol';\n} : function (it) {\n  return it instanceof $Symbol;\n};\n\nvar $defineProperty = function defineProperty(it, key, D) {\n  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);\n  anObject(it);\n  key = toPrimitive(key, true);\n  anObject(D);\n  if (has(AllSymbols, key)) {\n    if (!D.enumerable) {\n      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));\n      it[HIDDEN][key] = true;\n    } else {\n      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;\n      D = _create(D, { enumerable: createDesc(0, false) });\n    } return setSymbolDesc(it, key, D);\n  } return dP(it, key, D);\n};\nvar $defineProperties = function defineProperties(it, P) {\n  anObject(it);\n  var keys = enumKeys(P = toIObject(P));\n  var i = 0;\n  var l = keys.length;\n  var key;\n  while (l > i) $defineProperty(it, key = keys[i++], P[key]);\n  return it;\n};\nvar $create = function create(it, P) {\n  return P === undefined ? _create(it) : $defineProperties(_create(it), P);\n};\nvar $propertyIsEnumerable = function propertyIsEnumerable(key) {\n  var E = isEnum.call(this, key = toPrimitive(key, true));\n  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;\n  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;\n};\nvar $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {\n  it = toIObject(it);\n  key = toPrimitive(key, true);\n  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;\n  var D = gOPD(it, key);\n  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;\n  return D;\n};\nvar $getOwnPropertyNames = function getOwnPropertyNames(it) {\n  var names = gOPN(toIObject(it));\n  var result = [];\n  var i = 0;\n  var key;\n  while (names.length > i) {\n    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);\n  } return result;\n};\nvar $getOwnPropertySymbols = function getOwnPropertySymbols(it) {\n  var IS_OP = it === ObjectProto;\n  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));\n  var result = [];\n  var i = 0;\n  var key;\n  while (names.length > i) {\n    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);\n  } return result;\n};\n\n// 19.4.1.1 Symbol([description])\nif (!USE_NATIVE) {\n  $Symbol = function Symbol() {\n    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');\n    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);\n    var $set = function (value) {\n      if (this === ObjectProto) $set.call(OPSymbols, value);\n      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;\n      setSymbolDesc(this, tag, createDesc(1, value));\n    };\n    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });\n    return wrap(tag);\n  };\n  redefine($Symbol[PROTOTYPE], 'toString', function toString() {\n    return this._k;\n  });\n\n  $GOPD.f = $getOwnPropertyDescriptor;\n  $DP.f = $defineProperty;\n  __webpack_require__(107).f = gOPNExt.f = $getOwnPropertyNames;\n  __webpack_require__(38).f = $propertyIsEnumerable;\n  __webpack_require__(56).f = $getOwnPropertySymbols;\n\n  if (DESCRIPTORS && !__webpack_require__(59)) {\n    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);\n  }\n\n  wksExt.f = function (name) {\n    return wrap(wks(name));\n  };\n}\n\n$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });\n\nfor (var es6Symbols = (\n  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14\n  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'\n).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);\n\nfor (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);\n\n$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {\n  // 19.4.2.1 Symbol.for(key)\n  'for': function (key) {\n    return has(SymbolRegistry, key += '')\n      ? SymbolRegistry[key]\n      : SymbolRegistry[key] = $Symbol(key);\n  },\n  // 19.4.2.5 Symbol.keyFor(sym)\n  keyFor: function keyFor(sym) {\n    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');\n    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;\n  },\n  useSetter: function () { setter = true; },\n  useSimple: function () { setter = false; }\n});\n\n$export($export.S + $export.F * !USE_NATIVE, 'Object', {\n  // 19.1.2.2 Object.create(O [, Properties])\n  create: $create,\n  // 19.1.2.4 Object.defineProperty(O, P, Attributes)\n  defineProperty: $defineProperty,\n  // 19.1.2.3 Object.defineProperties(O, Properties)\n  defineProperties: $defineProperties,\n  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)\n  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,\n  // 19.1.2.7 Object.getOwnPropertyNames(O)\n  getOwnPropertyNames: $getOwnPropertyNames,\n  // 19.1.2.8 Object.getOwnPropertySymbols(O)\n  getOwnPropertySymbols: $getOwnPropertySymbols\n});\n\n// 24.3.2 JSON.stringify(value [, replacer [, space]])\n$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {\n  var S = $Symbol();\n  // MS Edge converts symbol values to JSON as {}\n  // WebKit converts symbol values to JSON as null\n  // V8 throws on boxed symbols\n  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';\n})), 'JSON', {\n  stringify: function stringify(it) {\n    var args = [it];\n    var i = 1;\n    var replacer, $replacer;\n    while (arguments.length > i) args.push(arguments[i++]);\n    $replacer = replacer = args[1];\n    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined\n    if (!isArray(replacer)) replacer = function (key, value) {\n      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);\n      if (!isSymbol(value)) return value;\n    };\n    args[1] = replacer;\n    return _stringify.apply($JSON, args);\n  }\n});\n\n// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)\n$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(20)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);\n// 19.4.3.5 Symbol.prototype[@@toStringTag]\nsetToStringTag($Symbol, 'Symbol');\n// 20.2.1.9 Math[@@toStringTag]\nsetToStringTag(Math, 'Math', true);\n// 24.3.3 JSON[@@toStringTag]\nsetToStringTag(global.JSON, 'JSON', true);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTczLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5zeW1ib2wuanM/N2Q2NyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG4vLyBFQ01BU2NyaXB0IDYgc3ltYm9scyBzaGltXG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgTUVUQSA9IHJlcXVpcmUoJy4vX21ldGEnKS5LRVk7XG52YXIgJGZhaWxzID0gcmVxdWlyZSgnLi9fZmFpbHMnKTtcbnZhciBzaGFyZWQgPSByZXF1aXJlKCcuL19zaGFyZWQnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4vX3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG52YXIgd2tzID0gcmVxdWlyZSgnLi9fd2tzJyk7XG52YXIgd2tzRXh0ID0gcmVxdWlyZSgnLi9fd2tzLWV4dCcpO1xudmFyIHdrc0RlZmluZSA9IHJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKTtcbnZhciBlbnVtS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0ta2V5cycpO1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL19pcy1hcnJheScpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuL190by1wcmltaXRpdmUnKTtcbnZhciBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xudmFyIF9jcmVhdGUgPSByZXF1aXJlKCcuL19vYmplY3QtY3JlYXRlJyk7XG52YXIgZ09QTkV4dCA9IHJlcXVpcmUoJy4vX29iamVjdC1nb3BuLWV4dCcpO1xudmFyICRHT1BEID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKTtcbnZhciAkRFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciAka2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzJyk7XG52YXIgZ09QRCA9ICRHT1BELmY7XG52YXIgZFAgPSAkRFAuZjtcbnZhciBnT1BOID0gZ09QTkV4dC5mO1xudmFyICRTeW1ib2wgPSBnbG9iYWwuU3ltYm9sO1xudmFyICRKU09OID0gZ2xvYmFsLkpTT047XG52YXIgX3N0cmluZ2lmeSA9ICRKU09OICYmICRKU09OLnN0cmluZ2lmeTtcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcbnZhciBISURERU4gPSB3a3MoJ19oaWRkZW4nKTtcbnZhciBUT19QUklNSVRJVkUgPSB3a3MoJ3RvUHJpbWl0aXZlJyk7XG52YXIgaXNFbnVtID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgU3ltYm9sUmVnaXN0cnkgPSBzaGFyZWQoJ3N5bWJvbC1yZWdpc3RyeScpO1xudmFyIEFsbFN5bWJvbHMgPSBzaGFyZWQoJ3N5bWJvbHMnKTtcbnZhciBPUFN5bWJvbHMgPSBzaGFyZWQoJ29wLXN5bWJvbHMnKTtcbnZhciBPYmplY3RQcm90byA9IE9iamVjdFtQUk9UT1RZUEVdO1xudmFyIFVTRV9OQVRJVkUgPSB0eXBlb2YgJFN5bWJvbCA9PSAnZnVuY3Rpb24nO1xudmFyIFFPYmplY3QgPSBnbG9iYWwuUU9iamVjdDtcbi8vIERvbid0IHVzZSBzZXR0ZXJzIGluIFF0IFNjcmlwdCwgaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzE3M1xudmFyIHNldHRlciA9ICFRT2JqZWN0IHx8ICFRT2JqZWN0W1BST1RPVFlQRV0gfHwgIVFPYmplY3RbUFJPVE9UWVBFXS5maW5kQ2hpbGQ7XG5cbi8vIGZhbGxiYWNrIGZvciBvbGQgQW5kcm9pZCwgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTY4N1xudmFyIHNldFN5bWJvbERlc2MgPSBERVNDUklQVE9SUyAmJiAkZmFpbHMoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gX2NyZWF0ZShkUCh7fSwgJ2EnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkUCh0aGlzLCAnYScsIHsgdmFsdWU6IDcgfSkuYTsgfVxuICB9KSkuYSAhPSA3O1xufSkgPyBmdW5jdGlvbiAoaXQsIGtleSwgRCkge1xuICB2YXIgcHJvdG9EZXNjID0gZ09QRChPYmplY3RQcm90bywga2V5KTtcbiAgaWYgKHByb3RvRGVzYykgZGVsZXRlIE9iamVjdFByb3RvW2tleV07XG4gIGRQKGl0LCBrZXksIEQpO1xuICBpZiAocHJvdG9EZXNjICYmIGl0ICE9PSBPYmplY3RQcm90bykgZFAoT2JqZWN0UHJvdG8sIGtleSwgcHJvdG9EZXNjKTtcbn0gOiBkUDtcblxudmFyIHdyYXAgPSBmdW5jdGlvbiAodGFnKSB7XG4gIHZhciBzeW0gPSBBbGxTeW1ib2xzW3RhZ10gPSBfY3JlYXRlKCRTeW1ib2xbUFJPVE9UWVBFXSk7XG4gIHN5bS5fayA9IHRhZztcbiAgcmV0dXJuIHN5bTtcbn07XG5cbnZhciBpc1N5bWJvbCA9IFVTRV9OQVRJVkUgJiYgdHlwZW9mICRTeW1ib2wuaXRlcmF0b3IgPT0gJ3N5bWJvbCcgPyBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJztcbn0gOiBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0IGluc3RhbmNlb2YgJFN5bWJvbDtcbn07XG5cbnZhciAkZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShpdCwga2V5LCBEKSB7XG4gIGlmIChpdCA9PT0gT2JqZWN0UHJvdG8pICRkZWZpbmVQcm9wZXJ0eShPUFN5bWJvbHMsIGtleSwgRCk7XG4gIGFuT2JqZWN0KGl0KTtcbiAga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKTtcbiAgYW5PYmplY3QoRCk7XG4gIGlmIChoYXMoQWxsU3ltYm9scywga2V5KSkge1xuICAgIGlmICghRC5lbnVtZXJhYmxlKSB7XG4gICAgICBpZiAoIWhhcyhpdCwgSElEREVOKSkgZFAoaXQsIEhJRERFTiwgY3JlYXRlRGVzYygxLCB7fSkpO1xuICAgICAgaXRbSElEREVOXVtrZXldID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pIGl0W0hJRERFTl1ba2V5XSA9IGZhbHNlO1xuICAgICAgRCA9IF9jcmVhdGUoRCwgeyBlbnVtZXJhYmxlOiBjcmVhdGVEZXNjKDAsIGZhbHNlKSB9KTtcbiAgICB9IHJldHVybiBzZXRTeW1ib2xEZXNjKGl0LCBrZXksIEQpO1xuICB9IHJldHVybiBkUChpdCwga2V5LCBEKTtcbn07XG52YXIgJGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKGl0LCBQKSB7XG4gIGFuT2JqZWN0KGl0KTtcbiAgdmFyIGtleXMgPSBlbnVtS2V5cyhQID0gdG9JT2JqZWN0KFApKTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgbCA9IGtleXMubGVuZ3RoO1xuICB2YXIga2V5O1xuICB3aGlsZSAobCA+IGkpICRkZWZpbmVQcm9wZXJ0eShpdCwga2V5ID0ga2V5c1tpKytdLCBQW2tleV0pO1xuICByZXR1cm4gaXQ7XG59O1xudmFyICRjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoaXQsIFApIHtcbiAgcmV0dXJuIFAgPT09IHVuZGVmaW5lZCA/IF9jcmVhdGUoaXQpIDogJGRlZmluZVByb3BlcnRpZXMoX2NyZWF0ZShpdCksIFApO1xufTtcbnZhciAkcHJvcGVydHlJc0VudW1lcmFibGUgPSBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShrZXkpIHtcbiAgdmFyIEUgPSBpc0VudW0uY2FsbCh0aGlzLCBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpKTtcbiAgaWYgKHRoaXMgPT09IE9iamVjdFByb3RvICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICFoYXMoT1BTeW1ib2xzLCBrZXkpKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBFIHx8ICFoYXModGhpcywga2V5KSB8fCAhaGFzKEFsbFN5bWJvbHMsIGtleSkgfHwgaGFzKHRoaXMsIEhJRERFTikgJiYgdGhpc1tISURERU5dW2tleV0gPyBFIDogdHJ1ZTtcbn07XG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KSB7XG4gIGl0ID0gdG9JT2JqZWN0KGl0KTtcbiAga2V5ID0gdG9QcmltaXRpdmUoa2V5LCB0cnVlKTtcbiAgaWYgKGl0ID09PSBPYmplY3RQcm90byAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9QU3ltYm9scywga2V5KSkgcmV0dXJuO1xuICB2YXIgRCA9IGdPUEQoaXQsIGtleSk7XG4gIGlmIChEICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICEoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSkpIEQuZW51bWVyYWJsZSA9IHRydWU7XG4gIHJldHVybiBEO1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlOYW1lcyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpIHtcbiAgdmFyIG5hbWVzID0gZ09QTih0b0lPYmplY3QoaXQpKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgaSA9IDA7XG4gIHZhciBrZXk7XG4gIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKSB7XG4gICAgaWYgKCFoYXMoQWxsU3ltYm9scywga2V5ID0gbmFtZXNbaSsrXSkgJiYga2V5ICE9IEhJRERFTiAmJiBrZXkgIT0gTUVUQSkgcmVzdWx0LnB1c2goa2V5KTtcbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGl0KSB7XG4gIHZhciBJU19PUCA9IGl0ID09PSBPYmplY3RQcm90bztcbiAgdmFyIG5hbWVzID0gZ09QTihJU19PUCA/IE9QU3ltYm9scyA6IHRvSU9iamVjdChpdCkpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBpID0gMDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIHtcbiAgICBpZiAoaGFzKEFsbFN5bWJvbHMsIGtleSA9IG5hbWVzW2krK10pICYmIChJU19PUCA/IGhhcyhPYmplY3RQcm90bywga2V5KSA6IHRydWUpKSByZXN1bHQucHVzaChBbGxTeW1ib2xzW2tleV0pO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyAxOS40LjEuMSBTeW1ib2woW2Rlc2NyaXB0aW9uXSlcbmlmICghVVNFX05BVElWRSkge1xuICAkU3ltYm9sID0gZnVuY3Rpb24gU3ltYm9sKCkge1xuICAgIGlmICh0aGlzIGluc3RhbmNlb2YgJFN5bWJvbCkgdGhyb3cgVHlwZUVycm9yKCdTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3IhJyk7XG4gICAgdmFyIHRhZyA9IHVpZChhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7XG4gICAgdmFyICRzZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGlmICh0aGlzID09PSBPYmplY3RQcm90bykgJHNldC5jYWxsKE9QU3ltYm9scywgdmFsdWUpO1xuICAgICAgaWYgKGhhcyh0aGlzLCBISURERU4pICYmIGhhcyh0aGlzW0hJRERFTl0sIHRhZykpIHRoaXNbSElEREVOXVt0YWddID0gZmFsc2U7XG4gICAgICBzZXRTeW1ib2xEZXNjKHRoaXMsIHRhZywgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xuICAgIH07XG4gICAgaWYgKERFU0NSSVBUT1JTICYmIHNldHRlcikgc2V0U3ltYm9sRGVzYyhPYmplY3RQcm90bywgdGFnLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgc2V0OiAkc2V0IH0pO1xuICAgIHJldHVybiB3cmFwKHRhZyk7XG4gIH07XG4gIHJlZGVmaW5lKCRTeW1ib2xbUFJPVE9UWVBFXSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2s7XG4gIH0pO1xuXG4gICRHT1BELmYgPSAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICAkRFAuZiA9ICRkZWZpbmVQcm9wZXJ0eTtcbiAgcmVxdWlyZSgnLi9fb2JqZWN0LWdvcG4nKS5mID0gZ09QTkV4dC5mID0gJGdldE93blByb3BlcnR5TmFtZXM7XG4gIHJlcXVpcmUoJy4vX29iamVjdC1waWUnKS5mID0gJHByb3BlcnR5SXNFbnVtZXJhYmxlO1xuICByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpLmYgPSAkZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4gIGlmIChERVNDUklQVE9SUyAmJiAhcmVxdWlyZSgnLi9fbGlicmFyeScpKSB7XG4gICAgcmVkZWZpbmUoT2JqZWN0UHJvdG8sICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICRwcm9wZXJ0eUlzRW51bWVyYWJsZSwgdHJ1ZSk7XG4gIH1cblxuICB3a3NFeHQuZiA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIHdyYXAod2tzKG5hbWUpKTtcbiAgfTtcbn1cblxuJGV4cG9ydCgkZXhwb3J0LkcgKyAkZXhwb3J0LlcgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgeyBTeW1ib2w6ICRTeW1ib2wgfSk7XG5cbmZvciAodmFyIGVzNlN5bWJvbHMgPSAoXG4gIC8vIDE5LjQuMi4yLCAxOS40LjIuMywgMTkuNC4yLjQsIDE5LjQuMi42LCAxOS40LjIuOCwgMTkuNC4yLjksIDE5LjQuMi4xMCwgMTkuNC4yLjExLCAxOS40LjIuMTIsIDE5LjQuMi4xMywgMTkuNC4yLjE0XG4gICdoYXNJbnN0YW5jZSxpc0NvbmNhdFNwcmVhZGFibGUsaXRlcmF0b3IsbWF0Y2gscmVwbGFjZSxzZWFyY2gsc3BlY2llcyxzcGxpdCx0b1ByaW1pdGl2ZSx0b1N0cmluZ1RhZyx1bnNjb3BhYmxlcydcbikuc3BsaXQoJywnKSwgaiA9IDA7IGVzNlN5bWJvbHMubGVuZ3RoID4gajspd2tzKGVzNlN5bWJvbHNbaisrXSk7XG5cbmZvciAodmFyIHdlbGxLbm93blN5bWJvbHMgPSAka2V5cyh3a3Muc3RvcmUpLCBrID0gMDsgd2VsbEtub3duU3ltYm9scy5sZW5ndGggPiBrOykgd2tzRGVmaW5lKHdlbGxLbm93blN5bWJvbHNbaysrXSk7XG5cbiRleHBvcnQoJGV4cG9ydC5TICsgJGV4cG9ydC5GICogIVVTRV9OQVRJVkUsICdTeW1ib2wnLCB7XG4gIC8vIDE5LjQuMi4xIFN5bWJvbC5mb3Ioa2V5KVxuICAnZm9yJzogZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBoYXMoU3ltYm9sUmVnaXN0cnksIGtleSArPSAnJylcbiAgICAgID8gU3ltYm9sUmVnaXN0cnlba2V5XVxuICAgICAgOiBTeW1ib2xSZWdpc3RyeVtrZXldID0gJFN5bWJvbChrZXkpO1xuICB9LFxuICAvLyAxOS40LjIuNSBTeW1ib2wua2V5Rm9yKHN5bSlcbiAga2V5Rm9yOiBmdW5jdGlvbiBrZXlGb3Ioc3ltKSB7XG4gICAgaWYgKCFpc1N5bWJvbChzeW0pKSB0aHJvdyBUeXBlRXJyb3Ioc3ltICsgJyBpcyBub3QgYSBzeW1ib2whJyk7XG4gICAgZm9yICh2YXIga2V5IGluIFN5bWJvbFJlZ2lzdHJ5KSBpZiAoU3ltYm9sUmVnaXN0cnlba2V5XSA9PT0gc3ltKSByZXR1cm4ga2V5O1xuICB9LFxuICB1c2VTZXR0ZXI6IGZ1bmN0aW9uICgpIHsgc2V0dGVyID0gdHJ1ZTsgfSxcbiAgdXNlU2ltcGxlOiBmdW5jdGlvbiAoKSB7IHNldHRlciA9IGZhbHNlOyB9XG59KTtcblxuJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAhVVNFX05BVElWRSwgJ09iamVjdCcsIHtcbiAgLy8gMTkuMS4yLjIgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxuICBjcmVhdGU6ICRjcmVhdGUsXG4gIC8vIDE5LjEuMi40IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKVxuICBkZWZpbmVQcm9wZXJ0eTogJGRlZmluZVByb3BlcnR5LFxuICAvLyAxOS4xLjIuMyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKVxuICBkZWZpbmVQcm9wZXJ0aWVzOiAkZGVmaW5lUHJvcGVydGllcyxcbiAgLy8gMTkuMS4yLjYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKVxuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsXG4gIC8vIDE5LjEuMi43IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE8pXG4gIGdldE93blByb3BlcnR5TmFtZXM6ICRnZXRPd25Qcm9wZXJ0eU5hbWVzLFxuICAvLyAxOS4xLjIuOCBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKE8pXG4gIGdldE93blByb3BlcnR5U3ltYm9sczogJGdldE93blByb3BlcnR5U3ltYm9sc1xufSk7XG5cbi8vIDI0LjMuMiBKU09OLnN0cmluZ2lmeSh2YWx1ZSBbLCByZXBsYWNlciBbLCBzcGFjZV1dKVxuJEpTT04gJiYgJGV4cG9ydCgkZXhwb3J0LlMgKyAkZXhwb3J0LkYgKiAoIVVTRV9OQVRJVkUgfHwgJGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgdmFyIFMgPSAkU3ltYm9sKCk7XG4gIC8vIE1TIEVkZ2UgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIHt9XG4gIC8vIFdlYktpdCBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMgbnVsbFxuICAvLyBWOCB0aHJvd3Mgb24gYm94ZWQgc3ltYm9sc1xuICByZXR1cm4gX3N0cmluZ2lmeShbU10pICE9ICdbbnVsbF0nIHx8IF9zdHJpbmdpZnkoeyBhOiBTIH0pICE9ICd7fScgfHwgX3N0cmluZ2lmeShPYmplY3QoUykpICE9ICd7fSc7XG59KSksICdKU09OJywge1xuICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCkge1xuICAgIHZhciBhcmdzID0gW2l0XTtcbiAgICB2YXIgaSA9IDE7XG4gICAgdmFyIHJlcGxhY2VyLCAkcmVwbGFjZXI7XG4gICAgd2hpbGUgKGFyZ3VtZW50cy5sZW5ndGggPiBpKSBhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xuICAgICRyZXBsYWNlciA9IHJlcGxhY2VyID0gYXJnc1sxXTtcbiAgICBpZiAoIWlzT2JqZWN0KHJlcGxhY2VyKSAmJiBpdCA9PT0gdW5kZWZpbmVkIHx8IGlzU3ltYm9sKGl0KSkgcmV0dXJuOyAvLyBJRTggcmV0dXJucyBzdHJpbmcgb24gdW5kZWZpbmVkXG4gICAgaWYgKCFpc0FycmF5KHJlcGxhY2VyKSkgcmVwbGFjZXIgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiAkcmVwbGFjZXIgPT0gJ2Z1bmN0aW9uJykgdmFsdWUgPSAkcmVwbGFjZXIuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgIGlmICghaXNTeW1ib2wodmFsdWUpKSByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgICBhcmdzWzFdID0gcmVwbGFjZXI7XG4gICAgcmV0dXJuIF9zdHJpbmdpZnkuYXBwbHkoJEpTT04sIGFyZ3MpO1xuICB9XG59KTtcblxuLy8gMTkuNC4zLjQgU3ltYm9sLnByb3RvdHlwZVtAQHRvUHJpbWl0aXZlXShoaW50KVxuJFN5bWJvbFtQUk9UT1RZUEVdW1RPX1BSSU1JVElWRV0gfHwgcmVxdWlyZSgnLi9faGlkZScpKCRTeW1ib2xbUFJPVE9UWVBFXSwgVE9fUFJJTUlUSVZFLCAkU3ltYm9sW1BST1RPVFlQRV0udmFsdWVPZik7XG4vLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZygkU3ltYm9sLCAnU3ltYm9sJyk7XG4vLyAyMC4yLjEuOSBNYXRoW0BAdG9TdHJpbmdUYWddXG5zZXRUb1N0cmluZ1RhZyhNYXRoLCAnTWF0aCcsIHRydWUpO1xuLy8gMjQuMy4zIEpTT05bQEB0b1N0cmluZ1RhZ11cbnNldFRvU3RyaW5nVGFnKGdsb2JhbC5KU09OLCAnSlNPTicsIHRydWUpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2LnN5bWJvbC5qc1xuLy8gbW9kdWxlIGlkID0gMTczXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///173\n")},function(module,exports,__webpack_require__){eval("var META = __webpack_require__(37)('meta');\nvar isObject = __webpack_require__(22);\nvar has = __webpack_require__(14);\nvar setDesc = __webpack_require__(12).f;\nvar id = 0;\nvar isExtensible = Object.isExtensible || function () {\n  return true;\n};\nvar FREEZE = !__webpack_require__(23)(function () {\n  return isExtensible(Object.preventExtensions({}));\n});\nvar setMeta = function (it) {\n  setDesc(it, META, { value: {\n    i: 'O' + ++id, // object ID\n    w: {}          // weak collections IDs\n  } });\n};\nvar fastKey = function (it, create) {\n  // return primitive with prefix\n  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;\n  if (!has(it, META)) {\n    // can't set metadata to uncaught frozen object\n    if (!isExtensible(it)) return 'F';\n    // not necessary to add metadata\n    if (!create) return 'E';\n    // add missing metadata\n    setMeta(it);\n  // return object ID\n  } return it[META].i;\n};\nvar getWeak = function (it, create) {\n  if (!has(it, META)) {\n    // can't set metadata to uncaught frozen object\n    if (!isExtensible(it)) return true;\n    // not necessary to add metadata\n    if (!create) return false;\n    // add missing metadata\n    setMeta(it);\n  // return hash weak collections IDs\n  } return it[META].w;\n};\n// add metadata on freeze-family methods calling\nvar onFreeze = function (it) {\n  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);\n  return it;\n};\nvar meta = module.exports = {\n  KEY: META,\n  NEED: false,\n  fastKey: fastKey,\n  getWeak: getWeak,\n  onFreeze: onFreeze\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTc0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19tZXRhLmpzP2QzYTMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIE1FVEEgPSByZXF1aXJlKCcuL191aWQnKSgnbWV0YScpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgc2V0RGVzYyA9IHJlcXVpcmUoJy4vX29iamVjdC1kcCcpLmY7XG52YXIgaWQgPSAwO1xudmFyIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGUgfHwgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgRlJFRVpFID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gaXNFeHRlbnNpYmxlKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSkpO1xufSk7XG52YXIgc2V0TWV0YSA9IGZ1bmN0aW9uIChpdCkge1xuICBzZXREZXNjKGl0LCBNRVRBLCB7IHZhbHVlOiB7XG4gICAgaTogJ08nICsgKytpZCwgLy8gb2JqZWN0IElEXG4gICAgdzoge30gICAgICAgICAgLy8gd2VhayBjb2xsZWN0aW9ucyBJRHNcbiAgfSB9KTtcbn07XG52YXIgZmFzdEtleSA9IGZ1bmN0aW9uIChpdCwgY3JlYXRlKSB7XG4gIC8vIHJldHVybiBwcmltaXRpdmUgd2l0aCBwcmVmaXhcbiAgaWYgKCFpc09iamVjdChpdCkpIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCcgPyBpdCA6ICh0eXBlb2YgaXQgPT0gJ3N0cmluZycgPyAnUycgOiAnUCcpICsgaXQ7XG4gIGlmICghaGFzKGl0LCBNRVRBKSkge1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYgKCFpc0V4dGVuc2libGUoaXQpKSByZXR1cm4gJ0YnO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYgKCFjcmVhdGUpIHJldHVybiAnRSc7XG4gICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcbiAgICBzZXRNZXRhKGl0KTtcbiAgLy8gcmV0dXJuIG9iamVjdCBJRFxuICB9IHJldHVybiBpdFtNRVRBXS5pO1xufTtcbnZhciBnZXRXZWFrID0gZnVuY3Rpb24gKGl0LCBjcmVhdGUpIHtcbiAgaWYgKCFoYXMoaXQsIE1FVEEpKSB7XG4gICAgLy8gY2FuJ3Qgc2V0IG1ldGFkYXRhIHRvIHVuY2F1Z2h0IGZyb3plbiBvYmplY3RcbiAgICBpZiAoIWlzRXh0ZW5zaWJsZShpdCkpIHJldHVybiB0cnVlO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYgKCFjcmVhdGUpIHJldHVybiBmYWxzZTtcbiAgICAvLyBhZGQgbWlzc2luZyBtZXRhZGF0YVxuICAgIHNldE1ldGEoaXQpO1xuICAvLyByZXR1cm4gaGFzaCB3ZWFrIGNvbGxlY3Rpb25zIElEc1xuICB9IHJldHVybiBpdFtNRVRBXS53O1xufTtcbi8vIGFkZCBtZXRhZGF0YSBvbiBmcmVlemUtZmFtaWx5IG1ldGhvZHMgY2FsbGluZ1xudmFyIG9uRnJlZXplID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChGUkVFWkUgJiYgbWV0YS5ORUVEICYmIGlzRXh0ZW5zaWJsZShpdCkgJiYgIWhhcyhpdCwgTUVUQSkpIHNldE1ldGEoaXQpO1xuICByZXR1cm4gaXQ7XG59O1xudmFyIG1ldGEgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgS0VZOiBNRVRBLFxuICBORUVEOiBmYWxzZSxcbiAgZmFzdEtleTogZmFzdEtleSxcbiAgZ2V0V2VhazogZ2V0V2VhayxcbiAgb25GcmVlemU6IG9uRnJlZXplXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX21ldGEuanNcbi8vIG1vZHVsZSBpZCA9IDE3NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///174\n")},function(module,exports,__webpack_require__){eval("// all enumerable object keys, includes symbols\nvar getKeys = __webpack_require__(36);\nvar gOPS = __webpack_require__(56);\nvar pIE = __webpack_require__(38);\nmodule.exports = function (it) {\n  var result = getKeys(it);\n  var getSymbols = gOPS.f;\n  if (getSymbols) {\n    var symbols = getSymbols(it);\n    var isEnum = pIE.f;\n    var i = 0;\n    var key;\n    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);\n  } return result;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTc1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19lbnVtLWtleXMuanM/NWRjZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBhbGwgZW51bWVyYWJsZSBvYmplY3Qga2V5cywgaW5jbHVkZXMgc3ltYm9sc1xudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xudmFyIGdPUFMgPSByZXF1aXJlKCcuL19vYmplY3QtZ29wcycpO1xudmFyIHBJRSA9IHJlcXVpcmUoJy4vX29iamVjdC1waWUnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciByZXN1bHQgPSBnZXRLZXlzKGl0KTtcbiAgdmFyIGdldFN5bWJvbHMgPSBnT1BTLmY7XG4gIGlmIChnZXRTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBnZXRTeW1ib2xzKGl0KTtcbiAgICB2YXIgaXNFbnVtID0gcElFLmY7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBrZXk7XG4gICAgd2hpbGUgKHN5bWJvbHMubGVuZ3RoID4gaSkgaWYgKGlzRW51bS5jYWxsKGl0LCBrZXkgPSBzeW1ib2xzW2krK10pKSByZXN1bHQucHVzaChrZXkpO1xuICB9IHJldHVybiByZXN1bHQ7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2VudW0ta2V5cy5qc1xuLy8gbW9kdWxlIGlkID0gMTc1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///175\n")},function(module,exports,__webpack_require__){eval("// 7.2.2 IsArray(argument)\nvar cof = __webpack_require__(50);\nmodule.exports = Array.isArray || function isArray(arg) {\n  return cof(arg) == 'Array';\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTc2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19pcy1hcnJheS5qcz9lZDQzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIDcuMi4yIElzQXJyYXkoYXJndW1lbnQpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcbiAgcmV0dXJuIGNvZihhcmcpID09ICdBcnJheSc7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvX2lzLWFycmF5LmpzXG4vLyBtb2R1bGUgaWQgPSAxNzZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///176\n")},function(module,exports,__webpack_require__){eval("// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window\nvar toIObject = __webpack_require__(15);\nvar gOPN = __webpack_require__(107).f;\nvar toString = {}.toString;\n\nvar windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames\n  ? Object.getOwnPropertyNames(window) : [];\n\nvar getWindowNames = function (it) {\n  try {\n    return gOPN(it);\n  } catch (e) {\n    return windowNames.slice();\n  }\n};\n\nmodule.exports.f = function getOwnPropertyNames(it) {\n  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTc3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wbi1leHQuanM/NDZiNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBmYWxsYmFjayBmb3IgSUUxMSBidWdneSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB3aXRoIGlmcmFtZSBhbmQgd2luZG93XG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIGdPUE4gPSByZXF1aXJlKCcuL19vYmplY3QtZ29wbicpLmY7XG52YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxudmFyIHdpbmRvd05hbWVzID0gdHlwZW9mIHdpbmRvdyA9PSAnb2JqZWN0JyAmJiB3aW5kb3cgJiYgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXNcbiAgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh3aW5kb3cpIDogW107XG5cbnZhciBnZXRXaW5kb3dOYW1lcyA9IGZ1bmN0aW9uIChpdCkge1xuICB0cnkge1xuICAgIHJldHVybiBnT1BOKGl0KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB3aW5kb3dOYW1lcy5zbGljZSgpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5mID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhpdCkge1xuICByZXR1cm4gd2luZG93TmFtZXMgJiYgdG9TdHJpbmcuY2FsbChpdCkgPT0gJ1tvYmplY3QgV2luZG93XScgPyBnZXRXaW5kb3dOYW1lcyhpdCkgOiBnT1BOKHRvSU9iamVjdChpdCkpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19vYmplY3QtZ29wbi1leHQuanNcbi8vIG1vZHVsZSBpZCA9IDE3N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///177\n")},function(module,exports){eval("//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTc4LmpzIiwic291cmNlcyI6W10sIm1hcHBpbmdzIjoiIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///178\n")},function(module,exports,__webpack_require__){eval("__webpack_require__(65)('asyncIterator');\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTc5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3IuanM/Mzk4OSJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKCcuL193a3MtZGVmaW5lJykoJ2FzeW5jSXRlcmF0b3InKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zeW1ib2wuYXN5bmMtaXRlcmF0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDE3OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///179\n")},function(module,exports,__webpack_require__){eval("__webpack_require__(65)('observable');\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTgwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNy5zeW1ib2wub2JzZXJ2YWJsZS5qcz80MTY3Il0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUoJy4vX3drcy1kZWZpbmUnKSgnb2JzZXJ2YWJsZScpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM3LnN5bWJvbC5vYnNlcnZhYmxlLmpzXG4vLyBtb2R1bGUgaWQgPSAxODBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///180\n")},function(module,exports,__webpack_require__){eval('module.exports = { "default": __webpack_require__(182), __esModule: true };//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTgxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzPzJiYTEiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3JcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2dldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qc1xuLy8gbW9kdWxlIGlkID0gMTgxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///181\n')},function(module,exports,__webpack_require__){eval("__webpack_require__(183);\nvar $Object = __webpack_require__(4).Object;\nmodule.exports = function getOwnPropertyDescriptor(it, key) {\n  return $Object.getOwnPropertyDescriptor(it, key);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTgyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzPzcyNzkiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcicpO1xudmFyICRPYmplY3QgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSkge1xuICByZXR1cm4gJE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDE4MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///182\n")},function(module,exports,__webpack_require__){eval("// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)\nvar toIObject = __webpack_require__(15);\nvar $getOwnPropertyDescriptor = __webpack_require__(66).f;\n\n__webpack_require__(105)('getOwnPropertyDescriptor', function () {\n  return function getOwnPropertyDescriptor(it, key) {\n    return $getOwnPropertyDescriptor(toIObject(it), key);\n  };\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTgzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzPzg4ODkiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gMTkuMS4yLjYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKVxudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdvcGQnKS5mO1xuXG5yZXF1aXJlKCcuL19vYmplY3Qtc2FwJykoJ2dldE93blByb3BlcnR5RGVzY3JpcHRvcicsIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KSB7XG4gICAgcmV0dXJuICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodG9JT2JqZWN0KGl0KSwga2V5KTtcbiAgfTtcbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDE4M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///183\n")},function(module,exports,__webpack_require__){eval('module.exports = { "default": __webpack_require__(185), __esModule: true };//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTg0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi5qcz85MjIwIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0geyBcImRlZmF1bHRcIjogcmVxdWlyZShcImNvcmUtanMvbGlicmFyeS9mbi9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZlwiKSwgX19lc01vZHVsZTogdHJ1ZSB9O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi5qc1xuLy8gbW9kdWxlIGlkID0gMTg0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///184\n')},function(module,exports,__webpack_require__){eval("__webpack_require__(186);\nmodule.exports = __webpack_require__(4).Object.setPrototypeOf;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTg1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3Qvc2V0LXByb3RvdHlwZS1vZi5qcz84YmYwIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUoJy4uLy4uL21vZHVsZXMvZXM2Lm9iamVjdC5zZXQtcHJvdG90eXBlLW9mJyk7XG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uLy4uL21vZHVsZXMvX2NvcmUnKS5PYmplY3Quc2V0UHJvdG90eXBlT2Y7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvZm4vb2JqZWN0L3NldC1wcm90b3R5cGUtb2YuanNcbi8vIG1vZHVsZSBpZCA9IDE4NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///185\n")},function(module,exports,__webpack_require__){eval("// 19.1.3.19 Object.setPrototypeOf(O, proto)\nvar $export = __webpack_require__(11);\n$export($export.S, 'Object', { setPrototypeOf: __webpack_require__(187).set });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTg2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3Quc2V0LXByb3RvdHlwZS1vZi5qcz83YjE4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIDE5LjEuMy4xOSBPYmplY3Quc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pXG52YXIgJGV4cG9ydCA9IHJlcXVpcmUoJy4vX2V4cG9ydCcpO1xuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7IHNldFByb3RvdHlwZU9mOiByZXF1aXJlKCcuL19zZXQtcHJvdG8nKS5zZXQgfSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9lczYub2JqZWN0LnNldC1wcm90b3R5cGUtb2YuanNcbi8vIG1vZHVsZSBpZCA9IDE4NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///186\n")},function(module,exports,__webpack_require__){eval("// Works with __proto__ only. Old v8 can't work with null proto objects.\n/* eslint-disable no-proto */\nvar isObject = __webpack_require__(22);\nvar anObject = __webpack_require__(21);\nvar check = function (O, proto) {\n  anObject(O);\n  if (!isObject(proto) && proto !== null) throw TypeError(proto + \": can't set as prototype!\");\n};\nmodule.exports = {\n  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line\n    function (test, buggy, set) {\n      try {\n        set = __webpack_require__(95)(Function.call, __webpack_require__(66).f(Object.prototype, '__proto__').set, 2);\n        set(test, []);\n        buggy = !(test instanceof Array);\n      } catch (e) { buggy = true; }\n      return function setPrototypeOf(O, proto) {\n        check(O, proto);\n        if (buggy) O.__proto__ = proto;\n        else set(O, proto);\n        return O;\n      };\n    }({}, false) : undefined),\n  check: check\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTg3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL19zZXQtcHJvdG8uanM/NjVhNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBXb3JrcyB3aXRoIF9fcHJvdG9fXyBvbmx5LiBPbGQgdjggY2FuJ3Qgd29yayB3aXRoIG51bGwgcHJvdG8gb2JqZWN0cy5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGNoZWNrID0gZnVuY3Rpb24gKE8sIHByb3RvKSB7XG4gIGFuT2JqZWN0KE8pO1xuICBpZiAoIWlzT2JqZWN0KHByb3RvKSAmJiBwcm90byAhPT0gbnVsbCkgdGhyb3cgVHlwZUVycm9yKHByb3RvICsgXCI6IGNhbid0IHNldCBhcyBwcm90b3R5cGUhXCIpO1xufTtcbm1vZHVsZS5leHBvcnRzID0ge1xuICBzZXQ6IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCAoJ19fcHJvdG9fXycgaW4ge30gPyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgZnVuY3Rpb24gKHRlc3QsIGJ1Z2d5LCBzZXQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNldCA9IHJlcXVpcmUoJy4vX2N0eCcpKEZ1bmN0aW9uLmNhbGwsIHJlcXVpcmUoJy4vX29iamVjdC1nb3BkJykuZihPYmplY3QucHJvdG90eXBlLCAnX19wcm90b19fJykuc2V0LCAyKTtcbiAgICAgICAgc2V0KHRlc3QsIFtdKTtcbiAgICAgICAgYnVnZ3kgPSAhKHRlc3QgaW5zdGFuY2VvZiBBcnJheSk7XG4gICAgICB9IGNhdGNoIChlKSB7IGJ1Z2d5ID0gdHJ1ZTsgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNldFByb3RvdHlwZU9mKE8sIHByb3RvKSB7XG4gICAgICAgIGNoZWNrKE8sIHByb3RvKTtcbiAgICAgICAgaWYgKGJ1Z2d5KSBPLl9fcHJvdG9fXyA9IHByb3RvO1xuICAgICAgICBlbHNlIHNldChPLCBwcm90byk7XG4gICAgICAgIHJldHVybiBPO1xuICAgICAgfTtcbiAgICB9KHt9LCBmYWxzZSkgOiB1bmRlZmluZWQpLFxuICBjaGVjazogY2hlY2tcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jb3JlLWpzL2xpYnJhcnkvbW9kdWxlcy9fc2V0LXByb3RvLmpzXG4vLyBtb2R1bGUgaWQgPSAxODdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///187\n")},function(module,exports,__webpack_require__){eval('module.exports = { "default": __webpack_require__(189), __esModule: true };//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTg4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2JhYmVsLXJ1bnRpbWUvY29yZS1qcy9vYmplY3QvY3JlYXRlLmpzPzNhZjQiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSB7IFwiZGVmYXVsdFwiOiByZXF1aXJlKFwiY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9jcmVhdGVcIiksIF9fZXNNb2R1bGU6IHRydWUgfTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9iYWJlbC1ydW50aW1lL2NvcmUtanMvb2JqZWN0L2NyZWF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMTg4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///188\n')},function(module,exports,__webpack_require__){eval("__webpack_require__(190);\nvar $Object = __webpack_require__(4).Object;\nmodule.exports = function create(P, D) {\n  return $Object.create(P, D);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTg5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9mbi9vYmplY3QvY3JlYXRlLmpzP2EwY2UiXSwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZSgnLi4vLi4vbW9kdWxlcy9lczYub2JqZWN0LmNyZWF0ZScpO1xudmFyICRPYmplY3QgPSByZXF1aXJlKCcuLi8uLi9tb2R1bGVzL19jb3JlJykuT2JqZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGUoUCwgRCkge1xuICByZXR1cm4gJE9iamVjdC5jcmVhdGUoUCwgRCk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L2ZuL29iamVjdC9jcmVhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDE4OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///189\n")},function(module,exports,__webpack_require__){eval("var $export = __webpack_require__(11);\n// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\n$export($export.S, 'Object', { create: __webpack_require__(60) });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTkwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbGlicmFyeS9tb2R1bGVzL2VzNi5vYmplY3QuY3JlYXRlLmpzP2IwNWYiXSwic291cmNlc0NvbnRlbnQiOlsidmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbi8vIDE5LjEuMi4yIC8gMTUuMi4zLjUgT2JqZWN0LmNyZWF0ZShPIFssIFByb3BlcnRpZXNdKVxuJGV4cG9ydCgkZXhwb3J0LlMsICdPYmplY3QnLCB7IGNyZWF0ZTogcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpIH0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY29yZS1qcy9saWJyYXJ5L21vZHVsZXMvZXM2Lm9iamVjdC5jcmVhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDE5MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///190\n")},function(module,exports,__webpack_require__){eval('var pug = __webpack_require__(39);\n\nfunction template(locals) {var pug_html = "", pug_mixins = {}, pug_interp;pug_html = pug_html + "\\u003Cdiv class=\\"container\\"\\u003E\\u003Cdiv class=\\"form-group has-feedback\\" ng-class=\\"{ \'has-success\' : $ctrl.isEndpointValid === true, \'has-error\' : $ctrl.isEndpointValid === false}\\"\\u003E\\u003Clabel\\u003EEndpoint\\u003C\\u002Flabel\\u003E\\u003Cinput class=\\"form-control\\" ng-change=\\"$ctrl.endpointChanged()\\" ng-model=\\"$ctrl.endpoint\\" type=\\"text\\"\\u003E\\u003Cspan class=\\"glyphicon glyphicon-ok form-control-feedback\\" ng-show=\\"$ctrl.isEndpointValid\\"\\u003E\\u003C\\u002Fspan\\u003E\\u003Cspan class=\\"glyphicon glyphicon-remove form-control-feedback\\" ng-show=\\"!$ctrl.isEndpointValid\\"\\u003E\\u003C\\u002Fspan\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\"form-group\\"\\u003E\\u003Clabel\\u003EDefault query level\\u003C\\u002Flabel\\u003E\\u003Cselect class=\\"form-control\\" ng-model=\\"$ctrl.defaultLevel\\" ng-options=\\"level for level in $ctrl.availableLevels\\"\\u003E\\u003C\\u002Fselect\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\"form-group\\"\\u003E\\u003Clabel\\u003EQuery\\u003C\\u002Flabel\\u003E\\u003Ctextarea class=\\"form-control\\" ng-model=\\"$ctrl.query\\"\\u003E\\u003C\\u002Ftextarea\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\"form-group\\"\\u003E\\u003Clabel\\u003EComparison query\\u003C\\u002Flabel\\u003E\\u003Ctextarea class=\\"form-control\\" ng-model=\\"$ctrl.comparisonQuery\\"\\u003E\\u003C\\u002Ftextarea\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\"form-group\\"\\u003E\\u003Clabel\\u003EAttribute\\u003C\\u002Flabel\\u003E\\u003Cselect class=\\"form-control\\" ng-model=\\"$ctrl.attr\\" ng-options=\\"attr.id as attr.id + \': \' + attr.description for attr in $ctrl.attrs\\"\\u003E\\u003C\\u002Fselect\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\"form-group\\"\\u003E\\u003Clabel\\u003EAttribute length\\u003C\\u002Flabel\\u003E\\u003Cinput class=\\"form-control\\" ng-model=\\"$ctrl.attrLength\\" type=\\"number\\"\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\"form-group\\"\\u003E\\u003Clabel\\u003EFrequency to show\\u003C\\u002Flabel\\u003E\\u003Cdiv class=\\"row\\"\\u003E\\u003Cdiv class=\\"col-xs-12\\"\\u003E\\u003Clabel class=\\"radio-inline\\"\\u003E\\u003Cinput name=\\"freq\\" ng-model=\\"$ctrl.plotTermFreq\\" ng-value=\\"false\\" type=\\"radio\\"\\u003Edocument\\u003C\\u002Flabel\\u003E\\u003Clabel class=\\"radio-inline\\"\\u003E\\u003Cinput name=\\"freq\\" ng-model=\\"$ctrl.plotTermFreq\\" ng-value=\\"true\\" type=\\"radio\\"\\u003Eterm\\u003C\\u002Flabel\\u003E\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\"form-group\\"\\u003E\\u003Clabel\\u003EFrequency to show\\u003C\\u002Flabel\\u003E\\u003Cdiv class=\\"row\\"\\u003E\\u003Cdiv class=\\"col-xs-12\\"\\u003E\\u003Clabel class=\\"radio-inline\\"\\u003E\\u003Cinput name=\\"freq2\\" ng-model=\\"$ctrl.plotAbsolute\\" ng-value=\\"false\\" type=\\"radio\\"\\u003Erelative\\u003C\\u002Flabel\\u003E\\u003Clabel class=\\"radio-inline\\"\\u003E\\u003Cinput name=\\"freq2\\" ng-model=\\"$ctrl.plotAbsolute\\" ng-value=\\"true\\" type=\\"radio\\"\\u003Eabsolute\\u003C\\u002Flabel\\u003E\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\"form-group\\"\\u003E\\u003Clabel\\u003EFurther options\\u003C\\u002Flabel\\u003E\\u003Cinput class=\\"form-control\\" ng-model=\\"$ctrl.furtherOptions\\" type=\\"text\\"\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cbutton class=\\"btn btn-success\\" ng-click=\\"$ctrl.runQuery()\\" ng-disabled=\\"$ctrl.queryRunning\\"\\u003EQuery\\u003C\\u002Fbutton\\u003E\\u003Cspan class=\\"glyphicon glyphicon-refresh\\" ng-show=\\"$ctrl.queryRunning\\"\\u003E\\u003C\\u002Fspan\\u003E\\u003Cdiv ng-show=\\"$ctrl.error\\"\\u003E\\u003Ch2\\u003EQuery resulted in error:\\u003C\\u002Fh2\\u003E{{$ctrl.error}}\\u003C\\u002Fdiv\\u003E\\u003Cdiv ng-show=\\"!$ctrl.queryRunning\\"\\u003E\\u003Ch2\\u003EResults\\u003C\\u002Fh2\\u003E\\u003Ch4\\u003ESample attributes\\u003C\\u002Fh4\\u003E\\u003Cspan ng-repeat=\\"attr in $ctrl.sampleAttrs\\"\\u003E{{attr}}{{$last ? \'\' : \', \'}}\\u003C\\u002Fspan\\u003E\\u003Ch4\\u003EGraph\\u003C\\u002Fh4\\u003E\\u003Cplotly data=\\"$ctrl.data\\" layout=\\"$ctrl.layout\\"\\u003E\\u003C\\u002Fplotly\\u003E\\u003Ch2 ng-click=\\"$ctrl.showRaw=!$ctrl.showRaw\\"\\u003ERaw results\\u003Cspan class=\\"glyphicon glyphicon-chevron-down\\" ng-show=\\"!$ctrl.showRaw\\"\\u003E\\u003C\\u002Fspan\\u003E\\u003Cspan class=\\"glyphicon glyphicon-chevron-up\\" ng-show=\\"$ctrl.showRaw\\"\\u003E\\u003C\\u002Fspan\\u003E\\u003C\\u002Fh2\\u003E\\u003Cdiv ng-show=\\"$ctrl.showRaw\\"\\u003E\\u003Ctextarea class=\\"form-control\\" disabled\\u003E{{$ctrl.queryURL}}      \\u003C\\u002Ftextarea\\u003E\\u003Cpre pretty-json=\\"$ctrl.response\\"\\u003E\\u003C\\u002Fpre\\u003E\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fdiv\\u003E";;return pug_html;};\nmodule.exports = template;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTkxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vYXBwL2NvbXBvbmVudHMvdHJlbmQtdmlldy90cmVuZC12aWV3LnB1Zz83YmI0Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBwdWcgPSByZXF1aXJlKFwiIS4uLy4uLy4uL25vZGVfbW9kdWxlcy9wdWctcnVudGltZS9pbmRleC5qc1wiKTtcblxuZnVuY3Rpb24gdGVtcGxhdGUobG9jYWxzKSB7dmFyIHB1Z19odG1sID0gXCJcIiwgcHVnX21peGlucyA9IHt9LCBwdWdfaW50ZXJwO3B1Z19odG1sID0gcHVnX2h0bWwgKyBcIlxcdTAwM0NkaXYgY2xhc3M9XFxcImNvbnRhaW5lclxcXCJcXHUwMDNFXFx1MDAzQ2RpdiBjbGFzcz1cXFwiZm9ybS1ncm91cCBoYXMtZmVlZGJhY2tcXFwiIG5nLWNsYXNzPVxcXCJ7ICdoYXMtc3VjY2VzcycgOiAkY3RybC5pc0VuZHBvaW50VmFsaWQgPT09IHRydWUsICdoYXMtZXJyb3InIDogJGN0cmwuaXNFbmRwb2ludFZhbGlkID09PSBmYWxzZX1cXFwiXFx1MDAzRVxcdTAwM0NsYWJlbFxcdTAwM0VFbmRwb2ludFxcdTAwM0NcXHUwMDJGbGFiZWxcXHUwMDNFXFx1MDAzQ2lucHV0IGNsYXNzPVxcXCJmb3JtLWNvbnRyb2xcXFwiIG5nLWNoYW5nZT1cXFwiJGN0cmwuZW5kcG9pbnRDaGFuZ2VkKClcXFwiIG5nLW1vZGVsPVxcXCIkY3RybC5lbmRwb2ludFxcXCIgdHlwZT1cXFwidGV4dFxcXCJcXHUwMDNFXFx1MDAzQ3NwYW4gY2xhc3M9XFxcImdseXBoaWNvbiBnbHlwaGljb24tb2sgZm9ybS1jb250cm9sLWZlZWRiYWNrXFxcIiBuZy1zaG93PVxcXCIkY3RybC5pc0VuZHBvaW50VmFsaWRcXFwiXFx1MDAzRVxcdTAwM0NcXHUwMDJGc3BhblxcdTAwM0VcXHUwMDNDc3BhbiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1yZW1vdmUgZm9ybS1jb250cm9sLWZlZWRiYWNrXFxcIiBuZy1zaG93PVxcXCIhJGN0cmwuaXNFbmRwb2ludFZhbGlkXFxcIlxcdTAwM0VcXHUwMDNDXFx1MDAyRnNwYW5cXHUwMDNFXFx1MDAzQ1xcdTAwMkZkaXZcXHUwMDNFXFx1MDAzQ2RpdiBjbGFzcz1cXFwiZm9ybS1ncm91cFxcXCJcXHUwMDNFXFx1MDAzQ2xhYmVsXFx1MDAzRURlZmF1bHQgcXVlcnkgbGV2ZWxcXHUwMDNDXFx1MDAyRmxhYmVsXFx1MDAzRVxcdTAwM0NzZWxlY3QgY2xhc3M9XFxcImZvcm0tY29udHJvbFxcXCIgbmctbW9kZWw9XFxcIiRjdHJsLmRlZmF1bHRMZXZlbFxcXCIgbmctb3B0aW9ucz1cXFwibGV2ZWwgZm9yIGxldmVsIGluICRjdHJsLmF2YWlsYWJsZUxldmVsc1xcXCJcXHUwMDNFXFx1MDAzQ1xcdTAwMkZzZWxlY3RcXHUwMDNFXFx1MDAzQ1xcdTAwMkZkaXZcXHUwMDNFXFx1MDAzQ2RpdiBjbGFzcz1cXFwiZm9ybS1ncm91cFxcXCJcXHUwMDNFXFx1MDAzQ2xhYmVsXFx1MDAzRVF1ZXJ5XFx1MDAzQ1xcdTAwMkZsYWJlbFxcdTAwM0VcXHUwMDNDdGV4dGFyZWEgY2xhc3M9XFxcImZvcm0tY29udHJvbFxcXCIgbmctbW9kZWw9XFxcIiRjdHJsLnF1ZXJ5XFxcIlxcdTAwM0VcXHUwMDNDXFx1MDAyRnRleHRhcmVhXFx1MDAzRVxcdTAwM0NcXHUwMDJGZGl2XFx1MDAzRVxcdTAwM0NkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiXFx1MDAzRVxcdTAwM0NsYWJlbFxcdTAwM0VDb21wYXJpc29uIHF1ZXJ5XFx1MDAzQ1xcdTAwMkZsYWJlbFxcdTAwM0VcXHUwMDNDdGV4dGFyZWEgY2xhc3M9XFxcImZvcm0tY29udHJvbFxcXCIgbmctbW9kZWw9XFxcIiRjdHJsLmNvbXBhcmlzb25RdWVyeVxcXCJcXHUwMDNFXFx1MDAzQ1xcdTAwMkZ0ZXh0YXJlYVxcdTAwM0VcXHUwMDNDXFx1MDAyRmRpdlxcdTAwM0VcXHUwMDNDZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIlxcdTAwM0VcXHUwMDNDbGFiZWxcXHUwMDNFQXR0cmlidXRlXFx1MDAzQ1xcdTAwMkZsYWJlbFxcdTAwM0VcXHUwMDNDc2VsZWN0IGNsYXNzPVxcXCJmb3JtLWNvbnRyb2xcXFwiIG5nLW1vZGVsPVxcXCIkY3RybC5hdHRyXFxcIiBuZy1vcHRpb25zPVxcXCJhdHRyLmlkIGFzIGF0dHIuaWQgKyAnOiAnICsgYXR0ci5kZXNjcmlwdGlvbiBmb3IgYXR0ciBpbiAkY3RybC5hdHRyc1xcXCJcXHUwMDNFXFx1MDAzQ1xcdTAwMkZzZWxlY3RcXHUwMDNFXFx1MDAzQ1xcdTAwMkZkaXZcXHUwMDNFXFx1MDAzQ2RpdiBjbGFzcz1cXFwiZm9ybS1ncm91cFxcXCJcXHUwMDNFXFx1MDAzQ2xhYmVsXFx1MDAzRUF0dHJpYnV0ZSBsZW5ndGhcXHUwMDNDXFx1MDAyRmxhYmVsXFx1MDAzRVxcdTAwM0NpbnB1dCBjbGFzcz1cXFwiZm9ybS1jb250cm9sXFxcIiBuZy1tb2RlbD1cXFwiJGN0cmwuYXR0ckxlbmd0aFxcXCIgdHlwZT1cXFwibnVtYmVyXFxcIlxcdTAwM0VcXHUwMDNDXFx1MDAyRmRpdlxcdTAwM0VcXHUwMDNDZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIlxcdTAwM0VcXHUwMDNDbGFiZWxcXHUwMDNFRnJlcXVlbmN5IHRvIHNob3dcXHUwMDNDXFx1MDAyRmxhYmVsXFx1MDAzRVxcdTAwM0NkaXYgY2xhc3M9XFxcInJvd1xcXCJcXHUwMDNFXFx1MDAzQ2RpdiBjbGFzcz1cXFwiY29sLXhzLTEyXFxcIlxcdTAwM0VcXHUwMDNDbGFiZWwgY2xhc3M9XFxcInJhZGlvLWlubGluZVxcXCJcXHUwMDNFXFx1MDAzQ2lucHV0IG5hbWU9XFxcImZyZXFcXFwiIG5nLW1vZGVsPVxcXCIkY3RybC5wbG90VGVybUZyZXFcXFwiIG5nLXZhbHVlPVxcXCJmYWxzZVxcXCIgdHlwZT1cXFwicmFkaW9cXFwiXFx1MDAzRWRvY3VtZW50XFx1MDAzQ1xcdTAwMkZsYWJlbFxcdTAwM0VcXHUwMDNDbGFiZWwgY2xhc3M9XFxcInJhZGlvLWlubGluZVxcXCJcXHUwMDNFXFx1MDAzQ2lucHV0IG5hbWU9XFxcImZyZXFcXFwiIG5nLW1vZGVsPVxcXCIkY3RybC5wbG90VGVybUZyZXFcXFwiIG5nLXZhbHVlPVxcXCJ0cnVlXFxcIiB0eXBlPVxcXCJyYWRpb1xcXCJcXHUwMDNFdGVybVxcdTAwM0NcXHUwMDJGbGFiZWxcXHUwMDNFXFx1MDAzQ1xcdTAwMkZkaXZcXHUwMDNFXFx1MDAzQ1xcdTAwMkZkaXZcXHUwMDNFXFx1MDAzQ1xcdTAwMkZkaXZcXHUwMDNFXFx1MDAzQ2RpdiBjbGFzcz1cXFwiZm9ybS1ncm91cFxcXCJcXHUwMDNFXFx1MDAzQ2xhYmVsXFx1MDAzRUZyZXF1ZW5jeSB0byBzaG93XFx1MDAzQ1xcdTAwMkZsYWJlbFxcdTAwM0VcXHUwMDNDZGl2IGNsYXNzPVxcXCJyb3dcXFwiXFx1MDAzRVxcdTAwM0NkaXYgY2xhc3M9XFxcImNvbC14cy0xMlxcXCJcXHUwMDNFXFx1MDAzQ2xhYmVsIGNsYXNzPVxcXCJyYWRpby1pbmxpbmVcXFwiXFx1MDAzRVxcdTAwM0NpbnB1dCBuYW1lPVxcXCJmcmVxMlxcXCIgbmctbW9kZWw9XFxcIiRjdHJsLnBsb3RBYnNvbHV0ZVxcXCIgbmctdmFsdWU9XFxcImZhbHNlXFxcIiB0eXBlPVxcXCJyYWRpb1xcXCJcXHUwMDNFcmVsYXRpdmVcXHUwMDNDXFx1MDAyRmxhYmVsXFx1MDAzRVxcdTAwM0NsYWJlbCBjbGFzcz1cXFwicmFkaW8taW5saW5lXFxcIlxcdTAwM0VcXHUwMDNDaW5wdXQgbmFtZT1cXFwiZnJlcTJcXFwiIG5nLW1vZGVsPVxcXCIkY3RybC5wbG90QWJzb2x1dGVcXFwiIG5nLXZhbHVlPVxcXCJ0cnVlXFxcIiB0eXBlPVxcXCJyYWRpb1xcXCJcXHUwMDNFYWJzb2x1dGVcXHUwMDNDXFx1MDAyRmxhYmVsXFx1MDAzRVxcdTAwM0NcXHUwMDJGZGl2XFx1MDAzRVxcdTAwM0NcXHUwMDJGZGl2XFx1MDAzRVxcdTAwM0NcXHUwMDJGZGl2XFx1MDAzRVxcdTAwM0NkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiXFx1MDAzRVxcdTAwM0NsYWJlbFxcdTAwM0VGdXJ0aGVyIG9wdGlvbnNcXHUwMDNDXFx1MDAyRmxhYmVsXFx1MDAzRVxcdTAwM0NpbnB1dCBjbGFzcz1cXFwiZm9ybS1jb250cm9sXFxcIiBuZy1tb2RlbD1cXFwiJGN0cmwuZnVydGhlck9wdGlvbnNcXFwiIHR5cGU9XFxcInRleHRcXFwiXFx1MDAzRVxcdTAwM0NcXHUwMDJGZGl2XFx1MDAzRVxcdTAwM0NidXR0b24gY2xhc3M9XFxcImJ0biBidG4tc3VjY2Vzc1xcXCIgbmctY2xpY2s9XFxcIiRjdHJsLnJ1blF1ZXJ5KClcXFwiIG5nLWRpc2FibGVkPVxcXCIkY3RybC5xdWVyeVJ1bm5pbmdcXFwiXFx1MDAzRVF1ZXJ5XFx1MDAzQ1xcdTAwMkZidXR0b25cXHUwMDNFXFx1MDAzQ3NwYW4gY2xhc3M9XFxcImdseXBoaWNvbiBnbHlwaGljb24tcmVmcmVzaFxcXCIgbmctc2hvdz1cXFwiJGN0cmwucXVlcnlSdW5uaW5nXFxcIlxcdTAwM0VcXHUwMDNDXFx1MDAyRnNwYW5cXHUwMDNFXFx1MDAzQ2RpdiBuZy1zaG93PVxcXCIkY3RybC5lcnJvclxcXCJcXHUwMDNFXFx1MDAzQ2gyXFx1MDAzRVF1ZXJ5IHJlc3VsdGVkIGluIGVycm9yOlxcdTAwM0NcXHUwMDJGaDJcXHUwMDNFe3skY3RybC5lcnJvcn19XFx1MDAzQ1xcdTAwMkZkaXZcXHUwMDNFXFx1MDAzQ2RpdiBuZy1zaG93PVxcXCIhJGN0cmwucXVlcnlSdW5uaW5nXFxcIlxcdTAwM0VcXHUwMDNDaDJcXHUwMDNFUmVzdWx0c1xcdTAwM0NcXHUwMDJGaDJcXHUwMDNFXFx1MDAzQ2g0XFx1MDAzRVNhbXBsZSBhdHRyaWJ1dGVzXFx1MDAzQ1xcdTAwMkZoNFxcdTAwM0VcXHUwMDNDc3BhbiBuZy1yZXBlYXQ9XFxcImF0dHIgaW4gJGN0cmwuc2FtcGxlQXR0cnNcXFwiXFx1MDAzRXt7YXR0cn19e3skbGFzdCA/ICcnIDogJywgJ319XFx1MDAzQ1xcdTAwMkZzcGFuXFx1MDAzRVxcdTAwM0NoNFxcdTAwM0VHcmFwaFxcdTAwM0NcXHUwMDJGaDRcXHUwMDNFXFx1MDAzQ3Bsb3RseSBkYXRhPVxcXCIkY3RybC5kYXRhXFxcIiBsYXlvdXQ9XFxcIiRjdHJsLmxheW91dFxcXCJcXHUwMDNFXFx1MDAzQ1xcdTAwMkZwbG90bHlcXHUwMDNFXFx1MDAzQ2gyIG5nLWNsaWNrPVxcXCIkY3RybC5zaG93UmF3PSEkY3RybC5zaG93UmF3XFxcIlxcdTAwM0VSYXcgcmVzdWx0c1xcdTAwM0NzcGFuIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLWNoZXZyb24tZG93blxcXCIgbmctc2hvdz1cXFwiISRjdHJsLnNob3dSYXdcXFwiXFx1MDAzRVxcdTAwM0NcXHUwMDJGc3BhblxcdTAwM0VcXHUwMDNDc3BhbiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1jaGV2cm9uLXVwXFxcIiBuZy1zaG93PVxcXCIkY3RybC5zaG93UmF3XFxcIlxcdTAwM0VcXHUwMDNDXFx1MDAyRnNwYW5cXHUwMDNFXFx1MDAzQ1xcdTAwMkZoMlxcdTAwM0VcXHUwMDNDZGl2IG5nLXNob3c9XFxcIiRjdHJsLnNob3dSYXdcXFwiXFx1MDAzRVxcdTAwM0N0ZXh0YXJlYSBjbGFzcz1cXFwiZm9ybS1jb250cm9sXFxcIiBkaXNhYmxlZFxcdTAwM0V7eyRjdHJsLnF1ZXJ5VVJMfX0gICAgICBcXHUwMDNDXFx1MDAyRnRleHRhcmVhXFx1MDAzRVxcdTAwM0NwcmUgcHJldHR5LWpzb249XFxcIiRjdHJsLnJlc3BvbnNlXFxcIlxcdTAwM0VcXHUwMDNDXFx1MDAyRnByZVxcdTAwM0VcXHUwMDNDXFx1MDAyRmRpdlxcdTAwM0VcXHUwMDNDXFx1MDAyRmRpdlxcdTAwM0VcXHUwMDNDXFx1MDAyRmRpdlxcdTAwM0VcIjs7cmV0dXJuIHB1Z19odG1sO307XG5tb2R1bGUuZXhwb3J0cyA9IHRlbXBsYXRlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYXBwL2NvbXBvbmVudHMvdHJlbmQtdmlldy90cmVuZC12aWV3LnB1Z1xuLy8gbW9kdWxlIGlkID0gMTkxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///191\n')},function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n    value: true\n});\nexports.WordCloudViewComponent = exports.WordCloudViewComponentController = undefined;\n\nvar _stringify = __webpack_require__(62);\n\nvar _stringify2 = _interopRequireDefault(_stringify);\n\nvar _getIterator2 = __webpack_require__(58);\n\nvar _getIterator3 = _interopRequireDefault(_getIterator2);\n\nvar _getPrototypeOf = __webpack_require__(41);\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _createClass2 = __webpack_require__(27);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = __webpack_require__(63);\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _get2 = __webpack_require__(67);\n\nvar _get3 = _interopRequireDefault(_get2);\n\nvar _inherits2 = __webpack_require__(68);\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _classCallCheck2 = __webpack_require__(19);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _angular = __webpack_require__(7);\n\nvar angular = _interopRequireWildcard(_angular);\n\nvar _d = __webpack_require__(193);\n\nvar d3 = _interopRequireWildcard(_d);\n\n__webpack_require__(194);\n\n__webpack_require__(197);\n\n__webpack_require__(69);\n\nvar _octavoComponentController = __webpack_require__(34);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar Word = function Word(text, size, color) {\n    (0, _classCallCheck3.default)(this, Word);\n\n    this.text = text;\n    this.size = size;\n    this.color = color;\n};\n\nvar WordCloudViewComponentController = exports.WordCloudViewComponentController = function (_OctavoComponentContr) {\n    WordCloudViewComponentController.$inject = ["$element", "$window", "$sce", "$q", "$http", "$httpParamSerializer", "$stateParams", "$state"];\n    (0, _inherits3.default)(WordCloudViewComponentController, _OctavoComponentContr);\n\n    /* @ngInject */\n    function WordCloudViewComponentController($element, $window, $sce, $q, $http, $httpParamSerializer, $stateParams, $state) {\n        (0, _classCallCheck3.default)(this, WordCloudViewComponentController);\n\n        var _this = (0, _possibleConstructorReturn3.default)(this, (WordCloudViewComponentController.__proto__ || (0, _getPrototypeOf2.default)(WordCloudViewComponentController)).call(this, $http, $stateParams, $state));\n\n        _this.$window = $window;\n        _this.$sce = $sce;\n        _this.$q = $q;\n        _this.$httpParamSerializer = $httpParamSerializer;\n        _this.wordClicked = function (word) {\n            if (d3.event.altKey) {\n                _this.query = word.text;\n                _this.doRunQuery();\n            } else {\n                var url = _this.$state.href("search", {\n                    endpoint: _this.endpoint,\n                    query: "+(" + _this.query + ") +" + word.text,\n                    defaultLevel: _this.defaultLevel\n                });\n                _this.$window.open(url, "_blank");\n            }\n        };\n        var element = $element.find("word-cloud")[0];\n        _this.cloudHeight = $window.innerHeight * 0.75;\n        _this.cloudWidth = element.children[0].offsetWidth;\n        if (!_this.furtherOptions) _this.furtherOptions = "";\n        if (!_this.limit) _this.limit = 100;\n        if (!_this.smoothing) _this.smoothing = 2;\n        if (!_this.maxDocs) _this.maxDocs = 50000;\n        if (!_this.minTotalTermFreq) _this.minTotalTermFreq = 0;\n        if (!_this.maxTotalTermFreq) _this.maxTotalTermFreq = -1;\n        if (!_this.minDocFreq) _this.minDocFreq = 0;\n        if (!_this.maxDocFreq) _this.maxDocFreq = -1;\n        if (!_this.minFreqInDoc) _this.minFreqInDoc = 0;\n        if (!_this.maxFreqInDoc) _this.maxFreqInDoc = -1;\n        if (!_this.minTermLength) _this.minTermLength = 0;\n        if (!_this.maxTermLength) _this.maxTermLength = -1;\n        if (!_this.minSumFreq) _this.minSumFreq = 0;\n        if (!_this.maxSumFreq) _this.maxSumFreq = -1;\n        if (!_this.termFilter) _this.termFilter = "";\n        if (!_this.localScaling) _this.localScaling = "ABSOLUTE";\n        if (!_this.sumScaling) _this.sumScaling = "TTF";\n        return _this;\n    }\n\n    (0, _createClass3.default)(WordCloudViewComponentController, [{\n        key: "mdsWordClicked",\n        value: function mdsWordClicked(data) {\n            if (data.event.altKey) {\n                this.query = data.points[0].data.text[data.points[0].pointNumber];\n                this.doRunQuery();\n            } else {\n                var url = this.$state.href("search", {\n                    endpoint: this.endpoint,\n                    query: "+(" + this.query + ") +" + data.points[0].data.text[data.points[0].pointNumber],\n                    defaultLevel: this.defaultLevel\n                });\n                this.$window.open(url, "_blank");\n            }\n        }\n    }, {\n        key: "endpointUpdated",\n        value: function endpointUpdated(indexInfo) {\n            var _this2 = this;\n\n            this.availableLevels = indexInfo.levels.map(function (level) {\n                return level.id;\n            });\n            if (!this.defaultLevel) this.defaultLevel = this.availableLevels[this.availableLevels.length - 1];\n            this.mquantiles = undefined;\n            this.quantiles = undefined;\n            this.mdquantiles = undefined;\n            this.dquantiles = undefined;\n            this.$http.get(this.endpoint + "indexStats?by=0.001").then(function (response) {\n                var tfs = response.data.termFreqQuantiles;\n                var dfs = response.data.docFreqQuantiles;\n                _this2.mquantiles = [tfs[100].freq, tfs[500].freq, tfs[800].freq, tfs[900].freq];\n                _this2.quantiles = [tfs[950].freq, tfs[990].freq, tfs[995].freq, tfs[999].freq, tfs[1000].freq];\n                _this2.mdquantiles = [dfs[100].freq, dfs[500].freq, dfs[800].freq, dfs[900].freq];\n                _this2.dquantiles = [dfs[950].freq, dfs[990].freq, dfs[995].freq, dfs[999].freq, dfs[1000].freq];\n                var tfData = {\n                    x: [],\n                    y: [],\n                    mode: "markers"\n                };\n                var _iteratorNormalCompletion = true;\n                var _didIteratorError = false;\n                var _iteratorError = undefined;\n\n                try {\n                    for (var _iterator = (0, _getIterator3.default)(tfs), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                        var q = _step.value;\n\n                        tfData.x.push((1.0 - parseFloat(q.quantile)) * 100)(tfData.y).push(q.freq);\n                    }\n                } catch (err) {\n                    _didIteratorError = true;\n                    _iteratorError = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion && _iterator.return) {\n                            _iterator.return();\n                        }\n                    } finally {\n                        if (_didIteratorError) {\n                            throw _iteratorError;\n                        }\n                    }\n                }\n\n                _this2.tfData = [tfData];\n                _this2.tfLayout = {\n                    title: "Term frequency quantiles (log)",\n                    yaxis: {\n                        type: "log",\n                        autorange: true\n                    }\n                };\n                var dfData = {\n                    x: [],\n                    y: [],\n                    mode: "markers"\n                };\n                var _iteratorNormalCompletion2 = true;\n                var _didIteratorError2 = false;\n                var _iteratorError2 = undefined;\n\n                try {\n                    for (var _iterator2 = (0, _getIterator3.default)(dfs.reverse()), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                        var _q = _step2.value;\n\n                        dfData.x.push((1.0 - parseFloat(_q.quantile)) * 100)(dfData.y).push(_q.freq);\n                    }\n                } catch (err) {\n                    _didIteratorError2 = true;\n                    _iteratorError2 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                            _iterator2.return();\n                        }\n                    } finally {\n                        if (_didIteratorError2) {\n                            throw _iteratorError2;\n                        }\n                    }\n                }\n\n                _this2.dfData = [dfData];\n                _this2.dfLayout = {\n                    title: "Document frequency quantiles (log)",\n                    yaxis: {\n                        type: "log",\n                        autorange: true\n                    }\n                };\n            });\n            if (this.query) this.doRunQuery();\n        }\n    }, {\n        key: "doRunQuery",\n        value: function doRunQuery() {\n            var _this3 = this;\n\n            (0, _get3.default)(WordCloudViewComponentController.prototype.__proto__ || (0, _getPrototypeOf2.default)(WordCloudViewComponentController.prototype), "doRunQuery", this).call(this);\n            var params = this.$httpParamSerializer({\n                query: this.defaultLevel && this.query.indexOf("<") !== 0 ? "<" + this.defaultLevel + "§" + this.query + "§" + this.defaultLevel + ">" : this.query,\n                limit: this.limit,\n                smoothing: this.smoothing,\n                maxDocs: this.maxDocs,\n                minTotalTermFreq: this.minTotalTermFreq,\n                maxTotalTermFreq: this.maxTotalTermFreq !== -1 ? this.maxTotalTermFreq : null,\n                minDocFreq: this.minDocFreq,\n                maxDocFreq: this.maxDocFreq !== -1 ? this.maxDocFreq : null,\n                minSumFreq: this.minSumFreq,\n                maxSumFreq: this.maxSumFreq !== -1 ? this.maxSumFreq : null,\n                termFilter: this.termFilter ? this.termFilter : null,\n                localScaling: this.localScaling,\n                sumScaling: this.sumScaling,\n                minTermLength: this.minTermLength,\n                maxTermLength: this.maxTermLength !== -1 ? this.maxTermLength : null,\n                r_smoothing: this.mds ? this.smoothing : null,\n                r_maxDocs: this.mds ? this.maxDocs : null,\n                r_minTotalTermFreq: this.mds ? this.minTotalTermFreq : null,\n                r_maxTotalTermFreq: this.mds && this.maxTotalTermFreq !== -1 ? this.maxTotalTermFreq : null,\n                r_minDocFreq: this.mds ? this.minDocFreq : null,\n                r_maxDocFreq: this.mds && this.maxDocFreq !== -1 ? this.maxDocFreq : null,\n                r_minSumFreq: this.mds ? this.minSumFreq : null,\n                r_maxSumFreq: this.mds && this.maxSumFreq !== -1 ? this.maxSumFreq : null,\n                r_termFilter: this.mds && this.termFilter ? this.termFilter : null,\n                r_localScaling: this.mds ? this.localScaling : null,\n                r_sumScaling: this.mds ? this.sumScaling : null,\n                r_minTermLength: this.mds ? this.minTermLength : null,\n                r_maxTermLength: this.mds && this.maxTermLength !== -1 ? this.maxTermLength : null,\n                dimensions: this.mds ? 2 : null\n            }) + "&" + this.furtherOptions;\n            this.queryURL = this.endpoint + "termVectors" + "?" + params;\n            this.$http.post(this.endpoint + "termVectors", params, {\n                headers: { "Content-Type": "application/x-www-form-urlencoded" }\n            }).then(function (response) {\n                _this3.response = JSON.parse((0, _stringify2.default)(response.data));\n                _this3.queryRunning = false;\n                _this3.totalResults = response.data.results.metadata.acceptedTerms;\n                var originWords = response.data.results.terms;\n                var maxCount = originWords[0].weight;\n                var minCount = originWords[originWords.length - 1].weight;\n                var maxWordSize = _this3.cloudWidth * 0.05;\n                var minWordSize = maxWordSize / 5;\n                var spread = maxCount - minCount;\n                if (spread <= 0) spread = 1;\n                var step = (maxWordSize - minWordSize) / spread;\n                if (!_this3.mds) _this3.words = originWords.map(function (word) {\n                    return new Word(word.term, Math.floor(maxWordSize - (maxCount - word.weight) * step));\n                });else {\n                    var mdsData = {\n                        x: [],\n                        y: [],\n                        text: [],\n                        type: "scatter",\n                        mode: "text+markers",\n                        marker: { size: [] }\n                    };\n                    var _iteratorNormalCompletion3 = true;\n                    var _didIteratorError3 = false;\n                    var _iteratorError3 = undefined;\n\n                    try {\n                        for (var _iterator3 = (0, _getIterator3.default)(response.data.results.terms), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                            var term = _step3.value;\n\n                            mdsData.text.push(term.term);\n                            mdsData.x.push(term.termVector.terms[0]);\n                            mdsData.y.push(term.termVector.terms[1]);\n                            mdsData.marker.size.push(Math.floor(maxWordSize - (maxCount - term.weight) * step));\n                        }\n                    } catch (err) {\n                        _didIteratorError3 = true;\n                        _iteratorError3 = err;\n                    } finally {\n                        try {\n                            if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                                _iterator3.return();\n                            }\n                        } finally {\n                            if (_didIteratorError3) {\n                                throw _iteratorError3;\n                            }\n                        }\n                    }\n\n                    _this3.mdsData = [mdsData];\n                    _this3.mdsLayout = {\n                        title: "Term space (MDS)",\n                        hovermode: "closest",\n                        autosize: false,\n                        width: 800,\n                        height: 800\n                    };\n                }\n            }, function (error) {\n                _this3.queryRunning = false;\n                _this3.error = error;\n            });\n        }\n    }]);\n    return WordCloudViewComponentController;\n}(_octavoComponentController.OctavoComponentController);\n\nvar WordCloudViewComponent = exports.WordCloudViewComponent = function WordCloudViewComponent() {\n    (0, _classCallCheck3.default)(this, WordCloudViewComponent);\n\n    this.controller = WordCloudViewComponentController;\n    this.template = __webpack_require__(198)();\n};\n\nangular.module("app.components.word-cloud-view", []).component("wordCloudView", new WordCloudViewComponent());//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTkyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2FwcC9jb21wb25lbnRzL3dvcmQtY2xvdWQtdmlldy93b3JkLWNsb3VkLXZpZXctY29tcG9uZW50LnRzP2E5YWUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgKiBhcyBhbmd1bGFyIGZyb20gXCJhbmd1bGFyXCI7XG5pbXBvcnQgKiBhcyBkMyBmcm9tIFwiZDNcIjtcbmltcG9ydCBcInNjcmlwdC1sb2FkZXIhZDMtY2xvdWQvYnVpbGQvZDMubGF5b3V0LmNsb3VkLmpzXCI7XG5pbXBvcnQgXCJhbmd1bGFyLWQzLXdvcmQtY2xvdWQvZGlzdC9hbmd1bGFyLXdvcmQtY2xvdWQuanNcIjtcbmltcG9ydCBcIm5nLXByZXR0eWpzb24vZGlzdC9uZy1wcmV0dHlqc29uLm1pbi5qc1wiO1xuaW1wb3J0IHsgT2N0YXZvQ29tcG9uZW50Q29udHJvbGxlciB9IGZyb20gXCJjb21wb25lbnRzL29jdGF2by1jb21wb25lbnQtY29udHJvbGxlclwiO1xuY2xhc3MgV29yZCB7XG4gICAgY29uc3RydWN0b3IodGV4dCwgc2l6ZSwgY29sb3IpIHtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICAgICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgICAgICAgdGhpcy5jb2xvciA9IGNvbG9yO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBXb3JkQ2xvdWRWaWV3Q29tcG9uZW50Q29udHJvbGxlciBleHRlbmRzIE9jdGF2b0NvbXBvbmVudENvbnRyb2xsZXIge1xuICAgIC8qIEBuZ0luamVjdCAqL1xuICAgIGNvbnN0cnVjdG9yKCRlbGVtZW50LCAkd2luZG93LCAkc2NlLCAkcSwgJGh0dHAsICRodHRwUGFyYW1TZXJpYWxpemVyLCAkc3RhdGVQYXJhbXMsICRzdGF0ZSkge1xuICAgICAgICBzdXBlcigkaHR0cCwgJHN0YXRlUGFyYW1zLCAkc3RhdGUpO1xuICAgICAgICB0aGlzLiR3aW5kb3cgPSAkd2luZG93O1xuICAgICAgICB0aGlzLiRzY2UgPSAkc2NlO1xuICAgICAgICB0aGlzLiRxID0gJHE7XG4gICAgICAgIHRoaXMuJGh0dHBQYXJhbVNlcmlhbGl6ZXIgPSAkaHR0cFBhcmFtU2VyaWFsaXplcjtcbiAgICAgICAgdGhpcy53b3JkQ2xpY2tlZCA9ICh3b3JkKSA9PiB7XG4gICAgICAgICAgICBpZiAoZDMuZXZlbnQuYWx0S2V5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5xdWVyeSA9IHdvcmQudGV4dDtcbiAgICAgICAgICAgICAgICB0aGlzLmRvUnVuUXVlcnkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCB1cmwgPSB0aGlzLiRzdGF0ZS5ocmVmKFwic2VhcmNoXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgZW5kcG9pbnQ6IHRoaXMuZW5kcG9pbnQsXG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiBcIisoXCIgKyB0aGlzLnF1ZXJ5ICsgXCIpICtcIiArIHdvcmQudGV4dCxcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdExldmVsOiB0aGlzLmRlZmF1bHRMZXZlbFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuJHdpbmRvdy5vcGVuKHVybCwgXCJfYmxhbmtcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGxldCBlbGVtZW50ID0gJGVsZW1lbnQuZmluZChcIndvcmQtY2xvdWRcIilbMF07XG4gICAgICAgIHRoaXMuY2xvdWRIZWlnaHQgPSAkd2luZG93LmlubmVySGVpZ2h0ICogMC43NTtcbiAgICAgICAgdGhpcy5jbG91ZFdpZHRoID0gZWxlbWVudC5jaGlsZHJlblswXS5vZmZzZXRXaWR0aDtcbiAgICAgICAgaWYgKCF0aGlzLmZ1cnRoZXJPcHRpb25zKVxuICAgICAgICAgICAgdGhpcy5mdXJ0aGVyT3B0aW9ucyA9IFwiXCI7XG4gICAgICAgIGlmICghdGhpcy5saW1pdClcbiAgICAgICAgICAgIHRoaXMubGltaXQgPSAxMDA7XG4gICAgICAgIGlmICghdGhpcy5zbW9vdGhpbmcpXG4gICAgICAgICAgICB0aGlzLnNtb290aGluZyA9IDI7XG4gICAgICAgIGlmICghdGhpcy5tYXhEb2NzKVxuICAgICAgICAgICAgdGhpcy5tYXhEb2NzID0gNTAwMDA7XG4gICAgICAgIGlmICghdGhpcy5taW5Ub3RhbFRlcm1GcmVxKVxuICAgICAgICAgICAgdGhpcy5taW5Ub3RhbFRlcm1GcmVxID0gMDtcbiAgICAgICAgaWYgKCF0aGlzLm1heFRvdGFsVGVybUZyZXEpXG4gICAgICAgICAgICB0aGlzLm1heFRvdGFsVGVybUZyZXEgPSAtMTtcbiAgICAgICAgaWYgKCF0aGlzLm1pbkRvY0ZyZXEpXG4gICAgICAgICAgICB0aGlzLm1pbkRvY0ZyZXEgPSAwO1xuICAgICAgICBpZiAoIXRoaXMubWF4RG9jRnJlcSlcbiAgICAgICAgICAgIHRoaXMubWF4RG9jRnJlcSA9IC0xO1xuICAgICAgICBpZiAoIXRoaXMubWluRnJlcUluRG9jKVxuICAgICAgICAgICAgdGhpcy5taW5GcmVxSW5Eb2MgPSAwO1xuICAgICAgICBpZiAoIXRoaXMubWF4RnJlcUluRG9jKVxuICAgICAgICAgICAgdGhpcy5tYXhGcmVxSW5Eb2MgPSAtMTtcbiAgICAgICAgaWYgKCF0aGlzLm1pblRlcm1MZW5ndGgpXG4gICAgICAgICAgICB0aGlzLm1pblRlcm1MZW5ndGggPSAwO1xuICAgICAgICBpZiAoIXRoaXMubWF4VGVybUxlbmd0aClcbiAgICAgICAgICAgIHRoaXMubWF4VGVybUxlbmd0aCA9IC0xO1xuICAgICAgICBpZiAoIXRoaXMubWluU3VtRnJlcSlcbiAgICAgICAgICAgIHRoaXMubWluU3VtRnJlcSA9IDA7XG4gICAgICAgIGlmICghdGhpcy5tYXhTdW1GcmVxKVxuICAgICAgICAgICAgdGhpcy5tYXhTdW1GcmVxID0gLTE7XG4gICAgICAgIGlmICghdGhpcy50ZXJtRmlsdGVyKVxuICAgICAgICAgICAgdGhpcy50ZXJtRmlsdGVyID0gXCJcIjtcbiAgICAgICAgaWYgKCF0aGlzLmxvY2FsU2NhbGluZylcbiAgICAgICAgICAgIHRoaXMubG9jYWxTY2FsaW5nID0gXCJBQlNPTFVURVwiO1xuICAgICAgICBpZiAoIXRoaXMuc3VtU2NhbGluZylcbiAgICAgICAgICAgIHRoaXMuc3VtU2NhbGluZyA9IFwiVFRGXCI7XG4gICAgfVxuICAgIG1kc1dvcmRDbGlja2VkKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEuZXZlbnQuYWx0S2V5KSB7XG4gICAgICAgICAgICB0aGlzLnF1ZXJ5ID0gZGF0YS5wb2ludHNbMF0uZGF0YS50ZXh0W2RhdGEucG9pbnRzWzBdLnBvaW50TnVtYmVyXTtcbiAgICAgICAgICAgIHRoaXMuZG9SdW5RdWVyeSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHVybCA9IHRoaXMuJHN0YXRlLmhyZWYoXCJzZWFyY2hcIiwge1xuICAgICAgICAgICAgICAgIGVuZHBvaW50OiB0aGlzLmVuZHBvaW50LFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBcIisoXCIgK1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnF1ZXJ5ICtcbiAgICAgICAgICAgICAgICAgICAgXCIpICtcIiArXG4gICAgICAgICAgICAgICAgICAgIGRhdGEucG9pbnRzWzBdLmRhdGEudGV4dFtkYXRhLnBvaW50c1swXS5wb2ludE51bWJlcl0sXG4gICAgICAgICAgICAgICAgZGVmYXVsdExldmVsOiB0aGlzLmRlZmF1bHRMZXZlbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLiR3aW5kb3cub3Blbih1cmwsIFwiX2JsYW5rXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVuZHBvaW50VXBkYXRlZChpbmRleEluZm8pIHtcbiAgICAgICAgdGhpcy5hdmFpbGFibGVMZXZlbHMgPSBpbmRleEluZm8ubGV2ZWxzLm1hcChsZXZlbCA9PiBsZXZlbC5pZCk7XG4gICAgICAgIGlmICghdGhpcy5kZWZhdWx0TGV2ZWwpXG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRMZXZlbCA9IHRoaXMuYXZhaWxhYmxlTGV2ZWxzW3RoaXMuYXZhaWxhYmxlTGV2ZWxzLmxlbmd0aCAtIDFdO1xuICAgICAgICB0aGlzLm1xdWFudGlsZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucXVhbnRpbGVzID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLm1kcXVhbnRpbGVzID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmRxdWFudGlsZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuJGh0dHBcbiAgICAgICAgICAgIC5nZXQodGhpcy5lbmRwb2ludCArIFwiaW5kZXhTdGF0cz9ieT0wLjAwMVwiKVxuICAgICAgICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICBsZXQgdGZzID0gcmVzcG9uc2UuZGF0YS50ZXJtRnJlcVF1YW50aWxlcztcbiAgICAgICAgICAgIGxldCBkZnMgPSByZXNwb25zZS5kYXRhLmRvY0ZyZXFRdWFudGlsZXM7XG4gICAgICAgICAgICB0aGlzLm1xdWFudGlsZXMgPSBbXG4gICAgICAgICAgICAgICAgdGZzWzEwMF0uZnJlcSxcbiAgICAgICAgICAgICAgICB0ZnNbNTAwXS5mcmVxLFxuICAgICAgICAgICAgICAgIHRmc1s4MDBdLmZyZXEsXG4gICAgICAgICAgICAgICAgdGZzWzkwMF0uZnJlcVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHRoaXMucXVhbnRpbGVzID0gW1xuICAgICAgICAgICAgICAgIHRmc1s5NTBdLmZyZXEsXG4gICAgICAgICAgICAgICAgdGZzWzk5MF0uZnJlcSxcbiAgICAgICAgICAgICAgICB0ZnNbOTk1XS5mcmVxLFxuICAgICAgICAgICAgICAgIHRmc1s5OTldLmZyZXEsXG4gICAgICAgICAgICAgICAgdGZzWzEwMDBdLmZyZXFcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICB0aGlzLm1kcXVhbnRpbGVzID0gW1xuICAgICAgICAgICAgICAgIGRmc1sxMDBdLmZyZXEsXG4gICAgICAgICAgICAgICAgZGZzWzUwMF0uZnJlcSxcbiAgICAgICAgICAgICAgICBkZnNbODAwXS5mcmVxLFxuICAgICAgICAgICAgICAgIGRmc1s5MDBdLmZyZXFcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICB0aGlzLmRxdWFudGlsZXMgPSBbXG4gICAgICAgICAgICAgICAgZGZzWzk1MF0uZnJlcSxcbiAgICAgICAgICAgICAgICBkZnNbOTkwXS5mcmVxLFxuICAgICAgICAgICAgICAgIGRmc1s5OTVdLmZyZXEsXG4gICAgICAgICAgICAgICAgZGZzWzk5OV0uZnJlcSxcbiAgICAgICAgICAgICAgICBkZnNbMTAwMF0uZnJlcVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGxldCB0ZkRhdGEgPSB7XG4gICAgICAgICAgICAgICAgeDogW10sXG4gICAgICAgICAgICAgICAgeTogW10sXG4gICAgICAgICAgICAgICAgbW9kZTogXCJtYXJrZXJzXCJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmb3IgKGxldCBxIG9mIHRmcykge1xuICAgICAgICAgICAgICAgIHRmRGF0YS54XG4gICAgICAgICAgICAgICAgICAgIC5wdXNoKCgxLjAgLSBwYXJzZUZsb2F0KHEucXVhbnRpbGUpKSAqIDEwMCkodGZEYXRhLnkpXG4gICAgICAgICAgICAgICAgICAgIC5wdXNoKHEuZnJlcSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRmRGF0YSA9IFt0ZkRhdGFdO1xuICAgICAgICAgICAgdGhpcy50ZkxheW91dCA9IHtcbiAgICAgICAgICAgICAgICB0aXRsZTogXCJUZXJtIGZyZXF1ZW5jeSBxdWFudGlsZXMgKGxvZylcIixcbiAgICAgICAgICAgICAgICB5YXhpczoge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImxvZ1wiLFxuICAgICAgICAgICAgICAgICAgICBhdXRvcmFuZ2U6IHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IGRmRGF0YSA9IHtcbiAgICAgICAgICAgICAgICB4OiBbXSxcbiAgICAgICAgICAgICAgICB5OiBbXSxcbiAgICAgICAgICAgICAgICBtb2RlOiBcIm1hcmtlcnNcIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAobGV0IHEgb2YgZGZzLnJldmVyc2UoKSkge1xuICAgICAgICAgICAgICAgIGRmRGF0YS54XG4gICAgICAgICAgICAgICAgICAgIC5wdXNoKCgxLjAgLSBwYXJzZUZsb2F0KHEucXVhbnRpbGUpKSAqIDEwMCkoZGZEYXRhLnkpXG4gICAgICAgICAgICAgICAgICAgIC5wdXNoKHEuZnJlcSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRmRGF0YSA9IFtkZkRhdGFdO1xuICAgICAgICAgICAgdGhpcy5kZkxheW91dCA9IHtcbiAgICAgICAgICAgICAgICB0aXRsZTogXCJEb2N1bWVudCBmcmVxdWVuY3kgcXVhbnRpbGVzIChsb2cpXCIsXG4gICAgICAgICAgICAgICAgeWF4aXM6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJsb2dcIixcbiAgICAgICAgICAgICAgICAgICAgYXV0b3JhbmdlOiB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLnF1ZXJ5KVxuICAgICAgICAgICAgdGhpcy5kb1J1blF1ZXJ5KCk7XG4gICAgfVxuICAgIGRvUnVuUXVlcnkoKSB7XG4gICAgICAgIHN1cGVyLmRvUnVuUXVlcnkoKTtcbiAgICAgICAgbGV0IHBhcmFtcyA9IHRoaXMuJGh0dHBQYXJhbVNlcmlhbGl6ZXIoe1xuICAgICAgICAgICAgcXVlcnk6IHRoaXMuZGVmYXVsdExldmVsICYmIHRoaXMucXVlcnkuaW5kZXhPZihcIjxcIikgIT09IDBcbiAgICAgICAgICAgICAgICA/IFwiPFwiICtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWZhdWx0TGV2ZWwgK1xuICAgICAgICAgICAgICAgICAgICBcIsKnXCIgK1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnF1ZXJ5ICtcbiAgICAgICAgICAgICAgICAgICAgXCLCp1wiICtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWZhdWx0TGV2ZWwgK1xuICAgICAgICAgICAgICAgICAgICBcIj5cIlxuICAgICAgICAgICAgICAgIDogdGhpcy5xdWVyeSxcbiAgICAgICAgICAgIGxpbWl0OiB0aGlzLmxpbWl0LFxuICAgICAgICAgICAgc21vb3RoaW5nOiB0aGlzLnNtb290aGluZyxcbiAgICAgICAgICAgIG1heERvY3M6IHRoaXMubWF4RG9jcyxcbiAgICAgICAgICAgIG1pblRvdGFsVGVybUZyZXE6IHRoaXMubWluVG90YWxUZXJtRnJlcSxcbiAgICAgICAgICAgIG1heFRvdGFsVGVybUZyZXE6IHRoaXMubWF4VG90YWxUZXJtRnJlcSAhPT0gLTEgPyB0aGlzLm1heFRvdGFsVGVybUZyZXEgOiBudWxsLFxuICAgICAgICAgICAgbWluRG9jRnJlcTogdGhpcy5taW5Eb2NGcmVxLFxuICAgICAgICAgICAgbWF4RG9jRnJlcTogdGhpcy5tYXhEb2NGcmVxICE9PSAtMSA/IHRoaXMubWF4RG9jRnJlcSA6IG51bGwsXG4gICAgICAgICAgICBtaW5TdW1GcmVxOiB0aGlzLm1pblN1bUZyZXEsXG4gICAgICAgICAgICBtYXhTdW1GcmVxOiB0aGlzLm1heFN1bUZyZXEgIT09IC0xID8gdGhpcy5tYXhTdW1GcmVxIDogbnVsbCxcbiAgICAgICAgICAgIHRlcm1GaWx0ZXI6IHRoaXMudGVybUZpbHRlciA/IHRoaXMudGVybUZpbHRlciA6IG51bGwsXG4gICAgICAgICAgICBsb2NhbFNjYWxpbmc6IHRoaXMubG9jYWxTY2FsaW5nLFxuICAgICAgICAgICAgc3VtU2NhbGluZzogdGhpcy5zdW1TY2FsaW5nLFxuICAgICAgICAgICAgbWluVGVybUxlbmd0aDogdGhpcy5taW5UZXJtTGVuZ3RoLFxuICAgICAgICAgICAgbWF4VGVybUxlbmd0aDogdGhpcy5tYXhUZXJtTGVuZ3RoICE9PSAtMSA/IHRoaXMubWF4VGVybUxlbmd0aCA6IG51bGwsXG4gICAgICAgICAgICByX3Ntb290aGluZzogdGhpcy5tZHMgPyB0aGlzLnNtb290aGluZyA6IG51bGwsXG4gICAgICAgICAgICByX21heERvY3M6IHRoaXMubWRzID8gdGhpcy5tYXhEb2NzIDogbnVsbCxcbiAgICAgICAgICAgIHJfbWluVG90YWxUZXJtRnJlcTogdGhpcy5tZHMgPyB0aGlzLm1pblRvdGFsVGVybUZyZXEgOiBudWxsLFxuICAgICAgICAgICAgcl9tYXhUb3RhbFRlcm1GcmVxOiB0aGlzLm1kcyAmJiB0aGlzLm1heFRvdGFsVGVybUZyZXEgIT09IC0xXG4gICAgICAgICAgICAgICAgPyB0aGlzLm1heFRvdGFsVGVybUZyZXFcbiAgICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICByX21pbkRvY0ZyZXE6IHRoaXMubWRzID8gdGhpcy5taW5Eb2NGcmVxIDogbnVsbCxcbiAgICAgICAgICAgIHJfbWF4RG9jRnJlcTogdGhpcy5tZHMgJiYgdGhpcy5tYXhEb2NGcmVxICE9PSAtMSA/IHRoaXMubWF4RG9jRnJlcSA6IG51bGwsXG4gICAgICAgICAgICByX21pblN1bUZyZXE6IHRoaXMubWRzID8gdGhpcy5taW5TdW1GcmVxIDogbnVsbCxcbiAgICAgICAgICAgIHJfbWF4U3VtRnJlcTogdGhpcy5tZHMgJiYgdGhpcy5tYXhTdW1GcmVxICE9PSAtMSA/IHRoaXMubWF4U3VtRnJlcSA6IG51bGwsXG4gICAgICAgICAgICByX3Rlcm1GaWx0ZXI6IHRoaXMubWRzICYmIHRoaXMudGVybUZpbHRlciA/IHRoaXMudGVybUZpbHRlciA6IG51bGwsXG4gICAgICAgICAgICByX2xvY2FsU2NhbGluZzogdGhpcy5tZHMgPyB0aGlzLmxvY2FsU2NhbGluZyA6IG51bGwsXG4gICAgICAgICAgICByX3N1bVNjYWxpbmc6IHRoaXMubWRzID8gdGhpcy5zdW1TY2FsaW5nIDogbnVsbCxcbiAgICAgICAgICAgIHJfbWluVGVybUxlbmd0aDogdGhpcy5tZHMgPyB0aGlzLm1pblRlcm1MZW5ndGggOiBudWxsLFxuICAgICAgICAgICAgcl9tYXhUZXJtTGVuZ3RoOiB0aGlzLm1kcyAmJiB0aGlzLm1heFRlcm1MZW5ndGggIT09IC0xID8gdGhpcy5tYXhUZXJtTGVuZ3RoIDogbnVsbCxcbiAgICAgICAgICAgIGRpbWVuc2lvbnM6IHRoaXMubWRzID8gMiA6IG51bGxcbiAgICAgICAgfSkgK1xuICAgICAgICAgICAgXCImXCIgK1xuICAgICAgICAgICAgdGhpcy5mdXJ0aGVyT3B0aW9ucztcbiAgICAgICAgdGhpcy5xdWVyeVVSTCA9IHRoaXMuZW5kcG9pbnQgKyBcInRlcm1WZWN0b3JzXCIgKyBcIj9cIiArIHBhcmFtcztcbiAgICAgICAgdGhpcy4kaHR0cFxuICAgICAgICAgICAgLnBvc3QodGhpcy5lbmRwb2ludCArIFwidGVybVZlY3RvcnNcIiwgcGFyYW1zLCB7XG4gICAgICAgICAgICBoZWFkZXJzOiB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIgfVxuICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlc3BvbnNlID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShyZXNwb25zZS5kYXRhKSk7XG4gICAgICAgICAgICB0aGlzLnF1ZXJ5UnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy50b3RhbFJlc3VsdHMgPSByZXNwb25zZS5kYXRhLnJlc3VsdHMubWV0YWRhdGEuYWNjZXB0ZWRUZXJtcztcbiAgICAgICAgICAgIGxldCBvcmlnaW5Xb3JkcyA9IHJlc3BvbnNlLmRhdGEucmVzdWx0cy50ZXJtcztcbiAgICAgICAgICAgIGxldCBtYXhDb3VudCA9IG9yaWdpbldvcmRzWzBdLndlaWdodDtcbiAgICAgICAgICAgIGxldCBtaW5Db3VudCA9IG9yaWdpbldvcmRzW29yaWdpbldvcmRzLmxlbmd0aCAtIDFdLndlaWdodDtcbiAgICAgICAgICAgIGxldCBtYXhXb3JkU2l6ZSA9IHRoaXMuY2xvdWRXaWR0aCAqIDAuMDU7XG4gICAgICAgICAgICBsZXQgbWluV29yZFNpemUgPSBtYXhXb3JkU2l6ZSAvIDU7XG4gICAgICAgICAgICBsZXQgc3ByZWFkID0gbWF4Q291bnQgLSBtaW5Db3VudDtcbiAgICAgICAgICAgIGlmIChzcHJlYWQgPD0gMClcbiAgICAgICAgICAgICAgICBzcHJlYWQgPSAxO1xuICAgICAgICAgICAgbGV0IHN0ZXAgPSAobWF4V29yZFNpemUgLSBtaW5Xb3JkU2l6ZSkgLyBzcHJlYWQ7XG4gICAgICAgICAgICBpZiAoIXRoaXMubWRzKVxuICAgICAgICAgICAgICAgIHRoaXMud29yZHMgPSBvcmlnaW5Xb3Jkcy5tYXAod29yZCA9PiBuZXcgV29yZCh3b3JkLnRlcm0sIE1hdGguZmxvb3IobWF4V29yZFNpemUgLSAobWF4Q291bnQgLSB3b3JkLndlaWdodCkgKiBzdGVwKSkpO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IG1kc0RhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgIHg6IFtdLFxuICAgICAgICAgICAgICAgICAgICB5OiBbXSxcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogW10sXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic2NhdHRlclwiLFxuICAgICAgICAgICAgICAgICAgICBtb2RlOiBcInRleHQrbWFya2Vyc1wiLFxuICAgICAgICAgICAgICAgICAgICBtYXJrZXI6IHsgc2l6ZTogW10gfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgdGVybSBvZiByZXNwb25zZS5kYXRhLnJlc3VsdHMudGVybXMpIHtcbiAgICAgICAgICAgICAgICAgICAgbWRzRGF0YS50ZXh0LnB1c2godGVybS50ZXJtKTtcbiAgICAgICAgICAgICAgICAgICAgbWRzRGF0YS54LnB1c2godGVybS50ZXJtVmVjdG9yLnRlcm1zWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgbWRzRGF0YS55LnB1c2godGVybS50ZXJtVmVjdG9yLnRlcm1zWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgbWRzRGF0YS5tYXJrZXIuc2l6ZS5wdXNoKE1hdGguZmxvb3IobWF4V29yZFNpemUgLSAobWF4Q291bnQgLSB0ZXJtLndlaWdodCkgKiBzdGVwKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMubWRzRGF0YSA9IFttZHNEYXRhXTtcbiAgICAgICAgICAgICAgICB0aGlzLm1kc0xheW91dCA9IHtcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFwiVGVybSBzcGFjZSAoTURTKVwiLFxuICAgICAgICAgICAgICAgICAgICBob3Zlcm1vZGU6IFwiY2xvc2VzdFwiLFxuICAgICAgICAgICAgICAgICAgICBhdXRvc2l6ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiA4MDAsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogODAwXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgZXJyb3IgPT4ge1xuICAgICAgICAgICAgdGhpcy5xdWVyeVJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFdvcmRDbG91ZFZpZXdDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNvbnRyb2xsZXIgPSBXb3JkQ2xvdWRWaWV3Q29tcG9uZW50Q29udHJvbGxlcjtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IHJlcXVpcmUoXCIuL3dvcmQtY2xvdWQtdmlldy5wdWdcIikoKTtcbiAgICB9XG59XG5hbmd1bGFyXG4gICAgLm1vZHVsZShcImFwcC5jb21wb25lbnRzLndvcmQtY2xvdWQtdmlld1wiLCBbXSlcbiAgICAuY29tcG9uZW50KFwid29yZENsb3VkVmlld1wiLCBuZXcgV29yZENsb3VkVmlld0NvbXBvbmVudCgpKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBhcHAvY29tcG9uZW50cy93b3JkLWNsb3VkLXZpZXcvd29yZC1jbG91ZC12aWV3LWNvbXBvbmVudC50cyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQUVBO0FBRUE7QUFFQTtBQXZEQTtBQXlEQTtBQUNBOzs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBSUE7QUFOQTtBQVFBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBTUE7QUFPQTtBQU1BO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQTdCQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBa0NBO0FBQUE7QUFDQTtBQUFBO0FBR0E7QUF0Q0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBc0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBRkE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBL0NBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFvREE7QUFBQTtBQUNBO0FBQUE7QUFHQTtBQXhEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUF3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFGQTtBQU9BO0FBQ0E7QUFFQTs7O0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF2Q0E7QUEyQ0E7QUFDQTtBQUVBO0FBREE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQURBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFTQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBZEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///192\n')},function(module,exports){eval("module.exports = d3;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTkzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiZDNcIj9jMGM0Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZDM7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJkM1wiXG4vLyBtb2R1bGUgaWQgPSAxOTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///193\n")},function(module,exports,__webpack_require__){eval("__webpack_require__(195)(__webpack_require__(196))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTk0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2QzLWNsb3VkL2J1aWxkL2QzLmxheW91dC5jbG91ZC5qcz84ZDgzIl0sInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUoXCIhIS9Vc2Vycy9qaWVtYWtlbC90eW8vb2N0YXZvLXVpL25vZGVfbW9kdWxlcy9zY3JpcHQtbG9hZGVyL2FkZFNjcmlwdC5qc1wiKShyZXF1aXJlKFwiISEvVXNlcnMvamllbWFrZWwvdHlvL29jdGF2by11aS9ub2RlX21vZHVsZXMvcmF3LWxvYWRlci9pbmRleC5qcyEvVXNlcnMvamllbWFrZWwvdHlvL29jdGF2by11aS9ub2RlX21vZHVsZXMvZDMtY2xvdWQvYnVpbGQvZDMubGF5b3V0LmNsb3VkLmpzXCIpKVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIhLi9ub2RlX21vZHVsZXMvZDMtY2xvdWQvYnVpbGQvZDMubGF5b3V0LmNsb3VkLmpzXG4vLyBtb2R1bGUgaWQgPSAxOTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///194\n")},function(module,exports){eval('/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\nmodule.exports = function(src) {\n\tfunction log(error) {\n\t\t(typeof console !== "undefined")\n\t\t&& (console.error || console.log)("[Script Loader]", error);\n\t}\n\n\t// Check for IE =< 8\n\tfunction isIE() {\n\t\treturn typeof attachEvent !== "undefined" && typeof addEventListener === "undefined";\n\t}\n\n\ttry {\n\t\tif (typeof execScript !== "undefined" && isIE()) {\n\t\t\texecScript(src);\n\t\t} else if (typeof eval !== "undefined") {\n\t\t\teval.call(null, src);\n\t\t} else {\n\t\t\tlog("EvalError: No eval function available");\n\t\t}\n\t} catch (error) {\n\t\tlog(error);\n\t}\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTk1LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIvYWRkU2NyaXB0LmpzPzNmZTciXSwic291cmNlc0NvbnRlbnQiOlsiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oc3JjKSB7XG5cdGZ1bmN0aW9uIGxvZyhlcnJvcikge1xuXHRcdCh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIilcblx0XHQmJiAoY29uc29sZS5lcnJvciB8fCBjb25zb2xlLmxvZykoXCJbU2NyaXB0IExvYWRlcl1cIiwgZXJyb3IpO1xuXHR9XG5cblx0Ly8gQ2hlY2sgZm9yIElFID08IDhcblx0ZnVuY3Rpb24gaXNJRSgpIHtcblx0XHRyZXR1cm4gdHlwZW9mIGF0dGFjaEV2ZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBhZGRFdmVudExpc3RlbmVyID09PSBcInVuZGVmaW5lZFwiO1xuXHR9XG5cblx0dHJ5IHtcblx0XHRpZiAodHlwZW9mIGV4ZWNTY3JpcHQgIT09IFwidW5kZWZpbmVkXCIgJiYgaXNJRSgpKSB7XG5cdFx0XHRleGVjU2NyaXB0KHNyYyk7XG5cdFx0fSBlbHNlIGlmICh0eXBlb2YgZXZhbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0ZXZhbC5jYWxsKG51bGwsIHNyYyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxvZyhcIkV2YWxFcnJvcjogTm8gZXZhbCBmdW5jdGlvbiBhdmFpbGFibGVcIik7XG5cdFx0fVxuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdGxvZyhlcnJvcik7XG5cdH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIvYWRkU2NyaXB0LmpzXG4vLyBtb2R1bGUgaWQgPSAxOTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///195\n')},function(module,exports){eval('module.exports = "(function(f){if(typeof exports===\\"object\\"&&typeof module!==\\"undefined\\"){module.exports=f()}else if(typeof define===\\"function\\"&&define.amd){define([],f)}else{var g;if(typeof window!==\\"undefined\\"){g=window}else if(typeof global!==\\"undefined\\"){g=global}else if(typeof self!==\\"undefined\\"){g=self}else{g=this}g=(g.d3||(g.d3 = {}));g=(g.layout||(g.layout = {}));g.cloud = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\\"function\\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\\"Cannot find module \'\\"+o+\\"\'\\");throw f.code=\\"MODULE_NOT_FOUND\\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\\"function\\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\\n// Word cloud layout by Jason Davies, https://www.jasondavies.com/wordcloud/\\n// Algorithm due to Jonathan Feinberg, http://static.mrfeinberg.com/bv_ch03.pdf\\n\\nvar dispatch = require(\\"d3-dispatch\\").dispatch;\\n\\nvar cloudRadians = Math.PI / 180,\\n    cw = 1 << 11 >> 5,\\n    ch = 1 << 11;\\n\\nmodule.exports = function() {\\n  var size = [256, 256],\\n      text = cloudText,\\n      font = cloudFont,\\n      fontSize = cloudFontSize,\\n      fontStyle = cloudFontNormal,\\n      fontWeight = cloudFontNormal,\\n      rotate = cloudRotate,\\n      padding = cloudPadding,\\n      spiral = archimedeanSpiral,\\n      words = [],\\n      timeInterval = Infinity,\\n      event = dispatch(\\"word\\", \\"end\\"),\\n      timer = null,\\n      random = Math.random,\\n      cloud = {},\\n      canvas = cloudCanvas;\\n\\n  cloud.canvas = function(_) {\\n    return arguments.length ? (canvas = functor(_), cloud) : canvas;\\n  };\\n\\n  cloud.start = function() {\\n    var contextAndRatio = getContext(canvas()),\\n        board = zeroArray((size[0] >> 5) * size[1]),\\n        bounds = null,\\n        n = words.length,\\n        i = -1,\\n        tags = [],\\n        data = words.map(function(d, i) {\\n          d.text = text.call(this, d, i);\\n          d.font = font.call(this, d, i);\\n          d.style = fontStyle.call(this, d, i);\\n          d.weight = fontWeight.call(this, d, i);\\n          d.rotate = rotate.call(this, d, i);\\n          d.size = ~~fontSize.call(this, d, i);\\n          d.padding = padding.call(this, d, i);\\n          return d;\\n        }).sort(function(a, b) { return b.size - a.size; });\\n\\n    if (timer) clearInterval(timer);\\n    timer = setInterval(step, 0);\\n    step();\\n\\n    return cloud;\\n\\n    function step() {\\n      var start = Date.now();\\n      while (Date.now() - start < timeInterval && ++i < n && timer) {\\n        var d = data[i];\\n        d.x = (size[0] * (random() + .5)) >> 1;\\n        d.y = (size[1] * (random() + .5)) >> 1;\\n        cloudSprite(contextAndRatio, d, data, i);\\n        if (d.hasText && place(board, d, bounds)) {\\n          tags.push(d);\\n          event.call(\\"word\\", cloud, d);\\n          if (bounds) cloudBounds(bounds, d);\\n          else bounds = [{x: d.x + d.x0, y: d.y + d.y0}, {x: d.x + d.x1, y: d.y + d.y1}];\\n          // Temporary hack\\n          d.x -= size[0] >> 1;\\n          d.y -= size[1] >> 1;\\n        }\\n      }\\n      if (i >= n) {\\n        cloud.stop();\\n        event.call(\\"end\\", cloud, tags, bounds);\\n      }\\n    }\\n  }\\n\\n  cloud.stop = function() {\\n    if (timer) {\\n      clearInterval(timer);\\n      timer = null;\\n    }\\n    return cloud;\\n  };\\n\\n  function getContext(canvas) {\\n    canvas.width = canvas.height = 1;\\n    var ratio = Math.sqrt(canvas.getContext(\\"2d\\").getImageData(0, 0, 1, 1).data.length >> 2);\\n    canvas.width = (cw << 5) / ratio;\\n    canvas.height = ch / ratio;\\n\\n    var context = canvas.getContext(\\"2d\\");\\n    context.fillStyle = context.strokeStyle = \\"red\\";\\n    context.textAlign = \\"center\\";\\n\\n    return {context: context, ratio: ratio};\\n  }\\n\\n  function place(board, tag, bounds) {\\n    var perimeter = [{x: 0, y: 0}, {x: size[0], y: size[1]}],\\n        startX = tag.x,\\n        startY = tag.y,\\n        maxDelta = Math.sqrt(size[0] * size[0] + size[1] * size[1]),\\n        s = spiral(size),\\n        dt = random() < .5 ? 1 : -1,\\n        t = -dt,\\n        dxdy,\\n        dx,\\n        dy;\\n\\n    while (dxdy = s(t += dt)) {\\n      dx = ~~dxdy[0];\\n      dy = ~~dxdy[1];\\n\\n      if (Math.min(Math.abs(dx), Math.abs(dy)) >= maxDelta) break;\\n\\n      tag.x = startX + dx;\\n      tag.y = startY + dy;\\n\\n      if (tag.x + tag.x0 < 0 || tag.y + tag.y0 < 0 ||\\n          tag.x + tag.x1 > size[0] || tag.y + tag.y1 > size[1]) continue;\\n      // TODO only check for collisions within current bounds.\\n      if (!bounds || !cloudCollide(tag, board, size[0])) {\\n        if (!bounds || collideRects(tag, bounds)) {\\n          var sprite = tag.sprite,\\n              w = tag.width >> 5,\\n              sw = size[0] >> 5,\\n              lx = tag.x - (w << 4),\\n              sx = lx & 0x7f,\\n              msx = 32 - sx,\\n              h = tag.y1 - tag.y0,\\n              x = (tag.y + tag.y0) * sw + (lx >> 5),\\n              last;\\n          for (var j = 0; j < h; j++) {\\n            last = 0;\\n            for (var i = 0; i <= w; i++) {\\n              board[x + i] |= (last << msx) | (i < w ? (last = sprite[j * w + i]) >>> sx : 0);\\n            }\\n            x += sw;\\n          }\\n          delete tag.sprite;\\n          return true;\\n        }\\n      }\\n    }\\n    return false;\\n  }\\n\\n  cloud.timeInterval = function(_) {\\n    return arguments.length ? (timeInterval = _ == null ? Infinity : _, cloud) : timeInterval;\\n  };\\n\\n  cloud.words = function(_) {\\n    return arguments.length ? (words = _, cloud) : words;\\n  };\\n\\n  cloud.size = function(_) {\\n    return arguments.length ? (size = [+_[0], +_[1]], cloud) : size;\\n  };\\n\\n  cloud.font = function(_) {\\n    return arguments.length ? (font = functor(_), cloud) : font;\\n  };\\n\\n  cloud.fontStyle = function(_) {\\n    return arguments.length ? (fontStyle = functor(_), cloud) : fontStyle;\\n  };\\n\\n  cloud.fontWeight = function(_) {\\n    return arguments.length ? (fontWeight = functor(_), cloud) : fontWeight;\\n  };\\n\\n  cloud.rotate = function(_) {\\n    return arguments.length ? (rotate = functor(_), cloud) : rotate;\\n  };\\n\\n  cloud.text = function(_) {\\n    return arguments.length ? (text = functor(_), cloud) : text;\\n  };\\n\\n  cloud.spiral = function(_) {\\n    return arguments.length ? (spiral = spirals[_] || _, cloud) : spiral;\\n  };\\n\\n  cloud.fontSize = function(_) {\\n    return arguments.length ? (fontSize = functor(_), cloud) : fontSize;\\n  };\\n\\n  cloud.padding = function(_) {\\n    return arguments.length ? (padding = functor(_), cloud) : padding;\\n  };\\n\\n  cloud.random = function(_) {\\n    return arguments.length ? (random = _, cloud) : random;\\n  };\\n\\n  cloud.on = function() {\\n    var value = event.on.apply(event, arguments);\\n    return value === event ? cloud : value;\\n  };\\n\\n  return cloud;\\n};\\n\\nfunction cloudText(d) {\\n  return d.text;\\n}\\n\\nfunction cloudFont() {\\n  return \\"serif\\";\\n}\\n\\nfunction cloudFontNormal() {\\n  return \\"normal\\";\\n}\\n\\nfunction cloudFontSize(d) {\\n  return Math.sqrt(d.value);\\n}\\n\\nfunction cloudRotate() {\\n  return (~~(Math.random() * 6) - 3) * 30;\\n}\\n\\nfunction cloudPadding() {\\n  return 1;\\n}\\n\\n// Fetches a monochrome sprite bitmap for the specified text.\\n// Load in batches for speed.\\nfunction cloudSprite(contextAndRatio, d, data, di) {\\n  if (d.sprite) return;\\n  var c = contextAndRatio.context,\\n      ratio = contextAndRatio.ratio;\\n\\n  c.clearRect(0, 0, (cw << 5) / ratio, ch / ratio);\\n  var x = 0,\\n      y = 0,\\n      maxh = 0,\\n      n = data.length;\\n  --di;\\n  while (++di < n) {\\n    d = data[di];\\n    c.save();\\n    c.font = d.style + \\" \\" + d.weight + \\" \\" + ~~((d.size + 1) / ratio) + \\"px \\" + d.font;\\n    var w = c.measureText(d.text + \\"m\\").width * ratio,\\n        h = d.size << 1;\\n    if (d.rotate) {\\n      var sr = Math.sin(d.rotate * cloudRadians),\\n          cr = Math.cos(d.rotate * cloudRadians),\\n          wcr = w * cr,\\n          wsr = w * sr,\\n          hcr = h * cr,\\n          hsr = h * sr;\\n      w = (Math.max(Math.abs(wcr + hsr), Math.abs(wcr - hsr)) + 0x1f) >> 5 << 5;\\n      h = ~~Math.max(Math.abs(wsr + hcr), Math.abs(wsr - hcr));\\n    } else {\\n      w = (w + 0x1f) >> 5 << 5;\\n    }\\n    if (h > maxh) maxh = h;\\n    if (x + w >= (cw << 5)) {\\n      x = 0;\\n      y += maxh;\\n      maxh = 0;\\n    }\\n    if (y + h >= ch) break;\\n    c.translate((x + (w >> 1)) / ratio, (y + (h >> 1)) / ratio);\\n    if (d.rotate) c.rotate(d.rotate * cloudRadians);\\n    c.fillText(d.text, 0, 0);\\n    if (d.padding) c.lineWidth = 2 * d.padding, c.strokeText(d.text, 0, 0);\\n    c.restore();\\n    d.width = w;\\n    d.height = h;\\n    d.xoff = x;\\n    d.yoff = y;\\n    d.x1 = w >> 1;\\n    d.y1 = h >> 1;\\n    d.x0 = -d.x1;\\n    d.y0 = -d.y1;\\n    d.hasText = true;\\n    x += w;\\n  }\\n  var pixels = c.getImageData(0, 0, (cw << 5) / ratio, ch / ratio).data,\\n      sprite = [];\\n  while (--di >= 0) {\\n    d = data[di];\\n    if (!d.hasText) continue;\\n    var w = d.width,\\n        w32 = w >> 5,\\n        h = d.y1 - d.y0;\\n    // Zero the buffer\\n    for (var i = 0; i < h * w32; i++) sprite[i] = 0;\\n    x = d.xoff;\\n    if (x == null) return;\\n    y = d.yoff;\\n    var seen = 0,\\n        seenRow = -1;\\n    for (var j = 0; j < h; j++) {\\n      for (var i = 0; i < w; i++) {\\n        var k = w32 * j + (i >> 5),\\n            m = pixels[((y + j) * (cw << 5) + (x + i)) << 2] ? 1 << (31 - (i % 32)) : 0;\\n        sprite[k] |= m;\\n        seen |= m;\\n      }\\n      if (seen) seenRow = j;\\n      else {\\n        d.y0++;\\n        h--;\\n        j--;\\n        y++;\\n      }\\n    }\\n    d.y1 = d.y0 + seenRow;\\n    d.sprite = sprite.slice(0, (d.y1 - d.y0) * w32);\\n  }\\n}\\n\\n// Use mask-based collision detection.\\nfunction cloudCollide(tag, board, sw) {\\n  sw >>= 5;\\n  var sprite = tag.sprite,\\n      w = tag.width >> 5,\\n      lx = tag.x - (w << 4),\\n      sx = lx & 0x7f,\\n      msx = 32 - sx,\\n      h = tag.y1 - tag.y0,\\n      x = (tag.y + tag.y0) * sw + (lx >> 5),\\n      last;\\n  for (var j = 0; j < h; j++) {\\n    last = 0;\\n    for (var i = 0; i <= w; i++) {\\n      if (((last << msx) | (i < w ? (last = sprite[j * w + i]) >>> sx : 0))\\n          & board[x + i]) return true;\\n    }\\n    x += sw;\\n  }\\n  return false;\\n}\\n\\nfunction cloudBounds(bounds, d) {\\n  var b0 = bounds[0],\\n      b1 = bounds[1];\\n  if (d.x + d.x0 < b0.x) b0.x = d.x + d.x0;\\n  if (d.y + d.y0 < b0.y) b0.y = d.y + d.y0;\\n  if (d.x + d.x1 > b1.x) b1.x = d.x + d.x1;\\n  if (d.y + d.y1 > b1.y) b1.y = d.y + d.y1;\\n}\\n\\nfunction collideRects(a, b) {\\n  return a.x + a.x1 > b[0].x && a.x + a.x0 < b[1].x && a.y + a.y1 > b[0].y && a.y + a.y0 < b[1].y;\\n}\\n\\nfunction archimedeanSpiral(size) {\\n  var e = size[0] / size[1];\\n  return function(t) {\\n    return [e * (t *= .1) * Math.cos(t), t * Math.sin(t)];\\n  };\\n}\\n\\nfunction rectangularSpiral(size) {\\n  var dy = 4,\\n      dx = dy * size[0] / size[1],\\n      x = 0,\\n      y = 0;\\n  return function(t) {\\n    var sign = t < 0 ? -1 : 1;\\n    // See triangular numbers: T_n = n * (n + 1) / 2.\\n    switch ((Math.sqrt(1 + 4 * sign * t) - sign) & 3) {\\n      case 0:  x += dx; break;\\n      case 1:  y += dy; break;\\n      case 2:  x -= dx; break;\\n      default: y -= dy; break;\\n    }\\n    return [x, y];\\n  };\\n}\\n\\n// TODO reuse arrays?\\nfunction zeroArray(n) {\\n  var a = [],\\n      i = -1;\\n  while (++i < n) a[i] = 0;\\n  return a;\\n}\\n\\nfunction cloudCanvas() {\\n  return document.createElement(\\"canvas\\");\\n}\\n\\nfunction functor(d) {\\n  return typeof d === \\"function\\" ? d : function() { return d; };\\n}\\n\\nvar spirals = {\\n  archimedean: archimedeanSpiral,\\n  rectangular: rectangularSpiral\\n};\\n\\n},{\\"d3-dispatch\\":2}],2:[function(require,module,exports){\\n// https://d3js.org/d3-dispatch/ Version 1.0.2. Copyright 2016 Mike Bostock.\\n(function (global, factory) {\\n  typeof exports === \'object\' && typeof module !== \'undefined\' ? factory(exports) :\\n  typeof define === \'function\' && define.amd ? define([\'exports\'], factory) :\\n  (factory((global.d3 = global.d3 || {})));\\n}(this, (function (exports) { \'use strict\';\\n\\nvar noop = {value: function() {}};\\n\\nfunction dispatch() {\\n  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {\\n    if (!(t = arguments[i] + \\"\\") || (t in _)) throw new Error(\\"illegal type: \\" + t);\\n    _[t] = [];\\n  }\\n  return new Dispatch(_);\\n}\\n\\nfunction Dispatch(_) {\\n  this._ = _;\\n}\\n\\nfunction parseTypenames(typenames, types) {\\n  return typenames.trim().split(/^|\\\\s+/).map(function(t) {\\n    var name = \\"\\", i = t.indexOf(\\".\\");\\n    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);\\n    if (t && !types.hasOwnProperty(t)) throw new Error(\\"unknown type: \\" + t);\\n    return {type: t, name: name};\\n  });\\n}\\n\\nDispatch.prototype = dispatch.prototype = {\\n  constructor: Dispatch,\\n  on: function(typename, callback) {\\n    var _ = this._,\\n        T = parseTypenames(typename + \\"\\", _),\\n        t,\\n        i = -1,\\n        n = T.length;\\n\\n    // If no callback was specified, return the callback of the given type and name.\\n    if (arguments.length < 2) {\\n      while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;\\n      return;\\n    }\\n\\n    // If a type was specified, set the callback for the given type and name.\\n    // Otherwise, if a null callback was specified, remove callbacks of the given name.\\n    if (callback != null && typeof callback !== \\"function\\") throw new Error(\\"invalid callback: \\" + callback);\\n    while (++i < n) {\\n      if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);\\n      else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);\\n    }\\n\\n    return this;\\n  },\\n  copy: function() {\\n    var copy = {}, _ = this._;\\n    for (var t in _) copy[t] = _[t].slice();\\n    return new Dispatch(copy);\\n  },\\n  call: function(type, that) {\\n    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];\\n    if (!this._.hasOwnProperty(type)) throw new Error(\\"unknown type: \\" + type);\\n    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);\\n  },\\n  apply: function(type, that, args) {\\n    if (!this._.hasOwnProperty(type)) throw new Error(\\"unknown type: \\" + type);\\n    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);\\n  }\\n};\\n\\nfunction get(type, name) {\\n  for (var i = 0, n = type.length, c; i < n; ++i) {\\n    if ((c = type[i]).name === name) {\\n      return c.value;\\n    }\\n  }\\n}\\n\\nfunction set(type, name, callback) {\\n  for (var i = 0, n = type.length; i < n; ++i) {\\n    if (type[i].name === name) {\\n      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));\\n      break;\\n    }\\n  }\\n  if (callback != null) type.push({name: name, value: callback});\\n  return type;\\n}\\n\\nexports.dispatch = dispatch;\\n\\nObject.defineProperty(exports, \'__esModule\', { value: true });\\n\\n})));\\n\\n},{}]},{},[1])(1)\\n});"//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTk2LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2QzLWNsb3VkL2J1aWxkL2QzLmxheW91dC5jbG91ZC5qcz9lMmE1Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCIoZnVuY3Rpb24oZil7aWYodHlwZW9mIGV4cG9ydHM9PT1cXFwib2JqZWN0XFxcIiYmdHlwZW9mIG1vZHVsZSE9PVxcXCJ1bmRlZmluZWRcXFwiKXttb2R1bGUuZXhwb3J0cz1mKCl9ZWxzZSBpZih0eXBlb2YgZGVmaW5lPT09XFxcImZ1bmN0aW9uXFxcIiYmZGVmaW5lLmFtZCl7ZGVmaW5lKFtdLGYpfWVsc2V7dmFyIGc7aWYodHlwZW9mIHdpbmRvdyE9PVxcXCJ1bmRlZmluZWRcXFwiKXtnPXdpbmRvd31lbHNlIGlmKHR5cGVvZiBnbG9iYWwhPT1cXFwidW5kZWZpbmVkXFxcIil7Zz1nbG9iYWx9ZWxzZSBpZih0eXBlb2Ygc2VsZiE9PVxcXCJ1bmRlZmluZWRcXFwiKXtnPXNlbGZ9ZWxzZXtnPXRoaXN9Zz0oZy5kM3x8KGcuZDMgPSB7fSkpO2c9KGcubGF5b3V0fHwoZy5sYXlvdXQgPSB7fSkpO2cuY2xvdWQgPSBmKCl9fSkoZnVuY3Rpb24oKXt2YXIgZGVmaW5lLG1vZHVsZSxleHBvcnRzO3JldHVybiAoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVxcXCJmdW5jdGlvblxcXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXFxcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXFxcIitvK1xcXCInXFxcIik7dGhyb3cgZi5jb2RlPVxcXCJNT0RVTEVfTk9UX0ZPVU5EXFxcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVxcXCJmdW5jdGlvblxcXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pKHsxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4vLyBXb3JkIGNsb3VkIGxheW91dCBieSBKYXNvbiBEYXZpZXMsIGh0dHBzOi8vd3d3Lmphc29uZGF2aWVzLmNvbS93b3JkY2xvdWQvXFxuLy8gQWxnb3JpdGhtIGR1ZSB0byBKb25hdGhhbiBGZWluYmVyZywgaHR0cDovL3N0YXRpYy5tcmZlaW5iZXJnLmNvbS9idl9jaDAzLnBkZlxcblxcbnZhciBkaXNwYXRjaCA9IHJlcXVpcmUoXFxcImQzLWRpc3BhdGNoXFxcIikuZGlzcGF0Y2g7XFxuXFxudmFyIGNsb3VkUmFkaWFucyA9IE1hdGguUEkgLyAxODAsXFxuICAgIGN3ID0gMSA8PCAxMSA+PiA1LFxcbiAgICBjaCA9IDEgPDwgMTE7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcXG4gIHZhciBzaXplID0gWzI1NiwgMjU2XSxcXG4gICAgICB0ZXh0ID0gY2xvdWRUZXh0LFxcbiAgICAgIGZvbnQgPSBjbG91ZEZvbnQsXFxuICAgICAgZm9udFNpemUgPSBjbG91ZEZvbnRTaXplLFxcbiAgICAgIGZvbnRTdHlsZSA9IGNsb3VkRm9udE5vcm1hbCxcXG4gICAgICBmb250V2VpZ2h0ID0gY2xvdWRGb250Tm9ybWFsLFxcbiAgICAgIHJvdGF0ZSA9IGNsb3VkUm90YXRlLFxcbiAgICAgIHBhZGRpbmcgPSBjbG91ZFBhZGRpbmcsXFxuICAgICAgc3BpcmFsID0gYXJjaGltZWRlYW5TcGlyYWwsXFxuICAgICAgd29yZHMgPSBbXSxcXG4gICAgICB0aW1lSW50ZXJ2YWwgPSBJbmZpbml0eSxcXG4gICAgICBldmVudCA9IGRpc3BhdGNoKFxcXCJ3b3JkXFxcIiwgXFxcImVuZFxcXCIpLFxcbiAgICAgIHRpbWVyID0gbnVsbCxcXG4gICAgICByYW5kb20gPSBNYXRoLnJhbmRvbSxcXG4gICAgICBjbG91ZCA9IHt9LFxcbiAgICAgIGNhbnZhcyA9IGNsb3VkQ2FudmFzO1xcblxcbiAgY2xvdWQuY2FudmFzID0gZnVuY3Rpb24oXykge1xcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChjYW52YXMgPSBmdW5jdG9yKF8pLCBjbG91ZCkgOiBjYW52YXM7XFxuICB9O1xcblxcbiAgY2xvdWQuc3RhcnQgPSBmdW5jdGlvbigpIHtcXG4gICAgdmFyIGNvbnRleHRBbmRSYXRpbyA9IGdldENvbnRleHQoY2FudmFzKCkpLFxcbiAgICAgICAgYm9hcmQgPSB6ZXJvQXJyYXkoKHNpemVbMF0gPj4gNSkgKiBzaXplWzFdKSxcXG4gICAgICAgIGJvdW5kcyA9IG51bGwsXFxuICAgICAgICBuID0gd29yZHMubGVuZ3RoLFxcbiAgICAgICAgaSA9IC0xLFxcbiAgICAgICAgdGFncyA9IFtdLFxcbiAgICAgICAgZGF0YSA9IHdvcmRzLm1hcChmdW5jdGlvbihkLCBpKSB7XFxuICAgICAgICAgIGQudGV4dCA9IHRleHQuY2FsbCh0aGlzLCBkLCBpKTtcXG4gICAgICAgICAgZC5mb250ID0gZm9udC5jYWxsKHRoaXMsIGQsIGkpO1xcbiAgICAgICAgICBkLnN0eWxlID0gZm9udFN0eWxlLmNhbGwodGhpcywgZCwgaSk7XFxuICAgICAgICAgIGQud2VpZ2h0ID0gZm9udFdlaWdodC5jYWxsKHRoaXMsIGQsIGkpO1xcbiAgICAgICAgICBkLnJvdGF0ZSA9IHJvdGF0ZS5jYWxsKHRoaXMsIGQsIGkpO1xcbiAgICAgICAgICBkLnNpemUgPSB+fmZvbnRTaXplLmNhbGwodGhpcywgZCwgaSk7XFxuICAgICAgICAgIGQucGFkZGluZyA9IHBhZGRpbmcuY2FsbCh0aGlzLCBkLCBpKTtcXG4gICAgICAgICAgcmV0dXJuIGQ7XFxuICAgICAgICB9KS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIGIuc2l6ZSAtIGEuc2l6ZTsgfSk7XFxuXFxuICAgIGlmICh0aW1lcikgY2xlYXJJbnRlcnZhbCh0aW1lcik7XFxuICAgIHRpbWVyID0gc2V0SW50ZXJ2YWwoc3RlcCwgMCk7XFxuICAgIHN0ZXAoKTtcXG5cXG4gICAgcmV0dXJuIGNsb3VkO1xcblxcbiAgICBmdW5jdGlvbiBzdGVwKCkge1xcbiAgICAgIHZhciBzdGFydCA9IERhdGUubm93KCk7XFxuICAgICAgd2hpbGUgKERhdGUubm93KCkgLSBzdGFydCA8IHRpbWVJbnRlcnZhbCAmJiArK2kgPCBuICYmIHRpbWVyKSB7XFxuICAgICAgICB2YXIgZCA9IGRhdGFbaV07XFxuICAgICAgICBkLnggPSAoc2l6ZVswXSAqIChyYW5kb20oKSArIC41KSkgPj4gMTtcXG4gICAgICAgIGQueSA9IChzaXplWzFdICogKHJhbmRvbSgpICsgLjUpKSA+PiAxO1xcbiAgICAgICAgY2xvdWRTcHJpdGUoY29udGV4dEFuZFJhdGlvLCBkLCBkYXRhLCBpKTtcXG4gICAgICAgIGlmIChkLmhhc1RleHQgJiYgcGxhY2UoYm9hcmQsIGQsIGJvdW5kcykpIHtcXG4gICAgICAgICAgdGFncy5wdXNoKGQpO1xcbiAgICAgICAgICBldmVudC5jYWxsKFxcXCJ3b3JkXFxcIiwgY2xvdWQsIGQpO1xcbiAgICAgICAgICBpZiAoYm91bmRzKSBjbG91ZEJvdW5kcyhib3VuZHMsIGQpO1xcbiAgICAgICAgICBlbHNlIGJvdW5kcyA9IFt7eDogZC54ICsgZC54MCwgeTogZC55ICsgZC55MH0sIHt4OiBkLnggKyBkLngxLCB5OiBkLnkgKyBkLnkxfV07XFxuICAgICAgICAgIC8vIFRlbXBvcmFyeSBoYWNrXFxuICAgICAgICAgIGQueCAtPSBzaXplWzBdID4+IDE7XFxuICAgICAgICAgIGQueSAtPSBzaXplWzFdID4+IDE7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIGlmIChpID49IG4pIHtcXG4gICAgICAgIGNsb3VkLnN0b3AoKTtcXG4gICAgICAgIGV2ZW50LmNhbGwoXFxcImVuZFxcXCIsIGNsb3VkLCB0YWdzLCBib3VuZHMpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcblxcbiAgY2xvdWQuc3RvcCA9IGZ1bmN0aW9uKCkge1xcbiAgICBpZiAodGltZXIpIHtcXG4gICAgICBjbGVhckludGVydmFsKHRpbWVyKTtcXG4gICAgICB0aW1lciA9IG51bGw7XFxuICAgIH1cXG4gICAgcmV0dXJuIGNsb3VkO1xcbiAgfTtcXG5cXG4gIGZ1bmN0aW9uIGdldENvbnRleHQoY2FudmFzKSB7XFxuICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhcy5oZWlnaHQgPSAxO1xcbiAgICB2YXIgcmF0aW8gPSBNYXRoLnNxcnQoY2FudmFzLmdldENvbnRleHQoXFxcIjJkXFxcIikuZ2V0SW1hZ2VEYXRhKDAsIDAsIDEsIDEpLmRhdGEubGVuZ3RoID4+IDIpO1xcbiAgICBjYW52YXMud2lkdGggPSAoY3cgPDwgNSkgLyByYXRpbztcXG4gICAgY2FudmFzLmhlaWdodCA9IGNoIC8gcmF0aW87XFxuXFxuICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXFxcIjJkXFxcIik7XFxuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gY29udGV4dC5zdHJva2VTdHlsZSA9IFxcXCJyZWRcXFwiO1xcbiAgICBjb250ZXh0LnRleHRBbGlnbiA9IFxcXCJjZW50ZXJcXFwiO1xcblxcbiAgICByZXR1cm4ge2NvbnRleHQ6IGNvbnRleHQsIHJhdGlvOiByYXRpb307XFxuICB9XFxuXFxuICBmdW5jdGlvbiBwbGFjZShib2FyZCwgdGFnLCBib3VuZHMpIHtcXG4gICAgdmFyIHBlcmltZXRlciA9IFt7eDogMCwgeTogMH0sIHt4OiBzaXplWzBdLCB5OiBzaXplWzFdfV0sXFxuICAgICAgICBzdGFydFggPSB0YWcueCxcXG4gICAgICAgIHN0YXJ0WSA9IHRhZy55LFxcbiAgICAgICAgbWF4RGVsdGEgPSBNYXRoLnNxcnQoc2l6ZVswXSAqIHNpemVbMF0gKyBzaXplWzFdICogc2l6ZVsxXSksXFxuICAgICAgICBzID0gc3BpcmFsKHNpemUpLFxcbiAgICAgICAgZHQgPSByYW5kb20oKSA8IC41ID8gMSA6IC0xLFxcbiAgICAgICAgdCA9IC1kdCxcXG4gICAgICAgIGR4ZHksXFxuICAgICAgICBkeCxcXG4gICAgICAgIGR5O1xcblxcbiAgICB3aGlsZSAoZHhkeSA9IHModCArPSBkdCkpIHtcXG4gICAgICBkeCA9IH5+ZHhkeVswXTtcXG4gICAgICBkeSA9IH5+ZHhkeVsxXTtcXG5cXG4gICAgICBpZiAoTWF0aC5taW4oTWF0aC5hYnMoZHgpLCBNYXRoLmFicyhkeSkpID49IG1heERlbHRhKSBicmVhaztcXG5cXG4gICAgICB0YWcueCA9IHN0YXJ0WCArIGR4O1xcbiAgICAgIHRhZy55ID0gc3RhcnRZICsgZHk7XFxuXFxuICAgICAgaWYgKHRhZy54ICsgdGFnLngwIDwgMCB8fCB0YWcueSArIHRhZy55MCA8IDAgfHxcXG4gICAgICAgICAgdGFnLnggKyB0YWcueDEgPiBzaXplWzBdIHx8IHRhZy55ICsgdGFnLnkxID4gc2l6ZVsxXSkgY29udGludWU7XFxuICAgICAgLy8gVE9ETyBvbmx5IGNoZWNrIGZvciBjb2xsaXNpb25zIHdpdGhpbiBjdXJyZW50IGJvdW5kcy5cXG4gICAgICBpZiAoIWJvdW5kcyB8fCAhY2xvdWRDb2xsaWRlKHRhZywgYm9hcmQsIHNpemVbMF0pKSB7XFxuICAgICAgICBpZiAoIWJvdW5kcyB8fCBjb2xsaWRlUmVjdHModGFnLCBib3VuZHMpKSB7XFxuICAgICAgICAgIHZhciBzcHJpdGUgPSB0YWcuc3ByaXRlLFxcbiAgICAgICAgICAgICAgdyA9IHRhZy53aWR0aCA+PiA1LFxcbiAgICAgICAgICAgICAgc3cgPSBzaXplWzBdID4+IDUsXFxuICAgICAgICAgICAgICBseCA9IHRhZy54IC0gKHcgPDwgNCksXFxuICAgICAgICAgICAgICBzeCA9IGx4ICYgMHg3ZixcXG4gICAgICAgICAgICAgIG1zeCA9IDMyIC0gc3gsXFxuICAgICAgICAgICAgICBoID0gdGFnLnkxIC0gdGFnLnkwLFxcbiAgICAgICAgICAgICAgeCA9ICh0YWcueSArIHRhZy55MCkgKiBzdyArIChseCA+PiA1KSxcXG4gICAgICAgICAgICAgIGxhc3Q7XFxuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaDsgaisrKSB7XFxuICAgICAgICAgICAgbGFzdCA9IDA7XFxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gdzsgaSsrKSB7XFxuICAgICAgICAgICAgICBib2FyZFt4ICsgaV0gfD0gKGxhc3QgPDwgbXN4KSB8IChpIDwgdyA/IChsYXN0ID0gc3ByaXRlW2ogKiB3ICsgaV0pID4+PiBzeCA6IDApO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB4ICs9IHN3O1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGRlbGV0ZSB0YWcuc3ByaXRlO1xcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG4gICAgcmV0dXJuIGZhbHNlO1xcbiAgfVxcblxcbiAgY2xvdWQudGltZUludGVydmFsID0gZnVuY3Rpb24oXykge1xcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0aW1lSW50ZXJ2YWwgPSBfID09IG51bGwgPyBJbmZpbml0eSA6IF8sIGNsb3VkKSA6IHRpbWVJbnRlcnZhbDtcXG4gIH07XFxuXFxuICBjbG91ZC53b3JkcyA9IGZ1bmN0aW9uKF8pIHtcXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAod29yZHMgPSBfLCBjbG91ZCkgOiB3b3JkcztcXG4gIH07XFxuXFxuICBjbG91ZC5zaXplID0gZnVuY3Rpb24oXykge1xcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzaXplID0gWytfWzBdLCArX1sxXV0sIGNsb3VkKSA6IHNpemU7XFxuICB9O1xcblxcbiAgY2xvdWQuZm9udCA9IGZ1bmN0aW9uKF8pIHtcXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZm9udCA9IGZ1bmN0b3IoXyksIGNsb3VkKSA6IGZvbnQ7XFxuICB9O1xcblxcbiAgY2xvdWQuZm9udFN0eWxlID0gZnVuY3Rpb24oXykge1xcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChmb250U3R5bGUgPSBmdW5jdG9yKF8pLCBjbG91ZCkgOiBmb250U3R5bGU7XFxuICB9O1xcblxcbiAgY2xvdWQuZm9udFdlaWdodCA9IGZ1bmN0aW9uKF8pIHtcXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZm9udFdlaWdodCA9IGZ1bmN0b3IoXyksIGNsb3VkKSA6IGZvbnRXZWlnaHQ7XFxuICB9O1xcblxcbiAgY2xvdWQucm90YXRlID0gZnVuY3Rpb24oXykge1xcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyb3RhdGUgPSBmdW5jdG9yKF8pLCBjbG91ZCkgOiByb3RhdGU7XFxuICB9O1xcblxcbiAgY2xvdWQudGV4dCA9IGZ1bmN0aW9uKF8pIHtcXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodGV4dCA9IGZ1bmN0b3IoXyksIGNsb3VkKSA6IHRleHQ7XFxuICB9O1xcblxcbiAgY2xvdWQuc3BpcmFsID0gZnVuY3Rpb24oXykge1xcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzcGlyYWwgPSBzcGlyYWxzW19dIHx8IF8sIGNsb3VkKSA6IHNwaXJhbDtcXG4gIH07XFxuXFxuICBjbG91ZC5mb250U2l6ZSA9IGZ1bmN0aW9uKF8pIHtcXG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZm9udFNpemUgPSBmdW5jdG9yKF8pLCBjbG91ZCkgOiBmb250U2l6ZTtcXG4gIH07XFxuXFxuICBjbG91ZC5wYWRkaW5nID0gZnVuY3Rpb24oXykge1xcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChwYWRkaW5nID0gZnVuY3RvcihfKSwgY2xvdWQpIDogcGFkZGluZztcXG4gIH07XFxuXFxuICBjbG91ZC5yYW5kb20gPSBmdW5jdGlvbihfKSB7XFxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJhbmRvbSA9IF8sIGNsb3VkKSA6IHJhbmRvbTtcXG4gIH07XFxuXFxuICBjbG91ZC5vbiA9IGZ1bmN0aW9uKCkge1xcbiAgICB2YXIgdmFsdWUgPSBldmVudC5vbi5hcHBseShldmVudCwgYXJndW1lbnRzKTtcXG4gICAgcmV0dXJuIHZhbHVlID09PSBldmVudCA/IGNsb3VkIDogdmFsdWU7XFxuICB9O1xcblxcbiAgcmV0dXJuIGNsb3VkO1xcbn07XFxuXFxuZnVuY3Rpb24gY2xvdWRUZXh0KGQpIHtcXG4gIHJldHVybiBkLnRleHQ7XFxufVxcblxcbmZ1bmN0aW9uIGNsb3VkRm9udCgpIHtcXG4gIHJldHVybiBcXFwic2VyaWZcXFwiO1xcbn1cXG5cXG5mdW5jdGlvbiBjbG91ZEZvbnROb3JtYWwoKSB7XFxuICByZXR1cm4gXFxcIm5vcm1hbFxcXCI7XFxufVxcblxcbmZ1bmN0aW9uIGNsb3VkRm9udFNpemUoZCkge1xcbiAgcmV0dXJuIE1hdGguc3FydChkLnZhbHVlKTtcXG59XFxuXFxuZnVuY3Rpb24gY2xvdWRSb3RhdGUoKSB7XFxuICByZXR1cm4gKH5+KE1hdGgucmFuZG9tKCkgKiA2KSAtIDMpICogMzA7XFxufVxcblxcbmZ1bmN0aW9uIGNsb3VkUGFkZGluZygpIHtcXG4gIHJldHVybiAxO1xcbn1cXG5cXG4vLyBGZXRjaGVzIGEgbW9ub2Nocm9tZSBzcHJpdGUgYml0bWFwIGZvciB0aGUgc3BlY2lmaWVkIHRleHQuXFxuLy8gTG9hZCBpbiBiYXRjaGVzIGZvciBzcGVlZC5cXG5mdW5jdGlvbiBjbG91ZFNwcml0ZShjb250ZXh0QW5kUmF0aW8sIGQsIGRhdGEsIGRpKSB7XFxuICBpZiAoZC5zcHJpdGUpIHJldHVybjtcXG4gIHZhciBjID0gY29udGV4dEFuZFJhdGlvLmNvbnRleHQsXFxuICAgICAgcmF0aW8gPSBjb250ZXh0QW5kUmF0aW8ucmF0aW87XFxuXFxuICBjLmNsZWFyUmVjdCgwLCAwLCAoY3cgPDwgNSkgLyByYXRpbywgY2ggLyByYXRpbyk7XFxuICB2YXIgeCA9IDAsXFxuICAgICAgeSA9IDAsXFxuICAgICAgbWF4aCA9IDAsXFxuICAgICAgbiA9IGRhdGEubGVuZ3RoO1xcbiAgLS1kaTtcXG4gIHdoaWxlICgrK2RpIDwgbikge1xcbiAgICBkID0gZGF0YVtkaV07XFxuICAgIGMuc2F2ZSgpO1xcbiAgICBjLmZvbnQgPSBkLnN0eWxlICsgXFxcIiBcXFwiICsgZC53ZWlnaHQgKyBcXFwiIFxcXCIgKyB+figoZC5zaXplICsgMSkgLyByYXRpbykgKyBcXFwicHggXFxcIiArIGQuZm9udDtcXG4gICAgdmFyIHcgPSBjLm1lYXN1cmVUZXh0KGQudGV4dCArIFxcXCJtXFxcIikud2lkdGggKiByYXRpbyxcXG4gICAgICAgIGggPSBkLnNpemUgPDwgMTtcXG4gICAgaWYgKGQucm90YXRlKSB7XFxuICAgICAgdmFyIHNyID0gTWF0aC5zaW4oZC5yb3RhdGUgKiBjbG91ZFJhZGlhbnMpLFxcbiAgICAgICAgICBjciA9IE1hdGguY29zKGQucm90YXRlICogY2xvdWRSYWRpYW5zKSxcXG4gICAgICAgICAgd2NyID0gdyAqIGNyLFxcbiAgICAgICAgICB3c3IgPSB3ICogc3IsXFxuICAgICAgICAgIGhjciA9IGggKiBjcixcXG4gICAgICAgICAgaHNyID0gaCAqIHNyO1xcbiAgICAgIHcgPSAoTWF0aC5tYXgoTWF0aC5hYnMod2NyICsgaHNyKSwgTWF0aC5hYnMod2NyIC0gaHNyKSkgKyAweDFmKSA+PiA1IDw8IDU7XFxuICAgICAgaCA9IH5+TWF0aC5tYXgoTWF0aC5hYnMod3NyICsgaGNyKSwgTWF0aC5hYnMod3NyIC0gaGNyKSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgdyA9ICh3ICsgMHgxZikgPj4gNSA8PCA1O1xcbiAgICB9XFxuICAgIGlmIChoID4gbWF4aCkgbWF4aCA9IGg7XFxuICAgIGlmICh4ICsgdyA+PSAoY3cgPDwgNSkpIHtcXG4gICAgICB4ID0gMDtcXG4gICAgICB5ICs9IG1heGg7XFxuICAgICAgbWF4aCA9IDA7XFxuICAgIH1cXG4gICAgaWYgKHkgKyBoID49IGNoKSBicmVhaztcXG4gICAgYy50cmFuc2xhdGUoKHggKyAodyA+PiAxKSkgLyByYXRpbywgKHkgKyAoaCA+PiAxKSkgLyByYXRpbyk7XFxuICAgIGlmIChkLnJvdGF0ZSkgYy5yb3RhdGUoZC5yb3RhdGUgKiBjbG91ZFJhZGlhbnMpO1xcbiAgICBjLmZpbGxUZXh0KGQudGV4dCwgMCwgMCk7XFxuICAgIGlmIChkLnBhZGRpbmcpIGMubGluZVdpZHRoID0gMiAqIGQucGFkZGluZywgYy5zdHJva2VUZXh0KGQudGV4dCwgMCwgMCk7XFxuICAgIGMucmVzdG9yZSgpO1xcbiAgICBkLndpZHRoID0gdztcXG4gICAgZC5oZWlnaHQgPSBoO1xcbiAgICBkLnhvZmYgPSB4O1xcbiAgICBkLnlvZmYgPSB5O1xcbiAgICBkLngxID0gdyA+PiAxO1xcbiAgICBkLnkxID0gaCA+PiAxO1xcbiAgICBkLngwID0gLWQueDE7XFxuICAgIGQueTAgPSAtZC55MTtcXG4gICAgZC5oYXNUZXh0ID0gdHJ1ZTtcXG4gICAgeCArPSB3O1xcbiAgfVxcbiAgdmFyIHBpeGVscyA9IGMuZ2V0SW1hZ2VEYXRhKDAsIDAsIChjdyA8PCA1KSAvIHJhdGlvLCBjaCAvIHJhdGlvKS5kYXRhLFxcbiAgICAgIHNwcml0ZSA9IFtdO1xcbiAgd2hpbGUgKC0tZGkgPj0gMCkge1xcbiAgICBkID0gZGF0YVtkaV07XFxuICAgIGlmICghZC5oYXNUZXh0KSBjb250aW51ZTtcXG4gICAgdmFyIHcgPSBkLndpZHRoLFxcbiAgICAgICAgdzMyID0gdyA+PiA1LFxcbiAgICAgICAgaCA9IGQueTEgLSBkLnkwO1xcbiAgICAvLyBaZXJvIHRoZSBidWZmZXJcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoICogdzMyOyBpKyspIHNwcml0ZVtpXSA9IDA7XFxuICAgIHggPSBkLnhvZmY7XFxuICAgIGlmICh4ID09IG51bGwpIHJldHVybjtcXG4gICAgeSA9IGQueW9mZjtcXG4gICAgdmFyIHNlZW4gPSAwLFxcbiAgICAgICAgc2VlblJvdyA9IC0xO1xcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGg7IGorKykge1xcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdzsgaSsrKSB7XFxuICAgICAgICB2YXIgayA9IHczMiAqIGogKyAoaSA+PiA1KSxcXG4gICAgICAgICAgICBtID0gcGl4ZWxzWygoeSArIGopICogKGN3IDw8IDUpICsgKHggKyBpKSkgPDwgMl0gPyAxIDw8ICgzMSAtIChpICUgMzIpKSA6IDA7XFxuICAgICAgICBzcHJpdGVba10gfD0gbTtcXG4gICAgICAgIHNlZW4gfD0gbTtcXG4gICAgICB9XFxuICAgICAgaWYgKHNlZW4pIHNlZW5Sb3cgPSBqO1xcbiAgICAgIGVsc2Uge1xcbiAgICAgICAgZC55MCsrO1xcbiAgICAgICAgaC0tO1xcbiAgICAgICAgai0tO1xcbiAgICAgICAgeSsrO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICBkLnkxID0gZC55MCArIHNlZW5Sb3c7XFxuICAgIGQuc3ByaXRlID0gc3ByaXRlLnNsaWNlKDAsIChkLnkxIC0gZC55MCkgKiB3MzIpO1xcbiAgfVxcbn1cXG5cXG4vLyBVc2UgbWFzay1iYXNlZCBjb2xsaXNpb24gZGV0ZWN0aW9uLlxcbmZ1bmN0aW9uIGNsb3VkQ29sbGlkZSh0YWcsIGJvYXJkLCBzdykge1xcbiAgc3cgPj49IDU7XFxuICB2YXIgc3ByaXRlID0gdGFnLnNwcml0ZSxcXG4gICAgICB3ID0gdGFnLndpZHRoID4+IDUsXFxuICAgICAgbHggPSB0YWcueCAtICh3IDw8IDQpLFxcbiAgICAgIHN4ID0gbHggJiAweDdmLFxcbiAgICAgIG1zeCA9IDMyIC0gc3gsXFxuICAgICAgaCA9IHRhZy55MSAtIHRhZy55MCxcXG4gICAgICB4ID0gKHRhZy55ICsgdGFnLnkwKSAqIHN3ICsgKGx4ID4+IDUpLFxcbiAgICAgIGxhc3Q7XFxuICBmb3IgKHZhciBqID0gMDsgaiA8IGg7IGorKykge1xcbiAgICBsYXN0ID0gMDtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gdzsgaSsrKSB7XFxuICAgICAgaWYgKCgobGFzdCA8PCBtc3gpIHwgKGkgPCB3ID8gKGxhc3QgPSBzcHJpdGVbaiAqIHcgKyBpXSkgPj4+IHN4IDogMCkpXFxuICAgICAgICAgICYgYm9hcmRbeCArIGldKSByZXR1cm4gdHJ1ZTtcXG4gICAgfVxcbiAgICB4ICs9IHN3O1xcbiAgfVxcbiAgcmV0dXJuIGZhbHNlO1xcbn1cXG5cXG5mdW5jdGlvbiBjbG91ZEJvdW5kcyhib3VuZHMsIGQpIHtcXG4gIHZhciBiMCA9IGJvdW5kc1swXSxcXG4gICAgICBiMSA9IGJvdW5kc1sxXTtcXG4gIGlmIChkLnggKyBkLngwIDwgYjAueCkgYjAueCA9IGQueCArIGQueDA7XFxuICBpZiAoZC55ICsgZC55MCA8IGIwLnkpIGIwLnkgPSBkLnkgKyBkLnkwO1xcbiAgaWYgKGQueCArIGQueDEgPiBiMS54KSBiMS54ID0gZC54ICsgZC54MTtcXG4gIGlmIChkLnkgKyBkLnkxID4gYjEueSkgYjEueSA9IGQueSArIGQueTE7XFxufVxcblxcbmZ1bmN0aW9uIGNvbGxpZGVSZWN0cyhhLCBiKSB7XFxuICByZXR1cm4gYS54ICsgYS54MSA+IGJbMF0ueCAmJiBhLnggKyBhLngwIDwgYlsxXS54ICYmIGEueSArIGEueTEgPiBiWzBdLnkgJiYgYS55ICsgYS55MCA8IGJbMV0ueTtcXG59XFxuXFxuZnVuY3Rpb24gYXJjaGltZWRlYW5TcGlyYWwoc2l6ZSkge1xcbiAgdmFyIGUgPSBzaXplWzBdIC8gc2l6ZVsxXTtcXG4gIHJldHVybiBmdW5jdGlvbih0KSB7XFxuICAgIHJldHVybiBbZSAqICh0ICo9IC4xKSAqIE1hdGguY29zKHQpLCB0ICogTWF0aC5zaW4odCldO1xcbiAgfTtcXG59XFxuXFxuZnVuY3Rpb24gcmVjdGFuZ3VsYXJTcGlyYWwoc2l6ZSkge1xcbiAgdmFyIGR5ID0gNCxcXG4gICAgICBkeCA9IGR5ICogc2l6ZVswXSAvIHNpemVbMV0sXFxuICAgICAgeCA9IDAsXFxuICAgICAgeSA9IDA7XFxuICByZXR1cm4gZnVuY3Rpb24odCkge1xcbiAgICB2YXIgc2lnbiA9IHQgPCAwID8gLTEgOiAxO1xcbiAgICAvLyBTZWUgdHJpYW5ndWxhciBudW1iZXJzOiBUX24gPSBuICogKG4gKyAxKSAvIDIuXFxuICAgIHN3aXRjaCAoKE1hdGguc3FydCgxICsgNCAqIHNpZ24gKiB0KSAtIHNpZ24pICYgMykge1xcbiAgICAgIGNhc2UgMDogIHggKz0gZHg7IGJyZWFrO1xcbiAgICAgIGNhc2UgMTogIHkgKz0gZHk7IGJyZWFrO1xcbiAgICAgIGNhc2UgMjogIHggLT0gZHg7IGJyZWFrO1xcbiAgICAgIGRlZmF1bHQ6IHkgLT0gZHk7IGJyZWFrO1xcbiAgICB9XFxuICAgIHJldHVybiBbeCwgeV07XFxuICB9O1xcbn1cXG5cXG4vLyBUT0RPIHJldXNlIGFycmF5cz9cXG5mdW5jdGlvbiB6ZXJvQXJyYXkobikge1xcbiAgdmFyIGEgPSBbXSxcXG4gICAgICBpID0gLTE7XFxuICB3aGlsZSAoKytpIDwgbikgYVtpXSA9IDA7XFxuICByZXR1cm4gYTtcXG59XFxuXFxuZnVuY3Rpb24gY2xvdWRDYW52YXMoKSB7XFxuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcXFwiY2FudmFzXFxcIik7XFxufVxcblxcbmZ1bmN0aW9uIGZ1bmN0b3IoZCkge1xcbiAgcmV0dXJuIHR5cGVvZiBkID09PSBcXFwiZnVuY3Rpb25cXFwiID8gZCA6IGZ1bmN0aW9uKCkgeyByZXR1cm4gZDsgfTtcXG59XFxuXFxudmFyIHNwaXJhbHMgPSB7XFxuICBhcmNoaW1lZGVhbjogYXJjaGltZWRlYW5TcGlyYWwsXFxuICByZWN0YW5ndWxhcjogcmVjdGFuZ3VsYXJTcGlyYWxcXG59O1xcblxcbn0se1xcXCJkMy1kaXNwYXRjaFxcXCI6Mn1dLDI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbi8vIGh0dHBzOi8vZDNqcy5vcmcvZDMtZGlzcGF0Y2gvIFZlcnNpb24gMS4wLjIuIENvcHlyaWdodCAyMDE2IE1pa2UgQm9zdG9jay5cXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XFxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcXG4gIChmYWN0b3J5KChnbG9iYWwuZDMgPSBnbG9iYWwuZDMgfHwge30pKSk7XFxufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xcblxcbnZhciBub29wID0ge3ZhbHVlOiBmdW5jdGlvbigpIHt9fTtcXG5cXG5mdW5jdGlvbiBkaXNwYXRjaCgpIHtcXG4gIGZvciAodmFyIGkgPSAwLCBuID0gYXJndW1lbnRzLmxlbmd0aCwgXyA9IHt9LCB0OyBpIDwgbjsgKytpKSB7XFxuICAgIGlmICghKHQgPSBhcmd1bWVudHNbaV0gKyBcXFwiXFxcIikgfHwgKHQgaW4gXykpIHRocm93IG5ldyBFcnJvcihcXFwiaWxsZWdhbCB0eXBlOiBcXFwiICsgdCk7XFxuICAgIF9bdF0gPSBbXTtcXG4gIH1cXG4gIHJldHVybiBuZXcgRGlzcGF0Y2goXyk7XFxufVxcblxcbmZ1bmN0aW9uIERpc3BhdGNoKF8pIHtcXG4gIHRoaXMuXyA9IF87XFxufVxcblxcbmZ1bmN0aW9uIHBhcnNlVHlwZW5hbWVzKHR5cGVuYW1lcywgdHlwZXMpIHtcXG4gIHJldHVybiB0eXBlbmFtZXMudHJpbSgpLnNwbGl0KC9efFxcXFxzKy8pLm1hcChmdW5jdGlvbih0KSB7XFxuICAgIHZhciBuYW1lID0gXFxcIlxcXCIsIGkgPSB0LmluZGV4T2YoXFxcIi5cXFwiKTtcXG4gICAgaWYgKGkgPj0gMCkgbmFtZSA9IHQuc2xpY2UoaSArIDEpLCB0ID0gdC5zbGljZSgwLCBpKTtcXG4gICAgaWYgKHQgJiYgIXR5cGVzLmhhc093blByb3BlcnR5KHQpKSB0aHJvdyBuZXcgRXJyb3IoXFxcInVua25vd24gdHlwZTogXFxcIiArIHQpO1xcbiAgICByZXR1cm4ge3R5cGU6IHQsIG5hbWU6IG5hbWV9O1xcbiAgfSk7XFxufVxcblxcbkRpc3BhdGNoLnByb3RvdHlwZSA9IGRpc3BhdGNoLnByb3RvdHlwZSA9IHtcXG4gIGNvbnN0cnVjdG9yOiBEaXNwYXRjaCxcXG4gIG9uOiBmdW5jdGlvbih0eXBlbmFtZSwgY2FsbGJhY2spIHtcXG4gICAgdmFyIF8gPSB0aGlzLl8sXFxuICAgICAgICBUID0gcGFyc2VUeXBlbmFtZXModHlwZW5hbWUgKyBcXFwiXFxcIiwgXyksXFxuICAgICAgICB0LFxcbiAgICAgICAgaSA9IC0xLFxcbiAgICAgICAgbiA9IFQubGVuZ3RoO1xcblxcbiAgICAvLyBJZiBubyBjYWxsYmFjayB3YXMgc3BlY2lmaWVkLCByZXR1cm4gdGhlIGNhbGxiYWNrIG9mIHRoZSBnaXZlbiB0eXBlIGFuZCBuYW1lLlxcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcXG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKCh0ID0gKHR5cGVuYW1lID0gVFtpXSkudHlwZSkgJiYgKHQgPSBnZXQoX1t0XSwgdHlwZW5hbWUubmFtZSkpKSByZXR1cm4gdDtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgLy8gSWYgYSB0eXBlIHdhcyBzcGVjaWZpZWQsIHNldCB0aGUgY2FsbGJhY2sgZm9yIHRoZSBnaXZlbiB0eXBlIGFuZCBuYW1lLlxcbiAgICAvLyBPdGhlcndpc2UsIGlmIGEgbnVsbCBjYWxsYmFjayB3YXMgc3BlY2lmaWVkLCByZW1vdmUgY2FsbGJhY2tzIG9mIHRoZSBnaXZlbiBuYW1lLlxcbiAgICBpZiAoY2FsbGJhY2sgIT0gbnVsbCAmJiB0eXBlb2YgY2FsbGJhY2sgIT09IFxcXCJmdW5jdGlvblxcXCIpIHRocm93IG5ldyBFcnJvcihcXFwiaW52YWxpZCBjYWxsYmFjazogXFxcIiArIGNhbGxiYWNrKTtcXG4gICAgd2hpbGUgKCsraSA8IG4pIHtcXG4gICAgICBpZiAodCA9ICh0eXBlbmFtZSA9IFRbaV0pLnR5cGUpIF9bdF0gPSBzZXQoX1t0XSwgdHlwZW5hbWUubmFtZSwgY2FsbGJhY2spO1xcbiAgICAgIGVsc2UgaWYgKGNhbGxiYWNrID09IG51bGwpIGZvciAodCBpbiBfKSBfW3RdID0gc2V0KF9bdF0sIHR5cGVuYW1lLm5hbWUsIG51bGwpO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiB0aGlzO1xcbiAgfSxcXG4gIGNvcHk6IGZ1bmN0aW9uKCkge1xcbiAgICB2YXIgY29weSA9IHt9LCBfID0gdGhpcy5fO1xcbiAgICBmb3IgKHZhciB0IGluIF8pIGNvcHlbdF0gPSBfW3RdLnNsaWNlKCk7XFxuICAgIHJldHVybiBuZXcgRGlzcGF0Y2goY29weSk7XFxuICB9LFxcbiAgY2FsbDogZnVuY3Rpb24odHlwZSwgdGhhdCkge1xcbiAgICBpZiAoKG4gPSBhcmd1bWVudHMubGVuZ3RoIC0gMikgPiAwKSBmb3IgKHZhciBhcmdzID0gbmV3IEFycmF5KG4pLCBpID0gMCwgbiwgdDsgaSA8IG47ICsraSkgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMl07XFxuICAgIGlmICghdGhpcy5fLmhhc093blByb3BlcnR5KHR5cGUpKSB0aHJvdyBuZXcgRXJyb3IoXFxcInVua25vd24gdHlwZTogXFxcIiArIHR5cGUpO1xcbiAgICBmb3IgKHQgPSB0aGlzLl9bdHlwZV0sIGkgPSAwLCBuID0gdC5sZW5ndGg7IGkgPCBuOyArK2kpIHRbaV0udmFsdWUuYXBwbHkodGhhdCwgYXJncyk7XFxuICB9LFxcbiAgYXBwbHk6IGZ1bmN0aW9uKHR5cGUsIHRoYXQsIGFyZ3MpIHtcXG4gICAgaWYgKCF0aGlzLl8uaGFzT3duUHJvcGVydHkodHlwZSkpIHRocm93IG5ldyBFcnJvcihcXFwidW5rbm93biB0eXBlOiBcXFwiICsgdHlwZSk7XFxuICAgIGZvciAodmFyIHQgPSB0aGlzLl9bdHlwZV0sIGkgPSAwLCBuID0gdC5sZW5ndGg7IGkgPCBuOyArK2kpIHRbaV0udmFsdWUuYXBwbHkodGhhdCwgYXJncyk7XFxuICB9XFxufTtcXG5cXG5mdW5jdGlvbiBnZXQodHlwZSwgbmFtZSkge1xcbiAgZm9yICh2YXIgaSA9IDAsIG4gPSB0eXBlLmxlbmd0aCwgYzsgaSA8IG47ICsraSkge1xcbiAgICBpZiAoKGMgPSB0eXBlW2ldKS5uYW1lID09PSBuYW1lKSB7XFxuICAgICAgcmV0dXJuIGMudmFsdWU7XFxuICAgIH1cXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gc2V0KHR5cGUsIG5hbWUsIGNhbGxiYWNrKSB7XFxuICBmb3IgKHZhciBpID0gMCwgbiA9IHR5cGUubGVuZ3RoOyBpIDwgbjsgKytpKSB7XFxuICAgIGlmICh0eXBlW2ldLm5hbWUgPT09IG5hbWUpIHtcXG4gICAgICB0eXBlW2ldID0gbm9vcCwgdHlwZSA9IHR5cGUuc2xpY2UoMCwgaSkuY29uY2F0KHR5cGUuc2xpY2UoaSArIDEpKTtcXG4gICAgICBicmVhaztcXG4gICAgfVxcbiAgfVxcbiAgaWYgKGNhbGxiYWNrICE9IG51bGwpIHR5cGUucHVzaCh7bmFtZTogbmFtZSwgdmFsdWU6IGNhbGxiYWNrfSk7XFxuICByZXR1cm4gdHlwZTtcXG59XFxuXFxuZXhwb3J0cy5kaXNwYXRjaCA9IGRpc3BhdGNoO1xcblxcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XFxuXFxufSkpKTtcXG5cXG59LHt9XX0se30sWzFdKSgxKVxcbn0pO1wiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvcmF3LWxvYWRlciEuL25vZGVfbW9kdWxlcy9kMy1jbG91ZC9idWlsZC9kMy5sYXlvdXQuY2xvdWQuanNcbi8vIG1vZHVsZSBpZCA9IDE5NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///196\n')},function(module,exports){eval("/*\n * angular-d3-word-cloud 0.5.3\n * Running example base on express server\n * https://weihanchen.github.io/angular-d3-word-cloud/\n *\n * Released under the MIT license.\n*/\n\n(function () {\r\n   'use strict';\r\n   angular.module('angular-d3-word-cloud', [])\r\n      .directive('wordCloud', [wordCloud]);\r\n\r\n   function wordCloud() {\r\n      return {\r\n         restrict: 'E',\r\n         scope: {\r\n            height: '=',\r\n            padding: '=?',\r\n            rotate: '=?',\r\n            useTooltip: '=?',\r\n            useTransition: '=?',\r\n            words: '=',\r\n            width: '=',\r\n            random: '=',\r\n            onClick: '='\r\n         },\r\n         template: '<div></div>',\r\n         controller: ['$scope', '$element', wordsCloudController],\r\n         controllerAs: 'wordsCloudCtrl',\r\n         bindToController: true\r\n      };\r\n\r\n      function wordsCloudController($scope, $element) {\r\n         var self = this;\r\n         /* istanbul ignore next */\r\n         var fill = (d3.hasOwnProperty('scale')) ? d3.scale.category20() : d3.scaleOrdinal(d3.schemeCategory20);\r\n         var tooltip = d3.select('body')\r\n            .append('div')\r\n            .style('position', 'absolute')\r\n            .style('visibility', 'hidden');\r\n         /**\r\n          * layout grnerator by d3 and use drawListener to generate word cloud.\r\n          */\r\n         var layout = d3.layout.cloud()\r\n            .fontSize(function (d) {\r\n               return d.size;\r\n            })\r\n            .on('end', drawListener);\r\n\r\n         $scope.$watch(watchParameters, watchListener, true);\r\n\r\n         function defaultRotate() {\r\n            return ~~(Math.random() * 2) * 60;\r\n         }\r\n\r\n         function drawListener(words) {\r\n            var wordsCloudSVGDiv = d3.select($element[0]);\r\n            var width = layout.size()[0];\r\n            var height = layout.size()[1];\r\n            wordsCloudSVGDiv.select('svg').remove();\r\n            wordsCloudSVGDiv.append('svg')\r\n               .attr('width', width)\r\n               .attr('height', height)\r\n               .append('g')\r\n               .attr('transform', 'translate(' + width / 2 + ',' + height / 2 + ')')\r\n               .selectAll('text')\r\n               .data(words)\r\n               .enter().append('text')\r\n               .on('click', function (d) { //call back clicked element\r\n                  if (self.onClick) self.onClick(d);\r\n               })\r\n               .on('mouseover', function (d) { //zoom in font-size\r\n                  if (self.useTooltip) {\r\n                     tooltip.style('font-size', d.size + 'px').style('visibility', 'visible').text(d.tooltipText || d.text);\r\n                  }\r\n                  if (self.useTransition) {\r\n                     d3.select(this).transition().style('font-size', function (d) {\r\n                        return d.size * 1.2 + 'px';\r\n                     }).attr('opacity', 0.5);\r\n                  }\r\n               })\r\n               .on('mouseout', function () {\r\n                  if (self.useTooltip) {\r\n                     tooltip.style('visibility', 'hidden');\r\n                  }\r\n                  if (self.useTransition) {\r\n                     d3.select(this).transition().style('font-size', function (d) {\r\n                        return d.size + 'px';\r\n                     }).attr('opacity', 1);\r\n                  }\r\n               })\r\n               .on('mousemove', function () { return tooltip.style('top', (event.pageY - 10) + 'px').style('left', (event.pageX + 10) + 'px'); })\r\n               .style('font-size', function (d) {\r\n                  return d.size + 'px';\r\n               })\r\n               .style('font-family', 'Impact')\r\n               .style('fill', function (d, i) {\r\n                  return d.color || fill(i);\r\n               })\r\n               .attr('text-anchor', 'middle')\r\n               .attr('cursor', 'pointer')\r\n               .transition()\r\n               .attr('transform', function (d) {\r\n                  return 'translate(' + [d.x, d.y] + ')rotate(' + d.rotate + ')';\r\n               })\r\n               .text(function (d) {\r\n                  return d.text;\r\n               });\r\n         }\r\n\r\n         function updateLayout(width, height, words, padding, rotate, random) {\r\n            padding = padding || 5;\r\n            rotate = rotate || defaultRotate;\r\n            random = random || Math.random;\r\n            layout.size([width, height])\r\n               .rotate(rotate)\r\n               .random(random)\r\n               .padding(padding)\r\n               .words(words);\r\n            layout.start();\r\n         }\r\n\r\n         /**\r\n          * watch binding scope parameters\r\n          */\r\n         function watchParameters() {\r\n            return self;\r\n         }\r\n\r\n         function watchListener(newVal) {\r\n            var parameters = angular.copy(newVal);\r\n            if (angular.isUndefined(parameters.words) || angular.isUndefined(parameters.width) || angular.isUndefined(parameters.height)) return;\r\n            updateLayout(parameters.width, parameters.height, parameters.words, parameters.padding, parameters.rotate, parameters.random);\r\n         }\r\n      }\r\n   }\r\n})();\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTk3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2FuZ3VsYXItZDMtd29yZC1jbG91ZC9kaXN0L2FuZ3VsYXItd29yZC1jbG91ZC5qcz85NTU4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBhbmd1bGFyLWQzLXdvcmQtY2xvdWQgMC41LjNcbiAqIFJ1bm5pbmcgZXhhbXBsZSBiYXNlIG9uIGV4cHJlc3Mgc2VydmVyXG4gKiBodHRwczovL3dlaWhhbmNoZW4uZ2l0aHViLmlvL2FuZ3VsYXItZDMtd29yZC1jbG91ZC9cbiAqXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4qL1xuXG4oZnVuY3Rpb24gKCkge1xyXG4gICAndXNlIHN0cmljdCc7XHJcbiAgIGFuZ3VsYXIubW9kdWxlKCdhbmd1bGFyLWQzLXdvcmQtY2xvdWQnLCBbXSlcclxuICAgICAgLmRpcmVjdGl2ZSgnd29yZENsb3VkJywgW3dvcmRDbG91ZF0pO1xyXG5cclxuICAgZnVuY3Rpb24gd29yZENsb3VkKCkge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgICByZXN0cmljdDogJ0UnLFxyXG4gICAgICAgICBzY29wZToge1xyXG4gICAgICAgICAgICBoZWlnaHQ6ICc9JyxcclxuICAgICAgICAgICAgcGFkZGluZzogJz0/JyxcclxuICAgICAgICAgICAgcm90YXRlOiAnPT8nLFxyXG4gICAgICAgICAgICB1c2VUb29sdGlwOiAnPT8nLFxyXG4gICAgICAgICAgICB1c2VUcmFuc2l0aW9uOiAnPT8nLFxyXG4gICAgICAgICAgICB3b3JkczogJz0nLFxyXG4gICAgICAgICAgICB3aWR0aDogJz0nLFxyXG4gICAgICAgICAgICByYW5kb206ICc9JyxcclxuICAgICAgICAgICAgb25DbGljazogJz0nXHJcbiAgICAgICAgIH0sXHJcbiAgICAgICAgIHRlbXBsYXRlOiAnPGRpdj48L2Rpdj4nLFxyXG4gICAgICAgICBjb250cm9sbGVyOiBbJyRzY29wZScsICckZWxlbWVudCcsIHdvcmRzQ2xvdWRDb250cm9sbGVyXSxcclxuICAgICAgICAgY29udHJvbGxlckFzOiAnd29yZHNDbG91ZEN0cmwnLFxyXG4gICAgICAgICBiaW5kVG9Db250cm9sbGVyOiB0cnVlXHJcbiAgICAgIH07XHJcblxyXG4gICAgICBmdW5jdGlvbiB3b3Jkc0Nsb3VkQ29udHJvbGxlcigkc2NvcGUsICRlbGVtZW50KSB7XHJcbiAgICAgICAgIHZhciBzZWxmID0gdGhpcztcclxuICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICAgdmFyIGZpbGwgPSAoZDMuaGFzT3duUHJvcGVydHkoJ3NjYWxlJykpID8gZDMuc2NhbGUuY2F0ZWdvcnkyMCgpIDogZDMuc2NhbGVPcmRpbmFsKGQzLnNjaGVtZUNhdGVnb3J5MjApO1xyXG4gICAgICAgICB2YXIgdG9vbHRpcCA9IGQzLnNlbGVjdCgnYm9keScpXHJcbiAgICAgICAgICAgIC5hcHBlbmQoJ2RpdicpXHJcbiAgICAgICAgICAgIC5zdHlsZSgncG9zaXRpb24nLCAnYWJzb2x1dGUnKVxyXG4gICAgICAgICAgICAuc3R5bGUoJ3Zpc2liaWxpdHknLCAnaGlkZGVuJyk7XHJcbiAgICAgICAgIC8qKlxyXG4gICAgICAgICAgKiBsYXlvdXQgZ3JuZXJhdG9yIGJ5IGQzIGFuZCB1c2UgZHJhd0xpc3RlbmVyIHRvIGdlbmVyYXRlIHdvcmQgY2xvdWQuXHJcbiAgICAgICAgICAqL1xyXG4gICAgICAgICB2YXIgbGF5b3V0ID0gZDMubGF5b3V0LmNsb3VkKClcclxuICAgICAgICAgICAgLmZvbnRTaXplKGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgIHJldHVybiBkLnNpemU7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5vbignZW5kJywgZHJhd0xpc3RlbmVyKTtcclxuXHJcbiAgICAgICAgICRzY29wZS4kd2F0Y2god2F0Y2hQYXJhbWV0ZXJzLCB3YXRjaExpc3RlbmVyLCB0cnVlKTtcclxuXHJcbiAgICAgICAgIGZ1bmN0aW9uIGRlZmF1bHRSb3RhdGUoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB+fihNYXRoLnJhbmRvbSgpICogMikgKiA2MDtcclxuICAgICAgICAgfVxyXG5cclxuICAgICAgICAgZnVuY3Rpb24gZHJhd0xpc3RlbmVyKHdvcmRzKSB7XHJcbiAgICAgICAgICAgIHZhciB3b3Jkc0Nsb3VkU1ZHRGl2ID0gZDMuc2VsZWN0KCRlbGVtZW50WzBdKTtcclxuICAgICAgICAgICAgdmFyIHdpZHRoID0gbGF5b3V0LnNpemUoKVswXTtcclxuICAgICAgICAgICAgdmFyIGhlaWdodCA9IGxheW91dC5zaXplKClbMV07XHJcbiAgICAgICAgICAgIHdvcmRzQ2xvdWRTVkdEaXYuc2VsZWN0KCdzdmcnKS5yZW1vdmUoKTtcclxuICAgICAgICAgICAgd29yZHNDbG91ZFNWR0Rpdi5hcHBlbmQoJ3N2ZycpXHJcbiAgICAgICAgICAgICAgIC5hdHRyKCd3aWR0aCcsIHdpZHRoKVxyXG4gICAgICAgICAgICAgICAuYXR0cignaGVpZ2h0JywgaGVpZ2h0KVxyXG4gICAgICAgICAgICAgICAuYXBwZW5kKCdnJylcclxuICAgICAgICAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIHdpZHRoIC8gMiArICcsJyArIGhlaWdodCAvIDIgKyAnKScpXHJcbiAgICAgICAgICAgICAgIC5zZWxlY3RBbGwoJ3RleHQnKVxyXG4gICAgICAgICAgICAgICAuZGF0YSh3b3JkcylcclxuICAgICAgICAgICAgICAgLmVudGVyKCkuYXBwZW5kKCd0ZXh0JylcclxuICAgICAgICAgICAgICAgLm9uKCdjbGljaycsIGZ1bmN0aW9uIChkKSB7IC8vY2FsbCBiYWNrIGNsaWNrZWQgZWxlbWVudFxyXG4gICAgICAgICAgICAgICAgICBpZiAoc2VsZi5vbkNsaWNrKSBzZWxmLm9uQ2xpY2soZCk7XHJcbiAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgIC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKGQpIHsgLy96b29tIGluIGZvbnQtc2l6ZVxyXG4gICAgICAgICAgICAgICAgICBpZiAoc2VsZi51c2VUb29sdGlwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgIHRvb2x0aXAuc3R5bGUoJ2ZvbnQtc2l6ZScsIGQuc2l6ZSArICdweCcpLnN0eWxlKCd2aXNpYmlsaXR5JywgJ3Zpc2libGUnKS50ZXh0KGQudG9vbHRpcFRleHQgfHwgZC50ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICBpZiAoc2VsZi51c2VUcmFuc2l0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS50cmFuc2l0aW9uKCkuc3R5bGUoJ2ZvbnQtc2l6ZScsIGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkLnNpemUgKiAxLjIgKyAncHgnO1xyXG4gICAgICAgICAgICAgICAgICAgICB9KS5hdHRyKCdvcGFjaXR5JywgMC41KTtcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAub24oJ21vdXNlb3V0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICBpZiAoc2VsZi51c2VUb29sdGlwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgIHRvb2x0aXAuc3R5bGUoJ3Zpc2liaWxpdHknLCAnaGlkZGVuJyk7XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgaWYgKHNlbGYudXNlVHJhbnNpdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICBkMy5zZWxlY3QodGhpcykudHJhbnNpdGlvbigpLnN0eWxlKCdmb250LXNpemUnLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZC5zaXplICsgJ3B4JztcclxuICAgICAgICAgICAgICAgICAgICAgfSkuYXR0cignb3BhY2l0eScsIDEpO1xyXG4gICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgIC5vbignbW91c2Vtb3ZlJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gdG9vbHRpcC5zdHlsZSgndG9wJywgKGV2ZW50LnBhZ2VZIC0gMTApICsgJ3B4Jykuc3R5bGUoJ2xlZnQnLCAoZXZlbnQucGFnZVggKyAxMCkgKyAncHgnKTsgfSlcclxuICAgICAgICAgICAgICAgLnN0eWxlKCdmb250LXNpemUnLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICAgICAgICByZXR1cm4gZC5zaXplICsgJ3B4JztcclxuICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgLnN0eWxlKCdmb250LWZhbWlseScsICdJbXBhY3QnKVxyXG4gICAgICAgICAgICAgICAuc3R5bGUoJ2ZpbGwnLCBmdW5jdGlvbiAoZCwgaSkge1xyXG4gICAgICAgICAgICAgICAgICByZXR1cm4gZC5jb2xvciB8fCBmaWxsKGkpO1xyXG4gICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAuYXR0cigndGV4dC1hbmNob3InLCAnbWlkZGxlJylcclxuICAgICAgICAgICAgICAgLmF0dHIoJ2N1cnNvcicsICdwb2ludGVyJylcclxuICAgICAgICAgICAgICAgLnRyYW5zaXRpb24oKVxyXG4gICAgICAgICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoJyArIFtkLngsIGQueV0gKyAnKXJvdGF0ZSgnICsgZC5yb3RhdGUgKyAnKSc7XHJcbiAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uIChkKSB7XHJcbiAgICAgICAgICAgICAgICAgIHJldHVybiBkLnRleHQ7XHJcbiAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICB9XHJcblxyXG4gICAgICAgICBmdW5jdGlvbiB1cGRhdGVMYXlvdXQod2lkdGgsIGhlaWdodCwgd29yZHMsIHBhZGRpbmcsIHJvdGF0ZSwgcmFuZG9tKSB7XHJcbiAgICAgICAgICAgIHBhZGRpbmcgPSBwYWRkaW5nIHx8IDU7XHJcbiAgICAgICAgICAgIHJvdGF0ZSA9IHJvdGF0ZSB8fCBkZWZhdWx0Um90YXRlO1xyXG4gICAgICAgICAgICByYW5kb20gPSByYW5kb20gfHwgTWF0aC5yYW5kb207XHJcbiAgICAgICAgICAgIGxheW91dC5zaXplKFt3aWR0aCwgaGVpZ2h0XSlcclxuICAgICAgICAgICAgICAgLnJvdGF0ZShyb3RhdGUpXHJcbiAgICAgICAgICAgICAgIC5yYW5kb20ocmFuZG9tKVxyXG4gICAgICAgICAgICAgICAucGFkZGluZyhwYWRkaW5nKVxyXG4gICAgICAgICAgICAgICAud29yZHMod29yZHMpO1xyXG4gICAgICAgICAgICBsYXlvdXQuc3RhcnQoKTtcclxuICAgICAgICAgfVxyXG5cclxuICAgICAgICAgLyoqXHJcbiAgICAgICAgICAqIHdhdGNoIGJpbmRpbmcgc2NvcGUgcGFyYW1ldGVyc1xyXG4gICAgICAgICAgKi9cclxuICAgICAgICAgZnVuY3Rpb24gd2F0Y2hQYXJhbWV0ZXJzKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gc2VsZjtcclxuICAgICAgICAgfVxyXG5cclxuICAgICAgICAgZnVuY3Rpb24gd2F0Y2hMaXN0ZW5lcihuZXdWYWwpIHtcclxuICAgICAgICAgICAgdmFyIHBhcmFtZXRlcnMgPSBhbmd1bGFyLmNvcHkobmV3VmFsKTtcclxuICAgICAgICAgICAgaWYgKGFuZ3VsYXIuaXNVbmRlZmluZWQocGFyYW1ldGVycy53b3JkcykgfHwgYW5ndWxhci5pc1VuZGVmaW5lZChwYXJhbWV0ZXJzLndpZHRoKSB8fCBhbmd1bGFyLmlzVW5kZWZpbmVkKHBhcmFtZXRlcnMuaGVpZ2h0KSkgcmV0dXJuO1xyXG4gICAgICAgICAgICB1cGRhdGVMYXlvdXQocGFyYW1ldGVycy53aWR0aCwgcGFyYW1ldGVycy5oZWlnaHQsIHBhcmFtZXRlcnMud29yZHMsIHBhcmFtZXRlcnMucGFkZGluZywgcGFyYW1ldGVycy5yb3RhdGUsIHBhcmFtZXRlcnMucmFuZG9tKTtcclxuICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgIH1cclxufSkoKTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvYW5ndWxhci1kMy13b3JkLWNsb3VkL2Rpc3QvYW5ndWxhci13b3JkLWNsb3VkLmpzXG4vLyBtb2R1bGUgaWQgPSAxOTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///197\n")},function(module,exports,__webpack_require__){eval('var pug = __webpack_require__(39);\n\nfunction template(locals) {var pug_html = "", pug_mixins = {}, pug_interp;pug_html = pug_html + "\\u003Cdiv class=\\"container\\"\\u003E\\u003Cdiv class=\\"form-group has-feedback\\" ng-class=\\"{ \'has-success\' : $ctrl.isEndpointValid === true, \'has-error\' : $ctrl.isEndpointValid === false}\\"\\u003E\\u003Clabel\\u003EEndpoint\\u003C\\u002Flabel\\u003E\\u003Cinput class=\\"form-control\\" type=\\"text\\" ng-model=\\"$ctrl.endpoint\\" ng-change=\\"$ctrl.endpointChanged()\\"\\u003E\\u003Cspan class=\\"glyphicon glyphicon-ok form-control-feedback\\" ng-show=\\"$ctrl.isEndpointValid\\"\\u003E\\u003C\\u002Fspan\\u003E\\u003Cspan class=\\"glyphicon glyphicon-remove form-control-feedback\\" ng-show=\\"!$ctrl.isEndpointValid\\"\\u003E\\u003C\\u002Fspan\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\"form-group\\"\\u003E\\u003Clabel\\u003EDefault query level\\u003C\\u002Flabel\\u003E\\u003Cselect class=\\"form-control\\" ng-model=\\"$ctrl.defaultLevel\\" ng-options=\\"level for level in $ctrl.availableLevels\\"\\u003E\\u003C\\u002Fselect\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\"form-group\\"\\u003E\\u003Clabel\\u003EQuery\\u003C\\u002Flabel\\u003E\\u003Ctextarea class=\\"form-control\\" ng-model=\\"$ctrl.query\\"\\u003E\\u003C\\u002Ftextarea\\u003E\\u003Cp class=\\"help-block\\"\\u003EUnderstands an expanded form of \\u003Ca href=\\"http:\\u002F\\u002Flucene.apache.org\\u002Fcore\\u002F6_5_1\\u002Fqueryparser\\u002Forg\\u002Fapache\\u002Flucene\\u002Fqueryparser\\u002Fclassic\\u002Fpackage-summary.html#package.description\\"\\u003ELucene query parser syntax\\u003C\\u002Fa\\u003E.\\u003C\\u002Fp\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\"form-group\\"\\u003E\\u003Clabel\\u003ELimit\\u003C\\u002Flabel\\u003E\\u003Cinput class=\\"form-control\\" type=\\"number\\" ng-model=\\"$ctrl.limit\\"\\u003E\\u003Cp class=\\"help-block\\"\\u003E-1 for no limit\\u003C\\u002Fp\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\"form-group\\"\\u003E\\u003Clabel\\u003EMaximum number of documents to process\\u003C\\u002Flabel\\u003E\\u003Cinput class=\\"form-control\\" type=\\"number\\" ng-model=\\"$ctrl.maxDocs\\"\\u003E\\u003Cp class=\\"help-block\\"\\u003EMore hits than this triggers probabilistic sampling. -1 for no limit.\\u003C\\u002Fp\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\"form-group\\"\\u003E\\u003Cdiv class=\\"checkbox\\"\\u003E\\u003Clabel\\u003E \\u003Cinput type=\\"checkbox\\" ng-model=\\"$ctrl.mds\\"\\u003EPlot terms in MDS space\\u003C\\u002Flabel\\u003E\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\"form-group\\"\\u003E\\u003Clabel\\u003EFurther options\\u003C\\u002Flabel\\u003E\\u003Cinput class=\\"form-control\\" type=\\"text\\" ng-model=\\"$ctrl.furtherOptions\\"\\u003E\\u003C\\u002Fdiv\\u003E\\u003Ch2 ng-click=\\"$ctrl.showWeightingOptions=!$ctrl.showWeightingOptions\\"\\u003ETerm weighting\\u003Cspan class=\\"glyphicon glyphicon-chevron-down\\" ng-show=\\"!$ctrl.showWeightingOptions\\"\\u003E\\u003C\\u002Fspan\\u003E\\u003Cspan class=\\"glyphicon glyphicon-chevron-up\\" ng-show=\\"$ctrl.showWeightingOptions\\"\\u003E\\u003C\\u002Fspan\\u003E\\u003C\\u002Fh2\\u003E\\u003Cdiv ng-show=\\"$ctrl.showWeightingOptions\\"\\u003E\\u003Cdiv class=\\"form-group\\"\\u003E\\u003Clabel\\u003Eaggregate weighting formula\\u003C\\u002Flabel\\u003E\\u003Cselect class=\\"form-control\\" ng-model=\\"$ctrl.sumScaling\\"\\u003E\\u003Coption value=\\"ABSOLUTE\\"\\u003Eabsolute counts\\u003C\\u002Foption\\u003E\\u003Coption value=\\"TTF\\"\\u003Eterm frequency weighted counts\\u003C\\u002Foption\\u003E\\u003Coption value=\\"DF\\"\\u003Edocument frequency weighted counts\\u003C\\u002Foption\\u003E\\u003C\\u002Fselect\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\"form-group\\"\\u003E\\u003Clabel\\u003ELaplace smoothing to use when weighting\\u003C\\u002Flabel\\u003E\\u003Cinput class=\\"form-control\\" type=\\"number\\" ng-model=\\"$ctrl.smoothing\\"\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\"form-group\\"\\u003E\\u003Clabel\\u003Elocal weighting formula\\u003C\\u002Flabel\\u003E\\u003Cselect class=\\"form-control\\" ng-model=\\"$ctrl.localScaling\\"\\u003E\\u003Coption value=\\"ABSOLUTE\\"\\u003Eabsolute occurrence count\\u003C\\u002Foption\\u003E\\u003Coption value=\\"MIN\\"\\u003Eabsolute count up to query frequency\\u003C\\u002Foption\\u003E\\u003Coption value=\\"FLAT\\"\\u003Eone occurrence counted per document\\u003C\\u002Foption\\u003E\\u003C\\u002Fselect\\u003E\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fdiv\\u003E\\u003Ch2 ng-click=\\"$ctrl.showFilteringOptions=!$ctrl.showFilteringOptions\\"\\u003ETerm filtering\\u003Cspan class=\\"glyphicon glyphicon-chevron-down\\" ng-show=\\"!$ctrl.showFilteringOptions\\"\\u003E\\u003C\\u002Fspan\\u003E\\u003Cspan class=\\"glyphicon glyphicon-chevron-up\\" ng-show=\\"$ctrl.showFilteringOptions\\"\\u003E\\u003C\\u002Fspan\\u003E\\u003C\\u002Fh2\\u003E\\u003Cdiv ng-show=\\"$ctrl.showFilteringOptions\\"\\u003E\\u003Cplotly data=\\"$ctrl.tfData\\" layout=\\"$ctrl.tfLayout\\"\\u003E\\u003C\\u002Fplotly\\u003E\\u003Cdiv class=\\"form-group\\"\\u003E\\u003Clabel\\u003EMinimum total term frequency for term\\u003C\\u002Flabel\\u003E\\u003Cinput class=\\"form-control\\" type=\\"number\\" ng-model=\\"$ctrl.minTotalTermFreq\\"\\u003E\\u003Cp class=\\"help-block\\" ng-show=\\"$ctrl.mquantiles\\"\\u003E 90% of terms have frequency {{$ctrl.mquantiles[0] | number}} or more.\\u003Cbr \\u002F\\u003E50%: {{$ctrl.mquantiles[1] | number}} or more, \\u003Cbr \\u002F\\u003E20%: {{$ctrl.mquantiles[2] | number}} or more, \\u003Cbr \\u002F\\u003E10%: {{$ctrl.mquantiles[3] | number}} or more.\\u003C\\u002Fp\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\"form-group\\"\\u003E\\u003Clabel\\u003EMaximum total term frequency for term\\u003C\\u002Flabel\\u003E\\u003Cinput class=\\"form-control\\" type=\\"number\\" ng-model=\\"$ctrl.maxTotalTermFreq\\"\\u003E\\u003Cp class=\\"help-block\\"\\u003E\\u003Cspan ng-show=\\"$ctrl.quantiles\\"\\u003E95% of terms have frequency {{$ctrl.quantiles[0] | number}} or less. \\u003Cbr \\u002F\\u003E99%: {{$ctrl.quantiles[1] | number}} or less, \\u003Cbr \\u002F\\u003E99.5%: {{$ctrl.quantiles[2] | number}} or less, \\u003Cbr \\u002F\\u003E99.9%: {{$ctrl.quantiles[3] | number}} or less, \\u003Cbr \\u002F\\u003E100%: {{$ctrl.quantiles[4] | number}} or less.\\u003Cbr \\u002F\\u003E\\u003C\\u002Fspan\\u003E\\u003Cspan\\u003E-1 for no limit.\\u003C\\u002Fspan\\u003E\\u003C\\u002Fp\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cplotly data=\\"$ctrl.dfData\\" layout=\\"$ctrl.dfLayout\\"\\u003E\\u003C\\u002Fplotly\\u003E\\u003Cdiv class=\\"form-group\\"\\u003E\\u003Clabel\\u003EMinimum total document frequency for term\\u003C\\u002Flabel\\u003E\\u003Cinput class=\\"form-control\\" type=\\"number\\" ng-model=\\"$ctrl.minDocFreq\\"\\u003E\\u003Cp class=\\"help-block\\" ng-show=\\"$ctrl.mdquantiles\\"\\u003E 90% of terms have frequency {{$ctrl.mdquantiles[0] | number}} or more. \\u003Cbr \\u002F\\u003E50%: {{$ctrl.mdquantiles[1] | number}} or more, \\u003Cbr \\u002F\\u003E20%: {{$ctrl.mdquantiles[2] | number}} or more, \\u003Cbr \\u002F\\u003E10%: {{$ctrl.mdquantiles[3] | number}} or more.\\u003C\\u002Fp\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\"form-group\\"\\u003E\\u003Clabel\\u003EMaximum total document frequency for term\\u003C\\u002Flabel\\u003E\\u003Cinput class=\\"form-control\\" type=\\"number\\" ng-model=\\"$ctrl.maxDocFreq\\"\\u003E\\u003Cp class=\\"help-block\\"\\u003E\\u003Cspan ng-show=\\"$ctrl.dquantiles\\"\\u003E95% of terms have frequency {{$ctrl.dquantiles[0] | number}} or less. \\u003Cbr \\u002F\\u003E99%: {{$ctrl.dquantiles[1] | number}} or less, \\u003Cbr \\u002F\\u003E99.5%: {{$ctrl.dquantiles[2] | number}} or less, \\u003Cbr \\u002F\\u003E99.9%: {{$ctrl.dquantiles[3] | number}} or less, \\u003Cbr \\u002F\\u003E100% {{$ctrl.dquantiles[4] | number}} or less.\\u003Cbr \\u002F\\u003E\\u003C\\u002Fspan\\u003E\\u003Cspan\\u003E-1 for no limit.\\u003C\\u002Fspan\\u003E\\u003C\\u002Fp\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\"form-group\\"\\u003E\\u003Clabel\\u003EMinimum occurrences for term with regard to query\\u003C\\u002Flabel\\u003E\\u003Cinput class=\\"form-control\\" type=\\"number\\" ng-model=\\"$ctrl.minSumFreq\\"\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\"form-group\\"\\u003E\\u003Clabel\\u003EMaximum occurrences for term with regard to query\\u003C\\u002Flabel\\u003E\\u003Cinput class=\\"form-control\\" type=\\"number\\" ng-model=\\"$ctrl.maxSumFreq\\"\\u003E\\u003Cp class=\\"help-block\\"\\u003E-1 for no limit.\\u003C\\u002Fp\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\"form-group\\"\\u003E\\u003Clabel\\u003EMinimum occurrences for term inside a single document for that document to be counted\\u003C\\u002Flabel\\u003E\\u003Cinput class=\\"form-control\\" type=\\"number\\" ng-model=\\"$ctrl.minFreqInDoc\\"\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\"form-group\\"\\u003E\\u003Clabel\\u003EMaximum occurrences for term inside a single document for that document to be counted\\u003C\\u002Flabel\\u003E\\u003Cinput class=\\"form-control\\" type=\\"number\\" ng-model=\\"$ctrl.maxFreqInDoc\\"\\u003E\\u003Cp class=\\"help-block\\"\\u003E-1 for no limit.\\u003C\\u002Fp\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\"form-group\\"\\u003E\\u003Clabel\\u003EMinimum term length\\u003C\\u002Flabel\\u003E\\u003Cinput class=\\"form-control\\" type=\\"number\\" ng-model=\\"$ctrl.minTermLength\\"\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\"form-group\\"\\u003E\\u003Clabel\\u003EMaximum term length\\u003C\\u002Flabel\\u003E\\u003Cinput class=\\"form-control\\" type=\\"number\\" ng-model=\\"$ctrl.maxTermLength\\"\\u003E\\u003Cp class=\\"help-block\\"\\u003E-1 for no limit.\\u003C\\u002Fp\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\"form-group\\"\\u003E\\u003Clabel\\u003ETerm filter\\u003C\\u002Flabel\\u003E\\u003Cinput class=\\"form-control\\" type=\\"text\\" ng-model=\\"$ctrl.termFilter\\"\\u003E\\u003Cp class=\\"help-block\\"\\u003EGroovy expression returning a boolean. Term=term      \\u003C\\u002Fp\\u003E\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cbutton class=\\"btn btn-success\\" ng-click=\\"$ctrl.runQuery()\\" ng-disabled=\\"$ctrl.queryRunning\\"\\u003EQuery\\u003Cspan ng-show=\\"$ctrl.queryRunning\\"\\u003E&nbsp;\\u003Cspan class=\\"glyphicon glyphicon-hourglass\\"\\u003E\\u003C\\u002Fspan\\u003E\\u003C\\u002Fspan\\u003E\\u003C\\u002Fbutton\\u003E\\u003Cdiv ng-show=\\"$ctrl.error\\"\\u003E\\u003Ch2\\u003EQuery resulted in error:\\u003C\\u002Fh2\\u003E{{$ctrl.error}}\\u003C\\u002Fdiv\\u003E\\u003Cdiv ng-show=\\"!$ctrl.queryRunning\\"\\u003E{{$ctrl.totalResults}}\\u003Cplotly ng-show=\\"$ctrl.mds\\" data=\\"$ctrl.mdsData\\" layout=\\"$ctrl.mdsLayout\\" on-click=\\"$ctrl.mdsWordClicked(data)\\"\\u003E\\u003C\\u002Fplotly\\u003E\\u003Cword-cloud ng-show=\\"!$ctrl.mds\\" words=\\"$ctrl.words\\" width=\\"$ctrl.cloudWidth\\" height=\\"$ctrl.cloudHeight\\" on-click=\\"$ctrl.wordClicked\\" rotate=\\"360\\"\\u003E\\u003C\\u002Fword-cloud\\u003E\\u003Ch2 ng-click=\\"$ctrl.showRaw=!$ctrl.showRaw\\"\\u003ERaw results\\u003Cspan class=\\"glyphicon glyphicon-chevron-down\\" ng-show=\\"!$ctrl.showRaw\\"\\u003E\\u003C\\u002Fspan\\u003E\\u003Cspan class=\\"glyphicon glyphicon-chevron-up\\" ng-show=\\"$ctrl.showRaw\\"\\u003E\\u003C\\u002Fspan\\u003E\\u003C\\u002Fh2\\u003E\\u003Cdiv ng-show=\\"$ctrl.showRaw\\"\\u003E\\u003Ctextarea class=\\"form-control\\" disabled\\u003E{{$ctrl.queryURL}}      \\u003C\\u002Ftextarea\\u003E\\u003Cpre pretty-json=\\"$ctrl.response\\"\\u003E\\u003C\\u002Fpre\\u003E\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fdiv\\u003E";;return pug_html;};\nmodule.exports = template;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTk4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vYXBwL2NvbXBvbmVudHMvd29yZC1jbG91ZC12aWV3L3dvcmQtY2xvdWQtdmlldy5wdWc/ODMzMSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgcHVnID0gcmVxdWlyZShcIiEuLi8uLi8uLi9ub2RlX21vZHVsZXMvcHVnLXJ1bnRpbWUvaW5kZXguanNcIik7XG5cbmZ1bmN0aW9uIHRlbXBsYXRlKGxvY2Fscykge3ZhciBwdWdfaHRtbCA9IFwiXCIsIHB1Z19taXhpbnMgPSB7fSwgcHVnX2ludGVycDtwdWdfaHRtbCA9IHB1Z19odG1sICsgXCJcXHUwMDNDZGl2IGNsYXNzPVxcXCJjb250YWluZXJcXFwiXFx1MDAzRVxcdTAwM0NkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXAgaGFzLWZlZWRiYWNrXFxcIiBuZy1jbGFzcz1cXFwieyAnaGFzLXN1Y2Nlc3MnIDogJGN0cmwuaXNFbmRwb2ludFZhbGlkID09PSB0cnVlLCAnaGFzLWVycm9yJyA6ICRjdHJsLmlzRW5kcG9pbnRWYWxpZCA9PT0gZmFsc2V9XFxcIlxcdTAwM0VcXHUwMDNDbGFiZWxcXHUwMDNFRW5kcG9pbnRcXHUwMDNDXFx1MDAyRmxhYmVsXFx1MDAzRVxcdTAwM0NpbnB1dCBjbGFzcz1cXFwiZm9ybS1jb250cm9sXFxcIiB0eXBlPVxcXCJ0ZXh0XFxcIiBuZy1tb2RlbD1cXFwiJGN0cmwuZW5kcG9pbnRcXFwiIG5nLWNoYW5nZT1cXFwiJGN0cmwuZW5kcG9pbnRDaGFuZ2VkKClcXFwiXFx1MDAzRVxcdTAwM0NzcGFuIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLW9rIGZvcm0tY29udHJvbC1mZWVkYmFja1xcXCIgbmctc2hvdz1cXFwiJGN0cmwuaXNFbmRwb2ludFZhbGlkXFxcIlxcdTAwM0VcXHUwMDNDXFx1MDAyRnNwYW5cXHUwMDNFXFx1MDAzQ3NwYW4gY2xhc3M9XFxcImdseXBoaWNvbiBnbHlwaGljb24tcmVtb3ZlIGZvcm0tY29udHJvbC1mZWVkYmFja1xcXCIgbmctc2hvdz1cXFwiISRjdHJsLmlzRW5kcG9pbnRWYWxpZFxcXCJcXHUwMDNFXFx1MDAzQ1xcdTAwMkZzcGFuXFx1MDAzRVxcdTAwM0NcXHUwMDJGZGl2XFx1MDAzRVxcdTAwM0NkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiXFx1MDAzRVxcdTAwM0NsYWJlbFxcdTAwM0VEZWZhdWx0IHF1ZXJ5IGxldmVsXFx1MDAzQ1xcdTAwMkZsYWJlbFxcdTAwM0VcXHUwMDNDc2VsZWN0IGNsYXNzPVxcXCJmb3JtLWNvbnRyb2xcXFwiIG5nLW1vZGVsPVxcXCIkY3RybC5kZWZhdWx0TGV2ZWxcXFwiIG5nLW9wdGlvbnM9XFxcImxldmVsIGZvciBsZXZlbCBpbiAkY3RybC5hdmFpbGFibGVMZXZlbHNcXFwiXFx1MDAzRVxcdTAwM0NcXHUwMDJGc2VsZWN0XFx1MDAzRVxcdTAwM0NcXHUwMDJGZGl2XFx1MDAzRVxcdTAwM0NkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiXFx1MDAzRVxcdTAwM0NsYWJlbFxcdTAwM0VRdWVyeVxcdTAwM0NcXHUwMDJGbGFiZWxcXHUwMDNFXFx1MDAzQ3RleHRhcmVhIGNsYXNzPVxcXCJmb3JtLWNvbnRyb2xcXFwiIG5nLW1vZGVsPVxcXCIkY3RybC5xdWVyeVxcXCJcXHUwMDNFXFx1MDAzQ1xcdTAwMkZ0ZXh0YXJlYVxcdTAwM0VcXHUwMDNDcCBjbGFzcz1cXFwiaGVscC1ibG9ja1xcXCJcXHUwMDNFVW5kZXJzdGFuZHMgYW4gZXhwYW5kZWQgZm9ybSBvZiBcXHUwMDNDYSBocmVmPVxcXCJodHRwOlxcdTAwMkZcXHUwMDJGbHVjZW5lLmFwYWNoZS5vcmdcXHUwMDJGY29yZVxcdTAwMkY2XzVfMVxcdTAwMkZxdWVyeXBhcnNlclxcdTAwMkZvcmdcXHUwMDJGYXBhY2hlXFx1MDAyRmx1Y2VuZVxcdTAwMkZxdWVyeXBhcnNlclxcdTAwMkZjbGFzc2ljXFx1MDAyRnBhY2thZ2Utc3VtbWFyeS5odG1sI3BhY2thZ2UuZGVzY3JpcHRpb25cXFwiXFx1MDAzRUx1Y2VuZSBxdWVyeSBwYXJzZXIgc3ludGF4XFx1MDAzQ1xcdTAwMkZhXFx1MDAzRS5cXHUwMDNDXFx1MDAyRnBcXHUwMDNFXFx1MDAzQ1xcdTAwMkZkaXZcXHUwMDNFXFx1MDAzQ2RpdiBjbGFzcz1cXFwiZm9ybS1ncm91cFxcXCJcXHUwMDNFXFx1MDAzQ2xhYmVsXFx1MDAzRUxpbWl0XFx1MDAzQ1xcdTAwMkZsYWJlbFxcdTAwM0VcXHUwMDNDaW5wdXQgY2xhc3M9XFxcImZvcm0tY29udHJvbFxcXCIgdHlwZT1cXFwibnVtYmVyXFxcIiBuZy1tb2RlbD1cXFwiJGN0cmwubGltaXRcXFwiXFx1MDAzRVxcdTAwM0NwIGNsYXNzPVxcXCJoZWxwLWJsb2NrXFxcIlxcdTAwM0UtMSBmb3Igbm8gbGltaXRcXHUwMDNDXFx1MDAyRnBcXHUwMDNFXFx1MDAzQ1xcdTAwMkZkaXZcXHUwMDNFXFx1MDAzQ2RpdiBjbGFzcz1cXFwiZm9ybS1ncm91cFxcXCJcXHUwMDNFXFx1MDAzQ2xhYmVsXFx1MDAzRU1heGltdW0gbnVtYmVyIG9mIGRvY3VtZW50cyB0byBwcm9jZXNzXFx1MDAzQ1xcdTAwMkZsYWJlbFxcdTAwM0VcXHUwMDNDaW5wdXQgY2xhc3M9XFxcImZvcm0tY29udHJvbFxcXCIgdHlwZT1cXFwibnVtYmVyXFxcIiBuZy1tb2RlbD1cXFwiJGN0cmwubWF4RG9jc1xcXCJcXHUwMDNFXFx1MDAzQ3AgY2xhc3M9XFxcImhlbHAtYmxvY2tcXFwiXFx1MDAzRU1vcmUgaGl0cyB0aGFuIHRoaXMgdHJpZ2dlcnMgcHJvYmFiaWxpc3RpYyBzYW1wbGluZy4gLTEgZm9yIG5vIGxpbWl0LlxcdTAwM0NcXHUwMDJGcFxcdTAwM0VcXHUwMDNDXFx1MDAyRmRpdlxcdTAwM0VcXHUwMDNDZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIlxcdTAwM0VcXHUwMDNDZGl2IGNsYXNzPVxcXCJjaGVja2JveFxcXCJcXHUwMDNFXFx1MDAzQ2xhYmVsXFx1MDAzRSBcXHUwMDNDaW5wdXQgdHlwZT1cXFwiY2hlY2tib3hcXFwiIG5nLW1vZGVsPVxcXCIkY3RybC5tZHNcXFwiXFx1MDAzRVBsb3QgdGVybXMgaW4gTURTIHNwYWNlXFx1MDAzQ1xcdTAwMkZsYWJlbFxcdTAwM0VcXHUwMDNDXFx1MDAyRmRpdlxcdTAwM0VcXHUwMDNDXFx1MDAyRmRpdlxcdTAwM0VcXHUwMDNDZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIlxcdTAwM0VcXHUwMDNDbGFiZWxcXHUwMDNFRnVydGhlciBvcHRpb25zXFx1MDAzQ1xcdTAwMkZsYWJlbFxcdTAwM0VcXHUwMDNDaW5wdXQgY2xhc3M9XFxcImZvcm0tY29udHJvbFxcXCIgdHlwZT1cXFwidGV4dFxcXCIgbmctbW9kZWw9XFxcIiRjdHJsLmZ1cnRoZXJPcHRpb25zXFxcIlxcdTAwM0VcXHUwMDNDXFx1MDAyRmRpdlxcdTAwM0VcXHUwMDNDaDIgbmctY2xpY2s9XFxcIiRjdHJsLnNob3dXZWlnaHRpbmdPcHRpb25zPSEkY3RybC5zaG93V2VpZ2h0aW5nT3B0aW9uc1xcXCJcXHUwMDNFVGVybSB3ZWlnaHRpbmdcXHUwMDNDc3BhbiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1jaGV2cm9uLWRvd25cXFwiIG5nLXNob3c9XFxcIiEkY3RybC5zaG93V2VpZ2h0aW5nT3B0aW9uc1xcXCJcXHUwMDNFXFx1MDAzQ1xcdTAwMkZzcGFuXFx1MDAzRVxcdTAwM0NzcGFuIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLWNoZXZyb24tdXBcXFwiIG5nLXNob3c9XFxcIiRjdHJsLnNob3dXZWlnaHRpbmdPcHRpb25zXFxcIlxcdTAwM0VcXHUwMDNDXFx1MDAyRnNwYW5cXHUwMDNFXFx1MDAzQ1xcdTAwMkZoMlxcdTAwM0VcXHUwMDNDZGl2IG5nLXNob3c9XFxcIiRjdHJsLnNob3dXZWlnaHRpbmdPcHRpb25zXFxcIlxcdTAwM0VcXHUwMDNDZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIlxcdTAwM0VcXHUwMDNDbGFiZWxcXHUwMDNFYWdncmVnYXRlIHdlaWdodGluZyBmb3JtdWxhXFx1MDAzQ1xcdTAwMkZsYWJlbFxcdTAwM0VcXHUwMDNDc2VsZWN0IGNsYXNzPVxcXCJmb3JtLWNvbnRyb2xcXFwiIG5nLW1vZGVsPVxcXCIkY3RybC5zdW1TY2FsaW5nXFxcIlxcdTAwM0VcXHUwMDNDb3B0aW9uIHZhbHVlPVxcXCJBQlNPTFVURVxcXCJcXHUwMDNFYWJzb2x1dGUgY291bnRzXFx1MDAzQ1xcdTAwMkZvcHRpb25cXHUwMDNFXFx1MDAzQ29wdGlvbiB2YWx1ZT1cXFwiVFRGXFxcIlxcdTAwM0V0ZXJtIGZyZXF1ZW5jeSB3ZWlnaHRlZCBjb3VudHNcXHUwMDNDXFx1MDAyRm9wdGlvblxcdTAwM0VcXHUwMDNDb3B0aW9uIHZhbHVlPVxcXCJERlxcXCJcXHUwMDNFZG9jdW1lbnQgZnJlcXVlbmN5IHdlaWdodGVkIGNvdW50c1xcdTAwM0NcXHUwMDJGb3B0aW9uXFx1MDAzRVxcdTAwM0NcXHUwMDJGc2VsZWN0XFx1MDAzRVxcdTAwM0NcXHUwMDJGZGl2XFx1MDAzRVxcdTAwM0NkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiXFx1MDAzRVxcdTAwM0NsYWJlbFxcdTAwM0VMYXBsYWNlIHNtb290aGluZyB0byB1c2Ugd2hlbiB3ZWlnaHRpbmdcXHUwMDNDXFx1MDAyRmxhYmVsXFx1MDAzRVxcdTAwM0NpbnB1dCBjbGFzcz1cXFwiZm9ybS1jb250cm9sXFxcIiB0eXBlPVxcXCJudW1iZXJcXFwiIG5nLW1vZGVsPVxcXCIkY3RybC5zbW9vdGhpbmdcXFwiXFx1MDAzRVxcdTAwM0NcXHUwMDJGZGl2XFx1MDAzRVxcdTAwM0NkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiXFx1MDAzRVxcdTAwM0NsYWJlbFxcdTAwM0Vsb2NhbCB3ZWlnaHRpbmcgZm9ybXVsYVxcdTAwM0NcXHUwMDJGbGFiZWxcXHUwMDNFXFx1MDAzQ3NlbGVjdCBjbGFzcz1cXFwiZm9ybS1jb250cm9sXFxcIiBuZy1tb2RlbD1cXFwiJGN0cmwubG9jYWxTY2FsaW5nXFxcIlxcdTAwM0VcXHUwMDNDb3B0aW9uIHZhbHVlPVxcXCJBQlNPTFVURVxcXCJcXHUwMDNFYWJzb2x1dGUgb2NjdXJyZW5jZSBjb3VudFxcdTAwM0NcXHUwMDJGb3B0aW9uXFx1MDAzRVxcdTAwM0NvcHRpb24gdmFsdWU9XFxcIk1JTlxcXCJcXHUwMDNFYWJzb2x1dGUgY291bnQgdXAgdG8gcXVlcnkgZnJlcXVlbmN5XFx1MDAzQ1xcdTAwMkZvcHRpb25cXHUwMDNFXFx1MDAzQ29wdGlvbiB2YWx1ZT1cXFwiRkxBVFxcXCJcXHUwMDNFb25lIG9jY3VycmVuY2UgY291bnRlZCBwZXIgZG9jdW1lbnRcXHUwMDNDXFx1MDAyRm9wdGlvblxcdTAwM0VcXHUwMDNDXFx1MDAyRnNlbGVjdFxcdTAwM0VcXHUwMDNDXFx1MDAyRmRpdlxcdTAwM0VcXHUwMDNDXFx1MDAyRmRpdlxcdTAwM0VcXHUwMDNDaDIgbmctY2xpY2s9XFxcIiRjdHJsLnNob3dGaWx0ZXJpbmdPcHRpb25zPSEkY3RybC5zaG93RmlsdGVyaW5nT3B0aW9uc1xcXCJcXHUwMDNFVGVybSBmaWx0ZXJpbmdcXHUwMDNDc3BhbiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1jaGV2cm9uLWRvd25cXFwiIG5nLXNob3c9XFxcIiEkY3RybC5zaG93RmlsdGVyaW5nT3B0aW9uc1xcXCJcXHUwMDNFXFx1MDAzQ1xcdTAwMkZzcGFuXFx1MDAzRVxcdTAwM0NzcGFuIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLWNoZXZyb24tdXBcXFwiIG5nLXNob3c9XFxcIiRjdHJsLnNob3dGaWx0ZXJpbmdPcHRpb25zXFxcIlxcdTAwM0VcXHUwMDNDXFx1MDAyRnNwYW5cXHUwMDNFXFx1MDAzQ1xcdTAwMkZoMlxcdTAwM0VcXHUwMDNDZGl2IG5nLXNob3c9XFxcIiRjdHJsLnNob3dGaWx0ZXJpbmdPcHRpb25zXFxcIlxcdTAwM0VcXHUwMDNDcGxvdGx5IGRhdGE9XFxcIiRjdHJsLnRmRGF0YVxcXCIgbGF5b3V0PVxcXCIkY3RybC50ZkxheW91dFxcXCJcXHUwMDNFXFx1MDAzQ1xcdTAwMkZwbG90bHlcXHUwMDNFXFx1MDAzQ2RpdiBjbGFzcz1cXFwiZm9ybS1ncm91cFxcXCJcXHUwMDNFXFx1MDAzQ2xhYmVsXFx1MDAzRU1pbmltdW0gdG90YWwgdGVybSBmcmVxdWVuY3kgZm9yIHRlcm1cXHUwMDNDXFx1MDAyRmxhYmVsXFx1MDAzRVxcdTAwM0NpbnB1dCBjbGFzcz1cXFwiZm9ybS1jb250cm9sXFxcIiB0eXBlPVxcXCJudW1iZXJcXFwiIG5nLW1vZGVsPVxcXCIkY3RybC5taW5Ub3RhbFRlcm1GcmVxXFxcIlxcdTAwM0VcXHUwMDNDcCBjbGFzcz1cXFwiaGVscC1ibG9ja1xcXCIgbmctc2hvdz1cXFwiJGN0cmwubXF1YW50aWxlc1xcXCJcXHUwMDNFIDkwJSBvZiB0ZXJtcyBoYXZlIGZyZXF1ZW5jeSB7eyRjdHJsLm1xdWFudGlsZXNbMF0gfCBudW1iZXJ9fSBvciBtb3JlLlxcdTAwM0NiciBcXHUwMDJGXFx1MDAzRTUwJToge3skY3RybC5tcXVhbnRpbGVzWzFdIHwgbnVtYmVyfX0gb3IgbW9yZSwgXFx1MDAzQ2JyIFxcdTAwMkZcXHUwMDNFMjAlOiB7eyRjdHJsLm1xdWFudGlsZXNbMl0gfCBudW1iZXJ9fSBvciBtb3JlLCBcXHUwMDNDYnIgXFx1MDAyRlxcdTAwM0UxMCU6IHt7JGN0cmwubXF1YW50aWxlc1szXSB8IG51bWJlcn19IG9yIG1vcmUuXFx1MDAzQ1xcdTAwMkZwXFx1MDAzRVxcdTAwM0NcXHUwMDJGZGl2XFx1MDAzRVxcdTAwM0NkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiXFx1MDAzRVxcdTAwM0NsYWJlbFxcdTAwM0VNYXhpbXVtIHRvdGFsIHRlcm0gZnJlcXVlbmN5IGZvciB0ZXJtXFx1MDAzQ1xcdTAwMkZsYWJlbFxcdTAwM0VcXHUwMDNDaW5wdXQgY2xhc3M9XFxcImZvcm0tY29udHJvbFxcXCIgdHlwZT1cXFwibnVtYmVyXFxcIiBuZy1tb2RlbD1cXFwiJGN0cmwubWF4VG90YWxUZXJtRnJlcVxcXCJcXHUwMDNFXFx1MDAzQ3AgY2xhc3M9XFxcImhlbHAtYmxvY2tcXFwiXFx1MDAzRVxcdTAwM0NzcGFuIG5nLXNob3c9XFxcIiRjdHJsLnF1YW50aWxlc1xcXCJcXHUwMDNFOTUlIG9mIHRlcm1zIGhhdmUgZnJlcXVlbmN5IHt7JGN0cmwucXVhbnRpbGVzWzBdIHwgbnVtYmVyfX0gb3IgbGVzcy4gXFx1MDAzQ2JyIFxcdTAwMkZcXHUwMDNFOTklOiB7eyRjdHJsLnF1YW50aWxlc1sxXSB8IG51bWJlcn19IG9yIGxlc3MsIFxcdTAwM0NiciBcXHUwMDJGXFx1MDAzRTk5LjUlOiB7eyRjdHJsLnF1YW50aWxlc1syXSB8IG51bWJlcn19IG9yIGxlc3MsIFxcdTAwM0NiciBcXHUwMDJGXFx1MDAzRTk5LjklOiB7eyRjdHJsLnF1YW50aWxlc1szXSB8IG51bWJlcn19IG9yIGxlc3MsIFxcdTAwM0NiciBcXHUwMDJGXFx1MDAzRTEwMCU6IHt7JGN0cmwucXVhbnRpbGVzWzRdIHwgbnVtYmVyfX0gb3IgbGVzcy5cXHUwMDNDYnIgXFx1MDAyRlxcdTAwM0VcXHUwMDNDXFx1MDAyRnNwYW5cXHUwMDNFXFx1MDAzQ3NwYW5cXHUwMDNFLTEgZm9yIG5vIGxpbWl0LlxcdTAwM0NcXHUwMDJGc3BhblxcdTAwM0VcXHUwMDNDXFx1MDAyRnBcXHUwMDNFXFx1MDAzQ1xcdTAwMkZkaXZcXHUwMDNFXFx1MDAzQ3Bsb3RseSBkYXRhPVxcXCIkY3RybC5kZkRhdGFcXFwiIGxheW91dD1cXFwiJGN0cmwuZGZMYXlvdXRcXFwiXFx1MDAzRVxcdTAwM0NcXHUwMDJGcGxvdGx5XFx1MDAzRVxcdTAwM0NkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiXFx1MDAzRVxcdTAwM0NsYWJlbFxcdTAwM0VNaW5pbXVtIHRvdGFsIGRvY3VtZW50IGZyZXF1ZW5jeSBmb3IgdGVybVxcdTAwM0NcXHUwMDJGbGFiZWxcXHUwMDNFXFx1MDAzQ2lucHV0IGNsYXNzPVxcXCJmb3JtLWNvbnRyb2xcXFwiIHR5cGU9XFxcIm51bWJlclxcXCIgbmctbW9kZWw9XFxcIiRjdHJsLm1pbkRvY0ZyZXFcXFwiXFx1MDAzRVxcdTAwM0NwIGNsYXNzPVxcXCJoZWxwLWJsb2NrXFxcIiBuZy1zaG93PVxcXCIkY3RybC5tZHF1YW50aWxlc1xcXCJcXHUwMDNFIDkwJSBvZiB0ZXJtcyBoYXZlIGZyZXF1ZW5jeSB7eyRjdHJsLm1kcXVhbnRpbGVzWzBdIHwgbnVtYmVyfX0gb3IgbW9yZS4gXFx1MDAzQ2JyIFxcdTAwMkZcXHUwMDNFNTAlOiB7eyRjdHJsLm1kcXVhbnRpbGVzWzFdIHwgbnVtYmVyfX0gb3IgbW9yZSwgXFx1MDAzQ2JyIFxcdTAwMkZcXHUwMDNFMjAlOiB7eyRjdHJsLm1kcXVhbnRpbGVzWzJdIHwgbnVtYmVyfX0gb3IgbW9yZSwgXFx1MDAzQ2JyIFxcdTAwMkZcXHUwMDNFMTAlOiB7eyRjdHJsLm1kcXVhbnRpbGVzWzNdIHwgbnVtYmVyfX0gb3IgbW9yZS5cXHUwMDNDXFx1MDAyRnBcXHUwMDNFXFx1MDAzQ1xcdTAwMkZkaXZcXHUwMDNFXFx1MDAzQ2RpdiBjbGFzcz1cXFwiZm9ybS1ncm91cFxcXCJcXHUwMDNFXFx1MDAzQ2xhYmVsXFx1MDAzRU1heGltdW0gdG90YWwgZG9jdW1lbnQgZnJlcXVlbmN5IGZvciB0ZXJtXFx1MDAzQ1xcdTAwMkZsYWJlbFxcdTAwM0VcXHUwMDNDaW5wdXQgY2xhc3M9XFxcImZvcm0tY29udHJvbFxcXCIgdHlwZT1cXFwibnVtYmVyXFxcIiBuZy1tb2RlbD1cXFwiJGN0cmwubWF4RG9jRnJlcVxcXCJcXHUwMDNFXFx1MDAzQ3AgY2xhc3M9XFxcImhlbHAtYmxvY2tcXFwiXFx1MDAzRVxcdTAwM0NzcGFuIG5nLXNob3c9XFxcIiRjdHJsLmRxdWFudGlsZXNcXFwiXFx1MDAzRTk1JSBvZiB0ZXJtcyBoYXZlIGZyZXF1ZW5jeSB7eyRjdHJsLmRxdWFudGlsZXNbMF0gfCBudW1iZXJ9fSBvciBsZXNzLiBcXHUwMDNDYnIgXFx1MDAyRlxcdTAwM0U5OSU6IHt7JGN0cmwuZHF1YW50aWxlc1sxXSB8IG51bWJlcn19IG9yIGxlc3MsIFxcdTAwM0NiciBcXHUwMDJGXFx1MDAzRTk5LjUlOiB7eyRjdHJsLmRxdWFudGlsZXNbMl0gfCBudW1iZXJ9fSBvciBsZXNzLCBcXHUwMDNDYnIgXFx1MDAyRlxcdTAwM0U5OS45JToge3skY3RybC5kcXVhbnRpbGVzWzNdIHwgbnVtYmVyfX0gb3IgbGVzcywgXFx1MDAzQ2JyIFxcdTAwMkZcXHUwMDNFMTAwJSB7eyRjdHJsLmRxdWFudGlsZXNbNF0gfCBudW1iZXJ9fSBvciBsZXNzLlxcdTAwM0NiciBcXHUwMDJGXFx1MDAzRVxcdTAwM0NcXHUwMDJGc3BhblxcdTAwM0VcXHUwMDNDc3BhblxcdTAwM0UtMSBmb3Igbm8gbGltaXQuXFx1MDAzQ1xcdTAwMkZzcGFuXFx1MDAzRVxcdTAwM0NcXHUwMDJGcFxcdTAwM0VcXHUwMDNDXFx1MDAyRmRpdlxcdTAwM0VcXHUwMDNDZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIlxcdTAwM0VcXHUwMDNDbGFiZWxcXHUwMDNFTWluaW11bSBvY2N1cnJlbmNlcyBmb3IgdGVybSB3aXRoIHJlZ2FyZCB0byBxdWVyeVxcdTAwM0NcXHUwMDJGbGFiZWxcXHUwMDNFXFx1MDAzQ2lucHV0IGNsYXNzPVxcXCJmb3JtLWNvbnRyb2xcXFwiIHR5cGU9XFxcIm51bWJlclxcXCIgbmctbW9kZWw9XFxcIiRjdHJsLm1pblN1bUZyZXFcXFwiXFx1MDAzRVxcdTAwM0NcXHUwMDJGZGl2XFx1MDAzRVxcdTAwM0NkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiXFx1MDAzRVxcdTAwM0NsYWJlbFxcdTAwM0VNYXhpbXVtIG9jY3VycmVuY2VzIGZvciB0ZXJtIHdpdGggcmVnYXJkIHRvIHF1ZXJ5XFx1MDAzQ1xcdTAwMkZsYWJlbFxcdTAwM0VcXHUwMDNDaW5wdXQgY2xhc3M9XFxcImZvcm0tY29udHJvbFxcXCIgdHlwZT1cXFwibnVtYmVyXFxcIiBuZy1tb2RlbD1cXFwiJGN0cmwubWF4U3VtRnJlcVxcXCJcXHUwMDNFXFx1MDAzQ3AgY2xhc3M9XFxcImhlbHAtYmxvY2tcXFwiXFx1MDAzRS0xIGZvciBubyBsaW1pdC5cXHUwMDNDXFx1MDAyRnBcXHUwMDNFXFx1MDAzQ1xcdTAwMkZkaXZcXHUwMDNFXFx1MDAzQ2RpdiBjbGFzcz1cXFwiZm9ybS1ncm91cFxcXCJcXHUwMDNFXFx1MDAzQ2xhYmVsXFx1MDAzRU1pbmltdW0gb2NjdXJyZW5jZXMgZm9yIHRlcm0gaW5zaWRlIGEgc2luZ2xlIGRvY3VtZW50IGZvciB0aGF0IGRvY3VtZW50IHRvIGJlIGNvdW50ZWRcXHUwMDNDXFx1MDAyRmxhYmVsXFx1MDAzRVxcdTAwM0NpbnB1dCBjbGFzcz1cXFwiZm9ybS1jb250cm9sXFxcIiB0eXBlPVxcXCJudW1iZXJcXFwiIG5nLW1vZGVsPVxcXCIkY3RybC5taW5GcmVxSW5Eb2NcXFwiXFx1MDAzRVxcdTAwM0NcXHUwMDJGZGl2XFx1MDAzRVxcdTAwM0NkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiXFx1MDAzRVxcdTAwM0NsYWJlbFxcdTAwM0VNYXhpbXVtIG9jY3VycmVuY2VzIGZvciB0ZXJtIGluc2lkZSBhIHNpbmdsZSBkb2N1bWVudCBmb3IgdGhhdCBkb2N1bWVudCB0byBiZSBjb3VudGVkXFx1MDAzQ1xcdTAwMkZsYWJlbFxcdTAwM0VcXHUwMDNDaW5wdXQgY2xhc3M9XFxcImZvcm0tY29udHJvbFxcXCIgdHlwZT1cXFwibnVtYmVyXFxcIiBuZy1tb2RlbD1cXFwiJGN0cmwubWF4RnJlcUluRG9jXFxcIlxcdTAwM0VcXHUwMDNDcCBjbGFzcz1cXFwiaGVscC1ibG9ja1xcXCJcXHUwMDNFLTEgZm9yIG5vIGxpbWl0LlxcdTAwM0NcXHUwMDJGcFxcdTAwM0VcXHUwMDNDXFx1MDAyRmRpdlxcdTAwM0VcXHUwMDNDZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIlxcdTAwM0VcXHUwMDNDbGFiZWxcXHUwMDNFTWluaW11bSB0ZXJtIGxlbmd0aFxcdTAwM0NcXHUwMDJGbGFiZWxcXHUwMDNFXFx1MDAzQ2lucHV0IGNsYXNzPVxcXCJmb3JtLWNvbnRyb2xcXFwiIHR5cGU9XFxcIm51bWJlclxcXCIgbmctbW9kZWw9XFxcIiRjdHJsLm1pblRlcm1MZW5ndGhcXFwiXFx1MDAzRVxcdTAwM0NcXHUwMDJGZGl2XFx1MDAzRVxcdTAwM0NkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiXFx1MDAzRVxcdTAwM0NsYWJlbFxcdTAwM0VNYXhpbXVtIHRlcm0gbGVuZ3RoXFx1MDAzQ1xcdTAwMkZsYWJlbFxcdTAwM0VcXHUwMDNDaW5wdXQgY2xhc3M9XFxcImZvcm0tY29udHJvbFxcXCIgdHlwZT1cXFwibnVtYmVyXFxcIiBuZy1tb2RlbD1cXFwiJGN0cmwubWF4VGVybUxlbmd0aFxcXCJcXHUwMDNFXFx1MDAzQ3AgY2xhc3M9XFxcImhlbHAtYmxvY2tcXFwiXFx1MDAzRS0xIGZvciBubyBsaW1pdC5cXHUwMDNDXFx1MDAyRnBcXHUwMDNFXFx1MDAzQ1xcdTAwMkZkaXZcXHUwMDNFXFx1MDAzQ2RpdiBjbGFzcz1cXFwiZm9ybS1ncm91cFxcXCJcXHUwMDNFXFx1MDAzQ2xhYmVsXFx1MDAzRVRlcm0gZmlsdGVyXFx1MDAzQ1xcdTAwMkZsYWJlbFxcdTAwM0VcXHUwMDNDaW5wdXQgY2xhc3M9XFxcImZvcm0tY29udHJvbFxcXCIgdHlwZT1cXFwidGV4dFxcXCIgbmctbW9kZWw9XFxcIiRjdHJsLnRlcm1GaWx0ZXJcXFwiXFx1MDAzRVxcdTAwM0NwIGNsYXNzPVxcXCJoZWxwLWJsb2NrXFxcIlxcdTAwM0VHcm9vdnkgZXhwcmVzc2lvbiByZXR1cm5pbmcgYSBib29sZWFuLiBUZXJtPXRlcm0gICAgICBcXHUwMDNDXFx1MDAyRnBcXHUwMDNFXFx1MDAzQ1xcdTAwMkZkaXZcXHUwMDNFXFx1MDAzQ1xcdTAwMkZkaXZcXHUwMDNFXFx1MDAzQ2J1dHRvbiBjbGFzcz1cXFwiYnRuIGJ0bi1zdWNjZXNzXFxcIiBuZy1jbGljaz1cXFwiJGN0cmwucnVuUXVlcnkoKVxcXCIgbmctZGlzYWJsZWQ9XFxcIiRjdHJsLnF1ZXJ5UnVubmluZ1xcXCJcXHUwMDNFUXVlcnlcXHUwMDNDc3BhbiBuZy1zaG93PVxcXCIkY3RybC5xdWVyeVJ1bm5pbmdcXFwiXFx1MDAzRSZuYnNwO1xcdTAwM0NzcGFuIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLWhvdXJnbGFzc1xcXCJcXHUwMDNFXFx1MDAzQ1xcdTAwMkZzcGFuXFx1MDAzRVxcdTAwM0NcXHUwMDJGc3BhblxcdTAwM0VcXHUwMDNDXFx1MDAyRmJ1dHRvblxcdTAwM0VcXHUwMDNDZGl2IG5nLXNob3c9XFxcIiRjdHJsLmVycm9yXFxcIlxcdTAwM0VcXHUwMDNDaDJcXHUwMDNFUXVlcnkgcmVzdWx0ZWQgaW4gZXJyb3I6XFx1MDAzQ1xcdTAwMkZoMlxcdTAwM0V7eyRjdHJsLmVycm9yfX1cXHUwMDNDXFx1MDAyRmRpdlxcdTAwM0VcXHUwMDNDZGl2IG5nLXNob3c9XFxcIiEkY3RybC5xdWVyeVJ1bm5pbmdcXFwiXFx1MDAzRXt7JGN0cmwudG90YWxSZXN1bHRzfX1cXHUwMDNDcGxvdGx5IG5nLXNob3c9XFxcIiRjdHJsLm1kc1xcXCIgZGF0YT1cXFwiJGN0cmwubWRzRGF0YVxcXCIgbGF5b3V0PVxcXCIkY3RybC5tZHNMYXlvdXRcXFwiIG9uLWNsaWNrPVxcXCIkY3RybC5tZHNXb3JkQ2xpY2tlZChkYXRhKVxcXCJcXHUwMDNFXFx1MDAzQ1xcdTAwMkZwbG90bHlcXHUwMDNFXFx1MDAzQ3dvcmQtY2xvdWQgbmctc2hvdz1cXFwiISRjdHJsLm1kc1xcXCIgd29yZHM9XFxcIiRjdHJsLndvcmRzXFxcIiB3aWR0aD1cXFwiJGN0cmwuY2xvdWRXaWR0aFxcXCIgaGVpZ2h0PVxcXCIkY3RybC5jbG91ZEhlaWdodFxcXCIgb24tY2xpY2s9XFxcIiRjdHJsLndvcmRDbGlja2VkXFxcIiByb3RhdGU9XFxcIjM2MFxcXCJcXHUwMDNFXFx1MDAzQ1xcdTAwMkZ3b3JkLWNsb3VkXFx1MDAzRVxcdTAwM0NoMiBuZy1jbGljaz1cXFwiJGN0cmwuc2hvd1Jhdz0hJGN0cmwuc2hvd1Jhd1xcXCJcXHUwMDNFUmF3IHJlc3VsdHNcXHUwMDNDc3BhbiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1jaGV2cm9uLWRvd25cXFwiIG5nLXNob3c9XFxcIiEkY3RybC5zaG93UmF3XFxcIlxcdTAwM0VcXHUwMDNDXFx1MDAyRnNwYW5cXHUwMDNFXFx1MDAzQ3NwYW4gY2xhc3M9XFxcImdseXBoaWNvbiBnbHlwaGljb24tY2hldnJvbi11cFxcXCIgbmctc2hvdz1cXFwiJGN0cmwuc2hvd1Jhd1xcXCJcXHUwMDNFXFx1MDAzQ1xcdTAwMkZzcGFuXFx1MDAzRVxcdTAwM0NcXHUwMDJGaDJcXHUwMDNFXFx1MDAzQ2RpdiBuZy1zaG93PVxcXCIkY3RybC5zaG93UmF3XFxcIlxcdTAwM0VcXHUwMDNDdGV4dGFyZWEgY2xhc3M9XFxcImZvcm0tY29udHJvbFxcXCIgZGlzYWJsZWRcXHUwMDNFe3skY3RybC5xdWVyeVVSTH19ICAgICAgXFx1MDAzQ1xcdTAwMkZ0ZXh0YXJlYVxcdTAwM0VcXHUwMDNDcHJlIHByZXR0eS1qc29uPVxcXCIkY3RybC5yZXNwb25zZVxcXCJcXHUwMDNFXFx1MDAzQ1xcdTAwMkZwcmVcXHUwMDNFXFx1MDAzQ1xcdTAwMkZkaXZcXHUwMDNFXFx1MDAzQ1xcdTAwMkZkaXZcXHUwMDNFXFx1MDAzQ1xcdTAwMkZkaXZcXHUwMDNFXCI7O3JldHVybiBwdWdfaHRtbDt9O1xubW9kdWxlLmV4cG9ydHMgPSB0ZW1wbGF0ZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2FwcC9jb21wb25lbnRzL3dvcmQtY2xvdWQtdmlldy93b3JkLWNsb3VkLXZpZXcucHVnXG4vLyBtb2R1bGUgaWQgPSAxOThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///198\n')},function(module,exports,__webpack_require__){"use strict";eval('\n\nvar _stringify = __webpack_require__(62);\n\nvar _stringify2 = _interopRequireDefault(_stringify);\n\nvar _getIterator2 = __webpack_require__(58);\n\nvar _getIterator3 = _interopRequireDefault(_getIterator2);\n\nvar _getPrototypeOf = __webpack_require__(41);\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _createClass2 = __webpack_require__(27);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = __webpack_require__(63);\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _get2 = __webpack_require__(67);\n\nvar _get3 = _interopRequireDefault(_get2);\n\nvar _inherits2 = __webpack_require__(68);\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _classCallCheck2 = __webpack_require__(19);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _angular = __webpack_require__(7);\n\nvar angular = _interopRequireWildcard(_angular);\n\n__webpack_require__(69);\n\nvar _octavoComponentController = __webpack_require__(34);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar Field = function Field(id, description) {\n    (0, _classCallCheck3.default)(this, Field);\n\n    this.id = id;\n    this.description = description;\n};\n\nvar SearchViewComponentController = function (_OctavoComponentContr) {\n    SearchViewComponentController.$inject = ["$sce", "$q", "$http", "$httpParamSerializer", "$stateParams", "$state"];\n    (0, _inherits3.default)(SearchViewComponentController, _OctavoComponentContr);\n\n    /* @ngInject */\n    function SearchViewComponentController($sce, $q, $http, $httpParamSerializer, $stateParams, $state) {\n        (0, _classCallCheck3.default)(this, SearchViewComponentController);\n\n        var _this = (0, _possibleConstructorReturn3.default)(this, (SearchViewComponentController.__proto__ || (0, _getPrototypeOf2.default)(SearchViewComponentController)).call(this, $http, $stateParams, $state));\n\n        _this.$sce = $sce;\n        _this.$q = $q;\n        _this.$httpParamSerializer = $httpParamSerializer;\n        _this.selectedFields = {};\n        _this.showMatches = true;\n        _this.furtherOptions = "";\n        if (!_this.limit) _this.limit = 20;\n        if (!_this.field) _this.field = [];\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n            for (var _iterator = (0, _getIterator3.default)(_this.field), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                var field = _step.value;\n\n                _this.selectedFields[field] = true;\n            }\n        } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n        } finally {\n            try {\n                if (!_iteratorNormalCompletion && _iterator.return) {\n                    _iterator.return();\n                }\n            } finally {\n                if (_didIteratorError) {\n                    throw _iteratorError;\n                }\n            }\n        }\n\n        return _this;\n    }\n\n    (0, _createClass3.default)(SearchViewComponentController, [{\n        key: "endpointUpdated",\n        value: function endpointUpdated(indexInfo) {\n            this.availableLevels = indexInfo.levels.map(function (level) {\n                return level.id;\n            });\n            if (!this.defaultLevel) this.defaultLevel = this.availableLevels[this.availableLevels.length - 1];\n            this.availableFields = [];\n            for (var field in indexInfo.commonFields) {\n                this.availableFields.push(new Field(field, indexInfo.commonFields[field].description));\n            }if (this.query) this.doRunQuery();\n        }\n    }, {\n        key: "updateSelectedFields",\n        value: function updateSelectedFields() {\n            var _this2 = this;\n\n            if (this.availableFields) this.field = this.availableFields.map(function (f) {\n                return f.id;\n            }).filter(function (f) {\n                return _this2.selectedFields[f];\n            });\n        }\n    }, {\n        key: "doRunQuery",\n        value: function doRunQuery() {\n            var _this3 = this;\n\n            this.updateSelectedFields();\n            (0, _get3.default)(SearchViewComponentController.prototype.__proto__ || (0, _getPrototypeOf2.default)(SearchViewComponentController.prototype), "doRunQuery", this).call(this);\n            var params = this.$httpParamSerializer({\n                query: this.defaultLevel && this.query.indexOf("<") !== 0 ? "<" + this.defaultLevel + "§" + this.query + "§" + this.defaultLevel + ">" : this.query,\n                returnMatches: this.showMatches,\n                field: this.field,\n                limit: this.limit\n            }) + "&" + this.furtherOptions;\n            this.queryURL = this.endpoint + "search" + "?" + params;\n            this.$http.post(this.endpoint + "search", params, {\n                headers: { "Content-Type": "application/x-www-form-urlencoded" }\n            }).then(function (response) {\n                _this3.response = JSON.parse((0, _stringify2.default)(response.data));\n                _this3.queryRunning = false;\n                _this3.totalResults = response.data.results.total;\n                _this3.results = response.data.results.docs;\n                var _iteratorNormalCompletion2 = true;\n                var _didIteratorError2 = false;\n                var _iteratorError2 = undefined;\n\n                try {\n                    for (var _iterator2 = (0, _getIterator3.default)(_this3.results), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                        var doc = _step2.value;\n\n                        doc.matches = doc.matches.map(_this3.$sce.trustAsHtml);\n                    }\n                } catch (err) {\n                    _didIteratorError2 = true;\n                    _iteratorError2 = err;\n                } finally {\n                    try {\n                        if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                            _iterator2.return();\n                        }\n                    } finally {\n                        if (_didIteratorError2) {\n                            throw _iteratorError2;\n                        }\n                    }\n                }\n            }, function (error) {\n                _this3.queryRunning = false;\n                _this3.error = error;\n            });\n        }\n    }]);\n    return SearchViewComponentController;\n}(_octavoComponentController.OctavoComponentController);\n\nvar SearchViewComponent = function SearchViewComponent() {\n    (0, _classCallCheck3.default)(this, SearchViewComponent);\n\n    this.controller = SearchViewComponentController;\n    this.template = __webpack_require__(200)();\n};\n\nangular.module("app.components.search-view", []).component("searchView", new SearchViewComponent());//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTk5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2FwcC9jb21wb25lbnRzL3NlYXJjaC12aWV3L3NlYXJjaC12aWV3LWNvbXBvbmVudC50cz8yMDBiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0ICogYXMgYW5ndWxhciBmcm9tIFwiYW5ndWxhclwiO1xuaW1wb3J0IFwibmctcHJldHR5anNvbi9kaXN0L25nLXByZXR0eWpzb24ubWluLmpzXCI7XG5pbXBvcnQgeyBPY3Rhdm9Db21wb25lbnRDb250cm9sbGVyIH0gZnJvbSBcIi4uL29jdGF2by1jb21wb25lbnQtY29udHJvbGxlclwiO1xuY2xhc3MgRmllbGQge1xuICAgIGNvbnN0cnVjdG9yKGlkLCBkZXNjcmlwdGlvbikge1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbjtcbiAgICB9XG59XG5jbGFzcyBTZWFyY2hWaWV3Q29tcG9uZW50Q29udHJvbGxlciBleHRlbmRzIE9jdGF2b0NvbXBvbmVudENvbnRyb2xsZXIge1xuICAgIC8qIEBuZ0luamVjdCAqL1xuICAgIGNvbnN0cnVjdG9yKCRzY2UsICRxLCAkaHR0cCwgJGh0dHBQYXJhbVNlcmlhbGl6ZXIsICRzdGF0ZVBhcmFtcywgJHN0YXRlKSB7XG4gICAgICAgIHN1cGVyKCRodHRwLCAkc3RhdGVQYXJhbXMsICRzdGF0ZSk7XG4gICAgICAgIHRoaXMuJHNjZSA9ICRzY2U7XG4gICAgICAgIHRoaXMuJHEgPSAkcTtcbiAgICAgICAgdGhpcy4kaHR0cFBhcmFtU2VyaWFsaXplciA9ICRodHRwUGFyYW1TZXJpYWxpemVyO1xuICAgICAgICB0aGlzLnNlbGVjdGVkRmllbGRzID0ge307XG4gICAgICAgIHRoaXMuc2hvd01hdGNoZXMgPSB0cnVlO1xuICAgICAgICB0aGlzLmZ1cnRoZXJPcHRpb25zID0gXCJcIjtcbiAgICAgICAgaWYgKCF0aGlzLmxpbWl0KVxuICAgICAgICAgICAgdGhpcy5saW1pdCA9IDIwO1xuICAgICAgICBpZiAoIXRoaXMuZmllbGQpXG4gICAgICAgICAgICB0aGlzLmZpZWxkID0gW107XG4gICAgICAgIGZvciAobGV0IGZpZWxkIG9mIHRoaXMuZmllbGQpXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkRmllbGRzW2ZpZWxkXSA9IHRydWU7XG4gICAgfVxuICAgIGVuZHBvaW50VXBkYXRlZChpbmRleEluZm8pIHtcbiAgICAgICAgdGhpcy5hdmFpbGFibGVMZXZlbHMgPSBpbmRleEluZm8ubGV2ZWxzLm1hcChsZXZlbCA9PiBsZXZlbC5pZCk7XG4gICAgICAgIGlmICghdGhpcy5kZWZhdWx0TGV2ZWwpXG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRMZXZlbCA9IHRoaXMuYXZhaWxhYmxlTGV2ZWxzW3RoaXMuYXZhaWxhYmxlTGV2ZWxzLmxlbmd0aCAtIDFdO1xuICAgICAgICB0aGlzLmF2YWlsYWJsZUZpZWxkcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBmaWVsZCBpbiBpbmRleEluZm8uY29tbW9uRmllbGRzKVxuICAgICAgICAgICAgdGhpcy5hdmFpbGFibGVGaWVsZHMucHVzaChuZXcgRmllbGQoZmllbGQsIGluZGV4SW5mby5jb21tb25GaWVsZHNbZmllbGRdLmRlc2NyaXB0aW9uKSk7XG4gICAgICAgIGlmICh0aGlzLnF1ZXJ5KVxuICAgICAgICAgICAgdGhpcy5kb1J1blF1ZXJ5KCk7XG4gICAgfVxuICAgIHVwZGF0ZVNlbGVjdGVkRmllbGRzKCkge1xuICAgICAgICBpZiAodGhpcy5hdmFpbGFibGVGaWVsZHMpXG4gICAgICAgICAgICB0aGlzLmZpZWxkID0gdGhpcy5hdmFpbGFibGVGaWVsZHNcbiAgICAgICAgICAgICAgICAubWFwKGYgPT4gZi5pZClcbiAgICAgICAgICAgICAgICAuZmlsdGVyKGYgPT4gdGhpcy5zZWxlY3RlZEZpZWxkc1tmXSk7XG4gICAgfVxuICAgIGRvUnVuUXVlcnkoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlU2VsZWN0ZWRGaWVsZHMoKTtcbiAgICAgICAgc3VwZXIuZG9SdW5RdWVyeSgpO1xuICAgICAgICBsZXQgcGFyYW1zID0gdGhpcy4kaHR0cFBhcmFtU2VyaWFsaXplcih7XG4gICAgICAgICAgICBxdWVyeTogdGhpcy5kZWZhdWx0TGV2ZWwgJiYgdGhpcy5xdWVyeS5pbmRleE9mKFwiPFwiKSAhPT0gMFxuICAgICAgICAgICAgICAgID8gXCI8XCIgK1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlZmF1bHRMZXZlbCArXG4gICAgICAgICAgICAgICAgICAgIFwiwqdcIiArXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucXVlcnkgK1xuICAgICAgICAgICAgICAgICAgICBcIsKnXCIgK1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlZmF1bHRMZXZlbCArXG4gICAgICAgICAgICAgICAgICAgIFwiPlwiXG4gICAgICAgICAgICAgICAgOiB0aGlzLnF1ZXJ5LFxuICAgICAgICAgICAgcmV0dXJuTWF0Y2hlczogdGhpcy5zaG93TWF0Y2hlcyxcbiAgICAgICAgICAgIGZpZWxkOiB0aGlzLmZpZWxkLFxuICAgICAgICAgICAgbGltaXQ6IHRoaXMubGltaXRcbiAgICAgICAgfSkgK1xuICAgICAgICAgICAgXCImXCIgK1xuICAgICAgICAgICAgdGhpcy5mdXJ0aGVyT3B0aW9ucztcbiAgICAgICAgdGhpcy5xdWVyeVVSTCA9IHRoaXMuZW5kcG9pbnQgKyBcInNlYXJjaFwiICsgXCI/XCIgKyBwYXJhbXM7XG4gICAgICAgIHRoaXMuJGh0dHBcbiAgICAgICAgICAgIC5wb3N0KHRoaXMuZW5kcG9pbnQgKyBcInNlYXJjaFwiLCBwYXJhbXMsIHtcbiAgICAgICAgICAgIGhlYWRlcnM6IHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiB9XG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigocmVzcG9uc2UpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVzcG9uc2UgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHJlc3BvbnNlLmRhdGEpKTtcbiAgICAgICAgICAgIHRoaXMucXVlcnlSdW5uaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnRvdGFsUmVzdWx0cyA9IHJlc3BvbnNlLmRhdGEucmVzdWx0cy50b3RhbDtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0cyA9IHJlc3BvbnNlLmRhdGEucmVzdWx0cy5kb2NzO1xuICAgICAgICAgICAgZm9yIChsZXQgZG9jIG9mIHRoaXMucmVzdWx0cylcbiAgICAgICAgICAgICAgICBkb2MubWF0Y2hlcyA9IGRvYy5tYXRjaGVzLm1hcCh0aGlzLiRzY2UudHJ1c3RBc0h0bWwpO1xuICAgICAgICB9LCBlcnJvciA9PiB7XG4gICAgICAgICAgICB0aGlzLnF1ZXJ5UnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5lcnJvciA9IGVycm9yO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5jbGFzcyBTZWFyY2hWaWV3Q29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jb250cm9sbGVyID0gU2VhcmNoVmlld0NvbXBvbmVudENvbnRyb2xsZXI7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSByZXF1aXJlKFwiLi9zZWFyY2gtdmlldy5wdWdcIikoKTtcbiAgICB9XG59XG5hbmd1bGFyXG4gICAgLm1vZHVsZShcImFwcC5jb21wb25lbnRzLnNlYXJjaC12aWV3XCIsIFtdKVxuICAgIC5jb21wb25lbnQoXCJzZWFyY2hWaWV3XCIsIG5ldyBTZWFyY2hWaWV3Q29tcG9uZW50KCkpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGFwcC9jb21wb25lbnRzL3NlYXJjaC12aWV3L3NlYXJjaC12aWV3LWNvbXBvbmVudC50cyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQVZBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFZQTtBQUFBO0FBQ0E7QUFBQTtBQURBO0FBWkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFjQTtBQUNBOzs7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBREE7QUFJQTs7O0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUNBOzs7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQVNBO0FBQ0E7QUFDQTtBQVpBO0FBZ0JBO0FBQ0E7QUFFQTtBQURBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBS0E7QUFBQTtBQUNBO0FBQUE7QUFEQTtBQUxBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///199\n')},function(module,exports,__webpack_require__){eval('var pug = __webpack_require__(39);\n\nfunction template(locals) {var pug_html = "", pug_mixins = {}, pug_interp;pug_html = pug_html + "\\u003Cdiv class=\\"container\\"\\u003E\\u003Cdiv class=\\"form-group has-feedback\\" ng-class=\\"{ \'has-success\' : $ctrl.isEndpointValid === true, \'has-error\' : $ctrl.isEndpointValid === false}\\"\\u003E\\u003Clabel\\u003EEndpoint\\u003C\\u002Flabel\\u003E\\u003Cinput class=\\"form-control\\" ng-change=\\"$ctrl.endpointChanged()\\" ng-model=\\"$ctrl.endpoint\\" type=\\"text\\"\\u003E\\u003Cspan class=\\"glyphicon glyphicon-ok form-control-feedback\\" ng-show=\\"$ctrl.isEndpointValid\\"\\u003E\\u003C\\u002Fspan\\u003E\\u003Cspan class=\\"glyphicon glyphicon-remove form-control-feedback\\" ng-show=\\"!$ctrl.isEndpointValid\\"\\u003E\\u003C\\u002Fspan\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\"form-group\\"\\u003E\\u003Clabel\\u003EDefault query level\\u003C\\u002Flabel\\u003E\\u003Cselect class=\\"form-control\\" ng-model=\\"$ctrl.defaultLevel\\" ng-options=\\"level for level in $ctrl.availableLevels\\"\\u003E\\u003C\\u002Fselect\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\"form-group\\"\\u003E\\u003Clabel\\u003EQuery\\u003C\\u002Flabel\\u003E\\u003Ctextarea class=\\"form-control\\" ng-model=\\"$ctrl.query\\"\\u003E\\u003C\\u002Ftextarea\\u003E\\u003Cp class=\\"help-block\\"\\u003EUnderstands an expanded form of \\u003Ca href=\\"http:\\u002F\\u002Flucene.apache.org\\u002Fcore\\u002F6_5_1\\u002Fqueryparser\\u002Forg\\u002Fapache\\u002Flucene\\u002Fqueryparser\\u002Fclassic\\u002Fpackage-summary.html#package.description\\"\\u003ELucene query parser syntax\\u003C\\u002Fa\\u003E.\\u003C\\u002Fp\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\"form-group\\"\\u003E\\u003Clabel\\u003EFields to show\\u003C\\u002Flabel\\u003E\\u003Cdiv class=\\"row\\"\\u003E\\u003Cdiv class=\\"col-xs-12\\"\\u003E\\u003Clabel class=\\"checkbox-inline\\" ng-repeat=\\"field in $ctrl.availableFields\\" title=\\"{{field.description}}\\"\\u003E\\u003Cinput ng-model=\\"$ctrl.selectedFields[field.id]\\" type=\\"checkbox\\"\\u003E{{field.id}}\\u003C\\u002Flabel\\u003E\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\"form-group\\"\\u003E\\u003Clabel\\u003E \\u003Cinput ng-model=\\"$ctrl.showMatches\\" type=\\"checkbox\\"\\u003E&nbsp;Show matches\\u003C\\u002Flabel\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\"form-group\\"\\u003E\\u003Clabel\\u003ELimit\\u003Cinput class=\\"form-control\\" ng-model=\\"$ctrl.limit\\" type=\\"number\\"\\u003E\\u003C\\u002Flabel\\u003E\\u003Cp class=\\"help-block\\"\\u003E-1 for no limit\\u003C\\u002Fp\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cdiv class=\\"form-group\\"\\u003E\\u003Clabel\\u003EFurther options\\u003C\\u002Flabel\\u003E\\u003Cinput class=\\"form-control\\" ng-model=\\"$ctrl.furtherOptions\\" type=\\"text\\"\\u003E\\u003C\\u002Fdiv\\u003E\\u003Cbutton class=\\"btn btn-success\\" ng-click=\\"$ctrl.runQuery()\\" ng-disabled=\\"$ctrl.queryRunning\\"\\u003EQuery\\u003C\\u002Fbutton\\u003E\\u003Cdiv ng-show=\\"$ctrl.error\\"\\u003E\\u003Ch2\\u003EQuery resulted in error:\\u003C\\u002Fh2\\u003E{{$ctrl.error}}\\u003C\\u002Fdiv\\u003E\\u003Cdiv ng-show=\\"!$ctrl.queryRunning\\"\\u003E\\u003Ch2\\u003E{{ ($ctrl.limit !== -1 && $ctrl.limit \\u003C $ctrl.totalResults) ? \'First \'+$ctrl.limit+\' of \' : \'\'}}{{$ctrl.totalResults}} Results\\u003C\\u002Fh2\\u003E\\u003Ctable class=\\"table table-bordered table-responsive\\"\\u003E\\u003Cthead\\u003E\\u003Ctr\\u003E\\u003Cth ng-click=\\"$ctrl.sortReverse = $ctrl.sortField == field ? !$ctrl.sortReverse : $ctrl.sortReverse;$ctrl.sortField = field\\" ng-repeat=\\"field in $ctrl.field track by $index \\"\\u003E{{::field}}\\u003Cspan class=\\"glyphicon glyphicon-chevron-down\\" ng-show=\\"$ctrl.sortField == field &amp;&amp; !$ctrl.sortReverse\\"\\u003E\\u003C\\u002Fspan\\u003E\\u003Cspan class=\\"glyphicon glyphicon-chevron-up\\" ng-show=\\"$ctrl.sortField == field &amp;&amp; $ctrl.sortReverse\\"\\u003E\\u003C\\u002Fspan\\u003E\\u003C\\u002Fth\\u003E\\u003C\\u002Ftr\\u003E\\u003C\\u002Fthead\\u003E\\u003Ctbody ng-repeat=\\"result in $ctrl.results | orderBy:$ctrl.sortField:$ctrl.sortReverse\\"\\u003E\\u003Ctr class=\\"info\\"\\u003E\\u003Ctd ng-repeat=\\"field in $ctrl.field track by $index \\"\\u003E \\u003Ca ng-href=\\"{{result[field]}}\\" ng-if=\\"result[field].indexOf(\'http\') === 0\\" target=\\"_blank\\"\\u003E{{::result[field]}}\\u003C\\u002Fa\\u003E\\u003Cspan ng-if=\\"result[field].indexOf(\'http\') !== 0\\"\\u003E{{::result[field]}}\\u003C\\u002Fspan\\u003E\\u003C\\u002Ftd\\u003E\\u003C\\u002Ftr\\u003E\\u003Ctr ng-repeat=\\"match in result.matches track by $index\\"\\u003E\\u003Ctd ng-bind-html=\\"match\\" colspan=\\"{{::$ctrl.field.length}}\\"\\u003E\\u003C\\u002Ftd\\u003E\\u003C\\u002Ftr\\u003E\\u003C\\u002Ftbody\\u003E\\u003C\\u002Ftable\\u003E\\u003Ch2 ng-click=\\"$ctrl.showRaw=!$ctrl.showRaw\\"\\u003ERaw results\\u003Cspan class=\\"glyphicon glyphicon-chevron-down\\" ng-show=\\"!$ctrl.showRaw\\"\\u003E\\u003C\\u002Fspan\\u003E\\u003Cspan class=\\"glyphicon glyphicon-chevron-up\\" ng-show=\\"$ctrl.showRaw\\"\\u003E\\u003C\\u002Fspan\\u003E\\u003C\\u002Fh2\\u003E\\u003Cdiv ng-show=\\"$ctrl.showRaw\\"\\u003E\\u003Ctextarea class=\\"form-control\\" disabled\\u003E{{$ctrl.queryURL}}      \\u003C\\u002Ftextarea\\u003E\\u003Cpre pretty-json=\\"$ctrl.response\\"\\u003E\\u003C\\u002Fpre\\u003E\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fdiv\\u003E\\u003C\\u002Fdiv\\u003E";;return pug_html;};\nmodule.exports = template;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjAwLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vYXBwL2NvbXBvbmVudHMvc2VhcmNoLXZpZXcvc2VhcmNoLXZpZXcucHVnP2JjZmMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHB1ZyA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3B1Zy1ydW50aW1lL2luZGV4LmpzXCIpO1xuXG5mdW5jdGlvbiB0ZW1wbGF0ZShsb2NhbHMpIHt2YXIgcHVnX2h0bWwgPSBcIlwiLCBwdWdfbWl4aW5zID0ge30sIHB1Z19pbnRlcnA7cHVnX2h0bWwgPSBwdWdfaHRtbCArIFwiXFx1MDAzQ2RpdiBjbGFzcz1cXFwiY29udGFpbmVyXFxcIlxcdTAwM0VcXHUwMDNDZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwIGhhcy1mZWVkYmFja1xcXCIgbmctY2xhc3M9XFxcInsgJ2hhcy1zdWNjZXNzJyA6ICRjdHJsLmlzRW5kcG9pbnRWYWxpZCA9PT0gdHJ1ZSwgJ2hhcy1lcnJvcicgOiAkY3RybC5pc0VuZHBvaW50VmFsaWQgPT09IGZhbHNlfVxcXCJcXHUwMDNFXFx1MDAzQ2xhYmVsXFx1MDAzRUVuZHBvaW50XFx1MDAzQ1xcdTAwMkZsYWJlbFxcdTAwM0VcXHUwMDNDaW5wdXQgY2xhc3M9XFxcImZvcm0tY29udHJvbFxcXCIgbmctY2hhbmdlPVxcXCIkY3RybC5lbmRwb2ludENoYW5nZWQoKVxcXCIgbmctbW9kZWw9XFxcIiRjdHJsLmVuZHBvaW50XFxcIiB0eXBlPVxcXCJ0ZXh0XFxcIlxcdTAwM0VcXHUwMDNDc3BhbiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1vayBmb3JtLWNvbnRyb2wtZmVlZGJhY2tcXFwiIG5nLXNob3c9XFxcIiRjdHJsLmlzRW5kcG9pbnRWYWxpZFxcXCJcXHUwMDNFXFx1MDAzQ1xcdTAwMkZzcGFuXFx1MDAzRVxcdTAwM0NzcGFuIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLXJlbW92ZSBmb3JtLWNvbnRyb2wtZmVlZGJhY2tcXFwiIG5nLXNob3c9XFxcIiEkY3RybC5pc0VuZHBvaW50VmFsaWRcXFwiXFx1MDAzRVxcdTAwM0NcXHUwMDJGc3BhblxcdTAwM0VcXHUwMDNDXFx1MDAyRmRpdlxcdTAwM0VcXHUwMDNDZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIlxcdTAwM0VcXHUwMDNDbGFiZWxcXHUwMDNFRGVmYXVsdCBxdWVyeSBsZXZlbFxcdTAwM0NcXHUwMDJGbGFiZWxcXHUwMDNFXFx1MDAzQ3NlbGVjdCBjbGFzcz1cXFwiZm9ybS1jb250cm9sXFxcIiBuZy1tb2RlbD1cXFwiJGN0cmwuZGVmYXVsdExldmVsXFxcIiBuZy1vcHRpb25zPVxcXCJsZXZlbCBmb3IgbGV2ZWwgaW4gJGN0cmwuYXZhaWxhYmxlTGV2ZWxzXFxcIlxcdTAwM0VcXHUwMDNDXFx1MDAyRnNlbGVjdFxcdTAwM0VcXHUwMDNDXFx1MDAyRmRpdlxcdTAwM0VcXHUwMDNDZGl2IGNsYXNzPVxcXCJmb3JtLWdyb3VwXFxcIlxcdTAwM0VcXHUwMDNDbGFiZWxcXHUwMDNFUXVlcnlcXHUwMDNDXFx1MDAyRmxhYmVsXFx1MDAzRVxcdTAwM0N0ZXh0YXJlYSBjbGFzcz1cXFwiZm9ybS1jb250cm9sXFxcIiBuZy1tb2RlbD1cXFwiJGN0cmwucXVlcnlcXFwiXFx1MDAzRVxcdTAwM0NcXHUwMDJGdGV4dGFyZWFcXHUwMDNFXFx1MDAzQ3AgY2xhc3M9XFxcImhlbHAtYmxvY2tcXFwiXFx1MDAzRVVuZGVyc3RhbmRzIGFuIGV4cGFuZGVkIGZvcm0gb2YgXFx1MDAzQ2EgaHJlZj1cXFwiaHR0cDpcXHUwMDJGXFx1MDAyRmx1Y2VuZS5hcGFjaGUub3JnXFx1MDAyRmNvcmVcXHUwMDJGNl81XzFcXHUwMDJGcXVlcnlwYXJzZXJcXHUwMDJGb3JnXFx1MDAyRmFwYWNoZVxcdTAwMkZsdWNlbmVcXHUwMDJGcXVlcnlwYXJzZXJcXHUwMDJGY2xhc3NpY1xcdTAwMkZwYWNrYWdlLXN1bW1hcnkuaHRtbCNwYWNrYWdlLmRlc2NyaXB0aW9uXFxcIlxcdTAwM0VMdWNlbmUgcXVlcnkgcGFyc2VyIHN5bnRheFxcdTAwM0NcXHUwMDJGYVxcdTAwM0UuXFx1MDAzQ1xcdTAwMkZwXFx1MDAzRVxcdTAwM0NcXHUwMDJGZGl2XFx1MDAzRVxcdTAwM0NkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiXFx1MDAzRVxcdTAwM0NsYWJlbFxcdTAwM0VGaWVsZHMgdG8gc2hvd1xcdTAwM0NcXHUwMDJGbGFiZWxcXHUwMDNFXFx1MDAzQ2RpdiBjbGFzcz1cXFwicm93XFxcIlxcdTAwM0VcXHUwMDNDZGl2IGNsYXNzPVxcXCJjb2wteHMtMTJcXFwiXFx1MDAzRVxcdTAwM0NsYWJlbCBjbGFzcz1cXFwiY2hlY2tib3gtaW5saW5lXFxcIiBuZy1yZXBlYXQ9XFxcImZpZWxkIGluICRjdHJsLmF2YWlsYWJsZUZpZWxkc1xcXCIgdGl0bGU9XFxcInt7ZmllbGQuZGVzY3JpcHRpb259fVxcXCJcXHUwMDNFXFx1MDAzQ2lucHV0IG5nLW1vZGVsPVxcXCIkY3RybC5zZWxlY3RlZEZpZWxkc1tmaWVsZC5pZF1cXFwiIHR5cGU9XFxcImNoZWNrYm94XFxcIlxcdTAwM0V7e2ZpZWxkLmlkfX1cXHUwMDNDXFx1MDAyRmxhYmVsXFx1MDAzRVxcdTAwM0NcXHUwMDJGZGl2XFx1MDAzRVxcdTAwM0NcXHUwMDJGZGl2XFx1MDAzRVxcdTAwM0NcXHUwMDJGZGl2XFx1MDAzRVxcdTAwM0NkaXYgY2xhc3M9XFxcImZvcm0tZ3JvdXBcXFwiXFx1MDAzRVxcdTAwM0NsYWJlbFxcdTAwM0UgXFx1MDAzQ2lucHV0IG5nLW1vZGVsPVxcXCIkY3RybC5zaG93TWF0Y2hlc1xcXCIgdHlwZT1cXFwiY2hlY2tib3hcXFwiXFx1MDAzRSZuYnNwO1Nob3cgbWF0Y2hlc1xcdTAwM0NcXHUwMDJGbGFiZWxcXHUwMDNFXFx1MDAzQ1xcdTAwMkZkaXZcXHUwMDNFXFx1MDAzQ2RpdiBjbGFzcz1cXFwiZm9ybS1ncm91cFxcXCJcXHUwMDNFXFx1MDAzQ2xhYmVsXFx1MDAzRUxpbWl0XFx1MDAzQ2lucHV0IGNsYXNzPVxcXCJmb3JtLWNvbnRyb2xcXFwiIG5nLW1vZGVsPVxcXCIkY3RybC5saW1pdFxcXCIgdHlwZT1cXFwibnVtYmVyXFxcIlxcdTAwM0VcXHUwMDNDXFx1MDAyRmxhYmVsXFx1MDAzRVxcdTAwM0NwIGNsYXNzPVxcXCJoZWxwLWJsb2NrXFxcIlxcdTAwM0UtMSBmb3Igbm8gbGltaXRcXHUwMDNDXFx1MDAyRnBcXHUwMDNFXFx1MDAzQ1xcdTAwMkZkaXZcXHUwMDNFXFx1MDAzQ2RpdiBjbGFzcz1cXFwiZm9ybS1ncm91cFxcXCJcXHUwMDNFXFx1MDAzQ2xhYmVsXFx1MDAzRUZ1cnRoZXIgb3B0aW9uc1xcdTAwM0NcXHUwMDJGbGFiZWxcXHUwMDNFXFx1MDAzQ2lucHV0IGNsYXNzPVxcXCJmb3JtLWNvbnRyb2xcXFwiIG5nLW1vZGVsPVxcXCIkY3RybC5mdXJ0aGVyT3B0aW9uc1xcXCIgdHlwZT1cXFwidGV4dFxcXCJcXHUwMDNFXFx1MDAzQ1xcdTAwMkZkaXZcXHUwMDNFXFx1MDAzQ2J1dHRvbiBjbGFzcz1cXFwiYnRuIGJ0bi1zdWNjZXNzXFxcIiBuZy1jbGljaz1cXFwiJGN0cmwucnVuUXVlcnkoKVxcXCIgbmctZGlzYWJsZWQ9XFxcIiRjdHJsLnF1ZXJ5UnVubmluZ1xcXCJcXHUwMDNFUXVlcnlcXHUwMDNDXFx1MDAyRmJ1dHRvblxcdTAwM0VcXHUwMDNDZGl2IG5nLXNob3c9XFxcIiRjdHJsLmVycm9yXFxcIlxcdTAwM0VcXHUwMDNDaDJcXHUwMDNFUXVlcnkgcmVzdWx0ZWQgaW4gZXJyb3I6XFx1MDAzQ1xcdTAwMkZoMlxcdTAwM0V7eyRjdHJsLmVycm9yfX1cXHUwMDNDXFx1MDAyRmRpdlxcdTAwM0VcXHUwMDNDZGl2IG5nLXNob3c9XFxcIiEkY3RybC5xdWVyeVJ1bm5pbmdcXFwiXFx1MDAzRVxcdTAwM0NoMlxcdTAwM0V7eyAoJGN0cmwubGltaXQgIT09IC0xICYmICRjdHJsLmxpbWl0IFxcdTAwM0MgJGN0cmwudG90YWxSZXN1bHRzKSA/ICdGaXJzdCAnKyRjdHJsLmxpbWl0Kycgb2YgJyA6ICcnfX17eyRjdHJsLnRvdGFsUmVzdWx0c319IFJlc3VsdHNcXHUwMDNDXFx1MDAyRmgyXFx1MDAzRVxcdTAwM0N0YWJsZSBjbGFzcz1cXFwidGFibGUgdGFibGUtYm9yZGVyZWQgdGFibGUtcmVzcG9uc2l2ZVxcXCJcXHUwMDNFXFx1MDAzQ3RoZWFkXFx1MDAzRVxcdTAwM0N0clxcdTAwM0VcXHUwMDNDdGggbmctY2xpY2s9XFxcIiRjdHJsLnNvcnRSZXZlcnNlID0gJGN0cmwuc29ydEZpZWxkID09IGZpZWxkID8gISRjdHJsLnNvcnRSZXZlcnNlIDogJGN0cmwuc29ydFJldmVyc2U7JGN0cmwuc29ydEZpZWxkID0gZmllbGRcXFwiIG5nLXJlcGVhdD1cXFwiZmllbGQgaW4gJGN0cmwuZmllbGQgdHJhY2sgYnkgJGluZGV4IFxcXCJcXHUwMDNFe3s6OmZpZWxkfX1cXHUwMDNDc3BhbiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1jaGV2cm9uLWRvd25cXFwiIG5nLXNob3c9XFxcIiRjdHJsLnNvcnRGaWVsZCA9PSBmaWVsZCAmYW1wOyZhbXA7ICEkY3RybC5zb3J0UmV2ZXJzZVxcXCJcXHUwMDNFXFx1MDAzQ1xcdTAwMkZzcGFuXFx1MDAzRVxcdTAwM0NzcGFuIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLWNoZXZyb24tdXBcXFwiIG5nLXNob3c9XFxcIiRjdHJsLnNvcnRGaWVsZCA9PSBmaWVsZCAmYW1wOyZhbXA7ICRjdHJsLnNvcnRSZXZlcnNlXFxcIlxcdTAwM0VcXHUwMDNDXFx1MDAyRnNwYW5cXHUwMDNFXFx1MDAzQ1xcdTAwMkZ0aFxcdTAwM0VcXHUwMDNDXFx1MDAyRnRyXFx1MDAzRVxcdTAwM0NcXHUwMDJGdGhlYWRcXHUwMDNFXFx1MDAzQ3Rib2R5IG5nLXJlcGVhdD1cXFwicmVzdWx0IGluICRjdHJsLnJlc3VsdHMgfCBvcmRlckJ5OiRjdHJsLnNvcnRGaWVsZDokY3RybC5zb3J0UmV2ZXJzZVxcXCJcXHUwMDNFXFx1MDAzQ3RyIGNsYXNzPVxcXCJpbmZvXFxcIlxcdTAwM0VcXHUwMDNDdGQgbmctcmVwZWF0PVxcXCJmaWVsZCBpbiAkY3RybC5maWVsZCB0cmFjayBieSAkaW5kZXggXFxcIlxcdTAwM0UgXFx1MDAzQ2EgbmctaHJlZj1cXFwie3tyZXN1bHRbZmllbGRdfX1cXFwiIG5nLWlmPVxcXCJyZXN1bHRbZmllbGRdLmluZGV4T2YoJ2h0dHAnKSA9PT0gMFxcXCIgdGFyZ2V0PVxcXCJfYmxhbmtcXFwiXFx1MDAzRXt7OjpyZXN1bHRbZmllbGRdfX1cXHUwMDNDXFx1MDAyRmFcXHUwMDNFXFx1MDAzQ3NwYW4gbmctaWY9XFxcInJlc3VsdFtmaWVsZF0uaW5kZXhPZignaHR0cCcpICE9PSAwXFxcIlxcdTAwM0V7ezo6cmVzdWx0W2ZpZWxkXX19XFx1MDAzQ1xcdTAwMkZzcGFuXFx1MDAzRVxcdTAwM0NcXHUwMDJGdGRcXHUwMDNFXFx1MDAzQ1xcdTAwMkZ0clxcdTAwM0VcXHUwMDNDdHIgbmctcmVwZWF0PVxcXCJtYXRjaCBpbiByZXN1bHQubWF0Y2hlcyB0cmFjayBieSAkaW5kZXhcXFwiXFx1MDAzRVxcdTAwM0N0ZCBuZy1iaW5kLWh0bWw9XFxcIm1hdGNoXFxcIiBjb2xzcGFuPVxcXCJ7ezo6JGN0cmwuZmllbGQubGVuZ3RofX1cXFwiXFx1MDAzRVxcdTAwM0NcXHUwMDJGdGRcXHUwMDNFXFx1MDAzQ1xcdTAwMkZ0clxcdTAwM0VcXHUwMDNDXFx1MDAyRnRib2R5XFx1MDAzRVxcdTAwM0NcXHUwMDJGdGFibGVcXHUwMDNFXFx1MDAzQ2gyIG5nLWNsaWNrPVxcXCIkY3RybC5zaG93UmF3PSEkY3RybC5zaG93UmF3XFxcIlxcdTAwM0VSYXcgcmVzdWx0c1xcdTAwM0NzcGFuIGNsYXNzPVxcXCJnbHlwaGljb24gZ2x5cGhpY29uLWNoZXZyb24tZG93blxcXCIgbmctc2hvdz1cXFwiISRjdHJsLnNob3dSYXdcXFwiXFx1MDAzRVxcdTAwM0NcXHUwMDJGc3BhblxcdTAwM0VcXHUwMDNDc3BhbiBjbGFzcz1cXFwiZ2x5cGhpY29uIGdseXBoaWNvbi1jaGV2cm9uLXVwXFxcIiBuZy1zaG93PVxcXCIkY3RybC5zaG93UmF3XFxcIlxcdTAwM0VcXHUwMDNDXFx1MDAyRnNwYW5cXHUwMDNFXFx1MDAzQ1xcdTAwMkZoMlxcdTAwM0VcXHUwMDNDZGl2IG5nLXNob3c9XFxcIiRjdHJsLnNob3dSYXdcXFwiXFx1MDAzRVxcdTAwM0N0ZXh0YXJlYSBjbGFzcz1cXFwiZm9ybS1jb250cm9sXFxcIiBkaXNhYmxlZFxcdTAwM0V7eyRjdHJsLnF1ZXJ5VVJMfX0gICAgICBcXHUwMDNDXFx1MDAyRnRleHRhcmVhXFx1MDAzRVxcdTAwM0NwcmUgcHJldHR5LWpzb249XFxcIiRjdHJsLnJlc3BvbnNlXFxcIlxcdTAwM0VcXHUwMDNDXFx1MDAyRnByZVxcdTAwM0VcXHUwMDNDXFx1MDAyRmRpdlxcdTAwM0VcXHUwMDNDXFx1MDAyRmRpdlxcdTAwM0VcXHUwMDNDXFx1MDAyRmRpdlxcdTAwM0VcIjs7cmV0dXJuIHB1Z19odG1sO307XG5tb2R1bGUuZXhwb3J0cyA9IHRlbXBsYXRlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vYXBwL2NvbXBvbmVudHMvc2VhcmNoLXZpZXcvc2VhcmNoLXZpZXcucHVnXG4vLyBtb2R1bGUgaWQgPSAyMDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///200\n')},function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.PlotlyComponent = exports.PlotlyComponentController = undefined;\n\nvar _classCallCheck2 = __webpack_require__(19);\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = __webpack_require__(27);\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _angular = __webpack_require__(7);\n\nvar angular = _interopRequireWildcard(_angular);\n\nvar _plotly = __webpack_require__(202);\n\nvar Plotly = _interopRequireWildcard(_plotly);\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar PlotlyComponentController = exports.PlotlyComponentController = function () {\n    PlotlyComponentController.$inject = ['$element'];\n\n    /* @ngInject */\n    function PlotlyComponentController($element) {\n        (0, _classCallCheck3.default)(this, PlotlyComponentController);\n\n        this.$element = $element;\n        this.data = [];\n    }\n\n    (0, _createClass3.default)(PlotlyComponentController, [{\n        key: '$onChanges',\n        value: function $onChanges(changes) {\n            var _this = this;\n\n            if (changes.data && changes.data.currentValue) {\n                Plotly.newPlot(this.$element[0], this.data, this.layout, this.config);\n                if (this.onClick) this.$element[0]['on']('plotly_click', function (eventData) {\n                    return _this.onClick({ data: eventData });\n                });\n                if (this.onHover) this.$element[0]['on']('plotly_hover', function (eventData) {\n                    return _this.onHover({ data: eventData });\n                });\n                if (this.onUnhover) this.$element[0]['on']('plotly_unhover', function (eventData) {\n                    return _this.onUnhover({ data: eventData });\n                });\n                if (this.onSelecting) this.$element[0]['on']('plotly_selecting', function (eventData) {\n                    return _this.onSelecting({ data: eventData });\n                });\n                if (this.onSelected) this.$element[0]['on']('plotly_selected', function (eventData) {\n                    return _this.onSelected({ data: eventData });\n                });\n                if (this.onDoubleClick) this.$element[0]['on']('plotly_doubleclick', function (eventData) {\n                    return _this.onDoubleClick({ data: eventData });\n                });\n                //      Plotly.redraw(this.$element[0])\n            }\n        }\n    }]);\n    return PlotlyComponentController;\n}();\n\nvar PlotlyComponent = exports.PlotlyComponent = function PlotlyComponent() {\n    (0, _classCallCheck3.default)(this, PlotlyComponent);\n\n    this.bindings = {\n        data: '<',\n        layout: '<',\n        config: '<',\n        onClick: '&',\n        onHover: '&',\n        onUnhover: '&',\n        onSelecting: '&',\n        onSelected: '&',\n        onDoubleClick: '&'\n    };\n    this.controller = PlotlyComponentController;\n};\n\nangular.module('app.components.plotly', []).component('plotly', new PlotlyComponent());//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjAxLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2FwcC9jb21wb25lbnRzL3Bsb3RseS9wbG90bHktY29tcG9uZW50LnRzPzY1MTAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuaW1wb3J0ICogYXMgYW5ndWxhciBmcm9tICdhbmd1bGFyJztcbmltcG9ydCAqIGFzIFBsb3RseSBmcm9tICdwbG90bHkuanMnO1xuZXhwb3J0IGNsYXNzIFBsb3RseUNvbXBvbmVudENvbnRyb2xsZXIge1xuICAgIC8qIEBuZ0luamVjdCAqL1xuICAgIGNvbnN0cnVjdG9yKCRlbGVtZW50KSB7XG4gICAgICAgIHRoaXMuJGVsZW1lbnQgPSAkZWxlbWVudDtcbiAgICAgICAgdGhpcy5kYXRhID0gW107XG4gICAgfVxuICAgICRvbkNoYW5nZXMoY2hhbmdlcykge1xuICAgICAgICBpZiAoY2hhbmdlcy5kYXRhICYmIGNoYW5nZXMuZGF0YS5jdXJyZW50VmFsdWUpIHtcbiAgICAgICAgICAgIFBsb3RseS5uZXdQbG90KHRoaXMuJGVsZW1lbnRbMF0sIHRoaXMuZGF0YSwgdGhpcy5sYXlvdXQsIHRoaXMuY29uZmlnKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9uQ2xpY2spXG4gICAgICAgICAgICAgICAgdGhpcy4kZWxlbWVudFswXVsnb24nXSgncGxvdGx5X2NsaWNrJywgKGV2ZW50RGF0YSkgPT4gdGhpcy5vbkNsaWNrKHsgZGF0YTogZXZlbnREYXRhIH0pKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9uSG92ZXIpXG4gICAgICAgICAgICAgICAgdGhpcy4kZWxlbWVudFswXVsnb24nXSgncGxvdGx5X2hvdmVyJywgKGV2ZW50RGF0YSkgPT4gdGhpcy5vbkhvdmVyKHsgZGF0YTogZXZlbnREYXRhIH0pKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9uVW5ob3ZlcilcbiAgICAgICAgICAgICAgICB0aGlzLiRlbGVtZW50WzBdWydvbiddKCdwbG90bHlfdW5ob3ZlcicsIChldmVudERhdGEpID0+IHRoaXMub25VbmhvdmVyKHsgZGF0YTogZXZlbnREYXRhIH0pKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9uU2VsZWN0aW5nKVxuICAgICAgICAgICAgICAgIHRoaXMuJGVsZW1lbnRbMF1bJ29uJ10oJ3Bsb3RseV9zZWxlY3RpbmcnLCAoZXZlbnREYXRhKSA9PiB0aGlzLm9uU2VsZWN0aW5nKHsgZGF0YTogZXZlbnREYXRhIH0pKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9uU2VsZWN0ZWQpXG4gICAgICAgICAgICAgICAgdGhpcy4kZWxlbWVudFswXVsnb24nXSgncGxvdGx5X3NlbGVjdGVkJywgKGV2ZW50RGF0YSkgPT4gdGhpcy5vblNlbGVjdGVkKHsgZGF0YTogZXZlbnREYXRhIH0pKTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9uRG91YmxlQ2xpY2spXG4gICAgICAgICAgICAgICAgdGhpcy4kZWxlbWVudFswXVsnb24nXSgncGxvdGx5X2RvdWJsZWNsaWNrJywgKGV2ZW50RGF0YSkgPT4gdGhpcy5vbkRvdWJsZUNsaWNrKHsgZGF0YTogZXZlbnREYXRhIH0pKTtcbiAgICAgICAgICAgIC8vICAgICAgUGxvdGx5LnJlZHJhdyh0aGlzLiRlbGVtZW50WzBdKVxuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFBsb3RseUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuYmluZGluZ3MgPSB7XG4gICAgICAgICAgICBkYXRhOiAnPCcsXG4gICAgICAgICAgICBsYXlvdXQ6ICc8JyxcbiAgICAgICAgICAgIGNvbmZpZzogJzwnLFxuICAgICAgICAgICAgb25DbGljazogJyYnLFxuICAgICAgICAgICAgb25Ib3ZlcjogJyYnLFxuICAgICAgICAgICAgb25VbmhvdmVyOiAnJicsXG4gICAgICAgICAgICBvblNlbGVjdGluZzogJyYnLFxuICAgICAgICAgICAgb25TZWxlY3RlZDogJyYnLFxuICAgICAgICAgICAgb25Eb3VibGVDbGljazogJyYnXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY29udHJvbGxlciA9IFBsb3RseUNvbXBvbmVudENvbnRyb2xsZXI7XG4gICAgfVxufVxuYW5ndWxhci5tb2R1bGUoJ2FwcC5jb21wb25lbnRzLnBsb3RseScsIFtdKVxuICAgIC5jb21wb25lbnQoJ3Bsb3RseScsIG5ldyBQbG90bHlDb21wb25lbnQoKSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gYXBwL2NvbXBvbmVudHMvcGxvdGx5L3Bsb3RseS1jb21wb25lbnQudHMiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTs7Ozs7QUFBQTs7O0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBV0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///201\n")},function(module,exports){eval("module.exports = Plotly;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjAyLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiUGxvdGx5XCI/YmNlYyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFBsb3RseTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCBcIlBsb3RseVwiXG4vLyBtb2R1bGUgaWQgPSAyMDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///202\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nangular.module('app.filters', []);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjAzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2FwcC9maWx0ZXJzL2luZGV4LnRzPzQ1YzQiXSwic291cmNlc0NvbnRlbnQiOlsiYW5ndWxhci5tb2R1bGUoJ2FwcC5maWx0ZXJzJywgW10pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGFwcC9maWx0ZXJzL2luZGV4LnRzIl0sIm1hcHBpbmdzIjoiOztBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///203\n")},function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {\n  'use strict';\n\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(7)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else if (root.hasOwnProperty('angular')) {\n    // Browser globals (root is window), we don't register it.\n    factory(root.angular);\n  } else if (typeof exports === 'object') {\n    module.exports = factory(require('angular'));\n  }\n}(this , function (angular) {\n    'use strict';\n\n    // In cases where Angular does not get passed or angular is a truthy value\n    // but misses .module we can fall back to using window.\n    angular = (angular && angular.module ) ? angular : window.angular;\n\n\n    function isStorageSupported($window, storageType) {\n\n      // Some installations of IE, for an unknown reason, throw \"SCRIPT5: Error: Access is denied\"\n      // when accessing window.localStorage. This happens before you try to do anything with it. Catch\n      // that error and allow execution to continue.\n\n      // fix 'SecurityError: DOM Exception 18' exception in Desktop Safari, Mobile Safari\n      // when \"Block cookies\": \"Always block\" is turned on\n      var supported;\n      try {\n        supported = $window[storageType];\n      }\n      catch(err) {\n        supported = false;\n      }\n\n      // When Safari (OS X or iOS) is in private browsing mode, it appears as though localStorage and sessionStorage\n      // is available, but trying to call .setItem throws an exception below:\n      // \"QUOTA_EXCEEDED_ERR: DOM Exception 22: An attempt was made to add something to storage that exceeded the quota.\"\n      if(supported) {\n        var key = '__' + Math.round(Math.random() * 1e7);\n        try {\n          $window[storageType].setItem(key, key);\n          $window[storageType].removeItem(key, key);\n        }\n        catch(err) {\n          supported = false;\n        }\n      }\n\n      return supported;\n    }\n\n    /**\n     * @ngdoc overview\n     * @name ngStorage\n     */\n\n    return angular.module('ngStorage', [])\n\n    /**\n     * @ngdoc object\n     * @name ngStorage.$localStorage\n     * @requires $rootScope\n     * @requires $window\n     */\n\n    .provider('$localStorage', _storageProvider('localStorage'))\n\n    /**\n     * @ngdoc object\n     * @name ngStorage.$sessionStorage\n     * @requires $rootScope\n     * @requires $window\n     */\n\n    .provider('$sessionStorage', _storageProvider('sessionStorage'));\n\n    function _storageProvider(storageType) {\n        var providerWebStorage = isStorageSupported(window, storageType);\n\n        return function () {\n          var storageKeyPrefix = 'ngStorage-';\n\n          this.setKeyPrefix = function (prefix) {\n            if (typeof prefix !== 'string') {\n              throw new TypeError('[ngStorage] - ' + storageType + 'Provider.setKeyPrefix() expects a String.');\n            }\n            storageKeyPrefix = prefix;\n          };\n\n          var serializer = angular.toJson;\n          var deserializer = angular.fromJson;\n\n          this.setSerializer = function (s) {\n            if (typeof s !== 'function') {\n              throw new TypeError('[ngStorage] - ' + storageType + 'Provider.setSerializer expects a function.');\n            }\n\n            serializer = s;\n          };\n\n          this.setDeserializer = function (d) {\n            if (typeof d !== 'function') {\n              throw new TypeError('[ngStorage] - ' + storageType + 'Provider.setDeserializer expects a function.');\n            }\n\n            deserializer = d;\n          };\n\n          this.supported = function() {\n            return !!providerWebStorage;\n          };\n\n          // Note: This is not very elegant at all.\n          this.get = function (key) {\n            return providerWebStorage && deserializer(providerWebStorage.getItem(storageKeyPrefix + key));\n          };\n\n          // Note: This is not very elegant at all.\n          this.set = function (key, value) {\n            return providerWebStorage && providerWebStorage.setItem(storageKeyPrefix + key, serializer(value));\n          };\n\n          this.remove = function (key) {\n            providerWebStorage && providerWebStorage.removeItem(storageKeyPrefix + key);\n          }\n\n          this.$get = [\n              '$rootScope',\n              '$window',\n              '$log',\n              '$timeout',\n              '$document',\n\n              function(\n                  $rootScope,\n                  $window,\n                  $log,\n                  $timeout,\n                  $document\n              ){\n\n                // The magic number 10 is used which only works for some keyPrefixes...\n                // See https://github.com/gsklee/ngStorage/issues/137\n                var prefixLength = storageKeyPrefix.length;\n\n                // #9: Assign a placeholder object if Web Storage is unavailable to prevent breaking the entire AngularJS app\n                // Note: recheck mainly for testing (so we can use $window[storageType] rather than window[storageType])\n                var isSupported = isStorageSupported($window, storageType),\n                    webStorage = isSupported || ($log.warn('This browser does not support Web Storage!'), {setItem: angular.noop, getItem: angular.noop, removeItem: angular.noop}),\n                    $storage = {\n                        $default: function(items) {\n                            for (var k in items) {\n                                angular.isDefined($storage[k]) || ($storage[k] = angular.copy(items[k]) );\n                            }\n\n                            $storage.$sync();\n                            return $storage;\n                        },\n                        $reset: function(items) {\n                            for (var k in $storage) {\n                                '$' === k[0] || (delete $storage[k] && webStorage.removeItem(storageKeyPrefix + k));\n                            }\n\n                            return $storage.$default(items);\n                        },\n                        $sync: function () {\n                            for (var i = 0, l = webStorage.length, k; i < l; i++) {\n                                // #8, #10: `webStorage.key(i)` may be an empty string (or throw an exception in IE9 if `webStorage` is empty)\n                                (k = webStorage.key(i)) && storageKeyPrefix === k.slice(0, prefixLength) && ($storage[k.slice(prefixLength)] = deserializer(webStorage.getItem(k)));\n                            }\n                        },\n                        $apply: function() {\n                            var temp$storage;\n\n                            _debounce = null;\n\n                            if (!angular.equals($storage, _last$storage)) {\n                                temp$storage = angular.copy(_last$storage);\n                                angular.forEach($storage, function(v, k) {\n                                    if (angular.isDefined(v) && '$' !== k[0]) {\n                                        webStorage.setItem(storageKeyPrefix + k, serializer(v));\n                                        delete temp$storage[k];\n                                    }\n                                });\n\n                                for (var k in temp$storage) {\n                                    webStorage.removeItem(storageKeyPrefix + k);\n                                }\n\n                                _last$storage = angular.copy($storage);\n                            }\n                        },\n                        $supported: function() {\n                            return !!isSupported;\n                        }\n                    },\n                    _last$storage,\n                    _debounce;\n\n                $storage.$sync();\n\n                _last$storage = angular.copy($storage);\n\n                $rootScope.$watch(function() {\n                    _debounce || (_debounce = $timeout($storage.$apply, 100, false));\n                });\n\n                // #6: Use `$window.addEventListener` instead of `angular.element` to avoid the jQuery-specific `event.originalEvent`\n                $window.addEventListener && $window.addEventListener('storage', function(event) {\n                    if (!event.key) {\n                      return;\n                    }\n\n                    // Reference doc.\n                    var doc = $document[0];\n\n                    if ( (!doc.hasFocus || !doc.hasFocus()) && storageKeyPrefix === event.key.slice(0, prefixLength) ) {\n                        event.newValue ? $storage[event.key.slice(prefixLength)] = deserializer(event.newValue) : delete $storage[event.key.slice(prefixLength)];\n\n                        _last$storage = angular.copy($storage);\n\n                        $rootScope.$apply();\n                    }\n                });\n\n                $window.addEventListener && $window.addEventListener('beforeunload', function() {\n                    $storage.$apply();\n                });\n\n                return $storage;\n              }\n          ];\n      };\n    }\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjA0LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL25nc3RvcmFnZS9uZ1N0b3JhZ2UuanM/ODM4NCJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoWydhbmd1bGFyJ10sIGZhY3RvcnkpO1xuICB9IGVsc2UgaWYgKHJvb3QuaGFzT3duUHJvcGVydHkoJ2FuZ3VsYXInKSkge1xuICAgIC8vIEJyb3dzZXIgZ2xvYmFscyAocm9vdCBpcyB3aW5kb3cpLCB3ZSBkb24ndCByZWdpc3RlciBpdC5cbiAgICBmYWN0b3J5KHJvb3QuYW5ndWxhcik7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoJ2FuZ3VsYXInKSk7XG4gIH1cbn0odGhpcyAsIGZ1bmN0aW9uIChhbmd1bGFyKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLy8gSW4gY2FzZXMgd2hlcmUgQW5ndWxhciBkb2VzIG5vdCBnZXQgcGFzc2VkIG9yIGFuZ3VsYXIgaXMgYSB0cnV0aHkgdmFsdWVcbiAgICAvLyBidXQgbWlzc2VzIC5tb2R1bGUgd2UgY2FuIGZhbGwgYmFjayB0byB1c2luZyB3aW5kb3cuXG4gICAgYW5ndWxhciA9IChhbmd1bGFyICYmIGFuZ3VsYXIubW9kdWxlICkgPyBhbmd1bGFyIDogd2luZG93LmFuZ3VsYXI7XG5cblxuICAgIGZ1bmN0aW9uIGlzU3RvcmFnZVN1cHBvcnRlZCgkd2luZG93LCBzdG9yYWdlVHlwZSkge1xuXG4gICAgICAvLyBTb21lIGluc3RhbGxhdGlvbnMgb2YgSUUsIGZvciBhbiB1bmtub3duIHJlYXNvbiwgdGhyb3cgXCJTQ1JJUFQ1OiBFcnJvcjogQWNjZXNzIGlzIGRlbmllZFwiXG4gICAgICAvLyB3aGVuIGFjY2Vzc2luZyB3aW5kb3cubG9jYWxTdG9yYWdlLiBUaGlzIGhhcHBlbnMgYmVmb3JlIHlvdSB0cnkgdG8gZG8gYW55dGhpbmcgd2l0aCBpdC4gQ2F0Y2hcbiAgICAgIC8vIHRoYXQgZXJyb3IgYW5kIGFsbG93IGV4ZWN1dGlvbiB0byBjb250aW51ZS5cblxuICAgICAgLy8gZml4ICdTZWN1cml0eUVycm9yOiBET00gRXhjZXB0aW9uIDE4JyBleGNlcHRpb24gaW4gRGVza3RvcCBTYWZhcmksIE1vYmlsZSBTYWZhcmlcbiAgICAgIC8vIHdoZW4gXCJCbG9jayBjb29raWVzXCI6IFwiQWx3YXlzIGJsb2NrXCIgaXMgdHVybmVkIG9uXG4gICAgICB2YXIgc3VwcG9ydGVkO1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3VwcG9ydGVkID0gJHdpbmRvd1tzdG9yYWdlVHlwZV07XG4gICAgICB9XG4gICAgICBjYXRjaChlcnIpIHtcbiAgICAgICAgc3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIFdoZW4gU2FmYXJpIChPUyBYIG9yIGlPUykgaXMgaW4gcHJpdmF0ZSBicm93c2luZyBtb2RlLCBpdCBhcHBlYXJzIGFzIHRob3VnaCBsb2NhbFN0b3JhZ2UgYW5kIHNlc3Npb25TdG9yYWdlXG4gICAgICAvLyBpcyBhdmFpbGFibGUsIGJ1dCB0cnlpbmcgdG8gY2FsbCAuc2V0SXRlbSB0aHJvd3MgYW4gZXhjZXB0aW9uIGJlbG93OlxuICAgICAgLy8gXCJRVU9UQV9FWENFRURFRF9FUlI6IERPTSBFeGNlcHRpb24gMjI6IEFuIGF0dGVtcHQgd2FzIG1hZGUgdG8gYWRkIHNvbWV0aGluZyB0byBzdG9yYWdlIHRoYXQgZXhjZWVkZWQgdGhlIHF1b3RhLlwiXG4gICAgICBpZihzdXBwb3J0ZWQpIHtcbiAgICAgICAgdmFyIGtleSA9ICdfXycgKyBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiAxZTcpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICR3aW5kb3dbc3RvcmFnZVR5cGVdLnNldEl0ZW0oa2V5LCBrZXkpO1xuICAgICAgICAgICR3aW5kb3dbc3RvcmFnZVR5cGVdLnJlbW92ZUl0ZW0oa2V5LCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoKGVycikge1xuICAgICAgICAgIHN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdXBwb3J0ZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQG5nZG9jIG92ZXJ2aWV3XG4gICAgICogQG5hbWUgbmdTdG9yYWdlXG4gICAgICovXG5cbiAgICByZXR1cm4gYW5ndWxhci5tb2R1bGUoJ25nU3RvcmFnZScsIFtdKVxuXG4gICAgLyoqXG4gICAgICogQG5nZG9jIG9iamVjdFxuICAgICAqIEBuYW1lIG5nU3RvcmFnZS4kbG9jYWxTdG9yYWdlXG4gICAgICogQHJlcXVpcmVzICRyb290U2NvcGVcbiAgICAgKiBAcmVxdWlyZXMgJHdpbmRvd1xuICAgICAqL1xuXG4gICAgLnByb3ZpZGVyKCckbG9jYWxTdG9yYWdlJywgX3N0b3JhZ2VQcm92aWRlcignbG9jYWxTdG9yYWdlJykpXG5cbiAgICAvKipcbiAgICAgKiBAbmdkb2Mgb2JqZWN0XG4gICAgICogQG5hbWUgbmdTdG9yYWdlLiRzZXNzaW9uU3RvcmFnZVxuICAgICAqIEByZXF1aXJlcyAkcm9vdFNjb3BlXG4gICAgICogQHJlcXVpcmVzICR3aW5kb3dcbiAgICAgKi9cblxuICAgIC5wcm92aWRlcignJHNlc3Npb25TdG9yYWdlJywgX3N0b3JhZ2VQcm92aWRlcignc2Vzc2lvblN0b3JhZ2UnKSk7XG5cbiAgICBmdW5jdGlvbiBfc3RvcmFnZVByb3ZpZGVyKHN0b3JhZ2VUeXBlKSB7XG4gICAgICAgIHZhciBwcm92aWRlcldlYlN0b3JhZ2UgPSBpc1N0b3JhZ2VTdXBwb3J0ZWQod2luZG93LCBzdG9yYWdlVHlwZSk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgc3RvcmFnZUtleVByZWZpeCA9ICduZ1N0b3JhZ2UtJztcblxuICAgICAgICAgIHRoaXMuc2V0S2V5UHJlZml4ID0gZnVuY3Rpb24gKHByZWZpeCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcmVmaXggIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1tuZ1N0b3JhZ2VdIC0gJyArIHN0b3JhZ2VUeXBlICsgJ1Byb3ZpZGVyLnNldEtleVByZWZpeCgpIGV4cGVjdHMgYSBTdHJpbmcuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdG9yYWdlS2V5UHJlZml4ID0gcHJlZml4O1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICB2YXIgc2VyaWFsaXplciA9IGFuZ3VsYXIudG9Kc29uO1xuICAgICAgICAgIHZhciBkZXNlcmlhbGl6ZXIgPSBhbmd1bGFyLmZyb21Kc29uO1xuXG4gICAgICAgICAgdGhpcy5zZXRTZXJpYWxpemVyID0gZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdbbmdTdG9yYWdlXSAtICcgKyBzdG9yYWdlVHlwZSArICdQcm92aWRlci5zZXRTZXJpYWxpemVyIGV4cGVjdHMgYSBmdW5jdGlvbi4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2VyaWFsaXplciA9IHM7XG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHRoaXMuc2V0RGVzZXJpYWxpemVyID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdbbmdTdG9yYWdlXSAtICcgKyBzdG9yYWdlVHlwZSArICdQcm92aWRlci5zZXREZXNlcmlhbGl6ZXIgZXhwZWN0cyBhIGZ1bmN0aW9uLicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkZXNlcmlhbGl6ZXIgPSBkO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICB0aGlzLnN1cHBvcnRlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuICEhcHJvdmlkZXJXZWJTdG9yYWdlO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICAvLyBOb3RlOiBUaGlzIGlzIG5vdCB2ZXJ5IGVsZWdhbnQgYXQgYWxsLlxuICAgICAgICAgIHRoaXMuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyV2ViU3RvcmFnZSAmJiBkZXNlcmlhbGl6ZXIocHJvdmlkZXJXZWJTdG9yYWdlLmdldEl0ZW0oc3RvcmFnZUtleVByZWZpeCArIGtleSkpO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICAvLyBOb3RlOiBUaGlzIGlzIG5vdCB2ZXJ5IGVsZWdhbnQgYXQgYWxsLlxuICAgICAgICAgIHRoaXMuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm92aWRlcldlYlN0b3JhZ2UgJiYgcHJvdmlkZXJXZWJTdG9yYWdlLnNldEl0ZW0oc3RvcmFnZUtleVByZWZpeCArIGtleSwgc2VyaWFsaXplcih2YWx1ZSkpO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICB0aGlzLnJlbW92ZSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHByb3ZpZGVyV2ViU3RvcmFnZSAmJiBwcm92aWRlcldlYlN0b3JhZ2UucmVtb3ZlSXRlbShzdG9yYWdlS2V5UHJlZml4ICsga2V5KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLiRnZXQgPSBbXG4gICAgICAgICAgICAgICckcm9vdFNjb3BlJyxcbiAgICAgICAgICAgICAgJyR3aW5kb3cnLFxuICAgICAgICAgICAgICAnJGxvZycsXG4gICAgICAgICAgICAgICckdGltZW91dCcsXG4gICAgICAgICAgICAgICckZG9jdW1lbnQnLFxuXG4gICAgICAgICAgICAgIGZ1bmN0aW9uKFxuICAgICAgICAgICAgICAgICAgJHJvb3RTY29wZSxcbiAgICAgICAgICAgICAgICAgICR3aW5kb3csXG4gICAgICAgICAgICAgICAgICAkbG9nLFxuICAgICAgICAgICAgICAgICAgJHRpbWVvdXQsXG4gICAgICAgICAgICAgICAgICAkZG9jdW1lbnRcbiAgICAgICAgICAgICAgKXtcblxuICAgICAgICAgICAgICAgIC8vIFRoZSBtYWdpYyBudW1iZXIgMTAgaXMgdXNlZCB3aGljaCBvbmx5IHdvcmtzIGZvciBzb21lIGtleVByZWZpeGVzLi4uXG4gICAgICAgICAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9nc2tsZWUvbmdTdG9yYWdlL2lzc3Vlcy8xMzdcbiAgICAgICAgICAgICAgICB2YXIgcHJlZml4TGVuZ3RoID0gc3RvcmFnZUtleVByZWZpeC5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAvLyAjOTogQXNzaWduIGEgcGxhY2Vob2xkZXIgb2JqZWN0IGlmIFdlYiBTdG9yYWdlIGlzIHVuYXZhaWxhYmxlIHRvIHByZXZlbnQgYnJlYWtpbmcgdGhlIGVudGlyZSBBbmd1bGFySlMgYXBwXG4gICAgICAgICAgICAgICAgLy8gTm90ZTogcmVjaGVjayBtYWlubHkgZm9yIHRlc3RpbmcgKHNvIHdlIGNhbiB1c2UgJHdpbmRvd1tzdG9yYWdlVHlwZV0gcmF0aGVyIHRoYW4gd2luZG93W3N0b3JhZ2VUeXBlXSlcbiAgICAgICAgICAgICAgICB2YXIgaXNTdXBwb3J0ZWQgPSBpc1N0b3JhZ2VTdXBwb3J0ZWQoJHdpbmRvdywgc3RvcmFnZVR5cGUpLFxuICAgICAgICAgICAgICAgICAgICB3ZWJTdG9yYWdlID0gaXNTdXBwb3J0ZWQgfHwgKCRsb2cud2FybignVGhpcyBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgV2ViIFN0b3JhZ2UhJyksIHtzZXRJdGVtOiBhbmd1bGFyLm5vb3AsIGdldEl0ZW06IGFuZ3VsYXIubm9vcCwgcmVtb3ZlSXRlbTogYW5ndWxhci5ub29wfSksXG4gICAgICAgICAgICAgICAgICAgICRzdG9yYWdlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgJGRlZmF1bHQ6IGZ1bmN0aW9uKGl0ZW1zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgayBpbiBpdGVtcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmd1bGFyLmlzRGVmaW5lZCgkc3RvcmFnZVtrXSkgfHwgKCRzdG9yYWdlW2tdID0gYW5ndWxhci5jb3B5KGl0ZW1zW2tdKSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICRzdG9yYWdlLiRzeW5jKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICRzdG9yYWdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICRyZXNldDogZnVuY3Rpb24oaXRlbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrIGluICRzdG9yYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICckJyA9PT0ga1swXSB8fCAoZGVsZXRlICRzdG9yYWdlW2tdICYmIHdlYlN0b3JhZ2UucmVtb3ZlSXRlbShzdG9yYWdlS2V5UHJlZml4ICsgaykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAkc3RvcmFnZS4kZGVmYXVsdChpdGVtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgJHN5bmM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHdlYlN0b3JhZ2UubGVuZ3RoLCBrOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICM4LCAjMTA6IGB3ZWJTdG9yYWdlLmtleShpKWAgbWF5IGJlIGFuIGVtcHR5IHN0cmluZyAob3IgdGhyb3cgYW4gZXhjZXB0aW9uIGluIElFOSBpZiBgd2ViU3RvcmFnZWAgaXMgZW1wdHkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChrID0gd2ViU3RvcmFnZS5rZXkoaSkpICYmIHN0b3JhZ2VLZXlQcmVmaXggPT09IGsuc2xpY2UoMCwgcHJlZml4TGVuZ3RoKSAmJiAoJHN0b3JhZ2Vbay5zbGljZShwcmVmaXhMZW5ndGgpXSA9IGRlc2VyaWFsaXplcih3ZWJTdG9yYWdlLmdldEl0ZW0oaykpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgJGFwcGx5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcCRzdG9yYWdlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2RlYm91bmNlID0gbnVsbDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYW5ndWxhci5lcXVhbHMoJHN0b3JhZ2UsIF9sYXN0JHN0b3JhZ2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXAkc3RvcmFnZSA9IGFuZ3VsYXIuY29weShfbGFzdCRzdG9yYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5ndWxhci5mb3JFYWNoKCRzdG9yYWdlLCBmdW5jdGlvbih2LCBrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYW5ndWxhci5pc0RlZmluZWQodikgJiYgJyQnICE9PSBrWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2ViU3RvcmFnZS5zZXRJdGVtKHN0b3JhZ2VLZXlQcmVmaXggKyBrLCBzZXJpYWxpemVyKHYpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGVtcCRzdG9yYWdlW2tdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrIGluIHRlbXAkc3RvcmFnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2ViU3RvcmFnZS5yZW1vdmVJdGVtKHN0b3JhZ2VLZXlQcmVmaXggKyBrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9sYXN0JHN0b3JhZ2UgPSBhbmd1bGFyLmNvcHkoJHN0b3JhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAkc3VwcG9ydGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gISFpc1N1cHBvcnRlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgX2xhc3Qkc3RvcmFnZSxcbiAgICAgICAgICAgICAgICAgICAgX2RlYm91bmNlO1xuXG4gICAgICAgICAgICAgICAgJHN0b3JhZ2UuJHN5bmMoKTtcblxuICAgICAgICAgICAgICAgIF9sYXN0JHN0b3JhZ2UgPSBhbmd1bGFyLmNvcHkoJHN0b3JhZ2UpO1xuXG4gICAgICAgICAgICAgICAgJHJvb3RTY29wZS4kd2F0Y2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIF9kZWJvdW5jZSB8fCAoX2RlYm91bmNlID0gJHRpbWVvdXQoJHN0b3JhZ2UuJGFwcGx5LCAxMDAsIGZhbHNlKSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAvLyAjNjogVXNlIGAkd2luZG93LmFkZEV2ZW50TGlzdGVuZXJgIGluc3RlYWQgb2YgYGFuZ3VsYXIuZWxlbWVudGAgdG8gYXZvaWQgdGhlIGpRdWVyeS1zcGVjaWZpYyBgZXZlbnQub3JpZ2luYWxFdmVudGBcbiAgICAgICAgICAgICAgICAkd2luZG93LmFkZEV2ZW50TGlzdGVuZXIgJiYgJHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzdG9yYWdlJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFldmVudC5rZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBSZWZlcmVuY2UgZG9jLlxuICAgICAgICAgICAgICAgICAgICB2YXIgZG9jID0gJGRvY3VtZW50WzBdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICggKCFkb2MuaGFzRm9jdXMgfHwgIWRvYy5oYXNGb2N1cygpKSAmJiBzdG9yYWdlS2V5UHJlZml4ID09PSBldmVudC5rZXkuc2xpY2UoMCwgcHJlZml4TGVuZ3RoKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50Lm5ld1ZhbHVlID8gJHN0b3JhZ2VbZXZlbnQua2V5LnNsaWNlKHByZWZpeExlbmd0aCldID0gZGVzZXJpYWxpemVyKGV2ZW50Lm5ld1ZhbHVlKSA6IGRlbGV0ZSAkc3RvcmFnZVtldmVudC5rZXkuc2xpY2UocHJlZml4TGVuZ3RoKV07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIF9sYXN0JHN0b3JhZ2UgPSBhbmd1bGFyLmNvcHkoJHN0b3JhZ2UpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAkcm9vdFNjb3BlLiRhcHBseSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAkd2luZG93LmFkZEV2ZW50TGlzdGVuZXIgJiYgJHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgJHN0b3JhZ2UuJGFwcGx5KCk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gJHN0b3JhZ2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICBdO1xuICAgICAgfTtcbiAgICB9XG5cbn0pKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL25nc3RvcmFnZS9uZ1N0b3JhZ2UuanNcbi8vIG1vZHVsZSBpZCA9IDIwNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///204\n")}]);